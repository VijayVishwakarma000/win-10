"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateIn = (member, obj) => {
  if (Object(obj) !== obj)
    throw TypeError('Cannot use the "in" operator on this value');
  return member.has(obj);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _disposed, _stack, _a2, _b2, _disposed2, _stack2, _c2, _d, _emitter, _handlers, _e, _target, _type, _handler, _code, _originalMessage, _functionName, _siteString, _type2, _message, _defaultValue, _handled, _get, _updated, _amendments, _update, update_fn, _get2, get_fn, _handlers2, _isResolved, _isRejected, _value, _resolve, _taskPromise, _timeoutId, _timeoutError, _finish, finish_fn, _promise, _mutex, _f, _locked, _acquirers, _ensureElementIsInTheViewport, _waitForEnabled, _waitForStableBoundingBox, _waitForEnabledIfNeeded, _waitForStableBoundingBoxIfNeeded, _ensureElementIsInTheViewportIfNeeded, _click, click_fn, _fill, fill_fn, _hover, hover_fn, _scroll, scroll_fn, _pageOrFrame, _func, _delegate, _predicate, _mapper, _pageOrFrame2, _selector, _waitForVisibilityIfNeeded, _locators, _defaultTimeout, _defaultNavigationTimeout, _world, _polling, _root, _fn, _args, _timeout, _timeoutError2, _result, _poller, _signal, _reruns, _tasks, _disposed3, _url, _client, _richlyEditable, _editable, _focusable, _hidden, _name, _role, _ignored, _cachedHasFocusableChild, _isPlainTextField, isPlainTextField_fn, _isTextOnlyObject, isTextOnlyObject_fn, _hasFocusableChild, hasFocusableChild_fn, _name2, _fn2, _connection, _browser, _id, _callbacks, _idGenerator, _id2, _error, _deferred, _timer, _label, _sessionId, _targetType, _callbacks2, _connection2, _parentSessionId, _target2, _type3, _text, _args2, _stackTraceLocations, _element, _multiple, _handled2, _url2, _transport, _delay, _timeout2, _sessions, _closed, _manuallyAttached, _callbacks3, _onClose, onClose_fn, _jsCoverage, _cssCoverage, _client2, _enabled, _scriptURLs, _scriptSources, _subscriptions, _resetOnNavigation, _reportAnonymousScripts, _includeRawScriptCoverage, _onExecutionContextsCleared, onExecutionContextsCleared_fn, _onScriptParsed, onScriptParsed_fn, _client3, _enabled2, _stylesheetURLs, _stylesheetSources, _eventListeners, _resetOnNavigation2, _onExecutionContextsCleared2, onExecutionContextsCleared_fn2, _onStyleSheet, onStyleSheet_fn, _client4, _state, _clientProvider, _updater, _connection3, _discoveredTargetsByTargetId, _availableTargetsByTargetId, _availableTargetsBySessionId, _targetFilterCallback, _targetFactory, _attachedToTargetListenersBySession, _initializeDeferred, _targetsIdsForInit, _onSessionDetached, _onTargetCreated, _onTargetDestroyed, _onAttachedToTarget, _finishInitializationIfReady, finishInitializationIfReady_fn, _client5, _timeoutSettings, _id3, _handled3, _updateDevicesHandle, _waitForDevicePromises, _updateDevices, updateDevices_fn, _client6, _timeoutSettings2, _deviceRequestPrompDeferreds, _onDeviceRequestPrompted, onDeviceRequestPrompted_fn, _disposed4, _remoteObject, _world2, _client7, _world3, _id4, _name3, _disposables, _bindings, _mutex2, _addBinding, addBinding_fn, _onBindingCalled, onBindingCalled_fn, _onConsoleAPI, onConsoleAPI_fn, _bindingsInstalled, _puppeteerUtil, _addBindingWithoutThrowing, addBindingWithoutThrowing_fn, _evaluate, evaluate_fn, _context, _emitter2, _frameOrWorker, _onContextDisposed, onContextDisposed_fn, _onContextConsoleApiCalled, onContextConsoleApiCalled_fn, _onContextBindingCalled, onContextBindingCalled_fn, _executionContext, executionContext_fn, _waitForExecutionContext, waitForExecutionContext_fn, _expectedLifecycle, _frame, _timeout3, _navigationRequest, _subscriptions2, _initialLoaderId, _terminationDeferred, _sameDocumentNavigationDeferred, _lifecycleDeferred, _newDocumentNavigationDeferred, _hasSameDocumentNavigation, _swapped, _navigationResponseReceived, _onRequest, onRequest_fn, _onRequestFailed, onRequestFailed_fn, _onResponse, onResponse_fn, _onFrameDetached, onFrameDetached_fn, _navigatedWithinDocument, navigatedWithinDocument_fn, _navigated, navigated_fn, _frameSwapped, frameSwapped_fn, _checkLifecycleComplete, checkLifecycleComplete_fn, _frames, _parentIds, _childIds, _mainFrame, _isMainFrameStale, _waitRequests, _client8, _isNavigationRequest, _url3, _resourceType, _method, _hasPostData, _postData, _headers, _frame2, _initiator, _subjectName, _issuer, _validFrom, _validTo, _protocol, _sanList, _client9, _request, _contentPromise, _bodyLoadedDeferred, _remoteAddress, _status, _statusText, _url4, _fromDiskCache, _fromServiceWorker, _headers2, _securityDetails, _timing, _parseStatusTextFromExtraInfo, parseStatusTextFromExtraInfo_fn, _requestWillBeSentMap, _requestPausedMap, _httpRequestsMap, _responseReceivedExtraInfoMap, _queuedRedirectInfoMap, _queuedEventGroupMap, _frameManager, _networkEventManager, _extraHTTPHeaders, _credentials, _attemptedAuthentications, _userRequestInterceptionEnabled, _protocolRequestInterceptionEnabled, _userCacheDisabled, _emulatedNetworkConditions, _userAgent, _userAgentMetadata, _handlers3, _clients, _removeClient, removeClient_fn, _applyExtraHTTPHeaders, applyExtraHTTPHeaders_fn, _applyToAllClients, applyToAllClients_fn, _applyNetworkConditions, applyNetworkConditions_fn, _applyUserAgent, applyUserAgent_fn, _applyProtocolRequestInterception, applyProtocolRequestInterception_fn, _applyProtocolCacheDisabled, applyProtocolCacheDisabled_fn, _onRequestWillBeSent, onRequestWillBeSent_fn, _onAuthRequired, onAuthRequired_fn, _onRequestPaused, onRequestPaused_fn, _patchRequestEventHeaders, patchRequestEventHeaders_fn, _onRequestWithoutNetworkInstrumentation, onRequestWithoutNetworkInstrumentation_fn, _onRequest2, onRequest_fn2, _onRequestServedFromCache, onRequestServedFromCache_fn, _handleRequestRedirect, handleRequestRedirect_fn, _emitResponseEvent, emitResponseEvent_fn, _onResponseReceived, onResponseReceived_fn, _onResponseReceivedExtraInfo, onResponseReceivedExtraInfo_fn, _forgetRequest, forgetRequest_fn, _onLoadingFinished, onLoadingFinished_fn, _emitLoadingFinished, emitLoadingFinished_fn, _onLoadingFailed, onLoadingFailed_fn, _emitLoadingFailed, emitLoadingFailed_fn, _page, _networkManager, _timeoutSettings3, _isolatedWorlds, _client10, _frameNavigatedReceived, _deviceRequestPromptManagerMap, _frameTreeHandled, _onClientDisconnect, onClientDisconnect_fn, _onLifecycleEvent, onLifecycleEvent_fn, _onFrameStartedLoading, onFrameStartedLoading_fn, _onFrameStoppedLoading, onFrameStoppedLoading_fn, _handleFrameTree, handleFrameTree_fn, _onFrameAttached, onFrameAttached_fn, _onFrameNavigated, onFrameNavigated_fn, _createIsolatedWorld, createIsolatedWorld_fn, _onFrameNavigatedWithinDocument, onFrameNavigatedWithinDocument_fn, _onFrameDetached2, onFrameDetached_fn2, _onExecutionContextCreated, onExecutionContextCreated_fn, _removeFramesRecursively, removeFramesRecursively_fn, _client11, _pressedKeys, _modifierBit, modifierBit_fn, _keyDescriptionForString, keyDescriptionForString_fn, _client12, _keyboard, __state, _state2, state_get, _transactions, _createTransaction, createTransaction_fn, _withTransaction, withTransaction_fn, _client13, _keyboard2, _client14, _recording, _path, _world4, _client15, _id5, _targetType2, _closed2, _targetManager, _primaryTargetClient, _primaryTarget, _tabTargetClient, _tabTarget, _keyboard3, _mouse, _touchscreen, _accessibility, _frameManager2, _emulationManager, _tracing, _bindings2, _exposedFunctions, _coverage, _viewport, _workers, _fileChooserDeferreds, _sessionCloseDeferred, _serviceWorkerBypassed, _userDragInterceptionEnabled, _frameManagerHandlers, _networkManagerHandlers, _sessionHandlers, _onActivation, onActivation_fn, _onSecondaryTarget, onSecondaryTarget_fn, _setupPrimaryTargetListeners, setupPrimaryTargetListeners_fn, _onDetachedFromTarget, _onAttachedToTarget2, _initialize, initialize_fn, _onFileChooser, onFileChooser_fn, _onTargetCrashed, onTargetCrashed_fn, _onLogEntryAdded, onLogEntryAdded_fn, _emitMetrics, emitMetrics_fn, _buildMetricsObject, buildMetricsObject_fn, _handleException, handleException_fn, _onConsoleAPI2, onConsoleAPI_fn2, _onBindingCalled2, onBindingCalled_fn2, _addConsoleMessage, addConsoleMessage_fn, _onDialog, onDialog_fn, _go, go_fn, _browserContext, _session, _targetInfo, _targetManager2, _sessionFactory, _defaultViewport, _workerPromise, _connection4, _discoveredTargetsByTargetId2, _attachedTargetsByTargetId, _attachedTargetsBySessionId, _ignoredTargets, _targetFilterCallback2, _targetFactory2, _attachedToTargetListenersBySession2, _detachedFromTargetListenersBySession, _initializeDeferred2, _targetsIdsForInit2, _waitForInitiallyDiscoveredTargets, _discoveryFilter, _storeExistingTargetsForInit, _setupAttachmentListeners, setupAttachmentListeners_fn, _removeAttachmentListeners, removeAttachmentListeners_fn, _onSessionDetached2, _onTargetCreated2, _onTargetDestroyed2, _onTargetInfoChanged, _onAttachedToTarget3, _finishInitializationIfReady2, finishInitializationIfReady_fn2, _onDetachedFromTarget2, _defaultViewport2, _process, _connection5, _closeCallback, _targetFilterCallback3, _isPageTargetCallback, _defaultContext, _contexts, _targetManager3, _emitDisconnected, _setIsPageTargetCallback, setIsPageTargetCallback_fn, _createTarget, _onAttachedToTarget4, _onDetachedFromTarget3, _onTargetChanged, _onTargetDiscovered, _getVersion, getVersion_fn, _cache, _rootDir, _executablePath, _args3, _browserProcess, _exited, _hooksRan, _onExitHook, _browserProcessExiting, _runHooks, runHooks_fn, _configureStdio, configureStdio_fn, _clearListeners, clearListeners_fn, _onDriverProcessExit, _onDriverProcessSignal, _g, _ws, _pipeWrite, _subscriptions3, _isClosed, _pendingMessage, _dispatch, dispatch_fn, _product, __launcher, _lastLaunchedProduct, _launcher, launcher_get;
const electron = require("electron");
const path$f = require("node:path");
const require$$0$1 = require("net");
const require$$0$2 = require("http");
const promises = require("fs/promises");
const os = require("os");
const path$e = require("path");
const childProcess = require("child_process");
const fs$o = require("fs");
const readline = require("readline");
const require$$1 = require("https");
const require$$5$1 = require("url");
const require$$0$3 = require("tty");
const require$$4 = require("util");
const require$$1$1 = require("tls");
const require$$2$1 = require("crypto");
const require$$3$2 = require("events");
const require$$2 = require("assert");
const require$$0$4 = require("buffer");
const require$$0$5 = require("stream");
const require$$3$3 = require("dns");
const require$$0$6 = require("constants");
const require$$1$2 = require("zlib");
require("process");
var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
function _interopNamespaceDefault(e2) {
  const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k2 in e2) {
      if (k2 !== "default") {
        const d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: () => e2[k2]
        });
      }
    }
  }
  n2.default = e2;
  return Object.freeze(n2);
}
const require$$0__namespace = /* @__PURE__ */ _interopNamespaceDefault(require$$0$2);
const require$$1__namespace = /* @__PURE__ */ _interopNamespaceDefault(require$$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var bin$1 = {};
var getPort = { exports: {} };
const net$7 = require$$0$1;
class Locked extends Error {
  constructor(port) {
    super(`${port} is locked`);
  }
}
const lockedPorts = {
  old: /* @__PURE__ */ new Set(),
  young: /* @__PURE__ */ new Set()
};
const releaseOldLockedPortsIntervalMs = 1e3 * 15;
let interval;
const getAvailablePort = (options) => new Promise((resolve2, reject) => {
  const server = net$7.createServer();
  server.unref();
  server.on("error", reject);
  server.listen(options, () => {
    const { port } = server.address();
    server.close(() => {
      resolve2(port);
    });
  });
});
const portCheckSequence = function* (ports) {
  if (ports) {
    yield* ports;
  }
  yield 0;
};
getPort.exports = async (options) => {
  let ports;
  if (options) {
    ports = typeof options.port === "number" ? [options.port] : options.port;
  }
  if (interval === void 0) {
    interval = setInterval(() => {
      lockedPorts.old = lockedPorts.young;
      lockedPorts.young = /* @__PURE__ */ new Set();
    }, releaseOldLockedPortsIntervalMs);
    if (interval.unref) {
      interval.unref();
    }
  }
  for (const port of portCheckSequence(ports)) {
    try {
      let availablePort = await getAvailablePort({ ...options, port });
      while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
        if (port !== 0) {
          throw new Locked(port);
        }
        availablePort = await getAvailablePort({ ...options, port });
      }
      lockedPorts.young.add(availablePort);
      return availablePort;
    } catch (error) {
      if (!["EADDRINUSE", "EACCES"].includes(error.code) && !(error instanceof Locked)) {
        throw error;
      }
    }
  }
  throw new Error("No available ports found");
};
getPort.exports.makeRange = (from2, to) => {
  if (!Number.isInteger(from2) || !Number.isInteger(to)) {
    throw new TypeError("`from` and `to` must be integer numbers");
  }
  if (from2 < 1024 || from2 > 65535) {
    throw new RangeError("`from` must be between 1024 and 65535");
  }
  if (to < 1024 || to > 65536) {
    throw new RangeError("`to` must be between 1024 and 65536");
  }
  if (to < from2) {
    throw new RangeError("`to` must be greater than or equal to `from`");
  }
  const generator = function* (from3, to2) {
    for (let port = from3; port <= to2; port++) {
      yield port;
    }
  };
  return generator(from2, to);
};
var getPortExports = getPort.exports;
var retry$4 = {};
function RetryOperation(timeouts, options) {
  if (typeof options === "boolean") {
    options = { forever: options };
  }
  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;
  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }
  this._timeouts = [];
  this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (!err) {
    return false;
  }
  var currentTime = (/* @__PURE__ */ new Date()).getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error("RetryOperation timeout occurred"));
    return false;
  }
  this._errors.push(err);
  var timeout2 = this._timeouts.shift();
  if (timeout2 === void 0) {
    if (this._cachedTimeouts) {
      this._errors.splice(0, this._errors.length - 1);
      timeout2 = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }
  var self2 = this;
  this._timer = setTimeout(function() {
    self2._attempts++;
    if (self2._operationTimeoutCb) {
      self2._timeout = setTimeout(function() {
        self2._operationTimeoutCb(self2._attempts);
      }, self2._operationTimeout);
      if (self2._options.unref) {
        self2._timeout.unref();
      }
    }
    self2._fn(self2._attempts);
  }, timeout2);
  if (this._options.unref) {
    this._timer.unref();
  }
  return true;
};
RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;
  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }
  var self2 = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self2._operationTimeoutCb();
    }, self2._operationTimeout);
  }
  this._operationStart = (/* @__PURE__ */ new Date()).getTime();
  this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn) {
  console.log("Using RetryOperation.try() is deprecated");
  this.attempt(fn);
};
RetryOperation.prototype.start = function(fn) {
  console.log("Using RetryOperation.start() is deprecated");
  this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }
  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;
  for (var i2 = 0; i2 < this._errors.length; i2++) {
    var error = this._errors[i2];
    var message2 = error.message;
    var count = (counts[message2] || 0) + 1;
    counts[message2] = count;
    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }
  return mainError;
};
(function(exports2) {
  var RetryOperation2 = retry_operation;
  exports2.operation = function(options) {
    var timeouts = exports2.timeouts(options);
    return new RetryOperation2(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports2.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i2 = 0; i2 < opts.retries; i2++) {
      timeouts.push(this.createTimeout(i2, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i2, opts));
    }
    timeouts.sort(function(a2, b2) {
      return a2 - b2;
    });
    return timeouts;
  };
  exports2.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout2 = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout2 = Math.min(timeout2, opts.maxTimeout);
    return timeout2;
  };
  exports2.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i2 = 0; i2 < methods.length; i2++) {
      var method = methods[i2];
      var original = obj[method];
      obj[method] = (function retryWrapper(original2) {
        var op = exports2.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }).bind(obj, original);
      obj[method].options = options;
    }
  };
})(retry$4);
var retry$3 = retry$4;
var retrier = retry$3;
function retry$2(fn, opts) {
  function run(resolve2, reject) {
    var options = opts || {};
    var op;
    if (!("randomize" in options)) {
      options.randomize = true;
    }
    op = retrier.operation(options);
    function bail(err) {
      reject(err || new Error("Aborted"));
    }
    function onError(err, num) {
      if (err.bail) {
        bail(err);
        return;
      }
      if (!op.retry(err)) {
        reject(op.mainError());
      } else if (options.onRetry) {
        options.onRetry(err, num);
      }
    }
    function runAttempt(num) {
      var val;
      try {
        val = fn(bail, num);
      } catch (err) {
        onError(err, num);
        return;
      }
      Promise.resolve(val).then(resolve2).catch(function catchIt(err) {
        onError(err, num);
      });
    }
    op.attempt(runAttempt);
  }
  return new Promise(run);
}
var lib$2 = retry$2;
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1) {
  byteToHex.push((i$1 + 256).toString(16).substr(1));
}
function stringify$4(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset) {
  var i2 = buf && offset || 0;
  var b2 = buf || new Array(16);
  options = options || {};
  var node2 = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node2 == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node2 == null) {
      node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt2 < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i2++] = tl >>> 24 & 255;
  b2[i2++] = tl >>> 16 & 255;
  b2[i2++] = tl >>> 8 & 255;
  b2[i2++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i2++] = tmh >>> 8 & 255;
  b2[i2++] = tmh & 255;
  b2[i2++] = tmh >>> 24 & 15 | 16;
  b2[i2++] = tmh >>> 16 & 255;
  b2[i2++] = clockseq >>> 8 | 128;
  b2[i2++] = clockseq & 255;
  for (var n2 = 0; n2 < 6; ++n2) {
    b2[i2 + n2] = node2[n2];
  }
  return buf || stringify$4(b2);
}
function parse$7(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse$7(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return stringify$4(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i2 = 0; i2 < length32; i2 += 8) {
    var x2 = input[i2 >> 5] >>> i2 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b2 = -271733879;
  var c2 = -1732584194;
  var d2 = 271733878;
  for (var i2 = 0; i2 < x2.length; i2 += 16) {
    var olda = a2;
    var oldb = b2;
    var oldc = c2;
    var oldd = d2;
    a2 = md5ff(a2, b2, c2, d2, x2[i2], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 10], 17, -42063);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d2, x2[i2 + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c2, x2[i2 + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b2, x2[i2 + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d2, a2, x2[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d2, a2, x2[i2], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d2, x2[i2 + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c2, x2[i2 + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b2, x2[i2 + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d2, a2, x2[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c2, x2[i2], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d2, x2[i2 + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c2, x2[i2 + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b2, x2[i2 + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d2, a2, x2[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d2, x2[i2], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d2, x2[i2 + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c2, x2[i2 + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b2, x2[i2 + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d2, a2, x2[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x2, y2) {
  var lsw = (x2 & 65535) + (y2 & 65535);
  var msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a2, b2, x2, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x2, t2)), s2), b2);
}
function md5ff(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
}
function md5gg(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
}
function md5hh(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
}
function md5ii(a2, b2, c2, d2, x2, s2, t2) {
  return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify$4(rnds);
}
function f$1(s2, x2, y2, z2) {
  switch (s2) {
    case 0:
      return x2 & y2 ^ ~x2 & z2;
    case 1:
      return x2 ^ y2 ^ z2;
    case 2:
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    case 3:
      return x2 ^ y2 ^ z2;
  }
}
function ROTL(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function sha1(bytes) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l2 = bytes.length / 4 + 2;
  var N2 = Math.ceil(l2 / 16);
  var M2 = new Array(N2);
  for (var _i = 0; _i < N2; ++_i) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[_i * 64 + j2 * 4] << 24 | bytes[_i * 64 + j2 * 4 + 1] << 16 | bytes[_i * 64 + j2 * 4 + 2] << 8 | bytes[_i * 64 + j2 * 4 + 3];
    }
    M2[_i] = arr;
  }
  M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N2; ++_i2) {
    var W2 = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W2[t2] = M2[_i2][t2];
    }
    for (var _t2 = 16; _t2 < 80; ++_t2) {
      W2[_t2] = ROTL(W2[_t2 - 3] ^ W2[_t2 - 8] ^ W2[_t2 - 14] ^ W2[_t2 - 16], 1);
    }
    var a2 = H2[0];
    var b2 = H2[1];
    var c2 = H2[2];
    var d2 = H2[3];
    var e2 = H2[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s2 = Math.floor(_t22 / 20);
      var T2 = ROTL(a2, 5) + f$1(s2, b2, c2, d2) + e2 + K2[s2] + W2[_t22] >>> 0;
      e2 = d2;
      d2 = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T2;
    }
    H2[0] = H2[0] + a2 >>> 0;
    H2[1] = H2[1] + b2 >>> 0;
    H2[2] = H2[2] + c2 >>> 0;
    H2[3] = H2[3] + d2 >>> 0;
    H2[4] = H2[4] + e2 >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5;
const nil = "00000000-0000-0000-0000-000000000000";
function version$1(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$7,
  stringify: stringify$4,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getPage = exports2.connect = exports2.initialize = void 0;
  const get_port_1 = __importDefault2(getPortExports);
  const http_12 = __importDefault2(require$$0$2);
  const async_retry_1 = __importDefault2(lib$2);
  const uuid_1 = require$$3$1;
  const readJson = async (port) => new Promise((resolve2, reject) => {
    let json2 = "";
    const request = http_12.default.request({
      host: "127.0.0.1",
      path: "/json/version",
      port
    }, (response) => {
      response.on("error", reject);
      response.on("data", (chunk) => {
        json2 += chunk.toString();
      });
      response.on("end", () => resolve2(JSON.parse(json2)));
    });
    request.on("error", reject);
    request.end();
  });
  const initialize = async (app, port = 0) => {
    if (!app) {
      throw new Error("The parameter 'app' was not passed in. This may indicate that you are running in node rather than electron.");
    }
    if (app.isReady()) {
      throw new Error("Must be called at startup before the electron app is ready.");
    }
    if (port < 0 || port > 65535) {
      throw new Error(`Invalid port ${port}.`);
    }
    if (app.commandLine.getSwitchValue("remote-debugging-port")) {
      throw new Error("The electron application is already listening on a port. Double `initialize`?");
    }
    const actualPort = port === 0 ? await get_port_1.default({ host: "127.0.0.1" }) : port;
    app.commandLine.appendSwitch("remote-debugging-port", `${actualPort}`);
    app.commandLine.appendSwitch("remote-debugging-address", "127.0.0.1");
    const electronMajor = parseInt(app.getVersion().split(".")[0], 10);
    if (electronMajor >= 7) {
      app.commandLine.appendSwitch("enable-features", "NetworkService");
    }
  };
  exports2.initialize = initialize;
  const connect = async (app, puppeteer2) => {
    if (!puppeteer2) {
      throw new Error("The parameter 'puppeteer' was not passed in.");
    }
    const port = app.commandLine.getSwitchValue("remote-debugging-port");
    if (!port) {
      throw new Error("The electron application was not setup to listen on a port. Was `initialize` called at startup?");
    }
    await app.whenReady;
    const json2 = await async_retry_1.default(() => readJson(port));
    const browser2 = await puppeteer2.connect({
      browserWSEndpoint: json2.webSocketDebuggerUrl,
      defaultViewport: null
    });
    return browser2;
  };
  exports2.connect = connect;
  const getPage = async (browser2, window2, allowBlankNavigate = true) => {
    if (!browser2) {
      throw new Error("The parameter 'browser' was not passed in.");
    }
    if (!window2) {
      throw new Error("The parameter 'window' was not passed in.");
    }
    if (window2.webContents.getURL() === "") {
      if (allowBlankNavigate) {
        await window2.webContents.loadURL("about:blank");
      } else {
        throw new Error("In order to get the puppeteer Page, we must be able to execute JavaScript which requires the window having loaded a URL.");
      }
    }
    const guid = uuid_1.v4();
    await window2.webContents.executeJavaScript(`window.puppeteer = "${guid}"`);
    const pages = await browser2.pages();
    const guids = await Promise.all(pages.map(async (testPage) => {
      try {
        return await testPage.evaluate("window.puppeteer");
      } catch (_a3) {
        return void 0;
      }
    }));
    const index2 = guids.findIndex((testGuid) => testGuid === guid);
    await window2.webContents.executeJavaScript("delete window.puppeteer");
    const page = pages[index2];
    if (!page) {
      throw new Error("Unable to find puppeteer Page from BrowserWindow. Please report this.");
    }
    return page;
  };
  exports2.getPage = getPage;
  exports2.default = {
    connect: exports2.connect,
    getPage: exports2.getPage,
    initialize: exports2.initialize
  };
})(bin$1);
const pie = /* @__PURE__ */ getDefaultExportFromCjs(bin$1);
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b22) {
    d22.__proto__ = b22;
  } || function(d22, b22) {
    for (var p2 in b22)
      if (Object.prototype.hasOwnProperty.call(b22, p2))
        d22[p2] = b22[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter$1(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values$1(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spreadArray$1(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await$1(v2) {
  return this instanceof __await$1 ? (this.v = v2, this) : new __await$1(v2);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume2(n2, v2);
        });
      };
  }
  function resume2(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await$1 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume2("next", value);
  }
  function reject(value) {
    resume2("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume2(q2[0][0], q2[0][1]);
  }
}
function __asyncValues$1(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values$1 === "function" ? __values$1(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v22) {
      resolve2({ value: v22, done: d2 });
    }, reject);
  }
}
function isFunction(value) {
  return typeof value === "function";
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors2) {
    _super(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a3, e_2, _b3;
    var errors2;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values$1(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a3 = _parentage_1.return))
                _a3.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors2 = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values$1(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
              if (err instanceof UnsubscriptionError) {
                errors2 = __spreadArray$1(__spreadArray$1([], __read$1(errors2)), __read$1(err.errors));
              } else {
                errors2.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b3 = _finalizers_1.return))
              _b3.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors2) {
        throw new UnsubscriptionError(errors2);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a3;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a3 = this._finalizers) !== null && _a3 !== void 0 ? _a3 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray$1([handler, timeout2], __read$1(args)));
  },
  clearTimeout: function(handle) {
    return clearTimeout(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop$4() {
}
function errorContext(cb) {
  {
    cb();
  }
}
var Subscriber = function(_super) {
  __extends$1(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends$1(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop$4,
  error: defaultErrorHandler,
  complete: noop$4
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipe$1() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a3 = _this, operator = _a3.operator, source2 = _a3.source;
      subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a3;
    return (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a3;
  return (_a3 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a3 !== void 0 ? _a3 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function hasLift(source2) {
  return isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
}
function operate(init) {
  return function(source2) {
    if (hasLift(source2)) {
      return source2.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends$1(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a3;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a3 = this.onFinalize) === null || _a3 === void 0 ? void 0 : _a3.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends$1(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a3;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b3 = __values$1(_this.currentObservers), _c3 = _b3.next(); !_c3.done; _c3 = _b3.next()) {
            var observer = _c3.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c3 && !_c3.done && (_a3 = _b3.return))
              _a3.call(_b3);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a3;
      return ((_a3 = this.observers) === null || _a3 === void 0 ? void 0 : _a3.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a3 = this, hasError = _a3.hasError, isStopped = _a3.isStopped, observers = _a3.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a3 = this, hasError = _a3.hasError, thrownError = _a3.thrownError, isStopped = _a3.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source2) {
    return new AnonymousSubject(destination, source2);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends$1(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source2) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source2;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a3, _b3;
    (_b3 = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.next) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a3, _b3;
    (_b3 = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.error) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a3, _b3;
    (_b3 = (_a3 = this.destination) === null || _a3 === void 0 ? void 0 : _a3.complete) === null || _b3 === void 0 ? void 0 : _b3.call(_a3);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a3, _b3;
    return (_b3 = (_a3 = this.source) === null || _a3 === void 0 ? void 0 : _a3.subscribe(subscriber)) !== null && _b3 !== void 0 ? _b3 : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
var ReplaySubject = function(_super) {
  __extends$1(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a3 = this, isStopped = _a3.isStopped, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow, _timestampProvider = _a3._timestampProvider, _windowTime = _a3._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a3 = this, _infiniteTimeWindow = _a3._infiniteTimeWindow, _buffer = _a3._buffer;
    var copy2 = _buffer.slice();
    for (var i2 = 0; i2 < copy2.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a3 = this, _bufferSize = _a3._bufferSize, _timestampProvider = _a3._timestampProvider, _buffer = _a3._buffer, _infiniteTimeWindow = _a3._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last2 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
        last2 = i2;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);
var Action = function(_super) {
  __extends$1(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    return this;
  };
  return Action2;
}(Subscription);
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    return setInterval.apply(void 0, __spreadArray$1([handler, timeout2], __read$1(args)));
  },
  clearInterval: function(handle) {
    return clearInterval(handle);
  },
  delegate: void 0
};
var AsyncAction = function(_super) {
  __extends$1(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a3;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a3 = this.id) !== null && _a3 !== void 0 ? _a3 : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id6, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay2) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a3 = this, id = _a3.id, scheduler = _a3.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends$1(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator$1 = getSymbolIterator();
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator$1]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator$1(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a3, value, done;
    return __generator$1(this, function(_b3) {
      switch (_b3.label) {
        case 0:
          reader = readableStream.getReader();
          _b3.label = 1;
        case 1:
          _b3.trys.push([1, , 9, 10]);
          _b3.label = 2;
        case 2:
          return [4, __await$1(reader.read())];
        case 3:
          _a3 = _b3.sent(), value = _a3.value, done = _a3.done;
          if (!done)
            return [3, 5];
          return [4, __await$1(void 0)];
        case 4:
          return [2, _b3.sent()];
        case 5:
          return [4, __await$1(value)];
        case 6:
          return [4, _b3.sent()];
        case 7:
          _b3.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a3;
    try {
      for (var iterable_1 = __values$1(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a3 = iterable_1.return))
          _a3.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process$1(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process$1(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a3;
  return __awaiter$1(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator$1(this, function(_b3) {
      switch (_b3.label) {
        case 0:
          _b3.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues$1(asyncIterable);
          _b3.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b3.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b3.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b3.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b3.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a3 = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a3.call(asyncIterable_1)];
        case 7:
          _b3.sent();
          _b3.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source2, subscriber) {
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source2, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source2.subscribe(subscriber);
    }, delay2));
  });
}
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator$1]();
      executeSchedule(subscriber, scheduler, function() {
        var _a3;
        var value;
        var done;
        try {
          _a3 = iterator2.next(), value = _a3.value, done = _a3.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from$1(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from$1(args, scheduler);
}
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function lastValueFrom(source2, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var _hasValue = false;
    var _value2;
    source2.subscribe({
      next: function(value) {
        _value2 = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve2(_value2);
        } else if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}
function firstValueFrom(source2, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve2(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source2.subscribe(subscriber);
  });
}
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
function map(project, thisArg) {
  return operate(function(source2, subscriber) {
    var index2 = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index2++));
    }));
  });
}
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray$1([], __read$1(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}
var isArray2 = Array.isArray;
var getPrototypeOf$1 = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf$1(obj) === objectProto;
}
function createObject(keys, values) {
  return keys.reduce(function(result, key, i2) {
    return result[key] = values[i2], result;
  }, {});
}
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a3 = argsArgArrayOrObject(args), observables = _a3.args, keys = _a3.keys;
  if (observables.length === 0) {
    return from$1([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i22) {
        maybeSchedule(scheduler, function() {
          var source2 = from$1(observables[i22], scheduler);
          var hasFirstValue = false;
          source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i22] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i2 = 0; i2 < length; i2++) {
        _loop_1(i2);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
function mergeInternals(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index2 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source2.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a2, i2) {
      return map(function(b2, ii) {
        return resultSelector(a2, b2, i2, ii);
      })(innerFrom(project(a2, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source2, subscriber) {
    return mergeInternals(source2, subscriber, project, concurrent);
  });
}
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from$1(args, popScheduler(args)));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a3 = __read$1(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a3[0], remove2 = _a3[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove2(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from$1(sources, scheduler));
}
var NEVER = new Observable(noop$4);
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}
function filter(predicate, thisArg) {
  return operate(function(source2, subscriber) {
    var index2 = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index2++) && subscriber.next(value);
    }));
  });
}
function race() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i22) {
      subscriptions.push(innerFrom(sources[i22]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s2 = 0; s2 < subscriptions.length; s2++) {
            s2 !== i22 && subscriptions[s2].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i2 = 0; subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
      _loop_1(i2);
    }
  };
}
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
  return operate(function(source2, subscriber) {
    var buffers = [];
    var count = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a3, e_2, _b3;
      var toEmit = null;
      if (count++ % startBufferEvery === 0) {
        buffers.push([]);
      }
      try {
        for (var buffers_1 = __values$1(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer = buffers_1_1.value;
          buffer.push(value);
          if (bufferSize <= buffer.length) {
            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
            toEmit.push(buffer);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a3 = buffers_1.return))
            _a3.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (toEmit) {
        try {
          for (var toEmit_1 = __values$1(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
            var buffer = toEmit_1_1.value;
            arrRemove(buffers, buffer);
            subscriber.next(buffer);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (toEmit_1_1 && !toEmit_1_1.done && (_b3 = toEmit_1.return))
              _b3.call(toEmit_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    }, function() {
      var e_3, _a3;
      try {
        for (var buffers_2 = __values$1(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
          var buffer = buffers_2_1.value;
          subscriber.next(buffer);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (buffers_2_1 && !buffers_2_1.done && (_a3 = buffers_2.return))
            _a3.call(buffers_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffers = null;
    }));
  });
}
function catchError(selector) {
  return operate(function(source2, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source2.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source2)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}
function defaultIfEmpty(defaultValue) {
  return operate(function(source2, subscriber) {
    var hasValue = false;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
function take(count) {
  return count <= 0 ? function() {
    return EMPTY;
  } : operate(function(source2, subscriber) {
    var seen = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count) {
        subscriber.next(value);
        if (count <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
function ignoreElements() {
  return operate(function(source2, subscriber) {
    source2.subscribe(createOperatorSubscriber(subscriber, noop$4));
  });
}
function mapTo(value) {
  return map(function() {
    return value;
  });
}
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source2) {
      return concat$1(subscriptionDelay.pipe(take(1), ignoreElements()), source2.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value, index2) {
    return innerFrom(delayDurationSelector(value, index2)).pipe(take(1), mapTo(value));
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source2, subscriber) {
    var hasValue = false;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter(function(v2, i2) {
      return predicate(v2, i2, source2);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return operate(function(source2, subscriber) {
    var state = seed;
    return mergeInternals(source2, subscriber, function(value, index2) {
      return accumulator(state, value, index2);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source2, subscriber) {
    raceInit(__spreadArray$1([source2], __read$1(otherSources)))(subscriber);
  });
}
function retry$1(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a3 = config2.count, count = _a3 === void 0 ? Infinity : _a3, delay2 = config2.delay, _b3 = config2.resetOnSuccess, resetOnSuccess = _b3 === void 0 ? false : _b3;
  return count <= 0 ? identity : operate(function(source2, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source2, subscriber) {
    (scheduler ? concat$1(values, source2, scheduler) : concat$1(values, source2)).subscribe(subscriber);
  });
}
function switchMap(project, resultSelector) {
  return operate(function(source2, subscriber) {
    var innerSubscriber = null;
    var index2 = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index2++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
function takeUntil(notifier) {
  return operate(function(source2, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop$4));
    !subscriber.closed && source2.subscribe(subscriber);
  });
}
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source2, subscriber) {
    var _a3;
    (_a3 = tapObserver.subscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
    var isUnsub = true;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a22;
      (_a22 = tapObserver.next) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a22;
      isUnsub = false;
      (_a22 = tapObserver.complete) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a22;
      isUnsub = false;
      (_a22 = tapObserver.error) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a22, _b3;
      if (isUnsub) {
        (_a22 = tapObserver.unsubscribe) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
      }
      (_b3 = tapObserver.finalize) === null || _b3 === void 0 ? void 0 : _b3.call(tapObserver);
    }));
  }) : identity;
}
function mitt_default(n2) {
  return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {
    var i2 = n2.get(t2);
    i2 ? i2.push(e2) : n2.set(t2, [e2]);
  }, off: function(t2, e2) {
    var i2 = n2.get(t2);
    i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));
  }, emit: function(t2, e2) {
    var i2 = n2.get(t2);
    i2 && i2.slice().map(function(n22) {
      n22(e2);
    }), (i2 = n2.get("*")) && i2.slice().map(function(n22) {
      n22(t2, e2);
    });
  } };
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
Symbol.dispose ?? (Symbol.dispose = Symbol("dispose"));
Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol("asyncDispose"));
const disposeSymbol = Symbol.dispose;
const asyncDisposeSymbol = Symbol.asyncDispose;
const _DisposableStack = class _DisposableStack {
  constructor() {
    __privateAdd(this, _disposed, false);
    __privateAdd(this, _stack, []);
    __publicField(this, _a2, this.dispose);
    __publicField(this, _b2, "DisposableStack");
  }
  /**
   * Returns a value indicating whether this stack has been disposed.
   */
  get disposed() {
    return __privateGet(this, _disposed);
  }
  /**
   * Disposes each resource in the stack in the reverse order that they were added.
   */
  dispose() {
    if (__privateGet(this, _disposed)) {
      return;
    }
    __privateSet(this, _disposed, true);
    for (const resource of __privateGet(this, _stack).reverse()) {
      resource[disposeSymbol]();
    }
  }
  /**
   * Adds a disposable resource to the stack, returning the resource.
   *
   * @param value - The resource to add. `null` and `undefined` will not be added,
   * but will be returned.
   * @returns The provided `value`.
   */
  use(value) {
    if (value) {
      __privateGet(this, _stack).push(value);
    }
    return value;
  }
  /**
   * Adds a value and associated disposal callback as a resource to the stack.
   *
   * @param value - The value to add.
   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
   * method. Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(value, onDispose) {
    __privateGet(this, _stack).push({
      [disposeSymbol]() {
        onDispose(value);
      }
    });
    return value;
  }
  /**
   * Adds a callback to be invoked when the stack is disposed.
   */
  defer(onDispose) {
    __privateGet(this, _stack).push({
      [disposeSymbol]() {
        onDispose();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (__privateGet(this, _disposed)) {
      throw new ReferenceError("a disposed stack can not use anything new");
    }
    const stack = new _DisposableStack();
    __privateSet(stack, _stack, __privateGet(this, _stack));
    __privateSet(this, _disposed, true);
    return stack;
  }
};
_a2 = disposeSymbol, _b2 = Symbol.toStringTag;
_disposed = new WeakMap();
_stack = new WeakMap();
let DisposableStack = _DisposableStack;
const _AsyncDisposableStack = class _AsyncDisposableStack {
  constructor() {
    __privateAdd(this, _disposed2, false);
    __privateAdd(this, _stack2, []);
    __publicField(this, _c2, this.dispose);
    __publicField(this, _d, "AsyncDisposableStack");
  }
  /**
   * Returns a value indicating whether this stack has been disposed.
   */
  get disposed() {
    return __privateGet(this, _disposed2);
  }
  /**
   * Disposes each resource in the stack in the reverse order that they were added.
   */
  async dispose() {
    if (__privateGet(this, _disposed2)) {
      return;
    }
    __privateSet(this, _disposed2, true);
    for (const resource of __privateGet(this, _stack2).reverse()) {
      await resource[asyncDisposeSymbol]();
    }
  }
  /**
   * Adds a disposable resource to the stack, returning the resource.
   *
   * @param value - The resource to add. `null` and `undefined` will not be added,
   * but will be returned.
   * @returns The provided `value`.
   */
  use(value) {
    if (value) {
      __privateGet(this, _stack2).push(value);
    }
    return value;
  }
  /**
   * Adds a value and associated disposal callback as a resource to the stack.
   *
   * @param value - The value to add.
   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
   * method. Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(value, onDispose) {
    __privateGet(this, _stack2).push({
      [asyncDisposeSymbol]() {
        return onDispose(value);
      }
    });
    return value;
  }
  /**
   * Adds a callback to be invoked when the stack is disposed.
   */
  defer(onDispose) {
    __privateGet(this, _stack2).push({
      [asyncDisposeSymbol]() {
        return onDispose();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (__privateGet(this, _disposed2)) {
      throw new ReferenceError("a disposed stack can not use anything new");
    }
    const stack = new _AsyncDisposableStack();
    __privateSet(stack, _stack2, __privateGet(this, _stack2));
    __privateSet(this, _disposed2, true);
    return stack;
  }
};
_c2 = asyncDisposeSymbol, _d = Symbol.toStringTag;
_disposed2 = new WeakMap();
_stack2 = new WeakMap();
let AsyncDisposableStack = _AsyncDisposableStack;
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
let EventEmitter$2 = (_e = class {
  /**
   * If you pass an emitter, the returned emitter will wrap the passed emitter.
   *
   * @internal
   */
  constructor(emitter = mitt_default(/* @__PURE__ */ new Map())) {
    __privateAdd(this, _emitter, void 0);
    __privateAdd(this, _handlers, /* @__PURE__ */ new Map());
    __privateSet(this, _emitter, emitter);
  }
  /**
   * Bind an event listener to fire when an event occurs.
   * @param type - the event type you'd like to listen to. Can be a string or symbol.
   * @param handler - the function to be called when the event occurs.
   * @returns `this` to enable you to chain method calls.
   */
  on(type, handler) {
    const handlers = __privateGet(this, _handlers).get(type);
    if (handlers === void 0) {
      __privateGet(this, _handlers).set(type, [handler]);
    } else {
      handlers.push(handler);
    }
    __privateGet(this, _emitter).on(type, handler);
    return this;
  }
  /**
   * Remove an event listener from firing.
   * @param type - the event type you'd like to stop listening to.
   * @param handler - the function that should be removed.
   * @returns `this` to enable you to chain method calls.
   */
  off(type, handler) {
    const handlers = __privateGet(this, _handlers).get(type) ?? [];
    if (handler === void 0) {
      for (const handler2 of handlers) {
        __privateGet(this, _emitter).off(type, handler2);
      }
      __privateGet(this, _handlers).delete(type);
      return this;
    }
    const index2 = handlers.lastIndexOf(handler);
    if (index2 > -1) {
      __privateGet(this, _emitter).off(type, ...handlers.splice(index2, 1));
    }
    return this;
  }
  /**
   * Emit an event and call any associated listeners.
   *
   * @param type - the event you'd like to emit
   * @param eventData - any data you'd like to emit with the event
   * @returns `true` if there are any listeners, `false` if there are not.
   */
  emit(type, event) {
    __privateGet(this, _emitter).emit(type, event);
    return this.listenerCount(type) > 0;
  }
  /**
   * Like `on` but the listener will only be fired once and then it will be removed.
   * @param type - the event you'd like to listen to
   * @param handler - the handler function to run when the event occurs
   * @returns `this` to enable you to chain method calls.
   */
  once(type, handler) {
    const onceHandler = (eventData) => {
      handler(eventData);
      this.off(type, onceHandler);
    };
    return this.on(type, onceHandler);
  }
  /**
   * Gets the number of listeners for a given event.
   *
   * @param type - the event to get the listener count for
   * @returns the number of listeners bound to the given event
   */
  listenerCount(type) {
    var _a3;
    return ((_a3 = __privateGet(this, _handlers).get(type)) == null ? void 0 : _a3.length) || 0;
  }
  /**
   * Removes all listeners. If given an event argument, it will remove only
   * listeners for that event.
   *
   * @param type - the event to remove listeners for.
   * @returns `this` to enable you to chain method calls.
   */
  removeAllListeners(type) {
    if (type !== void 0) {
      return this.off(type);
    }
    this[disposeSymbol]();
    return this;
  }
  /**
   * @internal
   */
  [disposeSymbol]() {
    for (const [type, handlers] of __privateGet(this, _handlers)) {
      for (const handler of handlers) {
        __privateGet(this, _emitter).off(type, handler);
      }
    }
    __privateGet(this, _handlers).clear();
  }
}, _emitter = new WeakMap(), _handlers = new WeakMap(), _e);
class EventSubscription {
  constructor(target, type, handler) {
    __privateAdd(this, _target, void 0);
    __privateAdd(this, _type, void 0);
    __privateAdd(this, _handler, void 0);
    __privateSet(this, _target, target);
    __privateSet(this, _type, type);
    __privateSet(this, _handler, handler);
    __privateGet(this, _target).on(__privateGet(this, _type), __privateGet(this, _handler));
  }
  [disposeSymbol]() {
    __privateGet(this, _target).off(__privateGet(this, _type), __privateGet(this, _handler));
  }
}
_target = new WeakMap();
_type = new WeakMap();
_handler = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const assert$1 = (value, message2) => {
  if (!value) {
    throw new Error(message2);
  }
};
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const isNode = !!(typeof process !== "undefined" && process.version);
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
let debugModule = null;
async function importDebug() {
  if (!debugModule) {
    debugModule = (await Promise.resolve().then(() => index)).default;
  }
  return debugModule;
}
const debug$g = (prefix) => {
  if (isNode) {
    return async (...logArgs) => {
      (await importDebug())(prefix)(logArgs);
    };
  }
  return (...logArgs) => {
    const debugLevel = globalThis.__PUPPETEER_DEBUG;
    if (!debugLevel) {
      return;
    }
    const everythingShouldBeLogged = debugLevel === "*";
    const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
     * If the debug level is `foo*`, that means we match any prefix that
     * starts with `foo`. If the level is `foo`, we match only the prefix
     * `foo`.
     */
    (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
    if (!prefixMatchesDebugLevel) {
      return;
    }
    console.log(`${prefix}:`, ...logArgs);
  };
};
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PuppeteerError extends Error {
  /**
   * @internal
   */
  constructor(message2, options) {
    super(message2, options);
    this.name = this.constructor.name;
  }
  /**
   * @internal
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
}
let TimeoutError$1 = class TimeoutError extends PuppeteerError {
};
class ProtocolError extends PuppeteerError {
  constructor() {
    super(...arguments);
    __privateAdd(this, _code, void 0);
    __privateAdd(this, _originalMessage, "");
  }
  set code(code2) {
    __privateSet(this, _code, code2);
  }
  /**
   * @readonly
   * @public
   */
  get code() {
    return __privateGet(this, _code);
  }
  set originalMessage(originalMessage) {
    __privateSet(this, _originalMessage, originalMessage);
  }
  /**
   * @readonly
   * @public
   */
  get originalMessage() {
    return __privateGet(this, _originalMessage);
  }
}
_code = new WeakMap();
_originalMessage = new WeakMap();
class UnsupportedOperation extends PuppeteerError {
}
class TargetCloseError extends ProtocolError {
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const paperFormats = {
  letter: { width: 8.5, height: 11 },
  legal: { width: 8.5, height: 14 },
  tabloid: { width: 11, height: 17 },
  ledger: { width: 17, height: 11 },
  a0: { width: 33.1, height: 46.8 },
  a1: { width: 23.4, height: 33.1 },
  a2: { width: 16.54, height: 23.4 },
  a3: { width: 11.7, height: 16.54 },
  a4: { width: 8.27, height: 11.7 },
  a5: { width: 5.83, height: 8.27 },
  a6: { width: 4.13, height: 5.83 }
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugError = debug$g("puppeteer:error");
const DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
const SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
const _PuppeteerURL = class _PuppeteerURL {
  constructor() {
    __privateAdd(this, _functionName, void 0);
    __privateAdd(this, _siteString, void 0);
  }
  static fromCallSite(functionName, site) {
    const url = new _PuppeteerURL();
    __privateSet(url, _functionName, functionName);
    __privateSet(url, _siteString, site.toString());
    return url;
  }
  get functionName() {
    return __privateGet(this, _functionName);
  }
  get siteString() {
    return __privateGet(this, _siteString);
  }
  toString() {
    return `pptr:${[
      __privateGet(this, _functionName),
      encodeURIComponent(__privateGet(this, _siteString))
    ].join(";")}`;
  }
};
_functionName = new WeakMap();
_siteString = new WeakMap();
__publicField(_PuppeteerURL, "INTERNAL_URL", "pptr:internal");
__publicField(_PuppeteerURL, "parse", (url) => {
  url = url.slice("pptr:".length);
  const [functionName = "", siteString = ""] = url.split(";");
  const puppeteerUrl = new _PuppeteerURL();
  __privateSet(puppeteerUrl, _functionName, functionName);
  __privateSet(puppeteerUrl, _siteString, decodeURIComponent(siteString));
  return puppeteerUrl;
});
__publicField(_PuppeteerURL, "isPuppeteerURL", (url) => {
  return url.startsWith("pptr:");
});
let PuppeteerURL = _PuppeteerURL;
const withSourcePuppeteerURLIfNone = (functionName, object) => {
  if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
    return object;
  }
  const original = Error.prepareStackTrace;
  Error.prepareStackTrace = (_2, stack) => {
    return stack[2];
  };
  const site = new Error().stack;
  Error.prepareStackTrace = original;
  return Object.assign(object, {
    [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
  });
};
const getSourcePuppeteerURLIfAvailable = (object) => {
  if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
    return object[SOURCE_URL];
  }
  return void 0;
};
const isString = (obj) => {
  return typeof obj === "string" || obj instanceof String;
};
const isNumber = (obj) => {
  return typeof obj === "number" || obj instanceof Number;
};
const isPlainObject = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Object;
};
const isRegExp = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === RegExp;
};
const isDate = (obj) => {
  return typeof obj === "object" && (obj == null ? void 0 : obj.constructor) === Date;
};
function evaluationString(fun, ...args) {
  if (isString(fun)) {
    assert$1(args.length === 0, "Cannot evaluate a string with arguments");
    return fun;
  }
  function serializeArgument(arg) {
    if (Object.is(arg, void 0)) {
      return "undefined";
    }
    return JSON.stringify(arg);
  }
  return `(${fun})(${args.map(serializeArgument).join(",")})`;
}
let fs$n = null;
async function importFSPromises() {
  if (!fs$n) {
    try {
      fs$n = await import("fs/promises");
    } catch (error) {
      if (error instanceof TypeError) {
        throw new Error("Cannot write to a path outside of a Node-like environment.");
      }
      throw error;
    }
  }
  return fs$n;
}
async function getReadableAsBuffer(readable, path2) {
  const buffers = [];
  const reader = readable.getReader();
  if (path2) {
    const fs2 = await importFSPromises();
    const fileHandle = await fs2.open(path2, "w+");
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        buffers.push(value);
        await fileHandle.writeFile(value);
      }
    } finally {
      await fileHandle.close();
    }
  } else {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      buffers.push(value);
    }
  }
  try {
    return Buffer.concat(buffers);
  } catch (error) {
    debugError(error);
    return null;
  }
}
async function getReadableFromProtocolStream(client, handle) {
  return new ReadableStream({
    async pull(controller) {
      function getUnit8Array(data3, isBase64) {
        if (isBase64) {
          return Uint8Array.from(atob(data3), (m2) => {
            return m2.codePointAt(0);
          });
        }
        const encoder = new TextEncoder();
        return encoder.encode(data3);
      }
      const { data: data2, base64Encoded, eof } = await client.send("IO.read", {
        handle
      });
      controller.enqueue(getUnit8Array(data2, base64Encoded ?? false));
      if (eof) {
        await client.send("IO.close", { handle });
        controller.close();
      }
    }
  });
}
function validateDialogType(type) {
  let dialogType = null;
  const validDialogTypes = /* @__PURE__ */ new Set([
    "alert",
    "confirm",
    "prompt",
    "beforeunload"
  ]);
  if (validDialogTypes.has(type)) {
    dialogType = type;
  }
  assert$1(dialogType, `Unknown javascript dialog type: ${type}`);
  return dialogType;
}
function timeout(ms2, cause) {
  return ms2 === 0 ? NEVER : timer(ms2).pipe(map(() => {
    throw new TimeoutError$1(`Timed out after waiting ${ms2}ms`, { cause });
  }));
}
const UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
const SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
function getSourceUrlComment(url) {
  return `//# sourceURL=${url}`;
}
const NETWORK_IDLE_TIME = 500;
function parsePDFOptions(options = {}, lengthUnit = "in") {
  var _a3, _b3, _c3, _d2;
  const defaults = {
    scale: 1,
    displayHeaderFooter: false,
    headerTemplate: "",
    footerTemplate: "",
    printBackground: false,
    landscape: false,
    pageRanges: "",
    preferCSSPageSize: false,
    omitBackground: false,
    outline: false,
    tagged: true
  };
  let width = 8.5;
  let height = 11;
  if (options.format) {
    const format = paperFormats[options.format.toLowerCase()];
    assert$1(format, "Unknown paper format: " + options.format);
    width = format.width;
    height = format.height;
  } else {
    width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
    height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;
  }
  const margin = {
    top: convertPrintParameterToInches((_a3 = options.margin) == null ? void 0 : _a3.top, lengthUnit) || 0,
    left: convertPrintParameterToInches((_b3 = options.margin) == null ? void 0 : _b3.left, lengthUnit) || 0,
    bottom: convertPrintParameterToInches((_c3 = options.margin) == null ? void 0 : _c3.bottom, lengthUnit) || 0,
    right: convertPrintParameterToInches((_d2 = options.margin) == null ? void 0 : _d2.right, lengthUnit) || 0
  };
  if (options.outline) {
    options.tagged = true;
  }
  return {
    ...defaults,
    ...options,
    width,
    height,
    margin
  };
}
const unitToPixels = {
  px: 1,
  in: 96,
  cm: 37.8,
  mm: 3.78
};
function convertPrintParameterToInches(parameter, lengthUnit = "in") {
  if (typeof parameter === "undefined") {
    return void 0;
  }
  let pixels;
  if (isNumber(parameter)) {
    pixels = parameter;
  } else if (isString(parameter)) {
    const text = parameter;
    let unit = text.substring(text.length - 2).toLowerCase();
    let valueText = "";
    if (unit in unitToPixels) {
      valueText = text.substring(0, text.length - 2);
    } else {
      unit = "px";
      valueText = text;
    }
    const value = Number(valueText);
    assert$1(!isNaN(value), "Failed to parse parameter value: " + text);
    pixels = value * unitToPixels[unit];
  } else {
    throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
  }
  return pixels / unitToPixels[lengthUnit];
}
function fromEmitterEvent(emitter, eventName) {
  return new Observable((subscriber) => {
    const listener = (event) => {
      subscriber.next(event);
    };
    emitter.on(eventName, listener);
    return () => {
      emitter.off(eventName, listener);
    };
  });
}
function filterAsync(predicate) {
  return mergeMap((value) => {
    return from$1(Promise.resolve(predicate(value))).pipe(filter((isMatch) => {
      return isMatch;
    }), map(() => {
      return value;
    }));
  });
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
  ["geolocation", "geolocation"],
  ["midi", "midi"],
  ["notifications", "notifications"],
  // TODO: push isn't a valid type?
  // ['push', 'push'],
  ["camera", "videoCapture"],
  ["microphone", "audioCapture"],
  ["background-sync", "backgroundSync"],
  ["ambient-light-sensor", "sensors"],
  ["accelerometer", "sensors"],
  ["gyroscope", "sensors"],
  ["magnetometer", "sensors"],
  ["accessibility-events", "accessibilityEvents"],
  ["clipboard-read", "clipboardReadWrite"],
  ["clipboard-write", "clipboardReadWrite"],
  ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
  ["payment-handler", "paymentHandler"],
  ["persistent-storage", "durableStorage"],
  ["idle-detection", "idleDetection"],
  // chrome-specific permissions we have.
  ["midi-sysex", "midiSysex"]
]);
let Browser$1 = class Browser extends EventEmitter$2 {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browser.waitForTarget(
   *   target => target.url() === 'https://www.example.com/'
   * );
   * ```
   */
  async waitForTarget(predicate, options = {}) {
    const { timeout: ms2 = 3e4 } = options;
    return await firstValueFrom(merge(fromEmitterEvent(
      this,
      "targetcreated"
      /* BrowserEvent.TargetCreated */
    ), fromEmitterEvent(
      this,
      "targetchanged"
      /* BrowserEvent.TargetChanged */
    ), from$1(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms2))));
  }
  /**
   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
   *
   * If there ar multiple {@link BrowserContext | browser contexts}, this
   * returns all {@link Page | pages} in all
   * {@link BrowserContext | browser contexts}.
   *
   * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
   * will not be listed here. You can find them using {@link Target.page}.
   */
  async pages() {
    const contextPages = await Promise.all(this.browserContexts().map((context2) => {
      return context2.pages();
    }));
    return contextPages.reduce((acc, x2) => {
      return acc.concat(x2);
    }, []);
  }
  /**
   * Whether Puppeteer is connected to this {@link Browser | browser}.
   *
   * @deprecated Use {@link Browser | Browser.connected}.
   */
  isConnected() {
    return this.connected;
  }
  /** @internal */
  [disposeSymbol]() {
    if (this.process()) {
      return void this.close().catch(debugError);
    }
    return void this.disconnect().catch(debugError);
  }
  /** @internal */
  [asyncDisposeSymbol]() {
    if (this.process()) {
      return this.close();
    }
    return this.disconnect();
  }
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class BrowserContext extends EventEmitter$2 {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browserContext.waitForTarget(
   *   target => target.url() === 'https://www.example.com/'
   * );
   * ```
   */
  async waitForTarget(predicate, options = {}) {
    const { timeout: ms2 = 3e4 } = options;
    return await firstValueFrom(merge(fromEmitterEvent(
      this,
      "targetcreated"
      /* BrowserContextEvent.TargetCreated */
    ), fromEmitterEvent(
      this,
      "targetchanged"
      /* BrowserContextEvent.TargetChanged */
    ), from$1(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms2))));
  }
  /**
   * Whether this {@link BrowserContext | browser context} is closed.
   */
  get closed() {
    return !this.browser().browserContexts().includes(this);
  }
  /**
   * Identifier for this {@link BrowserContext | browser context}.
   */
  get id() {
    return void 0;
  }
  /** @internal */
  [disposeSymbol]() {
    return void this.close().catch(debugError);
  }
  /** @internal */
  [asyncDisposeSymbol]() {
    return this.close();
  }
}
var CDPSessionEvent;
(function(CDPSessionEvent2) {
  CDPSessionEvent2.Disconnected = Symbol("CDPSession.Disconnected");
  CDPSessionEvent2.Swapped = Symbol("CDPSession.Swapped");
  CDPSessionEvent2.Ready = Symbol("CDPSession.Ready");
  CDPSessionEvent2.SessionAttached = "sessionattached";
  CDPSessionEvent2.SessionDetached = "sessiondetached";
})(CDPSessionEvent || (CDPSessionEvent = {}));
class CDPSession extends EventEmitter$2 {
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Parent session in terms of CDP's auto-attach mechanism.
   *
   * @internal
   */
  parentSession() {
    return void 0;
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Dialog {
  /**
   * @internal
   */
  constructor(type, message2, defaultValue = "") {
    __privateAdd(this, _type2, void 0);
    __privateAdd(this, _message, void 0);
    __privateAdd(this, _defaultValue, void 0);
    __privateAdd(this, _handled, false);
    __privateSet(this, _type2, type);
    __privateSet(this, _message, message2);
    __privateSet(this, _defaultValue, defaultValue);
  }
  /**
   * The type of the dialog.
   */
  type() {
    return __privateGet(this, _type2);
  }
  /**
   * The message displayed in the dialog.
   */
  message() {
    return __privateGet(this, _message);
  }
  /**
   * The default value of the prompt, or an empty string if the dialog
   * is not a `prompt`.
   */
  defaultValue() {
    return __privateGet(this, _defaultValue);
  }
  /**
   * A promise that resolves when the dialog has been accepted.
   *
   * @param promptText - optional text that will be entered in the dialog
   * prompt. Has no effect if the dialog's type is not `prompt`.
   *
   */
  async accept(promptText) {
    assert$1(!__privateGet(this, _handled), "Cannot accept dialog which is already handled!");
    __privateSet(this, _handled, true);
    await this.handle({
      accept: true,
      text: promptText
    });
  }
  /**
   * A promise which will resolve once the dialog has been dismissed
   */
  async dismiss() {
    assert$1(!__privateGet(this, _handled), "Cannot dismiss dialog which is already handled!");
    __privateSet(this, _handled, true);
    await this.handle({
      accept: false
    });
  }
}
_type2 = new WeakMap();
_message = new WeakMap();
_defaultValue = new WeakMap();
_handled = new WeakMap();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _isElementHandle = Symbol("_isElementHandle");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function isErrorLike$1(obj) {
  return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
}
function rewriteError$1(error, message2, originalMessage) {
  error.message = message2;
  error.originalMessage = originalMessage ?? error.originalMessage;
  return error;
}
function createProtocolErrorMessage(object) {
  let message2 = object.error.message;
  if (object.error && typeof object.error === "object" && "data" in object.error) {
    message2 += ` ${object.error.data}`;
  }
  return message2;
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const createdFunctions = /* @__PURE__ */ new Map();
const createFunction = (functionValue) => {
  let fn = createdFunctions.get(functionValue);
  if (fn) {
    return fn;
  }
  fn = new Function(`return ${functionValue}`)();
  createdFunctions.set(functionValue, fn);
  return fn;
};
function stringifyFunction(fn) {
  let value = fn.toString();
  try {
    new Function(`(${value})`);
  } catch {
    let prefix = "function ";
    if (value.startsWith("async ")) {
      prefix = `async ${prefix}`;
      value = value.substring("async ".length);
    }
    value = `${prefix}${value}`;
    try {
      new Function(`(${value})`);
    } catch {
      throw new Error("Passed function cannot be serialized!");
    }
  }
  return value;
}
const interpolateFunction = (fn, replacements) => {
  let value = stringifyFunction(fn);
  for (const [name2, jsValue] of Object.entries(replacements)) {
    value = value.replace(
      new RegExp(`PLACEHOLDER\\(\\s*(?:'${name2}'|"${name2}")\\s*\\)`, "g"),
      // Wrapping this ensures tersers that accidentally inline PLACEHOLDER calls
      // are still valid. Without, we may get calls like ()=>{...}() which is
      // not valid.
      `(${jsValue})`
    );
  }
  return createFunction(value);
};
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$b = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$b = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
const DEFAULT_BATCH_SIZE = 20;
async function* fastTransposeIteratorHandle(iterator2, size) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const array = __addDisposableResource$b(env_1, await iterator2.evaluateHandle(async (iterator3, size2) => {
      const results = [];
      while (results.length < size2) {
        const result = await iterator3.next();
        if (result.done) {
          break;
        }
        results.push(result.value);
      }
      return results;
    }, size), false);
    const properties = await array.getProperties();
    const handles = properties.values();
    const stack = __addDisposableResource$b(env_1, new DisposableStack(), false);
    stack.defer(() => {
      for (const handle_1 of handles) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$b(env_2, handle_1, false);
          handle[disposeSymbol]();
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources$b(env_2);
        }
      }
    });
    yield* handles;
    return properties.size === 0;
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources$b(env_1);
  }
}
async function* transposeIteratorHandle(iterator2) {
  let size = DEFAULT_BATCH_SIZE;
  while (!(yield* fastTransposeIteratorHandle(iterator2, size))) {
    size <<= 1;
  }
}
async function* transposeIterableHandle(handle) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const generatorHandle = __addDisposableResource$b(env_3, await handle.evaluateHandle((iterable) => {
      return async function* () {
        yield* iterable;
      }();
    }), false);
    yield* transposeIteratorHandle(generatorHandle);
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    __disposeResources$b(env_3);
  }
}
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _LazyArg = class _LazyArg {
  constructor(get2) {
    __privateAdd(this, _get, void 0);
    __privateSet(this, _get, get2);
  }
  async get(context2) {
    return await __privateGet(this, _get).call(this, context2);
  }
};
_get = new WeakMap();
__publicField(_LazyArg, "create", (get2) => {
  return new _LazyArg(get2);
});
let LazyArg = _LazyArg;
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$a = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$a = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
class QueryHandler {
  static get _querySelector() {
    if (this.querySelector) {
      return this.querySelector;
    }
    if (!this.querySelectorAll) {
      throw new Error("Cannot create default `querySelector`.");
    }
    return this.querySelector = interpolateFunction(async (node2, selector, PuppeteerUtil) => {
      const querySelectorAll = PLACEHOLDER("querySelectorAll");
      const results = querySelectorAll(node2, selector, PuppeteerUtil);
      for await (const result of results) {
        return result;
      }
      return null;
    }, {
      querySelectorAll: stringifyFunction(this.querySelectorAll)
    });
  }
  static get _querySelectorAll() {
    if (this.querySelectorAll) {
      return this.querySelectorAll;
    }
    if (!this.querySelector) {
      throw new Error("Cannot create default `querySelectorAll`.");
    }
    return this.querySelectorAll = interpolateFunction(async function* (node2, selector, PuppeteerUtil) {
      const querySelector = PLACEHOLDER("querySelector");
      const result = await querySelector(node2, selector, PuppeteerUtil);
      if (result) {
        yield result;
      }
    }, {
      querySelector: stringifyFunction(this.querySelector)
    });
  }
  /**
   * Queries for multiple nodes given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
   */
  static async *queryAll(element, selector) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource$a(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context2) => {
        return context2.puppeteerUtil;
      })), false);
      yield* transposeIterableHandle(handle);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$a(env_1);
    }
  }
  /**
   * Queries for a single node given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
   */
  static async queryOne(element, selector) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const result = __addDisposableResource$a(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create((context2) => {
        return context2.puppeteerUtil;
      })), false);
      if (!(_isElementHandle in result)) {
        return null;
      }
      return result.move();
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      __disposeResources$a(env_2);
    }
  }
  /**
   * Waits until a single node appears for a given selector and
   * {@link ElementHandle}.
   *
   * This will always query the handle in the Puppeteer world and migrate the
   * result to the main world.
   */
  static async waitFor(elementOrFrame, selector, options) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      let frame;
      const element = __addDisposableResource$a(env_3, await (async () => {
        if (!(_isElementHandle in elementOrFrame)) {
          frame = elementOrFrame;
          return;
        }
        frame = elementOrFrame.frame;
        return await frame.isolatedRealm().adoptHandle(elementOrFrame);
      })(), false);
      const { visible = false, hidden = false, timeout: timeout2, signal } = options;
      try {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
          signal == null ? void 0 : signal.throwIfAborted();
          const handle = __addDisposableResource$a(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
            const querySelector = PuppeteerUtil.createFunction(query);
            const node2 = await querySelector(root ?? document, selector2, PuppeteerUtil);
            return PuppeteerUtil.checkVisibility(node2, visible2);
          }, {
            polling: visible || hidden ? "raf" : "mutation",
            root: element,
            timeout: timeout2,
            signal
          }, LazyArg.create((context2) => {
            return context2.puppeteerUtil;
          }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : void 0), false);
          if (signal == null ? void 0 : signal.aborted) {
            throw signal.reason;
          }
          if (!(_isElementHandle in handle)) {
            return null;
          }
          return await frame.mainRealm().transferHandle(handle);
        } catch (e_3) {
          env_4.error = e_3;
          env_4.hasError = true;
        } finally {
          __disposeResources$a(env_4);
        }
      } catch (error) {
        if (!isErrorLike$1(error)) {
          throw error;
        }
        if (error.name === "AbortError") {
          throw error;
        }
        error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
        throw error;
      }
    } catch (e_4) {
      env_3.error = e_4;
      env_3.hasError = true;
    } finally {
      __disposeResources$a(env_3);
    }
  }
}
// Either one of these may be implemented, but at least one must be.
__publicField(QueryHandler, "querySelectorAll");
__publicField(QueryHandler, "querySelector");
class AsyncIterableUtil {
  static async *map(iterable, map2) {
    for await (const value of iterable) {
      yield await map2(value);
    }
  }
  static async *flatMap(iterable, map2) {
    for await (const value of iterable) {
      yield* map2(value);
    }
  }
  static async collect(iterable) {
    const result = [];
    for await (const value of iterable) {
      result.push(value);
    }
    return result;
  }
  static async first(iterable) {
    for await (const value of iterable) {
      return value;
    }
    return;
  }
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const isKnownAttribute = (attribute) => {
  return ["name", "role"].includes(attribute);
};
const normalizeValue = (value) => {
  return value.replace(/ +/g, " ").trim();
};
const ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
const parseARIASelector = (selector) => {
  const queryOptions = {};
  const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_2, attribute, __, value) => {
    attribute = attribute.trim();
    assert$1(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
    queryOptions[attribute] = normalizeValue(value);
    return "";
  });
  if (defaultName && !queryOptions.name) {
    queryOptions.name = normalizeValue(defaultName);
  }
  return queryOptions;
};
const _ARIAQueryHandler = class _ARIAQueryHandler extends QueryHandler {
  static async *queryAll(element, selector) {
    const { name: name2, role } = parseARIASelector(selector);
    yield* element.queryAXTree(name2, role);
  }
};
__publicField(_ARIAQueryHandler, "querySelector", async (node2, selector, { ariaQuerySelector }) => {
  return await ariaQuerySelector(node2, selector);
});
__publicField(_ARIAQueryHandler, "queryOne", async (element, selector) => {
  return await AsyncIterableUtil.first(_ARIAQueryHandler.queryAll(element, selector)) ?? null;
});
let ARIAQueryHandler = _ARIAQueryHandler;
const source = '"use strict";var v=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var ne=Object.getOwnPropertyNames;var oe=Object.prototype.hasOwnProperty;var u=(t,e)=>{for(var n in e)v(t,n,{get:e[n],enumerable:!0})},se=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of ne(e))!oe.call(t,o)&&o!==n&&v(t,o,{get:()=>e[o],enumerable:!(r=re(e,o))||r.enumerable});return t};var ie=t=>se(v({},"__esModule",{value:!0}),t);var Re={};u(Re,{default:()=>ke});module.exports=ie(Re);var C=class extends Error{constructor(e,n){super(e,n),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},b=class extends C{};var f=class t{static create(e){return new t(e)}static async race(e){let n=new Set;try{let r=e.map(o=>o instanceof t?(o.#s&&n.add(o),o.valueOrThrow()):o);return await Promise.race(r)}finally{for(let r of n)r.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#n;#t;#o=new Promise(e=>{this.#t=e});#s;#l;constructor(e){e&&e.timeout>0&&(this.#l=new b(e.message),this.#s=setTimeout(()=>{this.reject(this.#l)},e.timeout))}#a(e){clearTimeout(this.#s),this.#n=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#a(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#a(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#n}#i;valueOrThrow(){return this.#i||(this.#i=(async()=>{if(await this.#o,this.#r)throw this.#n;return this.#n})()),this.#i}};var X=new Map,z=t=>{let e=X.get(t);return e||(e=new Function(`return ${t}`)(),X.set(t,e),e)};var k={};u(k,{ariaQuerySelector:()=>le,ariaQuerySelectorAll:()=>I});var le=(t,e)=>globalThis.__ariaQuerySelector(t,e),I=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var M={};u(M,{customQuerySelectors:()=>O});var R=class{#e=new Map;register(e,n){if(!n.queryOne&&n.queryAll){let r=n.queryAll;n.queryOne=(o,i)=>{for(let s of r(o,i))return s;return null}}else if(n.queryOne&&!n.queryAll){let r=n.queryOne;n.queryAll=(o,i)=>{let s=r(o,i);return s?[s]:[]}}else if(!n.queryOne||!n.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:n.queryOne,querySelectorAll:n.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},O=new R;var q={};u(q,{pierceQuerySelector:()=>ae,pierceQuerySelectorAll:()=>ce});var ae=(t,e)=>{let n=null,r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&!n&&s.matches(e)&&(n=s)}while(!n&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n},ce=(t,e)=>{let n=[],r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&s.matches(e)&&n.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n};var m=(t,e)=>{if(!t)throw new Error(e)};var T=class{#e;#r;#n;#t;constructor(e,n){this.#e=e,this.#r=n}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=new MutationObserver(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())}),this.#n.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(this.#n.disconnect(),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}},E=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=f.create(),n=await this.#e();if(n){e.resolve(n);return}let r=async()=>{if(e.finished())return;let o=await this.#e();if(!o){window.requestAnimationFrame(r);return}e.resolve(o),await this.stop()};window.requestAnimationFrame(r)}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return m(this.#r,"Polling never started."),this.#r.valueOrThrow()}},P=class{#e;#r;#n;#t;constructor(e,n){this.#e=e,this.#r=n}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=setInterval(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())},this.#r)}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#n&&(clearInterval(this.#n),this.#n=void 0)}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var F={};u(F,{pQuerySelector:()=>Ce,pQuerySelectorAll:()=>te});var c=class{static async*map(e,n){for await(let r of e)yield await n(r)}static async*flatMap(e,n){for await(let r of e)yield*n(r)}static async collect(e){let n=[];for await(let r of e)n.push(r);return n}static async first(e){for await(let n of e)return n}};var p={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,"pseudo-element":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>*)\\))?/gu,"pseudo-class":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>*)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},ue=new Set(["combinator","comma"]);var fe=t=>{switch(t){case"pseudo-element":case"pseudo-class":return new RegExp(p[t].source.replace("(?<argument>\\xB6*)","(?<argument>.*)"),"gu");default:return p[t]}};function de(t,e){let n=0,r="";for(;e<t.length;e++){let o=t[e];switch(o){case"(":++n;break;case")":--n;break}if(r+=o,n===0)return r}return r}function me(t,e=p){if(!t)return[];let n=[t];for(let[o,i]of Object.entries(e))for(let s=0;s<n.length;s++){let l=n[s];if(typeof l!="string")continue;i.lastIndex=0;let a=i.exec(l);if(!a)continue;let h=a.index-1,d=[],V=a[0],H=l.slice(0,h+1);H&&d.push(H),d.push({...a.groups,type:o,content:V});let B=l.slice(h+V.length+1);B&&d.push(B),n.splice(s,1,...d)}let r=0;for(let o of n)switch(typeof o){case"string":throw new Error(`Unexpected sequence ${o} found at index ${r}`);case"object":r+=o.content.length,o.pos=[r-o.content.length,r],ue.has(o.type)&&(o.content=o.content.trim()||" ");break}return n}var he=/([\'"])([^\\\\\\n]+?)\\1/g,pe=/\\\\./g;function G(t,e=p){if(t=t.trim(),t==="")return[];let n=[];t=t.replace(pe,(i,s)=>(n.push({value:i,offset:s}),"\\uE000".repeat(i.length))),t=t.replace(he,(i,s,l,a)=>(n.push({value:i,offset:a}),`${s}${"\\uE001".repeat(l.length)}${s}`));{let i=0,s;for(;(s=t.indexOf("(",i))>-1;){let l=de(t,s);n.push({value:l,offset:s}),t=`${t.substring(0,s)}(${"\\xB6".repeat(l.length-2)})${t.substring(s+l.length)}`,i=s+l.length}}let r=me(t,e),o=new Set;for(let i of n.reverse())for(let s of r){let{offset:l,value:a}=i;if(!(s.pos[0]<=l&&l+a.length<=s.pos[1]))continue;let{content:h}=s,d=l-s.pos[0];s.content=h.slice(0,d)+a+h.slice(d+a.length),s.content!==h&&o.add(s)}for(let i of o){let s=fe(i.type);if(!s)throw new Error(`Unknown token type: ${i.type}`);s.lastIndex=0;let l=s.exec(i.content);if(!l)throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);Object.assign(i,l.groups)}return r}function*x(t,e){switch(t.type){case"list":for(let n of t.list)yield*x(n,t);break;case"complex":yield*x(t.left,t),yield*x(t.right,t);break;case"compound":yield*t.list.map(n=>[n,t]);break;default:yield[t,e]}}function y(t){let e;return Array.isArray(t)?e=t:e=[...x(t)].map(([n])=>n),e.map(n=>n.content).join("")}p.combinator=/\\s*(>>>>?|[\\s>+~])\\s*/g;var ye=/\\\\[\\s\\S]/g,ge=t=>t.length<=1?t:((t[0]===\'"\'||t[0]==="\'")&&t.endsWith(t[0])&&(t=t.slice(1,-1)),t.replace(ye,e=>e[1]));function K(t){let e=!0,n=G(t);if(n.length===0)return[[],e];let r=[],o=[r],i=[o],s=[];for(let l of n){switch(l.type){case"combinator":switch(l.content){case">>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>"),o.push(r);continue;case">>>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>>"),o.push(r);continue}break;case"pseudo-element":if(!l.name.startsWith("-p-"))break;e=!1,s.length&&(r.push(y(s)),s.splice(0)),r.push({name:l.name.slice(3),value:ge(l.argument??"")});continue;case"comma":s.length&&(r.push(y(s)),s.splice(0)),r=[],o=[r],i.push(o);continue}s.push(l)}return s.length&&r.push(y(s)),[i,e]}var _={};u(_,{textQuerySelectorAll:()=>S});var we=new Set(["checkbox","image","radio"]),Se=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!we.has(t.type),be=new Set(["SCRIPT","STYLE"]),w=t=>!be.has(t.nodeName)&&!document.head?.contains(t),D=new WeakMap,J=t=>{for(;t;)D.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},Y=new WeakSet,Te=new MutationObserver(t=>{for(let e of t)J(e.target)}),g=t=>{let e=D.get(t);if(e||(e={full:"",immediate:[]},!w(t)))return e;let n="";if(Se(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",r=>{J(r.target)},{once:!0,capture:!0});else{for(let r=t.firstChild;r;r=r.nextSibling){if(r.nodeType===Node.TEXT_NODE){e.full+=r.nodeValue??"",n+=r.nodeValue??"";continue}n&&e.immediate.push(n),n="",r.nodeType===Node.ELEMENT_NODE&&(e.full+=g(r).full)}n&&e.immediate.push(n),t instanceof Element&&t.shadowRoot&&(e.full+=g(t.shadowRoot).full),Y.has(t)||(Te.observe(t,{childList:!0,characterData:!0,subtree:!0}),Y.add(t))}return D.set(t,e),e};var S=function*(t,e){let n=!1;for(let r of t.childNodes)if(r instanceof Element&&w(r)){let o;r.shadowRoot?o=S(r.shadowRoot,e):o=S(r,e);for(let i of o)yield i,n=!0}n||t instanceof Element&&w(t)&&g(t).full.includes(e)&&(yield t)};var L={};u(L,{checkVisibility:()=>Pe,pierce:()=>N,pierceAll:()=>Q});var Ee=["hidden","collapse"],Pe=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let n=t.nodeType===Node.TEXT_NODE?t.parentElement:t,r=window.getComputedStyle(n),o=r&&!Ee.includes(r.visibility)&&!xe(n);return e===o?t:!1};function xe(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var Ne=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*N(t){Ne(t)?yield t.shadowRoot:yield t}function*Q(t){t=N(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let n of e){let r;for(;r=n.nextNode();)r.shadowRoot&&(yield r.shadowRoot,e.push(document.createTreeWalker(r.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var j={};u(j,{xpathQuerySelectorAll:()=>$});var $=function*(t,e,n=-1){let o=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=o.iterateNext())&&(i.push(s),!(n&&i.length===n)););for(let l=0;l<i.length;l++)s=i[l],yield s,delete i[l]};var Ae=/[-\\w\\P{ASCII}*]/,Z=t=>"querySelectorAll"in t,A=class extends Error{constructor(e,n){super(`${e} is not a valid selector: ${n}`)}},U=class{#e;#r;#n=[];#t=void 0;elements;constructor(e,n,r){this.elements=[e],this.#e=n,this.#r=r,this.#o()}async run(){if(typeof this.#t=="string")switch(this.#t.trimStart()){case":scope":this.#o();break}for(;this.#t!==void 0;this.#o()){let e=this.#t,n=this.#e;typeof e=="string"?e[0]&&Ae.test(e[0])?this.elements=c.flatMap(this.elements,async function*(r){Z(r)&&(yield*r.querySelectorAll(e))}):this.elements=c.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!Z(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let i of r.parentElement.children)if(++o,i===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=c.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*S(r,e.value);break;case"xpath":yield*$(r,e.value);break;case"aria":yield*I(r,e.value);break;default:let o=O.get(e.name);if(!o)throw new A(n,`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#o(){if(this.#n.length!==0){this.#t=this.#n.shift();return}if(this.#r.length===0){this.#t=void 0;return}let e=this.#r.shift();switch(e){case">>>>":{this.elements=c.flatMap(this.elements,N),this.#o();break}case">>>":{this.elements=c.flatMap(this.elements,Q),this.#o();break}default:this.#n=e,this.#o();break}}},W=class{#e=new WeakMap;calculate(e,n=[]){if(e===null)return n;e instanceof ShadowRoot&&(e=e.host);let r=this.#e.get(e);if(r)return[...r,...n];let o=0;for(let s=e.previousSibling;s;s=s.previousSibling)++o;let i=this.calculate(e.parentNode,[o]);return this.#e.set(e,i),[...i,...n]}},ee=(t,e)=>{if(t.length+e.length===0)return 0;let[n=-1,...r]=t,[o=-1,...i]=e;return n===o?ee(r,i):n<o?-1:1},ve=async function*(t){let e=new Set;for await(let r of t)e.add(r);let n=new W;yield*[...e.values()].map(r=>[r,n.calculate(r)]).sort(([,r],[,o])=>ee(r,o)).map(([r])=>r)},te=function(t,e){let n,r;try{[n,r]=K(e)}catch{return t.querySelectorAll(e)}if(r)return t.querySelectorAll(e);if(n.some(o=>{let i=0;return o.some(s=>(typeof s=="string"?++i:i=0,i>1))}))throw new A(e,"Multiple deep combinators found in sequence.");return ve(c.flatMap(n,o=>{let i=new U(t,e,o);return i.run(),i.elements}))},Ce=async function(t,e){for await(let n of te(t,e))return n;return null};var Ie=Object.freeze({...k,...M,...q,...F,..._,...L,...j,Deferred:f,createFunction:z,createTextContent:g,IntervalPoller:P,isSuitableNodeForTextMatching:w,MutationPoller:T,RAFPoller:E}),ke=Ie;\n/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2024 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n';
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ScriptInjector {
  constructor() {
    __privateAdd(this, _update);
    __privateAdd(this, _get2);
    __privateAdd(this, _updated, false);
    __privateAdd(this, _amendments, /* @__PURE__ */ new Set());
  }
  // Appends a statement of the form `(PuppeteerUtil) => {...}`.
  append(statement) {
    __privateMethod(this, _update, update_fn).call(this, () => {
      __privateGet(this, _amendments).add(statement);
    });
  }
  pop(statement) {
    __privateMethod(this, _update, update_fn).call(this, () => {
      __privateGet(this, _amendments).delete(statement);
    });
  }
  inject(inject, force = false) {
    if (__privateGet(this, _updated) || force) {
      inject(__privateMethod(this, _get2, get_fn).call(this));
    }
    __privateSet(this, _updated, false);
  }
}
_updated = new WeakMap();
_amendments = new WeakMap();
_update = new WeakSet();
update_fn = function(callback) {
  callback();
  __privateSet(this, _updated, true);
};
_get2 = new WeakSet();
get_fn = function() {
  return `(() => {
      const module = {};
      ${source}
      ${[...__privateGet(this, _amendments)].map((statement) => {
    return `(${statement})(module.exports.default);`;
  }).join("")}
      return module.exports.default;
    })()`;
};
const scriptInjector = new ScriptInjector();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CustomQueryHandlerRegistry {
  constructor() {
    __privateAdd(this, _handlers2, /* @__PURE__ */ new Map());
  }
  get(name2) {
    const handler = __privateGet(this, _handlers2).get(name2);
    return handler ? handler[1] : void 0;
  }
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is
   * only allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```ts
   * Puppeteer.customQueryHandlers.register('lit', {  });
   * const aHandle = await page.$('lit/');
   * ```
   *
   * @param name - Name to register under.
   * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
   * register.
   */
  register(name2, handler) {
    var _a3;
    assert$1(!__privateGet(this, _handlers2).has(name2), `Cannot register over existing handler: ${name2}`);
    assert$1(/^[a-zA-Z]+$/.test(name2), `Custom query handler names may only contain [a-zA-Z]`);
    assert$1(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
    const Handler = (_a3 = class extends QueryHandler {
    }, __publicField(_a3, "querySelectorAll", interpolateFunction((node2, selector, PuppeteerUtil) => {
      return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node2, selector);
    }, { name: JSON.stringify(name2) })), __publicField(_a3, "querySelector", interpolateFunction((node2, selector, PuppeteerUtil) => {
      return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node2, selector);
    }, { name: JSON.stringify(name2) })), _a3);
    const registerScript = interpolateFunction((PuppeteerUtil) => {
      PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
        queryAll: PLACEHOLDER("queryAll"),
        queryOne: PLACEHOLDER("queryOne")
      });
    }, {
      name: JSON.stringify(name2),
      queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
      queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
    }).toString();
    __privateGet(this, _handlers2).set(name2, [registerScript, Handler]);
    scriptInjector.append(registerScript);
  }
  /**
   * Unregisters the {@link CustomQueryHandler | custom query handler} for the
   * given name.
   *
   * @throws `Error` if there is no handler under the given name.
   */
  unregister(name2) {
    const handler = __privateGet(this, _handlers2).get(name2);
    if (!handler) {
      throw new Error(`Cannot unregister unknown handler: ${name2}`);
    }
    scriptInjector.pop(handler[0]);
    __privateGet(this, _handlers2).delete(name2);
  }
  /**
   * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
   */
  names() {
    return [...__privateGet(this, _handlers2).keys()];
  }
  /**
   * Unregisters all custom query handlers.
   */
  clear() {
    for (const [registerScript] of __privateGet(this, _handlers2)) {
      scriptInjector.pop(registerScript);
    }
    __privateGet(this, _handlers2).clear();
  }
}
_handlers2 = new WeakMap();
const customQueryHandlers = new CustomQueryHandlerRegistry();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PierceQueryHandler extends QueryHandler {
}
__publicField(PierceQueryHandler, "querySelector", (element, selector, { pierceQuerySelector }) => {
  return pierceQuerySelector(element, selector);
});
__publicField(PierceQueryHandler, "querySelectorAll", (element, selector, { pierceQuerySelectorAll }) => {
  return pierceQuerySelectorAll(element, selector);
});
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PQueryHandler extends QueryHandler {
}
__publicField(PQueryHandler, "querySelectorAll", (element, selector, { pQuerySelectorAll }) => {
  return pQuerySelectorAll(element, selector);
});
__publicField(PQueryHandler, "querySelector", (element, selector, { pQuerySelector }) => {
  return pQuerySelector(element, selector);
});
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class TextQueryHandler extends QueryHandler {
}
__publicField(TextQueryHandler, "querySelectorAll", (element, selector, { textQuerySelectorAll }) => {
  return textQuerySelectorAll(element, selector);
});
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class XPathQueryHandler extends QueryHandler {
}
__publicField(XPathQueryHandler, "querySelectorAll", (element, selector, { xpathQuerySelectorAll }) => {
  return xpathQuerySelectorAll(element, selector);
});
__publicField(XPathQueryHandler, "querySelector", (element, selector, { xpathQuerySelectorAll }) => {
  for (const result of xpathQuerySelectorAll(element, selector, 1)) {
    return result;
  }
  return null;
});
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const BUILTIN_QUERY_HANDLERS = {
  aria: ARIAQueryHandler,
  pierce: PierceQueryHandler,
  xpath: XPathQueryHandler,
  text: TextQueryHandler
};
const QUERY_SEPARATORS = ["=", "/"];
function getQueryHandlerAndSelector(selector) {
  for (const handlerMap of [
    customQueryHandlers.names().map((name2) => {
      return [name2, customQueryHandlers.get(name2)];
    }),
    Object.entries(BUILTIN_QUERY_HANDLERS)
  ]) {
    for (const [name2, QueryHandler2] of handlerMap) {
      for (const separator of QUERY_SEPARATORS) {
        const prefix = `${name2}${separator}`;
        if (selector.startsWith(prefix)) {
          selector = selector.slice(prefix.length);
          return { updatedSelector: selector, QueryHandler: QueryHandler2 };
        }
      }
    }
  }
  return { updatedSelector: selector, QueryHandler: PQueryHandler };
}
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _Deferred = class _Deferred {
  constructor(opts) {
    __privateAdd(this, _finish);
    __privateAdd(this, _isResolved, false);
    __privateAdd(this, _isRejected, false);
    __privateAdd(this, _value, void 0);
    // SAFETY: This is ensured by #taskPromise.
    __privateAdd(this, _resolve, void 0);
    __privateAdd(this, _taskPromise, new Promise((resolve2) => {
      __privateSet(this, _resolve, resolve2);
    }));
    __privateAdd(this, _timeoutId, void 0);
    __privateAdd(this, _timeoutError, void 0);
    __privateAdd(this, _promise, void 0);
    if (opts && opts.timeout > 0) {
      __privateSet(this, _timeoutError, new TimeoutError$1(opts.message));
      __privateSet(this, _timeoutId, setTimeout(() => {
        this.reject(__privateGet(this, _timeoutError));
      }, opts.timeout));
    }
  }
  static create(opts) {
    return new _Deferred(opts);
  }
  static async race(awaitables) {
    const deferredWithTimeout = /* @__PURE__ */ new Set();
    try {
      const promises2 = awaitables.map((value) => {
        if (value instanceof _Deferred) {
          if (__privateGet(value, _timeoutId)) {
            deferredWithTimeout.add(value);
          }
          return value.valueOrThrow();
        }
        return value;
      });
      return await Promise.race(promises2);
    } finally {
      for (const deferred of deferredWithTimeout) {
        deferred.reject(new Error("Timeout cleared"));
      }
    }
  }
  resolve(value) {
    if (__privateGet(this, _isRejected) || __privateGet(this, _isResolved)) {
      return;
    }
    __privateSet(this, _isResolved, true);
    __privateMethod(this, _finish, finish_fn).call(this, value);
  }
  reject(error) {
    if (__privateGet(this, _isRejected) || __privateGet(this, _isResolved)) {
      return;
    }
    __privateSet(this, _isRejected, true);
    __privateMethod(this, _finish, finish_fn).call(this, error);
  }
  resolved() {
    return __privateGet(this, _isResolved);
  }
  finished() {
    return __privateGet(this, _isResolved) || __privateGet(this, _isRejected);
  }
  value() {
    return __privateGet(this, _value);
  }
  valueOrThrow() {
    if (!__privateGet(this, _promise)) {
      __privateSet(this, _promise, (async () => {
        await __privateGet(this, _taskPromise);
        if (__privateGet(this, _isRejected)) {
          throw __privateGet(this, _value);
        }
        return __privateGet(this, _value);
      })());
    }
    return __privateGet(this, _promise);
  }
};
_isResolved = new WeakMap();
_isRejected = new WeakMap();
_value = new WeakMap();
_resolve = new WeakMap();
_taskPromise = new WeakMap();
_timeoutId = new WeakMap();
_timeoutError = new WeakMap();
_finish = new WeakSet();
finish_fn = function(value) {
  clearTimeout(__privateGet(this, _timeoutId));
  __privateSet(this, _value, value);
  __privateGet(this, _resolve).call(this);
};
_promise = new WeakMap();
let Deferred = _Deferred;
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _Mutex = class _Mutex {
  constructor() {
    __privateAdd(this, _locked, false);
    __privateAdd(this, _acquirers, []);
  }
  // This is FIFO.
  async acquire() {
    if (!__privateGet(this, _locked)) {
      __privateSet(this, _locked, true);
      return new _Mutex.Guard(this);
    }
    const deferred = Deferred.create();
    __privateGet(this, _acquirers).push(deferred.resolve.bind(deferred));
    await deferred.valueOrThrow();
    return new _Mutex.Guard(this);
  }
  release() {
    const resolve2 = __privateGet(this, _acquirers).shift();
    if (!resolve2) {
      __privateSet(this, _locked, false);
      return;
    }
    resolve2();
  }
};
_locked = new WeakMap();
_acquirers = new WeakMap();
__publicField(_Mutex, "Guard", (_f = class {
  constructor(mutex) {
    __privateAdd(this, _mutex, void 0);
    __privateSet(this, _mutex, mutex);
  }
  [disposeSymbol]() {
    return __privateGet(this, _mutex).release();
  }
}, _mutex = new WeakMap(), _f));
let Mutex = _Mutex;
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$9 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$9 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
const instances = /* @__PURE__ */ new WeakSet();
function moveable(Class, _2) {
  let hasDispose = false;
  if (Class.prototype[disposeSymbol]) {
    const dispose = Class.prototype[disposeSymbol];
    Class.prototype[disposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return dispose.call(this);
    };
    hasDispose = true;
  }
  if (Class.prototype[asyncDisposeSymbol]) {
    const asyncDispose = Class.prototype[asyncDisposeSymbol];
    Class.prototype[asyncDisposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return asyncDispose.call(this);
    };
    hasDispose = true;
  }
  if (hasDispose) {
    Class.prototype.move = function() {
      instances.add(this);
      return this;
    };
  }
  return Class;
}
function throwIfDisposed(message2 = (value) => {
  return `Attempted to use disposed ${value.constructor.name}.`;
}) {
  return (target, _2) => {
    return function(...args) {
      if (this.disposed) {
        throw new Error(message2(this));
      }
      return target.call(this, ...args);
    };
  };
}
function inertIfDisposed(target, _2) {
  return function(...args) {
    if (this.disposed) {
      return;
    }
    return target.call(this, ...args);
  };
}
function invokeAtMostOnceForArguments(target, _2) {
  const cache = /* @__PURE__ */ new WeakMap();
  let cacheDepth = -1;
  return function(...args) {
    if (cacheDepth === -1) {
      cacheDepth = args.length;
    }
    if (cacheDepth !== args.length) {
      throw new Error("Memoized method was called with the wrong number of arguments");
    }
    let freshArguments = false;
    let cacheIterator = cache;
    for (const arg of args) {
      if (cacheIterator.has(arg)) {
        cacheIterator = cacheIterator.get(arg);
      } else {
        freshArguments = true;
        cacheIterator.set(arg, /* @__PURE__ */ new WeakMap());
        cacheIterator = cacheIterator.get(arg);
      }
    }
    if (!freshArguments) {
      return;
    }
    return target.call(this, ...args);
  };
}
function guarded(getKey = function() {
  return this;
}) {
  return (target, _2) => {
    const mutexes = /* @__PURE__ */ new WeakMap();
    return async function(...args) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const key = getKey.call(this);
        let mutex = mutexes.get(key);
        if (!mutex) {
          mutex = new Mutex();
          mutexes.set(key, mutex);
        }
        const _3 = __addDisposableResource$9(env_1, await mutex.acquire(), true);
        return await target.call(this, ...args);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        const result_1 = __disposeResources$9(env_1);
        if (result_1)
          await result_1;
      }
    };
  };
}
const bubbleHandlers = /* @__PURE__ */ new WeakMap();
function bubble(events) {
  return ({ set, get: get2 }, context2) => {
    context2.addInitializer(function() {
      const handlers = bubbleHandlers.get(this) ?? /* @__PURE__ */ new Map();
      if (handlers.has(events)) {
        return;
      }
      const handler = events !== void 0 ? (type, event) => {
        if (events.includes(type)) {
          this.emit(type, event);
        }
      } : (type, event) => {
        this.emit(type, event);
      };
      handlers.set(events, handler);
      bubbleHandlers.set(this, handlers);
    });
    return {
      set(emitter) {
        const handler = bubbleHandlers.get(this).get(events);
        const oldEmitter = get2.call(this);
        if (oldEmitter !== void 0) {
          oldEmitter.off("*", handler);
        }
        if (emitter === void 0) {
          return;
        }
        emitter.on("*", handler);
        set.call(this, emitter);
      },
      // @ts-expect-error -- TypeScript incorrectly types init to require a
      // return.
      init(emitter) {
        if (emitter === void 0) {
          return;
        }
        const handler = bubbleHandlers.get(this).get(events);
        emitter.on("*", handler);
        return emitter;
      }
    };
  };
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$8 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate$8 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource$8 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$8 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
let JSHandle = (() => {
  var _a3;
  let _classDecorators = [moveable];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _instanceExtraInitializers = [];
  let _getProperty_decorators;
  let _getProperties_decorators;
  _a3 = class {
    /**
     * @internal
     */
    constructor() {
      __runInitializers$8(this, _instanceExtraInitializers);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.realm.evaluate(pageFunction, this, ...args);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     *
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.realm.evaluateHandle(pageFunction, this, ...args);
    }
    /**
     * @internal
     */
    async getProperty(propertyName) {
      return await this.evaluateHandle((object, propertyName2) => {
        return object[propertyName2];
      }, propertyName);
    }
    /**
     * Gets a map of handles representing the properties of the current handle.
     *
     * @example
     *
     * ```ts
     * const listHandle = await page.evaluateHandle(() => document.body.children);
     * const properties = await listHandle.getProperties();
     * const children = [];
     * for (const property of properties.values()) {
     *   const element = property.asElement();
     *   if (element) {
     *     children.push(element);
     *   }
     * }
     * children; // holds elementHandles to all children of document.body
     * ```
     */
    async getProperties() {
      const propertyNames = await this.evaluate((object) => {
        var _a4;
        const enumerableProperties = [];
        const descriptors = Object.getOwnPropertyDescriptors(object);
        for (const propertyName in descriptors) {
          if ((_a4 = descriptors[propertyName]) == null ? void 0 : _a4.enumerable) {
            enumerableProperties.push(propertyName);
          }
        }
        return enumerableProperties;
      });
      const map2 = /* @__PURE__ */ new Map();
      const results = await Promise.all(propertyNames.map((key) => {
        return this.getProperty(key);
      }));
      for (const [key, value] of Object.entries(propertyNames)) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource$8(env_1, results[key], false);
          if (handle) {
            map2.set(value, handle.move());
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$8(env_1);
        }
      }
      return map2;
    }
    /** @internal */
    [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
      return void this.dispose().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.dispose();
    }
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    __esDecorate$8(_a3, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$8(_a3, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$8(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    _classThis = _classDescriptor.value;
    if (_metadata)
      Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers$8(_classThis, _classExtraInitializers);
  })(), _a3;
  return _classThis;
})();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$7 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate$7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource$7 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$7 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
let ElementHandle = (() => {
  var _checkVisibility, checkVisibility_fn, _clickableBox, clickableBox_fn, _intersectBoundingBoxesWithFrame, intersectBoundingBoxesWithFrame_fn, _getTopLeftCornerOfFrame, getTopLeftCornerOfFrame_fn, _nonEmptyVisibleBoundingBox, nonEmptyVisibleBoundingBox_fn, _asSVGElementHandle, asSVGElementHandle_fn, _getOwnerSVGElement, getOwnerSVGElement_fn, _a4;
  var _a3, _b3, _c3, _d2, _e2, _f2, _g2, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
  let _classSuper = JSHandle;
  let _instanceExtraInitializers = [];
  let _getProperty_decorators;
  let _getProperties_decorators;
  let _jsonValue_decorators;
  let _$_decorators;
  let _$$_decorators;
  let _waitForSelector_decorators;
  let _isVisible_decorators;
  let _isHidden_decorators;
  let _toElement_decorators;
  let _clickablePoint_decorators;
  let _hover_decorators;
  let _click_decorators;
  let _drag_decorators;
  let _dragEnter_decorators;
  let _dragOver_decorators;
  let _drop_decorators;
  let _dragAndDrop_decorators;
  let _select_decorators;
  let _tap_decorators;
  let _touchStart_decorators;
  let _touchMove_decorators;
  let _touchEnd_decorators;
  let _focus_decorators;
  let _type_decorators;
  let _press_decorators;
  let _boundingBox_decorators;
  let _boxModel_decorators;
  let _screenshot_decorators;
  let _isIntersectingViewport_decorators;
  let _scrollIntoView_decorators;
  return _a4 = class extends _classSuper {
    /**
     * @internal
     */
    constructor(handle) {
      super();
      __privateAdd(this, _checkVisibility);
      __privateAdd(this, _clickableBox);
      __privateAdd(this, _intersectBoundingBoxesWithFrame);
      __privateAdd(this, _getTopLeftCornerOfFrame);
      __privateAdd(this, _nonEmptyVisibleBoundingBox);
      /**
       * Returns true if an element is an SVGElement (included svg, path, rect
       * etc.).
       */
      __privateAdd(this, _asSVGElementHandle);
      __privateAdd(this, _getOwnerSVGElement);
      /**
       * @internal
       * Cached isolatedHandle to prevent
       * trying to adopt it multiple times
       */
      __publicField(this, "isolatedHandle", (__runInitializers$7(this, _instanceExtraInitializers), void 0));
      /**
       * @internal
       */
      __publicField(this, "handle");
      this.handle = handle;
      this[_isElementHandle] = true;
    }
    /**
     * A given method will have it's `this` replaced with an isolated version of
     * `this` when decorated with this decorator.
     *
     * All changes of isolated `this` are reflected on the actual `this`.
     *
     * @internal
     */
    static bindIsolatedHandle(target, _6) {
      return async function(...args) {
        if (this.realm === this.frame.isolatedRealm()) {
          return await target.call(this, ...args);
        }
        let adoptedThis;
        if (this["isolatedHandle"]) {
          adoptedThis = this["isolatedHandle"];
        } else {
          this["isolatedHandle"] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);
        }
        const result = await target.call(adoptedThis, ...args);
        if (result === adoptedThis) {
          return this;
        }
        if (result instanceof JSHandle) {
          return await this.realm.transferHandle(result);
        }
        if (Array.isArray(result)) {
          await Promise.all(result.map(async (item, index2, result2) => {
            if (item instanceof JSHandle) {
              result2[index2] = await this.realm.transferHandle(item);
            }
          }));
        }
        if (result instanceof Map) {
          await Promise.all([...result.entries()].map(async ([key, value]) => {
            if (value instanceof JSHandle) {
              result.set(key, await this.realm.transferHandle(value));
            }
          }));
        }
        return result;
      };
    }
    /**
     * @internal
     */
    get id() {
      return this.handle.id;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.handle.disposed;
    }
    /**
     * @internal
     */
    async getProperty(propertyName) {
      return await this.handle.getProperty(propertyName);
    }
    /**
     * @internal
     */
    async getProperties() {
      return await this.handle.getProperties();
    }
    /**
     * @internal
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.handle.evaluate(pageFunction, ...args);
    }
    /**
     * @internal
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.handle.evaluateHandle(pageFunction, ...args);
    }
    /**
     * @internal
     */
    async jsonValue() {
      return await this.handle.jsonValue();
    }
    /**
     * @internal
     */
    toString() {
      return this.handle.toString();
    }
    /**
     * @internal
     */
    remoteObject() {
      return this.handle.remoteObject();
    }
    /**
     * @internal
     */
    dispose() {
      return this.handle.dispose();
    }
    /**
     * @internal
     */
    asElement() {
      return this;
    }
    /**
     * Queries the current element for an element matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(selector) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.queryOne(this, updatedSelector);
    }
    /**
     * Queries the current element for all elements matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(selector) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const tweetHandle = await page.$('.tweet');
     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
     *   '100'
     * );
     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
     *   '10'
     * );
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in this element's page's
     * context. The first element matching the selector will be passed in as the
     * first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(selector, pageFunction, ...args) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        const elementHandle = __addDisposableResource$7(env_1, await this.$(selector), false);
        if (!elementHandle) {
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        }
        return await elementHandle.evaluate(pageFunction, ...args);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources$7(env_1);
      }
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     * HTML:
     *
     * ```html
     * <div class="feed">
     *   <div class="tweet">Hello!</div>
     *   <div class="tweet">Hi!</div>
     * </div>
     * ```
     *
     * JavaScript:
     *
     * ```ts
     * const feedHandle = await page.$('.feed');
     * expect(
     *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))
     * ).toEqual(['Hello!', 'Hi!']);
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in the element's page's
     * context. An array of elements matching the given selector will be passed to
     * the function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(selector, pageFunction, ...args) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        const results = await this.$$(selector);
        const elements = __addDisposableResource$7(env_2, await this.evaluateHandle((_6, ...elements2) => {
          return elements2;
        }, ...results), false);
        const [result] = await Promise.all([
          elements.evaluate(pageFunction, ...args),
          ...results.map((results2) => {
            return results2.dispose();
          })
        ]);
        return result;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        __disposeResources$7(env_2);
      }
    }
    /**
     * Wait for an element matching the given selector to appear in the current
     * element.
     *
     * Unlike {@link Frame.waitForSelector}, this method does not work across
     * navigations or if the element is detached from DOM.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .mainFrame()
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.waitFor(this, updatedSelector, options);
    }
    /**
     * Checks if an element is visible using the same mechanism as
     * {@link ElementHandle.waitForSelector}.
     */
    async isVisible() {
      return await __privateMethod(this, _checkVisibility, checkVisibility_fn).call(this, true);
    }
    /**
     * Checks if an element is hidden using the same mechanism as
     * {@link ElementHandle.waitForSelector}.
     */
    async isHidden() {
      return await __privateMethod(this, _checkVisibility, checkVisibility_fn).call(this, false);
    }
    /**
     * Converts the current handle to the given element type.
     *
     * @example
     *
     * ```ts
     * const element: ElementHandle<Element> = await page.$(
     *   '.class-name-of-anchor'
     * );
     * // DO NOT DISPOSE `element`, this will be always be the same handle.
     * const anchor: ElementHandle<HTMLAnchorElement> =
     *   await element.toElement('a');
     * ```
     *
     * @param tagName - The tag name of the desired element type.
     * @throws An error if the handle does not match. **The handle will not be
     * automatically disposed.**
     */
    async toElement(tagName) {
      const isMatchingTagName = await this.evaluate((node2, tagName2) => {
        return node2.nodeName === tagName2.toUpperCase();
      }, tagName);
      if (!isMatchingTagName) {
        throw new Error(`Element is not a(n) \`${tagName}\` element`);
      }
      return this;
    }
    /**
     * Returns the middle point within an element unless a specific offset is provided.
     */
    async clickablePoint(offset) {
      const box = await __privateMethod(this, _clickableBox, clickableBox_fn).call(this);
      if (!box) {
        throw new Error("Node is either not clickable or not an Element");
      }
      if (offset !== void 0) {
        return {
          x: box.x + offset.x,
          y: box.y + offset.y
        };
      }
      return {
        x: box.x + box.width / 2,
        y: box.y + box.height / 2
      };
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to hover over the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async hover() {
      await this.scrollIntoViewIfNeeded();
      const { x: x2, y: y2 } = await this.clickablePoint();
      await this.frame.page().mouse.move(x2, y2);
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to click in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async click(options = {}) {
      await this.scrollIntoViewIfNeeded();
      const { x: x2, y: y2 } = await this.clickablePoint(options.offset);
      await this.frame.page().mouse.click(x2, y2, options);
    }
    /**
     * Drags an element over the given element or point.
     *
     * @returns DEPRECATED. When drag interception is enabled, the drag payload is
     * returned.
     */
    async drag(target) {
      await this.scrollIntoViewIfNeeded();
      const page = this.frame.page();
      if (page.isDragInterceptionEnabled()) {
        const source2 = await this.clickablePoint();
        if (target instanceof _a4) {
          target = await target.clickablePoint();
        }
        return await page.mouse.drag(source2, target);
      }
      try {
        if (!page._isDragging) {
          page._isDragging = true;
          await this.hover();
          await page.mouse.down();
        }
        if (target instanceof _a4) {
          await target.hover();
        } else {
          await page.mouse.move(target.x, target.y);
        }
      } catch (error) {
        page._isDragging = false;
        throw error;
      }
    }
    /**
     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
     */
    async dragEnter(data2 = { items: [], dragOperationsMask: 1 }) {
      const page = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const target = await this.clickablePoint();
      await page.mouse.dragEnter(target, data2);
    }
    /**
     * @deprecated Do not use. `dragover` will automatically be performed during dragging.
     */
    async dragOver(data2 = { items: [], dragOperationsMask: 1 }) {
      const page = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const target = await this.clickablePoint();
      await page.mouse.dragOver(target, data2);
    }
    /**
     * @internal
     */
    async drop(dataOrElement = {
      items: [],
      dragOperationsMask: 1
    }) {
      const page = this.frame.page();
      if ("items" in dataOrElement) {
        await this.scrollIntoViewIfNeeded();
        const destination = await this.clickablePoint();
        await page.mouse.drop(destination, dataOrElement);
      } else {
        await dataOrElement.drag(this);
        page._isDragging = false;
        await page.mouse.up();
      }
    }
    /**
     * @deprecated Use `ElementHandle.drop` instead.
     */
    async dragAndDrop(target, options) {
      const page = this.frame.page();
      assert$1(page.isDragInterceptionEnabled(), "Drag Interception is not enabled!");
      await this.scrollIntoViewIfNeeded();
      const startPoint = await this.clickablePoint();
      const targetPoint = await target.clickablePoint();
      await page.mouse.dragAndDrop(startPoint, targetPoint, options);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * handle.select('blue'); // single selection
     * handle.select('red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     */
    async select(...values) {
      for (const value of values) {
        assert$1(isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
      }
      return await this.evaluate((element, vals) => {
        const values2 = new Set(vals);
        if (!(element instanceof HTMLSelectElement)) {
          throw new Error("Element is not a <select> element.");
        }
        const selectedValues = /* @__PURE__ */ new Set();
        if (!element.multiple) {
          for (const option of element.options) {
            option.selected = false;
          }
          for (const option of element.options) {
            if (values2.has(option.value)) {
              option.selected = true;
              selectedValues.add(option.value);
              break;
            }
          }
        } else {
          for (const option of element.options) {
            option.selected = values2.has(option.value);
            if (option.selected) {
              selectedValues.add(option.value);
            }
          }
        }
        element.dispatchEvent(new Event("input", { bubbles: true }));
        element.dispatchEvent(new Event("change", { bubbles: true }));
        return [...selectedValues.values()];
      }, values);
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Touchscreen.tap} to tap in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async tap() {
      await this.scrollIntoViewIfNeeded();
      const { x: x2, y: y2 } = await this.clickablePoint();
      await this.frame.page().touchscreen.tap(x2, y2);
    }
    async touchStart() {
      await this.scrollIntoViewIfNeeded();
      const { x: x2, y: y2 } = await this.clickablePoint();
      await this.frame.page().touchscreen.touchStart(x2, y2);
    }
    async touchMove() {
      await this.scrollIntoViewIfNeeded();
      const { x: x2, y: y2 } = await this.clickablePoint();
      await this.frame.page().touchscreen.touchMove(x2, y2);
    }
    async touchEnd() {
      await this.scrollIntoViewIfNeeded();
      await this.frame.page().touchscreen.touchEnd();
    }
    /**
     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
     */
    async focus() {
      await this.evaluate((element) => {
        if (!(element instanceof HTMLElement)) {
          throw new Error("Cannot focus non-HTMLElement");
        }
        return element.focus();
      });
    }
    /**
     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
     * `keyup` event for each character in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link ElementHandle.press}.
     *
     * @example
     *
     * ```ts
     * await elementHandle.type('Hello'); // Types instantly
     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @example
     * An example of typing into a text field and then submitting the form:
     *
     * ```ts
     * const elementHandle = await page.$('input');
     * await elementHandle.type('some text');
     * await elementHandle.press('Enter');
     * ```
     *
     * @param options - Delay in milliseconds. Defaults to 0.
     */
    async type(text, options) {
      await this.focus();
      await this.frame.page().keyboard.type(text, options);
    }
    /**
     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also be generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
     * will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     */
    async press(key, options) {
      await this.focus();
      await this.frame.page().keyboard.press(key, options);
    }
    /**
     * This method returns the bounding box of the element (relative to the main frame),
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     */
    async boundingBox() {
      const box = await this.evaluate((element) => {
        if (!(element instanceof Element)) {
          return null;
        }
        if (element.getClientRects().length === 0) {
          return null;
        }
        const rect = element.getBoundingClientRect();
        return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
      });
      if (!box) {
        return null;
      }
      const offset = await __privateMethod(this, _getTopLeftCornerOfFrame, getTopLeftCornerOfFrame_fn).call(this);
      if (!offset) {
        return null;
      }
      return {
        x: box.x + offset.x,
        y: box.y + offset.y,
        height: box.height,
        width: box.width
      };
    }
    /**
     * This method returns boxes of the element,
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     *
     * @remarks
     *
     * Boxes are represented as an array of points;
     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
     */
    async boxModel() {
      const model = await this.evaluate((element) => {
        if (!(element instanceof Element)) {
          return null;
        }
        if (element.getClientRects().length === 0) {
          return null;
        }
        const rect = element.getBoundingClientRect();
        const style = window.getComputedStyle(element);
        const offsets = {
          padding: {
            left: parseInt(style.paddingLeft, 10),
            top: parseInt(style.paddingTop, 10),
            right: parseInt(style.paddingRight, 10),
            bottom: parseInt(style.paddingBottom, 10)
          },
          margin: {
            left: -parseInt(style.marginLeft, 10),
            top: -parseInt(style.marginTop, 10),
            right: -parseInt(style.marginRight, 10),
            bottom: -parseInt(style.marginBottom, 10)
          },
          border: {
            left: parseInt(style.borderLeft, 10),
            top: parseInt(style.borderTop, 10),
            right: parseInt(style.borderRight, 10),
            bottom: parseInt(style.borderBottom, 10)
          }
        };
        const border = [
          { x: rect.left, y: rect.top },
          { x: rect.left + rect.width, y: rect.top },
          { x: rect.left + rect.width, y: rect.top + rect.bottom },
          { x: rect.left, y: rect.top + rect.bottom }
        ];
        const padding = transformQuadWithOffsets(border, offsets.border);
        const content = transformQuadWithOffsets(padding, offsets.padding);
        const margin = transformQuadWithOffsets(border, offsets.margin);
        return {
          content,
          padding,
          border,
          margin,
          width: rect.width,
          height: rect.height
        };
        function transformQuadWithOffsets(quad, offsets2) {
          return [
            {
              x: quad[0].x + offsets2.left,
              y: quad[0].y + offsets2.top
            },
            {
              x: quad[1].x - offsets2.right,
              y: quad[1].y + offsets2.top
            },
            {
              x: quad[2].x - offsets2.right,
              y: quad[2].y - offsets2.bottom
            },
            {
              x: quad[3].x + offsets2.left,
              y: quad[3].y - offsets2.bottom
            }
          ];
        }
      });
      if (!model) {
        return null;
      }
      const offset = await __privateMethod(this, _getTopLeftCornerOfFrame, getTopLeftCornerOfFrame_fn).call(this);
      if (!offset) {
        return null;
      }
      for (const attribute of [
        "content",
        "padding",
        "border",
        "margin"
      ]) {
        for (const point of model[attribute]) {
          point.x += offset.x;
          point.y += offset.y;
        }
      }
      return model;
    }
    async screenshot(options = {}) {
      const { scrollIntoView = true, clip } = options;
      const page = this.frame.page();
      if (scrollIntoView) {
        await this.scrollIntoViewIfNeeded();
      }
      const elementClip = await __privateMethod(this, _nonEmptyVisibleBoundingBox, nonEmptyVisibleBoundingBox_fn).call(this);
      const [pageLeft, pageTop] = await this.evaluate(() => {
        if (!window.visualViewport) {
          throw new Error("window.visualViewport is not supported.");
        }
        return [
          window.visualViewport.pageLeft,
          window.visualViewport.pageTop
        ];
      });
      elementClip.x += pageLeft;
      elementClip.y += pageTop;
      if (clip) {
        elementClip.x += clip.x;
        elementClip.y += clip.y;
        elementClip.height = clip.height;
        elementClip.width = clip.width;
      }
      return await page.screenshot({ ...options, clip: elementClip });
    }
    /**
     * @internal
     */
    async assertConnectedElement() {
      const error = await this.evaluate(async (element) => {
        if (!element.isConnected) {
          return "Node is detached from document";
        }
        if (element.nodeType !== Node.ELEMENT_NODE) {
          return "Node is not of type HTMLElement";
        }
        return;
      });
      if (error) {
        throw new Error(error);
      }
    }
    /**
     * @internal
     */
    async scrollIntoViewIfNeeded() {
      if (await this.isIntersectingViewport({
        threshold: 1
      })) {
        return;
      }
      await this.scrollIntoView();
    }
    /**
     * Resolves to true if the element is visible in the current viewport. If an
     * element is an SVG, we check if the svg owner element is in the viewport
     * instead. See https://crbug.com/963246.
     *
     * @param options - Threshold for the intersection between 0 (no intersection) and 1
     * (full intersection). Defaults to 1.
     */
    async isIntersectingViewport(options = {}) {
      var _a5;
      const env_5 = { stack: [], error: void 0, hasError: false };
      try {
        await this.assertConnectedElement();
        const handle = await __privateMethod(this, _asSVGElementHandle, asSVGElementHandle_fn).call(this);
        const target = __addDisposableResource$7(env_5, handle && await __privateMethod(_a5 = handle, _getOwnerSVGElement, getOwnerSVGElement_fn).call(_a5), false);
        return await (target ?? this).evaluate(async (element, threshold) => {
          const visibleRatio = await new Promise((resolve2) => {
            const observer = new IntersectionObserver((entries) => {
              resolve2(entries[0].intersectionRatio);
              observer.disconnect();
            });
            observer.observe(element);
          });
          return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
        }, options.threshold ?? 0);
      } catch (e_5) {
        env_5.error = e_5;
        env_5.hasError = true;
      } finally {
        __disposeResources$7(env_5);
      }
    }
    /**
     * Scrolls the element into view using either the automation protocol client
     * or by calling element.scrollIntoView.
     */
    async scrollIntoView() {
      await this.assertConnectedElement();
      await this.evaluate(async (element) => {
        element.scrollIntoView({
          block: "center",
          inline: "center",
          behavior: "instant"
        });
      });
    }
  }, _checkVisibility = new WeakSet(), checkVisibility_fn = async function(visibility) {
    return await this.evaluate(async (element, PuppeteerUtil, visibility2) => {
      return Boolean(PuppeteerUtil.checkVisibility(element, visibility2));
    }, LazyArg.create((context2) => {
      return context2.puppeteerUtil;
    }), visibility);
  }, _clickableBox = new WeakSet(), clickableBox_fn = async function() {
    var _a5;
    const boxes = await this.evaluate((element) => {
      if (!(element instanceof Element)) {
        return null;
      }
      return [...element.getClientRects()].map((rect) => {
        return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
      });
    });
    if (!(boxes == null ? void 0 : boxes.length)) {
      return null;
    }
    await __privateMethod(this, _intersectBoundingBoxesWithFrame, intersectBoundingBoxesWithFrame_fn).call(this, boxes);
    let frame = this.frame;
    let parentFrame;
    while (parentFrame = frame == null ? void 0 : frame.parentFrame()) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$7(env_3, await frame.frameElement(), false);
        if (!handle) {
          throw new Error("Unsupported frame type");
        }
        const parentBox = await handle.evaluate((element) => {
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          return {
            left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
            top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
          };
        });
        if (!parentBox) {
          return null;
        }
        for (const box2 of boxes) {
          box2.x += parentBox.left;
          box2.y += parentBox.top;
        }
        await __privateMethod(_a5 = handle, _intersectBoundingBoxesWithFrame, intersectBoundingBoxesWithFrame_fn).call(_a5, boxes);
        frame = parentFrame;
      } catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
      } finally {
        __disposeResources$7(env_3);
      }
    }
    const box = boxes.find((box2) => {
      return box2.width >= 1 && box2.height >= 1;
    });
    if (!box) {
      return null;
    }
    return {
      x: box.x,
      y: box.y,
      height: box.height,
      width: box.width
    };
  }, _intersectBoundingBoxesWithFrame = new WeakSet(), intersectBoundingBoxesWithFrame_fn = async function(boxes) {
    const { documentWidth, documentHeight } = await this.frame.isolatedRealm().evaluate(() => {
      return {
        documentWidth: document.documentElement.clientWidth,
        documentHeight: document.documentElement.clientHeight
      };
    });
    for (const box of boxes) {
      intersectBoundingBox(box, documentWidth, documentHeight);
    }
  }, _getTopLeftCornerOfFrame = new WeakSet(), getTopLeftCornerOfFrame_fn = async function() {
    const point = { x: 0, y: 0 };
    let frame = this.frame;
    let parentFrame;
    while (parentFrame = frame == null ? void 0 : frame.parentFrame()) {
      const env_4 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$7(env_4, await frame.frameElement(), false);
        if (!handle) {
          throw new Error("Unsupported frame type");
        }
        const parentBox = await handle.evaluate((element) => {
          if (element.getClientRects().length === 0) {
            return null;
          }
          const rect = element.getBoundingClientRect();
          const style = window.getComputedStyle(element);
          return {
            left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
            top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
          };
        });
        if (!parentBox) {
          return null;
        }
        point.x += parentBox.left;
        point.y += parentBox.top;
        frame = parentFrame;
      } catch (e_4) {
        env_4.error = e_4;
        env_4.hasError = true;
      } finally {
        __disposeResources$7(env_4);
      }
    }
    return point;
  }, _nonEmptyVisibleBoundingBox = new WeakSet(), nonEmptyVisibleBoundingBox_fn = async function() {
    const box = await this.boundingBox();
    assert$1(box, "Node is either not visible or not an HTMLElement");
    assert$1(box.width !== 0, "Node has 0 width.");
    assert$1(box.height !== 0, "Node has 0 height.");
    return box;
  }, _asSVGElementHandle = new WeakSet(), asSVGElementHandle_fn = async function() {
    if (await this.evaluate((element) => {
      return element instanceof SVGElement;
    })) {
      return this;
    } else {
      return null;
    }
  }, _getOwnerSVGElement = new WeakSet(), getOwnerSVGElement_fn = async function() {
    return await this.evaluateHandle((element) => {
      if (element instanceof SVGSVGElement) {
        return element;
      }
      return element.ownerSVGElement;
    });
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _getProperty_decorators = [throwIfDisposed(), (_a3 = _a4).bindIsolatedHandle.bind(_a3)];
    _getProperties_decorators = [throwIfDisposed(), (_b3 = _a4).bindIsolatedHandle.bind(_b3)];
    _jsonValue_decorators = [throwIfDisposed(), (_c3 = _a4).bindIsolatedHandle.bind(_c3)];
    _$_decorators = [throwIfDisposed(), (_d2 = _a4).bindIsolatedHandle.bind(_d2)];
    _$$_decorators = [throwIfDisposed(), (_e2 = _a4).bindIsolatedHandle.bind(_e2)];
    _waitForSelector_decorators = [throwIfDisposed(), (_f2 = _a4).bindIsolatedHandle.bind(_f2)];
    _isVisible_decorators = [throwIfDisposed(), (_g2 = _a4).bindIsolatedHandle.bind(_g2)];
    _isHidden_decorators = [throwIfDisposed(), (_h = _a4).bindIsolatedHandle.bind(_h)];
    _toElement_decorators = [throwIfDisposed(), (_j = _a4).bindIsolatedHandle.bind(_j)];
    _clickablePoint_decorators = [throwIfDisposed(), (_k = _a4).bindIsolatedHandle.bind(_k)];
    _hover_decorators = [throwIfDisposed(), (_l = _a4).bindIsolatedHandle.bind(_l)];
    _click_decorators = [throwIfDisposed(), (_m = _a4).bindIsolatedHandle.bind(_m)];
    _drag_decorators = [throwIfDisposed(), (_o = _a4).bindIsolatedHandle.bind(_o)];
    _dragEnter_decorators = [throwIfDisposed(), (_p = _a4).bindIsolatedHandle.bind(_p)];
    _dragOver_decorators = [throwIfDisposed(), (_q = _a4).bindIsolatedHandle.bind(_q)];
    _drop_decorators = [throwIfDisposed(), (_r = _a4).bindIsolatedHandle.bind(_r)];
    _dragAndDrop_decorators = [throwIfDisposed(), (_s = _a4).bindIsolatedHandle.bind(_s)];
    _select_decorators = [throwIfDisposed(), (_t2 = _a4).bindIsolatedHandle.bind(_t2)];
    _tap_decorators = [throwIfDisposed(), (_u = _a4).bindIsolatedHandle.bind(_u)];
    _touchStart_decorators = [throwIfDisposed(), (_v = _a4).bindIsolatedHandle.bind(_v)];
    _touchMove_decorators = [throwIfDisposed(), (_w = _a4).bindIsolatedHandle.bind(_w)];
    _touchEnd_decorators = [throwIfDisposed(), (_x = _a4).bindIsolatedHandle.bind(_x)];
    _focus_decorators = [throwIfDisposed(), (_y = _a4).bindIsolatedHandle.bind(_y)];
    _type_decorators = [throwIfDisposed(), (_z = _a4).bindIsolatedHandle.bind(_z)];
    _press_decorators = [throwIfDisposed(), (_0 = _a4).bindIsolatedHandle.bind(_0)];
    _boundingBox_decorators = [throwIfDisposed(), (_1 = _a4).bindIsolatedHandle.bind(_1)];
    _boxModel_decorators = [throwIfDisposed(), (_2 = _a4).bindIsolatedHandle.bind(_2)];
    _screenshot_decorators = [throwIfDisposed(), (_3 = _a4).bindIsolatedHandle.bind(_3)];
    _isIntersectingViewport_decorators = [throwIfDisposed(), (_4 = _a4).bindIsolatedHandle.bind(_4)];
    _scrollIntoView_decorators = [throwIfDisposed(), (_5 = _a4).bindIsolatedHandle.bind(_5)];
    __esDecorate$7(_a4, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: (obj) => "jsonValue" in obj, get: (obj) => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: (obj) => "isVisible" in obj, get: (obj) => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: (obj) => "isHidden" in obj, get: (obj) => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: (obj) => "toElement" in obj, get: (obj) => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: (obj) => "clickablePoint" in obj, get: (obj) => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: (obj) => "drag" in obj, get: (obj) => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: (obj) => "dragEnter" in obj, get: (obj) => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: (obj) => "dragOver" in obj, get: (obj) => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: (obj) => "drop" in obj, get: (obj) => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: (obj) => "dragAndDrop" in obj, get: (obj) => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: (obj) => "touchStart" in obj, get: (obj) => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: (obj) => "touchMove" in obj, get: (obj) => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: (obj) => "touchEnd" in obj, get: (obj) => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: (obj) => "press" in obj, get: (obj) => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: (obj) => "boundingBox" in obj, get: (obj) => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: (obj) => "boxModel" in obj, get: (obj) => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: (obj) => "isIntersectingViewport" in obj, get: (obj) => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$7(_a4, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a4, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a4;
})();
function intersectBoundingBox(box, width, height) {
  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
}
var __addDisposableResource$6 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$6 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
var LocatorEvent;
(function(LocatorEvent2) {
  LocatorEvent2["Action"] = "action";
})(LocatorEvent || (LocatorEvent = {}));
class Locator extends EventEmitter$2 {
  constructor() {
    super(...arguments);
    __privateAdd(this, _click);
    __privateAdd(this, _fill);
    __privateAdd(this, _hover);
    __privateAdd(this, _scroll);
    /**
     * @internal
     */
    __publicField(this, "visibility", null);
    /**
     * @internal
     */
    __publicField(this, "_timeout", 3e4);
    __privateAdd(this, _ensureElementIsInTheViewport, true);
    __privateAdd(this, _waitForEnabled, true);
    __privateAdd(this, _waitForStableBoundingBox, true);
    /**
     * @internal
     */
    __publicField(this, "operators", {
      conditions: (conditions, signal) => {
        return mergeMap((handle) => {
          return merge(...conditions.map((condition) => {
            return condition(handle, signal);
          })).pipe(defaultIfEmpty(handle));
        });
      },
      retryAndRaceWithSignalAndTimer: (signal, cause) => {
        const candidates = [];
        if (signal) {
          candidates.push(fromEvent(signal, "abort").pipe(map(() => {
            if (signal.reason instanceof Error) {
              signal.reason.cause = cause;
            }
            throw signal.reason;
          })));
        }
        candidates.push(timeout(this._timeout, cause));
        return pipe$1(retry$1({ delay: RETRY_DELAY }), raceWith(...candidates));
      }
    });
    /**
     * If the element has a "disabled" property, wait for the element to be
     * enabled.
     */
    __privateAdd(this, _waitForEnabledIfNeeded, (handle, signal) => {
      if (!__privateGet(this, _waitForEnabled)) {
        return EMPTY;
      }
      return from$1(handle.frame.waitForFunction((element) => {
        if (!(element instanceof HTMLElement)) {
          return true;
        }
        const isNativeFormControl = [
          "BUTTON",
          "INPUT",
          "SELECT",
          "TEXTAREA",
          "OPTION",
          "OPTGROUP"
        ].includes(element.nodeName);
        return !isNativeFormControl || !element.hasAttribute("disabled");
      }, {
        timeout: this._timeout,
        signal
      }, handle)).pipe(ignoreElements());
    });
    /**
     * Compares the bounding box of the element for two consecutive animation
     * frames and waits till they are the same.
     */
    __privateAdd(this, _waitForStableBoundingBoxIfNeeded, (handle) => {
      if (!__privateGet(this, _waitForStableBoundingBox)) {
        return EMPTY;
      }
      return defer(() => {
        return from$1(handle.evaluate((element) => {
          return new Promise((resolve2) => {
            window.requestAnimationFrame(() => {
              const rect1 = element.getBoundingClientRect();
              window.requestAnimationFrame(() => {
                const rect2 = element.getBoundingClientRect();
                resolve2([
                  {
                    x: rect1.x,
                    y: rect1.y,
                    width: rect1.width,
                    height: rect1.height
                  },
                  {
                    x: rect2.x,
                    y: rect2.y,
                    width: rect2.width,
                    height: rect2.height
                  }
                ]);
              });
            });
          });
        }));
      }).pipe(first(([rect1, rect2]) => {
        return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
      }), retry$1({ delay: RETRY_DELAY }), ignoreElements());
    });
    /**
     * Checks if the element is in the viewport and auto-scrolls it if it is not.
     */
    __privateAdd(this, _ensureElementIsInTheViewportIfNeeded, (handle) => {
      if (!__privateGet(this, _ensureElementIsInTheViewport)) {
        return EMPTY;
      }
      return from$1(handle.isIntersectingViewport({ threshold: 0 })).pipe(filter((isIntersectingViewport) => {
        return !isIntersectingViewport;
      }), mergeMap(() => {
        return from$1(handle.scrollIntoView());
      }), mergeMap(() => {
        return defer(() => {
          return from$1(handle.isIntersectingViewport({ threshold: 0 }));
        }).pipe(first(identity), retry$1({ delay: RETRY_DELAY }), ignoreElements());
      }));
    });
  }
  /**
   * Creates a race between multiple locators but ensures that only a single one
   * acts.
   *
   * @public
   */
  static race(locators) {
    return RaceLocator.create(locators);
  }
  // Determines when the locator will timeout for actions.
  get timeout() {
    return this._timeout;
  }
  setTimeout(timeout2) {
    const locator = this._clone();
    locator._timeout = timeout2;
    return locator;
  }
  setVisibility(visibility) {
    const locator = this._clone();
    locator.visibility = visibility;
    return locator;
  }
  setWaitForEnabled(value) {
    const locator = this._clone();
    __privateSet(locator, _waitForEnabled, value);
    return locator;
  }
  setEnsureElementIsInTheViewport(value) {
    const locator = this._clone();
    __privateSet(locator, _ensureElementIsInTheViewport, value);
    return locator;
  }
  setWaitForStableBoundingBox(value) {
    const locator = this._clone();
    __privateSet(locator, _waitForStableBoundingBox, value);
    return locator;
  }
  /**
   * @internal
   */
  copyOptions(locator) {
    this._timeout = locator._timeout;
    this.visibility = locator.visibility;
    __privateSet(this, _waitForEnabled, __privateGet(locator, _waitForEnabled));
    __privateSet(this, _ensureElementIsInTheViewport, __privateGet(locator, _ensureElementIsInTheViewport));
    __privateSet(this, _waitForStableBoundingBox, __privateGet(locator, _waitForStableBoundingBox));
    return this;
  }
  /**
   * Clones the locator.
   */
  clone() {
    return this._clone();
  }
  /**
   * Waits for the locator to get a handle from the page.
   *
   * @public
   */
  async waitHandle(options) {
    const cause = new Error("Locator.waitHandle");
    return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options == null ? void 0 : options.signal, cause)));
  }
  /**
   * Waits for the locator to get the serialized value from the page.
   *
   * Note this requires the value to be JSON-serializable.
   *
   * @public
   */
  async wait(options) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource$6(env_1, await this.waitHandle(options), false);
      return await handle.jsonValue();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$6(env_1);
    }
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @public
   */
  map(mapper) {
    return new MappedLocator(this._clone(), (handle) => {
      return handle.evaluateHandle(mapper);
    });
  }
  /**
   * Creates an expectation that is evaluated against located values.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @public
   */
  filter(predicate) {
    return new FilteredLocator(this._clone(), async (handle, signal) => {
      await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
      return true;
    });
  }
  /**
   * Creates an expectation that is evaluated against located handles.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @internal
   */
  filterHandle(predicate) {
    return new FilteredLocator(this._clone(), predicate);
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @internal
   */
  mapHandle(mapper) {
    return new MappedLocator(this._clone(), mapper);
  }
  click(options) {
    return firstValueFrom(__privateMethod(this, _click, click_fn).call(this, options));
  }
  /**
   * Fills out the input identified by the locator using the provided value. The
   * type of the input is determined at runtime and the appropriate fill-out
   * method is chosen based on the type. contenteditable, selector, inputs are
   * supported.
   */
  fill(value, options) {
    return firstValueFrom(__privateMethod(this, _fill, fill_fn).call(this, value, options));
  }
  hover(options) {
    return firstValueFrom(__privateMethod(this, _hover, hover_fn).call(this, options));
  }
  scroll(options) {
    return firstValueFrom(__privateMethod(this, _scroll, scroll_fn).call(this, options));
  }
}
_ensureElementIsInTheViewport = new WeakMap();
_waitForEnabled = new WeakMap();
_waitForStableBoundingBox = new WeakMap();
_waitForEnabledIfNeeded = new WeakMap();
_waitForStableBoundingBoxIfNeeded = new WeakMap();
_ensureElementIsInTheViewportIfNeeded = new WeakMap();
_click = new WeakSet();
click_fn = function(options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.click");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded),
    __privateGet(this, _waitForEnabledIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from$1(handle.click(options)).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
_fill = new WeakSet();
fill_fn = function(value, options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.fill");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded),
    __privateGet(this, _waitForEnabledIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from$1(handle.evaluate((el) => {
      if (el instanceof HTMLSelectElement) {
        return "select";
      }
      if (el instanceof HTMLTextAreaElement) {
        return "typeable-input";
      }
      if (el instanceof HTMLInputElement) {
        if ((/* @__PURE__ */ new Set([
          "textarea",
          "text",
          "url",
          "tel",
          "search",
          "password",
          "number",
          "email"
        ])).has(el.type)) {
          return "typeable-input";
        } else {
          return "other-input";
        }
      }
      if (el.isContentEditable) {
        return "contenteditable";
      }
      return "unknown";
    })).pipe(mergeMap((inputType) => {
      switch (inputType) {
        case "select":
          return from$1(handle.select(value).then(noop$4));
        case "contenteditable":
        case "typeable-input":
          return from$1(handle.evaluate((input, newValue) => {
            const currentValue = input.isContentEditable ? input.innerText : input.value;
            if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
              if (input.isContentEditable) {
                input.innerText = "";
              } else {
                input.value = "";
              }
              return newValue;
            }
            const originalValue = input.isContentEditable ? input.innerText : input.value;
            if (input.isContentEditable) {
              input.innerText = "";
              input.innerText = originalValue;
            } else {
              input.value = "";
              input.value = originalValue;
            }
            return newValue.substring(originalValue.length);
          }, value)).pipe(mergeMap((textToType) => {
            return from$1(handle.type(textToType));
          }));
        case "other-input":
          return from$1(handle.focus()).pipe(mergeMap(() => {
            return from$1(handle.evaluate((input, value2) => {
              input.value = value2;
              input.dispatchEvent(new Event("input", { bubbles: true }));
              input.dispatchEvent(new Event("change", { bubbles: true }));
            }, value));
          }));
        case "unknown":
          throw new Error(`Element cannot be filled out.`);
      }
    })).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
_hover = new WeakSet();
hover_fn = function(options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.hover");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from$1(handle.hover()).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
_scroll = new WeakSet();
scroll_fn = function(options) {
  const signal = options == null ? void 0 : options.signal;
  const cause = new Error("Locator.scroll");
  return this._wait(options).pipe(this.operators.conditions([
    __privateGet(this, _ensureElementIsInTheViewportIfNeeded),
    __privateGet(this, _waitForStableBoundingBoxIfNeeded)
  ], signal), tap(() => {
    return this.emit(LocatorEvent.Action, void 0);
  }), mergeMap((handle) => {
    return from$1(handle.evaluate((el, scrollTop, scrollLeft) => {
      if (scrollTop !== void 0) {
        el.scrollTop = scrollTop;
      }
      if (scrollLeft !== void 0) {
        el.scrollLeft = scrollLeft;
      }
    }, options == null ? void 0 : options.scrollTop, options == null ? void 0 : options.scrollLeft)).pipe(catchError((err) => {
      void handle.dispose().catch(debugError);
      throw err;
    }));
  }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause));
};
const _FunctionLocator = class _FunctionLocator extends Locator {
  constructor(pageOrFrame, func) {
    super();
    __privateAdd(this, _pageOrFrame, void 0);
    __privateAdd(this, _func, void 0);
    __privateSet(this, _pageOrFrame, pageOrFrame);
    __privateSet(this, _func, func);
  }
  static create(pageOrFrame, func) {
    return new _FunctionLocator(pageOrFrame, func).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
  }
  _clone() {
    return new _FunctionLocator(__privateGet(this, _pageOrFrame), __privateGet(this, _func));
  }
  _wait(options) {
    const signal = options == null ? void 0 : options.signal;
    return defer(() => {
      return from$1(__privateGet(this, _pageOrFrame).waitForFunction(__privateGet(this, _func), {
        timeout: this.timeout,
        signal
      }));
    }).pipe(throwIfEmpty());
  }
};
_pageOrFrame = new WeakMap();
_func = new WeakMap();
let FunctionLocator = _FunctionLocator;
class DelegatedLocator extends Locator {
  constructor(delegate) {
    super();
    __privateAdd(this, _delegate, void 0);
    __privateSet(this, _delegate, delegate);
    this.copyOptions(__privateGet(this, _delegate));
  }
  get delegate() {
    return __privateGet(this, _delegate);
  }
  setTimeout(timeout2) {
    const locator = super.setTimeout(timeout2);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setTimeout(timeout2));
    return locator;
  }
  setVisibility(visibility) {
    const locator = super.setVisibility(visibility);
    __privateSet(locator, _delegate, __privateGet(locator, _delegate).setVisibility(visibility));
    return locator;
  }
  setWaitForEnabled(value) {
    const locator = super.setWaitForEnabled(value);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setWaitForEnabled(value));
    return locator;
  }
  setEnsureElementIsInTheViewport(value) {
    const locator = super.setEnsureElementIsInTheViewport(value);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setEnsureElementIsInTheViewport(value));
    return locator;
  }
  setWaitForStableBoundingBox(value) {
    const locator = super.setWaitForStableBoundingBox(value);
    __privateSet(locator, _delegate, __privateGet(this, _delegate).setWaitForStableBoundingBox(value));
    return locator;
  }
}
_delegate = new WeakMap();
const _FilteredLocator = class _FilteredLocator extends DelegatedLocator {
  constructor(base, predicate) {
    super(base);
    __privateAdd(this, _predicate, void 0);
    __privateSet(this, _predicate, predicate);
  }
  _clone() {
    return new _FilteredLocator(this.delegate.clone(), __privateGet(this, _predicate)).copyOptions(this);
  }
  _wait(options) {
    return this.delegate._wait(options).pipe(mergeMap((handle) => {
      return from$1(Promise.resolve(__privateGet(this, _predicate).call(this, handle, options == null ? void 0 : options.signal))).pipe(filter((value) => {
        return value;
      }), map(() => {
        return handle;
      }));
    }), throwIfEmpty());
  }
};
_predicate = new WeakMap();
let FilteredLocator = _FilteredLocator;
const _MappedLocator = class _MappedLocator extends DelegatedLocator {
  constructor(base, mapper) {
    super(base);
    __privateAdd(this, _mapper, void 0);
    __privateSet(this, _mapper, mapper);
  }
  _clone() {
    return new _MappedLocator(this.delegate.clone(), __privateGet(this, _mapper)).copyOptions(this);
  }
  _wait(options) {
    return this.delegate._wait(options).pipe(mergeMap((handle) => {
      return from$1(Promise.resolve(__privateGet(this, _mapper).call(this, handle, options == null ? void 0 : options.signal)));
    }));
  }
};
_mapper = new WeakMap();
let MappedLocator = _MappedLocator;
const _NodeLocator = class _NodeLocator extends Locator {
  constructor(pageOrFrame, selector) {
    super();
    __privateAdd(this, _pageOrFrame2, void 0);
    __privateAdd(this, _selector, void 0);
    /**
     * Waits for the element to become visible or hidden. visibility === 'visible'
     * means that the element has a computed style, the visibility property other
     * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
     * 'hidden' means the opposite of that.
     */
    __privateAdd(this, _waitForVisibilityIfNeeded, (handle) => {
      if (!this.visibility) {
        return EMPTY;
      }
      return (() => {
        switch (this.visibility) {
          case "hidden":
            return defer(() => {
              return from$1(handle.isHidden());
            });
          case "visible":
            return defer(() => {
              return from$1(handle.isVisible());
            });
        }
      })().pipe(first(identity), retry$1({ delay: RETRY_DELAY }), ignoreElements());
    });
    __privateSet(this, _pageOrFrame2, pageOrFrame);
    __privateSet(this, _selector, selector);
  }
  static create(pageOrFrame, selector) {
    return new _NodeLocator(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
  }
  _clone() {
    return new _NodeLocator(__privateGet(this, _pageOrFrame2), __privateGet(this, _selector)).copyOptions(this);
  }
  _wait(options) {
    const signal = options == null ? void 0 : options.signal;
    return defer(() => {
      return from$1(__privateGet(this, _pageOrFrame2).waitForSelector(__privateGet(this, _selector), {
        visible: false,
        timeout: this._timeout,
        signal
      }));
    }).pipe(filter((value) => {
      return value !== null;
    }), throwIfEmpty(), this.operators.conditions([__privateGet(this, _waitForVisibilityIfNeeded)], signal));
  }
};
_pageOrFrame2 = new WeakMap();
_selector = new WeakMap();
_waitForVisibilityIfNeeded = new WeakMap();
let NodeLocator = _NodeLocator;
function checkLocatorArray(locators) {
  for (const locator of locators) {
    if (!(locator instanceof Locator)) {
      throw new Error("Unknown locator for race candidate");
    }
  }
  return locators;
}
const _RaceLocator = class _RaceLocator extends Locator {
  constructor(locators) {
    super();
    __privateAdd(this, _locators, void 0);
    __privateSet(this, _locators, locators);
  }
  static create(locators) {
    const array = checkLocatorArray(locators);
    return new _RaceLocator(array);
  }
  _clone() {
    return new _RaceLocator(__privateGet(this, _locators).map((locator) => {
      return locator.clone();
    })).copyOptions(this);
  }
  _wait(options) {
    return race(...__privateGet(this, _locators).map((locator) => {
      return locator._wait(options);
    }));
  }
};
_locators = new WeakMap();
let RaceLocator = _RaceLocator;
const RETRY_DELAY = 100;
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$6 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate$6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource$5 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$5 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
var FrameEvent;
(function(FrameEvent2) {
  FrameEvent2.FrameNavigated = Symbol("Frame.FrameNavigated");
  FrameEvent2.FrameSwapped = Symbol("Frame.FrameSwapped");
  FrameEvent2.LifecycleEvent = Symbol("Frame.LifecycleEvent");
  FrameEvent2.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument");
  FrameEvent2.FrameDetached = Symbol("Frame.FrameDetached");
  FrameEvent2.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
})(FrameEvent || (FrameEvent = {}));
const throwIfDetached = throwIfDisposed((frame) => {
  return `Attempted to use detached Frame '${frame._id}'.`;
});
let Frame = (() => {
  var __document, _document, document_fn, _a3;
  let _classSuper = EventEmitter$2;
  let _instanceExtraInitializers = [];
  let _frameElement_decorators;
  let _evaluateHandle_decorators;
  let _evaluate_decorators;
  let _locator_decorators;
  let _$_decorators;
  let _$$_decorators;
  let _$eval_decorators;
  let _$$eval_decorators;
  let _waitForSelector_decorators;
  let _waitForFunction_decorators;
  let _content_decorators;
  let _addScriptTag_decorators;
  let _addStyleTag_decorators;
  let _click_decorators;
  let _focus_decorators;
  let _hover_decorators;
  let _select_decorators;
  let _tap_decorators;
  let _type_decorators;
  let _title_decorators;
  return _a3 = class extends _classSuper {
    /**
     * @internal
     */
    constructor() {
      super();
      /**
       * @internal
       */
      __privateAdd(this, _document);
      /**
       * @internal
       */
      __publicField(this, "_id", (__runInitializers$6(this, _instanceExtraInitializers), void 0));
      /**
       * @internal
       */
      __publicField(this, "_parentId");
      /**
       * @internal
       */
      __publicField(this, "_name");
      /**
       * @internal
       */
      __publicField(this, "_hasStartedLoading", false);
      __privateAdd(this, __document, void 0);
    }
    /**
     * Used to clear the document handle that has been destroyed.
     *
     * @internal
     */
    clearDocumentHandle() {
      __privateSet(this, __document, void 0);
    }
    /**
     * @returns The frame element associated with this frame (if any).
     */
    async frameElement() {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const parentFrame = this.parentFrame();
        if (!parentFrame) {
          return null;
        }
        const list = __addDisposableResource$5(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
          return document.querySelectorAll("iframe,frame");
        }), false);
        for await (const iframe_1 of transposeIterableHandle(list)) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const iframe = __addDisposableResource$5(env_2, iframe_1, false);
            const frame = await iframe.contentFrame();
            if ((frame == null ? void 0 : frame._id) === this._id) {
              return iframe.move();
            }
          } catch (e_1) {
            env_2.error = e_1;
            env_2.hasError = true;
          } finally {
            __disposeResources$5(env_2);
          }
        }
        return null;
      } catch (e_2) {
        env_1.error = e_2;
        env_1.hasError = true;
      } finally {
        __disposeResources$5(env_1);
      }
    }
    /**
     * Behaves identically to {@link Page.evaluateHandle} except it's run within
     * the context of this frame.
     *
     * @see {@link Page.evaluateHandle} for details.
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.mainRealm().evaluateHandle(pageFunction, ...args);
    }
    /**
     * Behaves identically to {@link Page.evaluate} except it's run within
     * the context of this frame.
     *
     * @see {@link Page.evaluate} for details.
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.mainRealm().evaluate(pageFunction, ...args);
    }
    /**
     * @internal
     */
    locator(selectorOrFunc) {
      if (typeof selectorOrFunc === "string") {
        return NodeLocator.create(this, selectorOrFunc);
      } else {
        return FunctionLocator.create(this, selectorOrFunc);
      }
    }
    /**
     * Queries the frame for an element matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(selector) {
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$(selector);
    }
    /**
     * Queries the frame for all elements matching the given selector.
     *
     * @param selector - The selector to query for.
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(selector) {
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$$(selector);
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const searchValue = await frame.$eval('#search', el => el.value);
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * The first element matching the selector will be passed to the function as
     * its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$eval(selector, pageFunction, ...args);
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const divsCounts = await frame.$$eval('div', divs => divs.length);
     * ```
     *
     * @param selector - The selector to query for.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * An array of elements matching the given selector will be passed to the
     * function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
      const document2 = await __privateMethod(this, _document, document_fn).call(this);
      return await document2.$$eval(selector, pageFunction, ...args);
    }
    /**
     * Waits for an element matching the given selector to appear in the frame.
     *
     * This method works across navigations.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .mainFrame()
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.waitFor(this, updatedSelector, options);
    }
    /**
     * @example
     * The `waitForFunction` can be used to observe viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     * .  const browser = await puppeteer.launch();
     * .  const page = await browser.newPage();
     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
     * .  page.setViewport({width: 50, height: 50});
     * .  await watchDog;
     * .  await browser.close();
     * })();
     * ```
     *
     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
     *
     * ```ts
     * const selector = '.foo';
     * await frame.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {}, // empty options object
     *   selector
     * );
     * ```
     *
     * @param pageFunction - the function to evaluate in the frame context.
     * @param options - options to configure the polling method and timeout.
     * @param args - arguments to pass to the `pageFunction`.
     * @returns the promise which resolve when the `pageFunction` returns a truthy value.
     */
    async waitForFunction(pageFunction, options = {}, ...args) {
      return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
    }
    /**
     * The full HTML contents of the frame, including the DOCTYPE.
     */
    async content() {
      return await this.evaluate(() => {
        let content = "";
        for (const node2 of document.childNodes) {
          switch (node2) {
            case document.documentElement:
              content += document.documentElement.outerHTML;
              break;
            default:
              content += new XMLSerializer().serializeToString(node2);
              break;
          }
        }
        return content;
      });
    }
    /**
     * @internal
     */
    async setFrameContent(content) {
      return await this.evaluate((html) => {
        document.open();
        document.write(html);
        document.close();
      }, content);
    }
    /**
     * The frame's `name` attribute as specified in the tag.
     *
     * @remarks
     * If the name is empty, it returns the `id` attribute instead.
     *
     * @remarks
     * This value is calculated once when the frame is created, and will not
     * update if the attribute is changed later.
     *
     * @deprecated Use
     *
     * ```ts
     * const element = await frame.frameElement();
     * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);
     * ```
     */
    name() {
      return this._name || "";
    }
    /**
     * Is`true` if the frame has been detached. Otherwise, `false`.
     *
     * @deprecated Use the `detached` getter.
     */
    isDetached() {
      return this.detached;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.detached;
    }
    /**
     * Adds a `<script>` tag into the page with the desired url or content.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(options) {
      let { content = "", type } = options;
      const { path: path2 } = options;
      if (+!!options.url + +!!path2 + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path2) {
        const fs2 = await importFSPromises();
        content = await fs2.readFile(path2, "utf8");
        content += `//# sourceURL=${path2.replace(/\n/g, "")}`;
      }
      type = type ?? "text/javascript";
      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, id, type: type2, content: content2 }) => {
        return await new Promise((resolve2, reject) => {
          const script = document.createElement("script");
          script.type = type2;
          script.text = content2;
          script.addEventListener("error", (event) => {
            reject(new Error(event.message ?? "Could not load script"));
          }, { once: true });
          if (id) {
            script.id = id;
          }
          if (url) {
            script.src = url;
            script.addEventListener("load", () => {
              resolve2(script);
            }, { once: true });
            document.head.appendChild(script);
          } else {
            document.head.appendChild(script);
            resolve2(script);
          }
        });
      }, { ...options, type, content }));
    }
    /**
     * @internal
     */
    async addStyleTag(options) {
      let { content = "" } = options;
      const { path: path2 } = options;
      if (+!!options.url + +!!path2 + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path2) {
        const fs2 = await importFSPromises();
        content = await fs2.readFile(path2, "utf8");
        content += "/*# sourceURL=" + path2.replace(/\n/g, "") + "*/";
        options.content = content;
      }
      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url, content: content2 }) => {
        return await new Promise((resolve2, reject) => {
          let element;
          if (!url) {
            element = document.createElement("style");
            element.appendChild(document.createTextNode(content2));
          } else {
            const link2 = document.createElement("link");
            link2.rel = "stylesheet";
            link2.href = url;
            element = link2;
          }
          element.addEventListener("load", () => {
            resolve2(element);
          }, { once: true });
          element.addEventListener("error", (event) => {
            reject(new Error(event.message ?? "Could not load style"));
          }, { once: true });
          document.head.appendChild(element);
          return element;
        });
      }, options));
    }
    /**
     * Clicks the first element found that matches `selector`.
     *
     * @remarks
     * If `click()` triggers a navigation event and there's a separate
     * `page.waitForNavigation()` promise to be resolved, you may end up with a
     * race condition that yields unexpected results. The correct pattern for
     * click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   frame.click(selector, clickOptions),
     * ]);
     * ```
     *
     * @param selector - The selector to query for.
     */
    async click(selector, options = {}) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$5(env_3, await this.$(selector), false);
        assert$1(handle, `No element found for selector: ${selector}`);
        await handle.click(options);
        await handle.dispose();
      } catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
      } finally {
        __disposeResources$5(env_3);
      }
    }
    /**
     * Focuses the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async focus(selector) {
      const env_4 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$5(env_4, await this.$(selector), false);
        assert$1(handle, `No element found for selector: ${selector}`);
        await handle.focus();
      } catch (e_4) {
        env_4.error = e_4;
        env_4.hasError = true;
      } finally {
        __disposeResources$5(env_4);
      }
    }
    /**
     * Hovers the pointer over the center of the first element that matches the
     * `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async hover(selector) {
      const env_5 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$5(env_5, await this.$(selector), false);
        assert$1(handle, `No element found for selector: ${selector}`);
        await handle.hover();
      } catch (e_5) {
        env_5.error = e_5;
        env_5.hasError = true;
      } finally {
        __disposeResources$5(env_5);
      }
    }
    /**
     * Selects a set of value on the first `<select>` element that matches the
     * `selector`.
     *
     * @example
     *
     * ```ts
     * frame.select('select#colors', 'blue'); // single selection
     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - The selector to query for.
     * @param values - The array of values to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     * @returns the list of values that were successfully selected.
     * @throws Throws if there's no `<select>` matching `selector`.
     */
    async select(selector, ...values) {
      const env_6 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$5(env_6, await this.$(selector), false);
        assert$1(handle, `No element found for selector: ${selector}`);
        return await handle.select(...values);
      } catch (e_6) {
        env_6.error = e_6;
        env_6.hasError = true;
      } finally {
        __disposeResources$5(env_6);
      }
    }
    /**
     * Taps the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async tap(selector) {
      const env_7 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$5(env_7, await this.$(selector), false);
        assert$1(handle, `No element found for selector: ${selector}`);
        await handle.tap();
      } catch (e_7) {
        env_7.error = e_7;
        env_7.hasError = true;
      } finally {
        __disposeResources$5(env_7);
      }
    }
    /**
     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
     * in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`, use
     * {@link Keyboard.press}.
     *
     * @example
     *
     * ```ts
     * await frame.type('#mytextarea', 'Hello'); // Types instantly
     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param selector - the selector for the element to type into. If there are
     * multiple the first will be used.
     * @param text - text to type into the element
     * @param options - takes one option, `delay`, which sets the time to wait
     * between key presses in milliseconds. Defaults to `0`.
     */
    async type(selector, text, options) {
      const env_8 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource$5(env_8, await this.$(selector), false);
        assert$1(handle, `No element found for selector: ${selector}`);
        await handle.type(text, options);
      } catch (e_8) {
        env_8.error = e_8;
        env_8.hasError = true;
      } finally {
        __disposeResources$5(env_8);
      }
    }
    /**
     * The frame's title.
     */
    async title() {
      return await this.isolatedRealm().evaluate(() => {
        return document.title;
      });
    }
  }, __document = new WeakMap(), _document = new WeakSet(), document_fn = function() {
    if (!__privateGet(this, __document)) {
      __privateSet(this, __document, this.isolatedRealm().evaluateHandle(() => {
        return document;
      }).then((handle) => {
        return this.mainRealm().transferHandle(handle);
      }));
    }
    return __privateGet(this, __document);
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _frameElement_decorators = [throwIfDetached];
    _evaluateHandle_decorators = [throwIfDetached];
    _evaluate_decorators = [throwIfDetached];
    _locator_decorators = [throwIfDetached];
    _$_decorators = [throwIfDetached];
    _$$_decorators = [throwIfDetached];
    _$eval_decorators = [throwIfDetached];
    _$$eval_decorators = [throwIfDetached];
    _waitForSelector_decorators = [throwIfDetached];
    _waitForFunction_decorators = [throwIfDetached];
    _content_decorators = [throwIfDetached];
    _addScriptTag_decorators = [throwIfDetached];
    _addStyleTag_decorators = [throwIfDetached];
    _click_decorators = [throwIfDetached];
    _focus_decorators = [throwIfDetached];
    _hover_decorators = [throwIfDetached];
    _select_decorators = [throwIfDetached];
    _tap_decorators = [throwIfDetached];
    _type_decorators = [throwIfDetached];
    _title_decorators = [throwIfDetached];
    __esDecorate$6(_a3, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: (obj) => "frameElement" in obj, get: (obj) => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: (obj) => "evaluateHandle" in obj, get: (obj) => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: (obj) => "locator" in obj, get: (obj) => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: (obj) => "$eval" in obj, get: (obj) => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: (obj) => "$$eval" in obj, get: (obj) => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: (obj) => "waitForFunction" in obj, get: (obj) => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: (obj) => "content" in obj, get: (obj) => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: (obj) => "addScriptTag" in obj, get: (obj) => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: (obj) => "addStyleTag" in obj, get: (obj) => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$6(_a3, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: (obj) => "title" in obj, get: (obj) => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3;
})();
class HTTPRequest {
  /**
   * @internal
   */
  constructor() {
    /**
     * @internal
     */
    __publicField(this, "_interceptionId");
    /**
     * @internal
     */
    __publicField(this, "_failureText", null);
    /**
     * @internal
     */
    __publicField(this, "_response", null);
    /**
     * @internal
     */
    __publicField(this, "_fromMemoryCache", false);
    /**
     * @internal
     */
    __publicField(this, "_redirectChain", []);
    /**
     * @internal
     */
    __publicField(this, "interception", {
      enabled: false,
      handled: false,
      handlers: [],
      resolutionState: {
        action: InterceptResolutionAction.None
      },
      requestOverrides: {},
      response: null,
      abortReason: null
    });
  }
  /**
   * The `ContinueRequestOverrides` that will be used
   * if the interception is allowed to continue (ie, `abort()` and
   * `respond()` aren't called).
   */
  continueRequestOverrides() {
    assert$1(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.requestOverrides;
  }
  /**
   * The `ResponseForRequest` that gets used if the
   * interception is allowed to respond (ie, `abort()` is not called).
   */
  responseForRequest() {
    assert$1(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.response;
  }
  /**
   * The most recent reason for aborting the request
   */
  abortErrorReason() {
    assert$1(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.abortReason;
  }
  /**
   * An InterceptResolutionState object describing the current resolution
   * action and priority.
   *
   * InterceptResolutionState contains:
   * action: InterceptResolutionAction
   * priority?: number
   *
   * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
   * `disabled`, `none`, or `already-handled`.
   */
  interceptResolutionState() {
    if (!this.interception.enabled) {
      return { action: InterceptResolutionAction.Disabled };
    }
    if (this.interception.handled) {
      return { action: InterceptResolutionAction.AlreadyHandled };
    }
    return { ...this.interception.resolutionState };
  }
  /**
   * Is `true` if the intercept resolution has already been handled,
   * `false` otherwise.
   */
  isInterceptResolutionHandled() {
    return this.interception.handled;
  }
  /**
   * Adds an async request handler to the processing queue.
   * Deferred handlers are not guaranteed to execute in any particular order,
   * but they are guaranteed to resolve before the request interception
   * is finalized.
   */
  enqueueInterceptAction(pendingHandler) {
    this.interception.handlers.push(pendingHandler);
  }
  /**
   * Awaits pending interception handlers and then decides how to fulfill
   * the request interception.
   */
  async finalizeInterceptions() {
    await this.interception.handlers.reduce((promiseChain, interceptAction) => {
      return promiseChain.then(interceptAction);
    }, Promise.resolve());
    this.interception.handlers = [];
    const { action } = this.interceptResolutionState();
    switch (action) {
      case "abort":
        return await this._abort(this.interception.abortReason);
      case "respond":
        if (this.interception.response === null) {
          throw new Error("Response is missing for the interception");
        }
        return await this._respond(this.interception.response);
      case "continue":
        return await this._continue(this.interception.requestOverrides);
    }
  }
  /**
   * Continues request with optional request overrides.
   *
   * @example
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   // Override headers
   *   const headers = Object.assign({}, request.headers(), {
   *     foo: 'bar', // set "foo" header
   *     origin: undefined, // remove "origin" header
   *   });
   *   request.continue({headers});
   * });
   * ```
   *
   * @param overrides - optional overrides to apply to the request.
   * @param priority - If provided, intercept is resolved using cooperative
   * handling rules. Otherwise, intercept is resolved immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async continue(overrides = {}, priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    assert$1(this.interception.enabled, "Request Interception is not enabled!");
    assert$1(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._continue(overrides);
    }
    this.interception.requestOverrides = overrides;
    if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Continue,
        priority
      };
      return;
    }
    if (priority === this.interception.resolutionState.priority) {
      if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond") {
        return;
      }
      this.interception.resolutionState.action = InterceptResolutionAction.Continue;
    }
    return;
  }
  /**
   * Fulfills a request with the given response.
   *
   * @example
   * An example of fulfilling all requests with 404 responses:
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   request.respond({
   *     status: 404,
   *     contentType: 'text/plain',
   *     body: 'Not Found!',
   *   });
   * });
   * ```
   *
   * NOTE: Mocking responses for dataURL requests is not supported.
   * Calling `request.respond` for a dataURL request is a noop.
   *
   * @param response - the response to fulfill the request with.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request
   * interception should be enabled with {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async respond(response, priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    assert$1(this.interception.enabled, "Request Interception is not enabled!");
    assert$1(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._respond(response);
    }
    this.interception.response = response;
    if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Respond,
        priority
      };
      return;
    }
    if (priority === this.interception.resolutionState.priority) {
      if (this.interception.resolutionState.action === "abort") {
        return;
      }
      this.interception.resolutionState.action = InterceptResolutionAction.Respond;
    }
  }
  /**
   * Aborts a request.
   *
   * @param errorCode - optional error code to provide.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}. If it is not enabled, this method will
   * throw an exception immediately.
   */
  async abort(errorCode = "failed", priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    const errorReason = errorReasons[errorCode];
    assert$1(errorReason, "Unknown error code: " + errorCode);
    assert$1(this.interception.enabled, "Request Interception is not enabled!");
    assert$1(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._abort(errorReason);
    }
    this.interception.abortReason = errorReason;
    if (this.interception.resolutionState.priority === void 0 || priority >= this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Abort,
        priority
      };
      return;
    }
  }
}
var InterceptResolutionAction;
(function(InterceptResolutionAction2) {
  InterceptResolutionAction2["Abort"] = "abort";
  InterceptResolutionAction2["Respond"] = "respond";
  InterceptResolutionAction2["Continue"] = "continue";
  InterceptResolutionAction2["Disabled"] = "disabled";
  InterceptResolutionAction2["None"] = "none";
  InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
})(InterceptResolutionAction || (InterceptResolutionAction = {}));
function headersArray(headers) {
  const result = [];
  for (const name2 in headers) {
    const value = headers[name2];
    if (!Object.is(value, void 0)) {
      const values = Array.isArray(value) ? value : [value];
      result.push(...values.map((value2) => {
        return { name: name2, value: value2 + "" };
      }));
    }
  }
  return result;
}
const STATUS_TEXTS = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "Switch Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
const errorReasons = {
  aborted: "Aborted",
  accessdenied: "AccessDenied",
  addressunreachable: "AddressUnreachable",
  blockedbyclient: "BlockedByClient",
  blockedbyresponse: "BlockedByResponse",
  connectionaborted: "ConnectionAborted",
  connectionclosed: "ConnectionClosed",
  connectionfailed: "ConnectionFailed",
  connectionrefused: "ConnectionRefused",
  connectionreset: "ConnectionReset",
  internetdisconnected: "InternetDisconnected",
  namenotresolved: "NameNotResolved",
  timedout: "TimedOut",
  failed: "Failed"
};
function handleError(error) {
  if (error.originalMessage.includes("Invalid header")) {
    throw error;
  }
  debugError(error);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class HTTPResponse {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * True if the response was successful (status in the range 200-299).
   */
  ok() {
    const status = this.status();
    return status === 0 || status >= 200 && status <= 299;
  }
  /**
   * Promise which resolves to a text (utf8) representation of response body.
   */
  async text() {
    const content = await this.buffer();
    return content.toString("utf8");
  }
  /**
   * Promise which resolves to a JSON representation of response body.
   *
   * @remarks
   *
   * This method will throw if the response body is not parsable via
   * `JSON.parse`.
   */
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Keyboard {
  /**
   * @internal
   */
  constructor() {
  }
}
const MouseButton = Object.freeze({
  Left: "left",
  Right: "right",
  Middle: "middle",
  Back: "back",
  Forward: "forward"
});
class Mouse {
  /**
   * @internal
   */
  constructor() {
  }
}
class Touchscreen {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Dispatches a `touchstart` and `touchend` event.
   * @param x - Horizontal position of the tap.
   * @param y - Vertical position of the tap.
   */
  async tap(x2, y2) {
    await this.touchStart(x2, y2);
    await this.touchEnd();
  }
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const DEFAULT_TIMEOUT$1 = 3e4;
class TimeoutSettings {
  constructor() {
    __privateAdd(this, _defaultTimeout, void 0);
    __privateAdd(this, _defaultNavigationTimeout, void 0);
    __privateSet(this, _defaultTimeout, null);
    __privateSet(this, _defaultNavigationTimeout, null);
  }
  setDefaultTimeout(timeout2) {
    __privateSet(this, _defaultTimeout, timeout2);
  }
  setDefaultNavigationTimeout(timeout2) {
    __privateSet(this, _defaultNavigationTimeout, timeout2);
  }
  navigationTimeout() {
    if (__privateGet(this, _defaultNavigationTimeout) !== null) {
      return __privateGet(this, _defaultNavigationTimeout);
    }
    if (__privateGet(this, _defaultTimeout) !== null) {
      return __privateGet(this, _defaultTimeout);
    }
    return DEFAULT_TIMEOUT$1;
  }
  timeout() {
    if (__privateGet(this, _defaultTimeout) !== null) {
      return __privateGet(this, _defaultTimeout);
    }
    return DEFAULT_TIMEOUT$1;
  }
}
_defaultTimeout = new WeakMap();
_defaultNavigationTimeout = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$5 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate$5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __addDisposableResource$4 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$4 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
function setDefaultScreenshotOptions(options) {
  options.optimizeForSpeed ?? (options.optimizeForSpeed = false);
  options.type ?? (options.type = "png");
  options.fromSurface ?? (options.fromSurface = true);
  options.fullPage ?? (options.fullPage = false);
  options.omitBackground ?? (options.omitBackground = false);
  options.encoding ?? (options.encoding = "binary");
  options.captureBeyondViewport ?? (options.captureBeyondViewport = true);
}
let Page = (() => {
  var _requestHandlers, _inflight$, _screencastSessionCount, _startScreencastPromise, _getNativePixelDimensions, getNativePixelDimensions_fn, _a3;
  let _classSuper = EventEmitter$2;
  let _instanceExtraInitializers = [];
  let _screenshot_decorators;
  return _a3 = class extends _classSuper {
    /**
     * @internal
     */
    constructor() {
      super();
      /**
       * Gets the native, non-emulated dimensions of the viewport.
       */
      __privateAdd(this, _getNativePixelDimensions);
      /**
       * @internal
       */
      __publicField(this, "_isDragging", (__runInitializers$5(this, _instanceExtraInitializers), false));
      /**
       * @internal
       */
      __publicField(this, "_timeoutSettings", new TimeoutSettings());
      __privateAdd(this, _requestHandlers, /* @__PURE__ */ new WeakMap());
      __privateAdd(this, _inflight$, new ReplaySubject(1));
      __privateAdd(this, _screencastSessionCount, 0);
      __privateAdd(this, _startScreencastPromise, void 0);
      fromEmitterEvent(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(mergeMap((originalRequest) => {
        return concat$1(of(1), merge(fromEmitterEvent(
          this,
          "requestfailed"
          /* PageEvent.RequestFailed */
        ), fromEmitterEvent(
          this,
          "requestfinished"
          /* PageEvent.RequestFinished */
        ), fromEmitterEvent(
          this,
          "response"
          /* PageEvent.Response */
        ).pipe(map((response) => {
          return response.request();
        }))).pipe(filter((request) => {
          return request.id === originalRequest.id;
        }), take(1), map(() => {
          return -1;
        })));
      }), mergeScan((acc, addend) => {
        return of(acc + addend);
      }, 0), takeUntil(fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      )), startWith(0)).subscribe(__privateGet(this, _inflight$));
    }
    /**
     * Listen to page events.
     *
     * @remarks
     * This method exists to define event typings and handle proper wireup of
     * cooperative request interception. Actual event listening and dispatching is
     * delegated to {@link EventEmitter}.
     *
     * @internal
     */
    on(type, handler) {
      if (type !== "request") {
        return super.on(type, handler);
      }
      let wrapper = __privateGet(this, _requestHandlers).get(handler);
      if (wrapper === void 0) {
        wrapper = (event) => {
          event.enqueueInterceptAction(() => {
            return handler(event);
          });
        };
        __privateGet(this, _requestHandlers).set(handler, wrapper);
      }
      return super.on(type, wrapper);
    }
    /**
     * @internal
     */
    off(type, handler) {
      if (type === "request") {
        handler = __privateGet(this, _requestHandlers).get(handler) || handler;
      }
      return super.off(type, handler);
    }
    locator(selectorOrFunc) {
      if (typeof selectorOrFunc === "string") {
        return NodeLocator.create(this, selectorOrFunc);
      } else {
        return FunctionLocator.create(this, selectorOrFunc);
      }
    }
    /**
     * A shortcut for {@link Locator.race} that does not require static imports.
     *
     * @internal
     */
    locatorRace(locators) {
      return Locator.race(locators);
    }
    /**
     * Runs `document.querySelector` within the page. If no element matches the
     * selector, the return value resolves to `null`.
     *
     * @param selector - A `selector` to query page for
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query page for.
     */
    async $(selector) {
      return await this.mainFrame().$(selector);
    }
    /**
     * The method runs `document.querySelectorAll` within the page. If no elements
     * match the selector, the return value resolves to `[]`.
     *
     * @param selector - A `selector` to query page for
     *
     * @remarks
     *
     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
     */
    async $$(selector) {
      return await this.mainFrame().$$(selector);
    }
    /**
     * @remarks
     *
     * The only difference between {@link Page.evaluate | page.evaluate} and
     * `page.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * If the function passed to `page.evaluateHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluateHandle('document');
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluateHandle(() => document.body);
     * const resultHandle = await page.evaluateHandle(
     *   body => body.innerHTML,
     *   aHandle
     * );
     * console.log(await resultHandle.jsonValue());
     * await resultHandle.dispose();
     * ```
     *
     * Most of the time this function returns a {@link JSHandle},
     * but if `pageFunction` returns a reference to an element,
     * you instead get an {@link ElementHandle} back:
     *
     * @example
     *
     * ```ts
     * const button = await page.evaluateHandle(() =>
     *   document.querySelector('button')
     * );
     * // can call `click` because `button` is an `ElementHandle`
     * await button.click();
     * ```
     *
     * The TypeScript definitions assume that `evaluateHandle` returns
     * a `JSHandle`, but if you know it's going to return an
     * `ElementHandle`, pass it as the generic argument:
     *
     * ```ts
     * const button = await page.evaluateHandle<ElementHandle>(...);
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.mainFrame().evaluateHandle(pageFunction, ...args);
    }
    /**
     * This method runs `document.querySelector` within the page and passes the
     * result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If no element is found matching `selector`, the method will throw an error.
     *
     * If `pageFunction` returns a promise `$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * const searchValue = await page.$eval('#search', el => el.value);
     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
     * const html = await page.$eval('.main-container', el => el.outerHTML);
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * const searchValue = await page.$eval(
     *   '#search',
     *   (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$eval`:
     *
     * @example
     *
     * ```ts
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const searchValue = await page.$eval<string>(
     *   '#search',
     *   (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * @param selector - the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of `document.querySelector(selector)` as its
     * first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
      return await this.mainFrame().$eval(selector, pageFunction, ...args);
    }
    /**
     * This method runs `Array.from(document.querySelectorAll(selector))` within
     * the page and passes the result as the first argument to the `pageFunction`.
     *
     * @remarks
     * If `pageFunction` returns a promise `$$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * // get the amount of divs on the page
     * const divCount = await page.$$eval('div', divs => divs.length);
     *
     * // get the text content of all the `.options` elements:
     * const options = await page.$$eval('div > span.options', options => {
     *   return options.map(option => option.textContent);
     * });
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element[]`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * await page.$$eval('input', elements => {
     *   return elements.map(e => e.value);
     * });
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$$eval`:
     *
     * @example
     *
     * ```ts
     * const allInputValues = await page.$$eval('input', elements =>
     *   elements.map(e => e.textContent)
     * );
     * ```
     *
     * @param selector - the
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to query for
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of
     * `Array.from(document.querySelectorAll(selector))` as its first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $$eval(selector, pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
      return await this.mainFrame().$$eval(selector, pageFunction, ...args);
    }
    /**
     * Adds a `<script>` tag into the page with the desired URL or content.
     *
     * @remarks
     * Shortcut for
     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(options) {
      return await this.mainFrame().addScriptTag(options);
    }
    async addStyleTag(options) {
      return await this.mainFrame().addStyleTag(options);
    }
    /**
     * The page's URL.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.url | page.mainFrame().url()}.
     */
    url() {
      return this.mainFrame().url();
    }
    /**
     * The full HTML contents of the page, including the DOCTYPE.
     */
    async content() {
      return await this.mainFrame().content();
    }
    /**
     * Set the content of the page.
     *
     * @param html - HTML markup to assign to the page.
     * @param options - Parameters that has some properties.
     *
     * @remarks
     *
     * The parameter `options` might have the following options.
     *
     * - `timeout` : Maximum time in milliseconds for resources to load, defaults
     *   to 30 seconds, pass `0` to disable timeout. The default value can be
     *   changed by using the {@link Page.setDefaultNavigationTimeout} or
     *   {@link Page.setDefaultTimeout} methods.
     *
     * - `waitUntil`: When to consider setting markup succeeded, defaults to
     *   `load`. Given an array of event strings, setting content is considered
     *   to be successful after all events have been fired. Events can be
     *   either:<br/>
     * - `load` : consider setting content to be finished when the `load` event
     *   is fired.<br/>
     * - `domcontentloaded` : consider setting content to be finished when the
     *   `DOMContentLoaded` event is fired.<br/>
     * - `networkidle0` : consider setting content to be finished when there are
     *   no more than 0 network connections for at least `500` ms.<br/>
     * - `networkidle2` : consider setting content to be finished when there are
     *   no more than 2 network connections for at least `500` ms.
     */
    async setContent(html, options) {
      await this.mainFrame().setContent(html, options);
    }
    /**
     * Navigates the page to the given `url`.
     *
     * @remarks
     *
     * Navigation to `about:blank` or navigation to the same URL with a different
     * hash will succeed and return `null`.
     *
     * :::warning
     *
     * Headless mode doesn't support navigation to a PDF document. See the {@link
     * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream
     * issue}.
     *
     * :::
     *
     * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.
     *
     * @param url - URL to navigate page to. The URL should include scheme, e.g.
     * `https://`
     * @param options - Options to configure waiting behavior.
     * @returns A promise which resolves to the main resource response. In case of
     * multiple redirects, the navigation will resolve with the response of the
     * last redirect.
     * @throws If:
     *
     * - there's an SSL error (e.g. in case of self-signed certificates).
     * - target URL is invalid.
     * - the timeout is exceeded during navigation.
     * - the remote server does not respond or is unreachable.
     * - the main resource failed to load.
     *
     * This method will not throw an error when any valid HTTP status code is
     * returned by the remote server, including 404 "Not Found" and 500 "Internal
     * Server Error". The status code for such responses can be retrieved by
     * calling {@link HTTPResponse.status}.
     */
    async goto(url, options) {
      return await this.mainFrame().goto(url, options);
    }
    /**
     * Waits for the page to navigate to a new URL or to reload. It is useful when
     * you run code that will indirectly cause the page to navigate.
     *
     * @example
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(), // The promise resolves after navigation has finished
     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
     * ]);
     * ```
     *
     * @remarks
     *
     * Usage of the
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
     * to change the URL is considered a navigation.
     *
     * @param options - Navigation parameters which might have the following
     * properties:
     * @returns A `Promise` which resolves to the main resource response.
     *
     * - In case of multiple redirects, the navigation will resolve with the
     *   response of the last redirect.
     * - In case of navigation to a different anchor or navigation due to History
     *   API usage, the navigation will resolve with `null`.
     */
    async waitForNavigation(options = {}) {
      return await this.mainFrame().waitForNavigation(options);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched request
     * @example
     *
     * ```ts
     * const firstRequest = await page.waitForRequest(
     *   'https://example.com/resource'
     * );
     * const finalRequest = await page.waitForRequest(
     *   request => request.url() === 'https://example.com'
     * );
     * return finalRequest.response()?.ok();
     * ```
     *
     * @remarks
     * Optional Waiting Parameters have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass
     *   `0` to disable the timeout. The default value can be changed by using the
     *   {@link Page.setDefaultTimeout} method.
     */
    waitForRequest(urlOrPredicate, options = {}) {
      const { timeout: ms2 = this._timeoutSettings.timeout() } = options;
      if (typeof urlOrPredicate === "string") {
        const url = urlOrPredicate;
        urlOrPredicate = (request) => {
          return request.url() === url;
        };
      }
      const observable$ = fromEmitterEvent(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms2), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed!");
      }))));
      return firstValueFrom(observable$);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for.
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched response.
     * @example
     *
     * ```ts
     * const firstResponse = await page.waitForResponse(
     *   'https://example.com/resource'
     * );
     * const finalResponse = await page.waitForResponse(
     *   response =>
     *     response.url() === 'https://example.com' && response.status() === 200
     * );
     * const finalResponse = await page.waitForResponse(async response => {
     *   return (await response.text()).includes('<html>');
     * });
     * return finalResponse.ok();
     * ```
     *
     * @remarks
     * Optional Parameter have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,
     *   pass `0` to disable the timeout. The default value can be changed by using
     *   the {@link Page.setDefaultTimeout} method.
     */
    waitForResponse(urlOrPredicate, options = {}) {
      const { timeout: ms2 = this._timeoutSettings.timeout() } = options;
      if (typeof urlOrPredicate === "string") {
        const url = urlOrPredicate;
        urlOrPredicate = (response) => {
          return response.url() === url;
        };
      }
      const observable$ = fromEmitterEvent(
        this,
        "response"
        /* PageEvent.Response */
      ).pipe(filterAsync(urlOrPredicate), raceWith(timeout(ms2), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed!");
      }))));
      return firstValueFrom(observable$);
    }
    /**
     * Waits for the network to be idle.
     *
     * @param options - Options to configure waiting behavior.
     * @returns A promise which resolves once the network is idle.
     */
    waitForNetworkIdle(options = {}) {
      return firstValueFrom(this.waitForNetworkIdle$(options));
    }
    /**
     * @internal
     */
    waitForNetworkIdle$(options = {}) {
      const { timeout: ms2 = this._timeoutSettings.timeout(), idleTime = NETWORK_IDLE_TIME, concurrency = 0 } = options;
      return __privateGet(this, _inflight$).pipe(switchMap((inflight) => {
        if (inflight > concurrency) {
          return EMPTY;
        }
        return timer(idleTime);
      }), map(() => {
      }), raceWith(timeout(ms2), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed!");
      }))));
    }
    /**
     * Waits for a frame matching the given conditions to appear.
     *
     * @example
     *
     * ```ts
     * const frame = await page.waitForFrame(async frame => {
     *   return frame.name() === 'Test';
     * });
     * ```
     */
    async waitForFrame(urlOrPredicate, options = {}) {
      const { timeout: ms2 = this.getDefaultTimeout() } = options;
      if (isString(urlOrPredicate)) {
        urlOrPredicate = (frame) => {
          return urlOrPredicate === frame.url();
        };
      }
      return await firstValueFrom(merge(fromEmitterEvent(
        this,
        "frameattached"
        /* PageEvent.FrameAttached */
      ), fromEmitterEvent(
        this,
        "framenavigated"
        /* PageEvent.FrameNavigated */
      ), from$1(this.frames())).pipe(filterAsync(urlOrPredicate), first(), raceWith(timeout(ms2), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map(() => {
        throw new TargetCloseError("Page closed.");
      })))));
    }
    /**
     * Emulates a given device's metrics and user agent.
     *
     * To aid emulation, Puppeteer provides a list of known devices that can be
     * via {@link KnownDevices}.
     *
     * @remarks
     * This method is a shortcut for calling two methods:
     * {@link Page.setUserAgent} and {@link Page.setViewport}.
     *
     * This method will resize the page. A lot of websites don't expect phones to
     * change size, so you should emulate before navigating to the page.
     *
     * @example
     *
     * ```ts
     * import {KnownDevices} from 'puppeteer';
     * const iPhone = KnownDevices['iPhone 6'];
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.emulate(iPhone);
     *   await page.goto('https://www.google.com');
     *   // other actions...
     *   await browser.close();
     * })();
     * ```
     */
    async emulate(device) {
      await Promise.all([
        this.setUserAgent(device.userAgent),
        this.setViewport(device.viewport)
      ]);
    }
    /**
     * Evaluates a function in the page's context and returns the result.
     *
     * If the function passed to `page.evaluate` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * @example
     *
     * ```ts
     * const result = await frame.evaluate(() => {
     *   return Promise.resolve(8 * 7);
     * });
     * console.log(result); // prints "56"
     * ```
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluate('1 + 2');
     * ```
     *
     * To get the best TypeScript experience, you should pass in as the
     * generic the type of `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluate(() => 2);
     * ```
     *
     * @example
     *
     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
     * as arguments to the `pageFunction`:
     *
     * ```ts
     * const bodyHandle = await page.$('body');
     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
     * await bodyHandle.dispose();
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     *
     * @returns the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.mainFrame().evaluate(pageFunction, ...args);
    }
    /**
     * @internal
     */
    async _maybeWriteBufferToFile(path2, buffer) {
      if (!path2) {
        return;
      }
      const fs2 = await importFSPromises();
      await fs2.writeFile(path2, buffer);
    }
    /**
     * Captures a screencast of this {@link Page | page}.
     *
     * @example
     * Recording a {@link Page | page}:
     *
     * ```
     * import puppeteer from 'puppeteer';
     *
     * // Launch a browser
     * const browser = await puppeteer.launch();
     *
     * // Create a new page
     * const page = await browser.newPage();
     *
     * // Go to your site.
     * await page.goto("https://www.example.com");
     *
     * // Start recording.
     * const recorder = await page.screencast({path: 'recording.webm'});
     *
     * // Do something.
     *
     * // Stop recording.
     * await recorder.stop();
     *
     * browser.close();
     * ```
     *
     * @param options - Configures screencast behavior.
     *
     * @experimental
     *
     * @remarks
     *
     * All recordings will be {@link https://www.webmproject.org/ | WebM} format using
     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.
     *
     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
     */
    async screencast(options = {}) {
      const [{ ScreenRecorder: ScreenRecorder2 }, [width, height, devicePixelRatio]] = await Promise.all([
        Promise.resolve().then(() => ScreenRecorder$1),
        __privateMethod(this, _getNativePixelDimensions, getNativePixelDimensions_fn).call(this)
      ]);
      let crop;
      if (options.crop) {
        const { x: x2, y: y2, width: cropWidth, height: cropHeight } = roundRectangle(normalizeRectangle(options.crop));
        if (x2 < 0 || y2 < 0) {
          throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
        }
        if (cropWidth <= 0 || cropHeight <= 0) {
          throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
        }
        const viewportWidth = width / devicePixelRatio;
        const viewportHeight = height / devicePixelRatio;
        if (x2 + cropWidth > viewportWidth) {
          throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
        }
        if (y2 + cropHeight > viewportHeight) {
          throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
        }
        crop = {
          x: x2 * devicePixelRatio,
          y: y2 * devicePixelRatio,
          width: cropWidth * devicePixelRatio,
          height: cropHeight * devicePixelRatio
        };
      }
      if (options.speed !== void 0 && options.speed <= 0) {
        throw new Error(`\`speed\` must be greater than 0.`);
      }
      if (options.scale !== void 0 && options.scale <= 0) {
        throw new Error(`\`scale\` must be greater than 0.`);
      }
      const recorder = new ScreenRecorder2(this, width, height, {
        ...options,
        path: options.ffmpegPath,
        crop
      });
      try {
        await this._startScreencast();
      } catch (error) {
        void recorder.stop();
        throw error;
      }
      if (options.path) {
        const { createWriteStream } = await import("fs");
        const stream2 = createWriteStream(options.path, "binary");
        recorder.pipe(stream2);
      }
      return recorder;
    }
    /**
     * @internal
     */
    async _startScreencast() {
      ++__privateWrapper(this, _screencastSessionCount)._;
      if (!__privateGet(this, _startScreencastPromise)) {
        __privateSet(this, _startScreencastPromise, this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => {
          return new Promise((resolve2) => {
            return this.mainFrame().client.once("Page.screencastFrame", () => {
              return resolve2();
            });
          });
        }));
      }
      await __privateGet(this, _startScreencastPromise);
    }
    /**
     * @internal
     */
    async _stopScreencast() {
      --__privateWrapper(this, _screencastSessionCount)._;
      if (!__privateGet(this, _startScreencastPromise)) {
        return;
      }
      __privateSet(this, _startScreencastPromise, void 0);
      if (__privateGet(this, _screencastSessionCount) === 0) {
        await this.mainFrame().client.send("Page.stopScreencast");
      }
    }
    async screenshot(userOptions = {}) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        await this.bringToFront();
        const options = {
          ...userOptions,
          clip: userOptions.clip ? {
            ...userOptions.clip
          } : void 0
        };
        if (options.type === void 0 && options.path !== void 0) {
          const filePath = options.path;
          const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
          switch (extension) {
            case "png":
              options.type = "png";
              break;
            case "jpeg":
            case "jpg":
              options.type = "jpeg";
              break;
            case "webp":
              options.type = "webp";
              break;
          }
        }
        if (options.quality !== void 0) {
          if (options.quality < 0 && options.quality > 100) {
            throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
          }
          if (options.type === void 0 || !["jpeg", "webp"].includes(options.type)) {
            throw new Error(`${options.type ?? "png"} screenshots do not support 'quality'.`);
          }
        }
        if (options.clip) {
          if (options.clip.width <= 0) {
            throw new Error("'width' in 'clip' must be positive.");
          }
          if (options.clip.height <= 0) {
            throw new Error("'height' in 'clip' must be positive.");
          }
        }
        setDefaultScreenshotOptions(options);
        const stack = __addDisposableResource$4(env_2, new AsyncDisposableStack(), true);
        if (options.clip) {
          if (options.fullPage) {
            throw new Error("'clip' and 'fullPage' are mutually exclusive");
          }
          options.clip = roundRectangle(normalizeRectangle(options.clip));
        } else {
          if (options.fullPage) {
            if (!options.captureBeyondViewport) {
              const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                const element = document.documentElement;
                return {
                  width: element.scrollWidth,
                  height: element.scrollHeight
                };
              });
              const viewport = this.viewport();
              await this.setViewport({
                ...viewport,
                ...scrollDimensions
              });
              stack.defer(async () => {
                if (viewport) {
                  await this.setViewport(viewport).catch(debugError);
                } else {
                  await this.setViewport({
                    width: 0,
                    height: 0
                  }).catch(debugError);
                }
              });
            }
          } else {
            options.captureBeyondViewport = false;
          }
        }
        const data2 = await this._screenshot(options);
        if (options.encoding === "base64") {
          return data2;
        }
        const buffer = Buffer.from(data2, "base64");
        await this._maybeWriteBufferToFile(options.path, buffer);
        return buffer;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        const result_1 = __disposeResources$4(env_2);
        if (result_1)
          await result_1;
      }
    }
    /**
     * The page's title
     *
     * @remarks
     *
     * Shortcut for {@link Frame.title | page.mainFrame().title()}.
     */
    async title() {
      return await this.mainFrame().title();
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse} to click in the center of the
     * element. If there's no element matching `selector`, the method throws an
     * error.
     *
     * @remarks
     *
     * Bear in mind that if `click()` triggers a navigation event and
     * there's a separate `page.waitForNavigation()` promise to be resolved, you
     * may end up with a race condition that yields unexpected results. The
     * correct pattern for click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   page.click(selector, clickOptions),
     * ]);
     * ```
     *
     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
     * @param selector - A `selector` to search for element to click. If there are
     * multiple elements satisfying the `selector`, the first will be clicked
     * @param options - `Object`
     * @returns Promise which resolves when the element matching `selector` is
     * successfully clicked. The Promise will be rejected if there is no element
     * matching `selector`.
     */
    click(selector, options) {
      return this.mainFrame().click(selector, options);
    }
    /**
     * This method fetches an element with `selector` and focuses it. If there's no
     * element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }
     * of an element to focus. If there are multiple elements satisfying the
     * selector, the first will be focused.
     * @returns Promise which resolves when the element matching selector is
     * successfully focused. The promise will be rejected if there is no element
     * matching selector.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.
     */
    focus(selector) {
      return this.mainFrame().focus(selector);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse}
     * to hover over the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to search for element to hover. If there are multiple elements satisfying
     * the selector, the first will be hovered.
     * @returns Promise which resolves when the element matching `selector` is
     * successfully hovered. Promise gets rejected if there's no element matching
     * `selector`.
     *
     * @remarks
     *
     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
     */
    hover(selector) {
      return this.mainFrame().hover(selector);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * page.select('select#colors', 'blue'); // single selection
     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
     * to query the page for
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first one
     * is taken into account.
     * @returns
     *
     * @remarks
     *
     * Shortcut for {@link Frame.select | page.mainFrame().select()}
     */
    select(selector, ...values) {
      return this.mainFrame().select(selector, ...values);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.touchscreen}
     * to tap in the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
     * to search for element to tap. If there are multiple elements satisfying the
     * selector, the first will be tapped.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
     */
    tap(selector) {
      return this.mainFrame().tap(selector);
    }
    /**
     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
     * in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
     * @example
     *
     * ```ts
     * await page.type('#mytextarea', 'Hello');
     * // Types instantly
     * await page.type('#mytextarea', 'World', {delay: 100});
     * // Types slower, like a user
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * of an element to type into. If there are multiple elements satisfying the
     * selector, the first will be used.
     * @param text - A text to type into a focused element.
     * @param options - have property `delay` which is the Time to wait between
     * key presses in milliseconds. Defaults to `0`.
     * @returns
     */
    type(selector, text, options) {
      return this.mainFrame().type(selector, text, options);
    }
    /**
     * Wait for the `selector` to appear in page. If at the moment of calling the
     * method the `selector` already exists, the method will return immediately. If
     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
     * function will throw.
     *
     * @example
     * This method works across navigations:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * of an element to wait for
     * @param options - Optional waiting parameters
     * @returns Promise which resolves when element specified by selector string
     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
     * selector is not found in DOM.
     *
     * @remarks
     * The optional Parameter in Arguments `options` are:
     *
     * - `visible`: A boolean wait for element to be present in DOM and to be
     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
     *   properties. Defaults to `false`.
     *
     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
     *   `false`.
     *
     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
     *   by using the {@link Page.setDefaultTimeout} method.
     */
    async waitForSelector(selector, options = {}) {
      return await this.mainFrame().waitForSelector(selector, options);
    }
    /**
     * Waits for the provided function, `pageFunction`, to return a truthy value when
     * evaluated in the page's context.
     *
     * @example
     * {@link Page.waitForFunction} can be used to observe a viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   const watchDog = page.waitForFunction('window.innerWidth < 100');
     *   await page.setViewport({width: 50, height: 50});
     *   await watchDog;
     *   await browser.close();
     * })();
     * ```
     *
     * @example
     * Arguments can be passed from Node.js to `pageFunction`:
     *
     * ```ts
     * const selector = '.foo';
     * await page.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {},
     *   selector
     * );
     * ```
     *
     * @example
     * The provided `pageFunction` can be asynchronous:
     *
     * ```ts
     * const username = 'github-username';
     * await page.waitForFunction(
     *   async username => {
     *     const githubResponse = await fetch(
     *       `https://api.github.com/users/${username}`
     *     );
     *     const githubUser = await githubResponse.json();
     *     // show the avatar
     *     const img = document.createElement('img');
     *     img.src = githubUser.avatar_url;
     *     // wait 3 seconds
     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
     *     img.remove();
     *   },
     *   {},
     *   username
     * );
     * ```
     *
     * @param pageFunction - Function to be evaluated in browser context until it returns a
     * truthy value.
     * @param options - Options for configuring waiting behavior.
     */
    waitForFunction(pageFunction, options, ...args) {
      return this.mainFrame().waitForFunction(pageFunction, options, ...args);
    }
    /** @internal */
    [(_screenshot_decorators = [guarded(function() {
      return this.browser();
    })], disposeSymbol)]() {
      return void this.close().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.close();
    }
  }, _requestHandlers = new WeakMap(), _inflight$ = new WeakMap(), _screencastSessionCount = new WeakMap(), _startScreencastPromise = new WeakMap(), _getNativePixelDimensions = new WeakSet(), getNativePixelDimensions_fn = async function() {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const viewport = this.viewport();
      const stack = __addDisposableResource$4(env_1, new DisposableStack(), false);
      if (viewport && viewport.deviceScaleFactor !== 0) {
        await this.setViewport({ ...viewport, deviceScaleFactor: 0 });
        stack.defer(() => {
          void this.setViewport(viewport).catch(debugError);
        });
      }
      return await this.mainFrame().isolatedRealm().evaluate(() => {
        return [
          window.visualViewport.width * window.devicePixelRatio,
          window.visualViewport.height * window.devicePixelRatio,
          window.devicePixelRatio
        ];
      });
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources$4(env_1);
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    __esDecorate$5(_a3, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3;
})();
function normalizeRectangle(clip) {
  return {
    ...clip,
    ...clip.width < 0 ? {
      x: clip.x + clip.width,
      width: -clip.width
    } : {
      x: clip.x,
      width: clip.width
    },
    ...clip.height < 0 ? {
      y: clip.y + clip.height,
      height: -clip.height
    } : {
      y: clip.y,
      height: clip.height
    }
  };
}
function roundRectangle(clip) {
  const x2 = Math.round(clip.x);
  const y2 = Math.round(clip.y);
  const width = Math.round(clip.width + clip.x - x2);
  const height = Math.round(clip.height + clip.y - y2);
  return { ...clip, x: x2, y: y2, width, height };
}
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class WaitTask {
  constructor(world, options, fn, ...args) {
    __privateAdd(this, _world, void 0);
    __privateAdd(this, _polling, void 0);
    __privateAdd(this, _root, void 0);
    __privateAdd(this, _fn, void 0);
    __privateAdd(this, _args, void 0);
    __privateAdd(this, _timeout, void 0);
    __privateAdd(this, _timeoutError2, void 0);
    __privateAdd(this, _result, Deferred.create());
    __privateAdd(this, _poller, void 0);
    __privateAdd(this, _signal, void 0);
    __privateAdd(this, _reruns, []);
    var _a3;
    __privateSet(this, _world, world);
    __privateSet(this, _polling, options.polling);
    __privateSet(this, _root, options.root);
    __privateSet(this, _signal, options.signal);
    (_a3 = __privateGet(this, _signal)) == null ? void 0 : _a3.addEventListener("abort", () => {
      var _a4;
      void this.terminate((_a4 = __privateGet(this, _signal)) == null ? void 0 : _a4.reason);
    }, {
      once: true
    });
    switch (typeof fn) {
      case "string":
        __privateSet(this, _fn, `() => {return (${fn});}`);
        break;
      default:
        __privateSet(this, _fn, stringifyFunction(fn));
        break;
    }
    __privateSet(this, _args, args);
    __privateGet(this, _world).taskManager.add(this);
    if (options.timeout) {
      __privateSet(this, _timeoutError2, new TimeoutError$1(`Waiting failed: ${options.timeout}ms exceeded`));
      __privateSet(this, _timeout, setTimeout(() => {
        void this.terminate(__privateGet(this, _timeoutError2));
      }, options.timeout));
    }
    void this.rerun();
  }
  get result() {
    return __privateGet(this, _result).valueOrThrow();
  }
  async rerun() {
    for (const prev of __privateGet(this, _reruns)) {
      prev.abort();
    }
    __privateGet(this, _reruns).length = 0;
    const controller = new AbortController();
    __privateGet(this, _reruns).push(controller);
    try {
      switch (__privateGet(this, _polling)) {
        case "raf":
          __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn, ...args) => {
            const fun = createFunction2(fn);
            return new RAFPoller(() => {
              return fun(...args);
            });
          }, LazyArg.create((context2) => {
            return context2.puppeteerUtil;
          }), __privateGet(this, _fn), ...__privateGet(this, _args)));
          break;
        case "mutation":
          __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root, fn, ...args) => {
            const fun = createFunction2(fn);
            return new MutationPoller(() => {
              return fun(...args);
            }, root || document);
          }, LazyArg.create((context2) => {
            return context2.puppeteerUtil;
          }), __privateGet(this, _root), __privateGet(this, _fn), ...__privateGet(this, _args)));
          break;
        default:
          __privateSet(this, _poller, await __privateGet(this, _world).evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms2, fn, ...args) => {
            const fun = createFunction2(fn);
            return new IntervalPoller(() => {
              return fun(...args);
            }, ms2);
          }, LazyArg.create((context2) => {
            return context2.puppeteerUtil;
          }), __privateGet(this, _polling), __privateGet(this, _fn), ...__privateGet(this, _args)));
          break;
      }
      await __privateGet(this, _poller).evaluate((poller) => {
        void poller.start();
      });
      const result = await __privateGet(this, _poller).evaluateHandle((poller) => {
        return poller.result();
      });
      __privateGet(this, _result).resolve(result);
      await this.terminate();
    } catch (error) {
      if (controller.signal.aborted) {
        return;
      }
      const badError = this.getBadError(error);
      if (badError) {
        await this.terminate(badError);
      }
    }
  }
  async terminate(error) {
    __privateGet(this, _world).taskManager.delete(this);
    clearTimeout(__privateGet(this, _timeout));
    if (error && !__privateGet(this, _result).finished()) {
      __privateGet(this, _result).reject(error);
    }
    if (__privateGet(this, _poller)) {
      try {
        await __privateGet(this, _poller).evaluateHandle(async (poller) => {
          await poller.stop();
        });
        if (__privateGet(this, _poller)) {
          await __privateGet(this, _poller).dispose();
          __privateSet(this, _poller, void 0);
        }
      } catch {
      }
    }
  }
  /**
   * Not all errors lead to termination. They usually imply we need to rerun the task.
   */
  getBadError(error) {
    if (isErrorLike$1(error)) {
      if (error.message.includes("Execution context is not available in detached frame")) {
        return new Error("Waiting failed: Frame detached");
      }
      if (error.message.includes("Execution context was destroyed")) {
        return;
      }
      if (error.message.includes("Cannot find context with specified id")) {
        return;
      }
      if (error.message.includes("AbortError: Actor 'MessageHandlerFrame' destroyed")) {
        return;
      }
      return error;
    }
    return new Error("WaitTask failed with an error", {
      cause: error
    });
  }
}
_world = new WeakMap();
_polling = new WeakMap();
_root = new WeakMap();
_fn = new WeakMap();
_args = new WeakMap();
_timeout = new WeakMap();
_timeoutError2 = new WeakMap();
_result = new WeakMap();
_poller = new WeakMap();
_signal = new WeakMap();
_reruns = new WeakMap();
class TaskManager {
  constructor() {
    __privateAdd(this, _tasks, /* @__PURE__ */ new Set());
  }
  add(task) {
    __privateGet(this, _tasks).add(task);
  }
  delete(task) {
    __privateGet(this, _tasks).delete(task);
  }
  terminateAll(error) {
    for (const task of __privateGet(this, _tasks)) {
      void task.terminate(error);
    }
    __privateGet(this, _tasks).clear();
  }
  async rerunAll() {
    await Promise.all([...__privateGet(this, _tasks)].map((task) => {
      return task.rerun();
    }));
  }
}
_tasks = new WeakMap();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Realm {
  constructor(timeoutSettings) {
    __publicField(this, "timeoutSettings");
    __publicField(this, "taskManager", new TaskManager());
    __privateAdd(this, _disposed3, false);
    this.timeoutSettings = timeoutSettings;
  }
  async waitForFunction(pageFunction, options = {}, ...args) {
    const { polling = "raf", timeout: timeout2 = this.timeoutSettings.timeout(), root, signal } = options;
    if (typeof polling === "number" && polling < 0) {
      throw new Error("Cannot poll with non-positive interval");
    }
    const waitTask = new WaitTask(this, {
      polling,
      root,
      timeout: timeout2,
      signal
    }, pageFunction, ...args);
    return await waitTask.result;
  }
  get disposed() {
    return __privateGet(this, _disposed3);
  }
  /** @internal */
  dispose() {
    __privateSet(this, _disposed3, true);
    this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
  }
  /** @internal */
  [disposeSymbol]() {
    this.dispose();
  }
}
_disposed3 = new WeakMap();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
exports.TargetType = void 0;
(function(TargetType) {
  TargetType["PAGE"] = "page";
  TargetType["BACKGROUND_PAGE"] = "background_page";
  TargetType["SERVICE_WORKER"] = "service_worker";
  TargetType["SHARED_WORKER"] = "shared_worker";
  TargetType["BROWSER"] = "browser";
  TargetType["WEBVIEW"] = "webview";
  TargetType["OTHER"] = "other";
  TargetType["TAB"] = "tab";
})(exports.TargetType || (exports.TargetType = {}));
class Target {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
   */
  async worker() {
    return null;
  }
  /**
   * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
   * returns `null`.
   */
  async page() {
    return null;
  }
}
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class WebWorker extends EventEmitter$2 {
  /**
   * @internal
   */
  constructor(url) {
    super();
    /**
     * @internal
     */
    __publicField(this, "timeoutSettings", new TimeoutSettings());
    __privateAdd(this, _url, void 0);
    __privateSet(this, _url, url);
  }
  /**
   * The URL of this web worker.
   */
  url() {
    return __privateGet(this, _url);
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * As a rule of thumb, if the return value of the given function is more
   * complicated than a JSON object (e.g. most classes), then
   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
   * value (or `{}`). This is because we are not returning the actual return
   * value, but a deserialized version as a result of transferring the return
   * value through a protocol to Puppeteer.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns The result of `func`.
   */
  async evaluate(func, ...args) {
    func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
    return await this.mainRealm().evaluate(func, ...args);
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns A {@link JSHandle | handle} to the return value of `func`.
   */
  async evaluateHandle(func, ...args) {
    func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
    return await this.mainRealm().evaluateHandle(func, ...args);
  }
  async close() {
    throw new UnsupportedOperation("WebWorker.close() is not supported");
  }
}
_url = new WeakMap();
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Accessibility {
  /**
   * @internal
   */
  constructor(client) {
    __privateAdd(this, _client, void 0);
    __privateSet(this, _client, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client, client);
  }
  /**
   * Captures the current state of the accessibility tree.
   * The returned object represents the root accessible node of the page.
   *
   * @remarks
   *
   * **NOTE** The Chrome accessibility tree contains nodes that go unused on
   * most platforms and by most screen readers. Puppeteer will discard them as
   * well for an easier to process tree, unless `interestingOnly` is set to
   * `false`.
   *
   * @example
   * An example of dumping the entire accessibility tree:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * console.log(snapshot);
   * ```
   *
   * @example
   * An example of logging the focused node's name:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * const node = findFocusedNode(snapshot);
   * console.log(node && node.name);
   *
   * function findFocusedNode(node) {
   *   if (node.focused) return node;
   *   for (const child of node.children || []) {
   *     const foundNode = findFocusedNode(child);
   *     return foundNode;
   *   }
   *   return null;
   * }
   * ```
   *
   * @returns An AXNode object representing the snapshot.
   */
  async snapshot(options = {}) {
    const { interestingOnly = true, root = null } = options;
    const { nodes } = await __privateGet(this, _client).send("Accessibility.getFullAXTree");
    let backendNodeId;
    if (root) {
      const { node: node2 } = await __privateGet(this, _client).send("DOM.describeNode", {
        objectId: root.id
      });
      backendNodeId = node2.backendNodeId;
    }
    const defaultRoot = AXNode.createTree(nodes);
    let needle = defaultRoot;
    if (backendNodeId) {
      needle = defaultRoot.find((node2) => {
        return node2.payload.backendDOMNodeId === backendNodeId;
      });
      if (!needle) {
        return null;
      }
    }
    if (!interestingOnly) {
      return this.serializeTree(needle)[0] ?? null;
    }
    const interestingNodes = /* @__PURE__ */ new Set();
    this.collectInterestingNodes(interestingNodes, defaultRoot, false);
    if (!interestingNodes.has(needle)) {
      return null;
    }
    return this.serializeTree(needle, interestingNodes)[0] ?? null;
  }
  serializeTree(node2, interestingNodes) {
    const children = [];
    for (const child of node2.children) {
      children.push(...this.serializeTree(child, interestingNodes));
    }
    if (interestingNodes && !interestingNodes.has(node2)) {
      return children;
    }
    const serializedNode = node2.serialize();
    if (children.length) {
      serializedNode.children = children;
    }
    return [serializedNode];
  }
  collectInterestingNodes(collection, node2, insideControl) {
    if (node2.isInteresting(insideControl)) {
      collection.add(node2);
    }
    if (node2.isLeafNode()) {
      return;
    }
    insideControl = insideControl || node2.isControl();
    for (const child of node2.children) {
      this.collectInterestingNodes(collection, child, insideControl);
    }
  }
}
_client = new WeakMap();
const _AXNode = class _AXNode {
  constructor(payload) {
    __privateAdd(this, _isPlainTextField);
    __privateAdd(this, _isTextOnlyObject);
    __privateAdd(this, _hasFocusableChild);
    __publicField(this, "payload");
    __publicField(this, "children", []);
    __privateAdd(this, _richlyEditable, false);
    __privateAdd(this, _editable, false);
    __privateAdd(this, _focusable, false);
    __privateAdd(this, _hidden, false);
    __privateAdd(this, _name, void 0);
    __privateAdd(this, _role, void 0);
    __privateAdd(this, _ignored, void 0);
    __privateAdd(this, _cachedHasFocusableChild, void 0);
    this.payload = payload;
    __privateSet(this, _name, this.payload.name ? this.payload.name.value : "");
    __privateSet(this, _role, this.payload.role ? this.payload.role.value : "Unknown");
    __privateSet(this, _ignored, this.payload.ignored);
    for (const property of this.payload.properties || []) {
      if (property.name === "editable") {
        __privateSet(this, _richlyEditable, property.value.value === "richtext");
        __privateSet(this, _editable, true);
      }
      if (property.name === "focusable") {
        __privateSet(this, _focusable, property.value.value);
      }
      if (property.name === "hidden") {
        __privateSet(this, _hidden, property.value.value);
      }
    }
  }
  find(predicate) {
    if (predicate(this)) {
      return this;
    }
    for (const child of this.children) {
      const result = child.find(predicate);
      if (result) {
        return result;
      }
    }
    return null;
  }
  isLeafNode() {
    if (!this.children.length) {
      return true;
    }
    if (__privateMethod(this, _isPlainTextField, isPlainTextField_fn).call(this) || __privateMethod(this, _isTextOnlyObject, isTextOnlyObject_fn).call(this)) {
      return true;
    }
    switch (__privateGet(this, _role)) {
      case "doc-cover":
      case "graphics-symbol":
      case "img":
      case "image":
      case "Meter":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
    }
    if (__privateMethod(this, _hasFocusableChild, hasFocusableChild_fn).call(this)) {
      return false;
    }
    if (__privateGet(this, _focusable) && __privateGet(this, _name)) {
      return true;
    }
    if (__privateGet(this, _role) === "heading" && __privateGet(this, _name)) {
      return true;
    }
    return false;
  }
  isControl() {
    switch (__privateGet(this, _role)) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "tree":
      case "treeitem":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    const role = __privateGet(this, _role);
    if (role === "Ignored" || __privateGet(this, _hidden) || __privateGet(this, _ignored)) {
      return false;
    }
    if (__privateGet(this, _focusable) || __privateGet(this, _richlyEditable)) {
      return true;
    }
    if (this.isControl()) {
      return true;
    }
    if (insideControl) {
      return false;
    }
    return this.isLeafNode() && !!__privateGet(this, _name);
  }
  serialize() {
    const properties = /* @__PURE__ */ new Map();
    for (const property of this.payload.properties || []) {
      properties.set(property.name.toLowerCase(), property.value.value);
    }
    if (this.payload.name) {
      properties.set("name", this.payload.name.value);
    }
    if (this.payload.value) {
      properties.set("value", this.payload.value.value);
    }
    if (this.payload.description) {
      properties.set("description", this.payload.description.value);
    }
    const node2 = {
      role: __privateGet(this, _role)
    };
    const userStringProperties = [
      "name",
      "value",
      "description",
      "keyshortcuts",
      "roledescription",
      "valuetext"
    ];
    const getUserStringPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const userStringProperty of userStringProperties) {
      if (!properties.has(userStringProperty)) {
        continue;
      }
      node2[userStringProperty] = getUserStringPropertyValue(userStringProperty);
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    const getBooleanPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && __privateGet(this, _role) === "RootWebArea") {
        continue;
      }
      const value = getBooleanPropertyValue(booleanProperty);
      if (!value) {
        continue;
      }
      node2[booleanProperty] = getBooleanPropertyValue(booleanProperty);
    }
    const tristateProperties = ["checked", "pressed"];
    for (const tristateProperty of tristateProperties) {
      if (!properties.has(tristateProperty)) {
        continue;
      }
      const value = properties.get(tristateProperty);
      node2[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    const getNumericalPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const numericalProperty of numericalProperties) {
      if (!properties.has(numericalProperty)) {
        continue;
      }
      node2[numericalProperty] = getNumericalPropertyValue(numericalProperty);
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid",
      "orientation"
    ];
    const getTokenPropertyValue = (key) => {
      return properties.get(key);
    };
    for (const tokenProperty of tokenProperties) {
      const value = getTokenPropertyValue(tokenProperty);
      if (!value || value === "false") {
        continue;
      }
      node2[tokenProperty] = getTokenPropertyValue(tokenProperty);
    }
    return node2;
  }
  static createTree(payloads) {
    const nodeById = /* @__PURE__ */ new Map();
    for (const payload of payloads) {
      nodeById.set(payload.nodeId, new _AXNode(payload));
    }
    for (const node2 of nodeById.values()) {
      for (const childId of node2.payload.childIds || []) {
        const child = nodeById.get(childId);
        if (child) {
          node2.children.push(child);
        }
      }
    }
    return nodeById.values().next().value;
  }
};
_richlyEditable = new WeakMap();
_editable = new WeakMap();
_focusable = new WeakMap();
_hidden = new WeakMap();
_name = new WeakMap();
_role = new WeakMap();
_ignored = new WeakMap();
_cachedHasFocusableChild = new WeakMap();
_isPlainTextField = new WeakSet();
isPlainTextField_fn = function() {
  if (__privateGet(this, _richlyEditable)) {
    return false;
  }
  if (__privateGet(this, _editable)) {
    return true;
  }
  return __privateGet(this, _role) === "textbox" || __privateGet(this, _role) === "searchbox";
};
_isTextOnlyObject = new WeakSet();
isTextOnlyObject_fn = function() {
  const role = __privateGet(this, _role);
  return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
};
_hasFocusableChild = new WeakSet();
hasFocusableChild_fn = function() {
  var _a3;
  if (__privateGet(this, _cachedHasFocusableChild) === void 0) {
    __privateSet(this, _cachedHasFocusableChild, false);
    for (const child of this.children) {
      if (__privateGet(child, _focusable) || __privateMethod(_a3 = child, _hasFocusableChild, hasFocusableChild_fn).call(_a3)) {
        __privateSet(this, _cachedHasFocusableChild, true);
        break;
      }
    }
  }
  return __privateGet(this, _cachedHasFocusableChild);
};
let AXNode = _AXNode;
var __addDisposableResource$3 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$3 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
class Binding {
  constructor(name2, fn) {
    __privateAdd(this, _name2, void 0);
    __privateAdd(this, _fn2, void 0);
    __privateSet(this, _name2, name2);
    __privateSet(this, _fn2, fn);
  }
  get name() {
    return __privateGet(this, _name2);
  }
  /**
   * @param context - Context to run the binding in; the context should have
   * the binding added to it beforehand.
   * @param id - ID of the call. This should come from the CDP
   * `onBindingCalled` response.
   * @param args - Plain arguments from CDP.
   */
  async run(context2, id, args, isTrivial) {
    const stack = new DisposableStack();
    try {
      if (!isTrivial) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handles = __addDisposableResource$3(env_1, await context2.evaluateHandle((name2, seq) => {
            return globalThis[name2].args.get(seq);
          }, __privateGet(this, _name2), id), false);
          const properties = await handles.getProperties();
          for (const [index2, handle] of properties) {
            if (index2 in args) {
              switch (handle.remoteObject().subtype) {
                case "node":
                  args[+index2] = handle;
                  break;
                default:
                  stack.use(handle);
              }
            } else {
              stack.use(handle);
            }
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources$3(env_1);
        }
      }
      await context2.evaluate((name2, seq, result) => {
        const callbacks = globalThis[name2].callbacks;
        callbacks.get(seq).resolve(result);
        callbacks.delete(seq);
      }, __privateGet(this, _name2), id, await __privateGet(this, _fn2).call(this, ...args));
      for (const arg of args) {
        if (arg instanceof JSHandle) {
          stack.use(arg);
        }
      }
    } catch (error) {
      if (isErrorLike$1(error)) {
        await context2.evaluate((name2, seq, message2, stack2) => {
          const error2 = new Error(message2);
          error2.stack = stack2;
          const callbacks = globalThis[name2].callbacks;
          callbacks.get(seq).reject(error2);
          callbacks.delete(seq);
        }, __privateGet(this, _name2), id, error.message, error.stack).catch(debugError);
      } else {
        await context2.evaluate((name2, seq, error2) => {
          const callbacks = globalThis[name2].callbacks;
          callbacks.get(seq).reject(error2);
          callbacks.delete(seq);
        }, __privateGet(this, _name2), id, error).catch(debugError);
      }
    }
  }
}
_name2 = new WeakMap();
_fn2 = new WeakMap();
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpBrowserContext extends BrowserContext {
  constructor(connection, browser2, contextId) {
    super();
    __privateAdd(this, _connection, void 0);
    __privateAdd(this, _browser, void 0);
    __privateAdd(this, _id, void 0);
    __privateSet(this, _connection, connection);
    __privateSet(this, _browser, browser2);
    __privateSet(this, _id, contextId);
  }
  get id() {
    return __privateGet(this, _id);
  }
  targets() {
    return __privateGet(this, _browser).targets().filter((target) => {
      return target.browserContext() === this;
    });
  }
  async pages() {
    const pages = await Promise.all(this.targets().filter((target) => {
      var _a3;
      return target.type() === "page" || target.type() === "other" && ((_a3 = __privateGet(this, _browser)._getIsPageTargetCallback()) == null ? void 0 : _a3(target));
    }).map((target) => {
      return target.page();
    }));
    return pages.filter((page) => {
      return !!page;
    });
  }
  isIncognito() {
    return !!__privateGet(this, _id);
  }
  async overridePermissions(origin, permissions) {
    const protocolPermissions = permissions.map((permission) => {
      const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
      if (!protocolPermission) {
        throw new Error("Unknown permission: " + permission);
      }
      return protocolPermission;
    });
    await __privateGet(this, _connection).send("Browser.grantPermissions", {
      origin,
      browserContextId: __privateGet(this, _id) || void 0,
      permissions: protocolPermissions
    });
  }
  async clearPermissionOverrides() {
    await __privateGet(this, _connection).send("Browser.resetPermissions", {
      browserContextId: __privateGet(this, _id) || void 0
    });
  }
  newPage() {
    return __privateGet(this, _browser)._createPageInContext(__privateGet(this, _id));
  }
  browser() {
    return __privateGet(this, _browser);
  }
  async close() {
    assert$1(__privateGet(this, _id), "Non-incognito profiles cannot be closed!");
    await __privateGet(this, _browser)._disposeContext(__privateGet(this, _id));
  }
}
_connection = new WeakMap();
_browser = new WeakMap();
_id = new WeakMap();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CallbackRegistry {
  constructor() {
    __privateAdd(this, _callbacks, /* @__PURE__ */ new Map());
    __privateAdd(this, _idGenerator, createIncrementalIdGenerator());
  }
  create(label, timeout2, request) {
    const callback = new Callback(__privateGet(this, _idGenerator).call(this), label, timeout2);
    __privateGet(this, _callbacks).set(callback.id, callback);
    try {
      request(callback.id);
    } catch (error) {
      callback.promise.catch(debugError).finally(() => {
        __privateGet(this, _callbacks).delete(callback.id);
      });
      callback.reject(error);
      throw error;
    }
    return callback.promise.finally(() => {
      __privateGet(this, _callbacks).delete(callback.id);
    });
  }
  reject(id, message2, originalMessage) {
    const callback = __privateGet(this, _callbacks).get(id);
    if (!callback) {
      return;
    }
    this._reject(callback, message2, originalMessage);
  }
  _reject(callback, errorMessage, originalMessage) {
    let error;
    let message2;
    if (errorMessage instanceof ProtocolError) {
      error = errorMessage;
      error.cause = callback.error;
      message2 = errorMessage.message;
    } else {
      error = callback.error;
      message2 = errorMessage;
    }
    callback.reject(rewriteError$1(error, `Protocol error (${callback.label}): ${message2}`, originalMessage));
  }
  resolve(id, value) {
    const callback = __privateGet(this, _callbacks).get(id);
    if (!callback) {
      return;
    }
    callback.resolve(value);
  }
  clear() {
    for (const callback of __privateGet(this, _callbacks).values()) {
      this._reject(callback, new TargetCloseError("Target closed"));
    }
    __privateGet(this, _callbacks).clear();
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const result = [];
    for (const callback of __privateGet(this, _callbacks).values()) {
      result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
    }
    return result;
  }
}
_callbacks = new WeakMap();
_idGenerator = new WeakMap();
class Callback {
  constructor(id, label, timeout2) {
    __privateAdd(this, _id2, void 0);
    __privateAdd(this, _error, new ProtocolError());
    __privateAdd(this, _deferred, Deferred.create());
    __privateAdd(this, _timer, void 0);
    __privateAdd(this, _label, void 0);
    __privateSet(this, _id2, id);
    __privateSet(this, _label, label);
    if (timeout2) {
      __privateSet(this, _timer, setTimeout(() => {
        __privateGet(this, _deferred).reject(rewriteError$1(__privateGet(this, _error), `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
      }, timeout2));
    }
  }
  resolve(value) {
    clearTimeout(__privateGet(this, _timer));
    __privateGet(this, _deferred).resolve(value);
  }
  reject(error) {
    clearTimeout(__privateGet(this, _timer));
    __privateGet(this, _deferred).reject(error);
  }
  get id() {
    return __privateGet(this, _id2);
  }
  get promise() {
    return __privateGet(this, _deferred).valueOrThrow();
  }
  get error() {
    return __privateGet(this, _error);
  }
  get label() {
    return __privateGet(this, _label);
  }
}
_id2 = new WeakMap();
_error = new WeakMap();
_deferred = new WeakMap();
_timer = new WeakMap();
_label = new WeakMap();
function createIncrementalIdGenerator() {
  let id = 0;
  return () => {
    return ++id;
  };
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpCDPSession extends CDPSession {
  /**
   * @internal
   */
  constructor(connection, targetType, sessionId, parentSessionId) {
    super();
    __privateAdd(this, _sessionId, void 0);
    __privateAdd(this, _targetType, void 0);
    __privateAdd(this, _callbacks2, new CallbackRegistry());
    __privateAdd(this, _connection2, void 0);
    __privateAdd(this, _parentSessionId, void 0);
    __privateAdd(this, _target2, void 0);
    __privateSet(this, _connection2, connection);
    __privateSet(this, _targetType, targetType);
    __privateSet(this, _sessionId, sessionId);
    __privateSet(this, _parentSessionId, parentSessionId);
  }
  /**
   * Sets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  _setTarget(target) {
    __privateSet(this, _target2, target);
  }
  /**
   * Gets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  _target() {
    assert$1(__privateGet(this, _target2), "Target must exist");
    return __privateGet(this, _target2);
  }
  connection() {
    return __privateGet(this, _connection2);
  }
  parentSession() {
    var _a3;
    if (!__privateGet(this, _parentSessionId)) {
      return this;
    }
    const parent = (_a3 = __privateGet(this, _connection2)) == null ? void 0 : _a3.session(__privateGet(this, _parentSessionId));
    return parent ?? void 0;
  }
  send(method, params, options) {
    if (!__privateGet(this, _connection2)) {
      return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${__privateGet(this, _targetType)} has been closed.`));
    }
    return __privateGet(this, _connection2)._rawSend(__privateGet(this, _callbacks2), method, params, __privateGet(this, _sessionId), options);
  }
  /**
   * @internal
   */
  _onMessage(object) {
    if (object.id) {
      if (object.error) {
        __privateGet(this, _callbacks2).reject(object.id, createProtocolErrorMessage(object), object.error.message);
      } else {
        __privateGet(this, _callbacks2).resolve(object.id, object.result);
      }
    } else {
      assert$1(!object.id);
      this.emit(object.method, object.params);
    }
  }
  /**
   * Detaches the cdpSession from the target. Once detached, the cdpSession object
   * won't emit any events and can't be used to send messages.
   */
  async detach() {
    if (!__privateGet(this, _connection2)) {
      throw new Error(`Session already detached. Most likely the ${__privateGet(this, _targetType)} has been closed.`);
    }
    await __privateGet(this, _connection2).send("Target.detachFromTarget", {
      sessionId: __privateGet(this, _sessionId)
    });
  }
  /**
   * @internal
   */
  _onClosed() {
    __privateGet(this, _callbacks2).clear();
    __privateSet(this, _connection2, void 0);
    this.emit(CDPSessionEvent.Disconnected, void 0);
  }
  /**
   * Returns the session's id.
   */
  id() {
    return __privateGet(this, _sessionId);
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    return __privateGet(this, _callbacks2).getPendingProtocolErrors();
  }
}
_sessionId = new WeakMap();
_targetType = new WeakMap();
_callbacks2 = new WeakMap();
_connection2 = new WeakMap();
_parentSessionId = new WeakMap();
_target2 = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ConsoleMessage {
  /**
   * @public
   */
  constructor(type, text, args, stackTraceLocations) {
    __privateAdd(this, _type3, void 0);
    __privateAdd(this, _text, void 0);
    __privateAdd(this, _args2, void 0);
    __privateAdd(this, _stackTraceLocations, void 0);
    __privateSet(this, _type3, type);
    __privateSet(this, _text, text);
    __privateSet(this, _args2, args);
    __privateSet(this, _stackTraceLocations, stackTraceLocations);
  }
  /**
   * The type of the console message.
   */
  type() {
    return __privateGet(this, _type3);
  }
  /**
   * The text of the console message.
   */
  text() {
    return __privateGet(this, _text);
  }
  /**
   * An array of arguments passed to the console.
   */
  args() {
    return __privateGet(this, _args2);
  }
  /**
   * The location of the console message.
   */
  location() {
    return __privateGet(this, _stackTraceLocations)[0] ?? {};
  }
  /**
   * The array of locations on the stack of the console message.
   */
  stackTrace() {
    return __privateGet(this, _stackTraceLocations);
  }
}
_type3 = new WeakMap();
_text = new WeakMap();
_args2 = new WeakMap();
_stackTraceLocations = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class FileChooser {
  /**
   * @internal
   */
  constructor(element, event) {
    __privateAdd(this, _element, void 0);
    __privateAdd(this, _multiple, void 0);
    __privateAdd(this, _handled2, false);
    __privateSet(this, _element, element);
    __privateSet(this, _multiple, event.mode !== "selectSingle");
  }
  /**
   * Whether file chooser allow for
   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
   * file selection.
   */
  isMultiple() {
    return __privateGet(this, _multiple);
  }
  /**
   * Accept the file chooser request with the given file paths.
   *
   * @remarks This will not validate whether the file paths exists. Also, if a
   * path is relative, then it is resolved against the
   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
   * For locals script connecting to remote chrome environments, paths must be
   * absolute.
   */
  async accept(paths) {
    assert$1(!__privateGet(this, _handled2), "Cannot accept FileChooser which is already handled!");
    __privateSet(this, _handled2, true);
    await __privateGet(this, _element).uploadFile(...paths);
  }
  /**
   * Closes the file chooser without selecting any files.
   */
  async cancel() {
    assert$1(!__privateGet(this, _handled2), "Cannot cancel FileChooser which is already handled!");
    __privateSet(this, _handled2, true);
    await __privateGet(this, _element).evaluate((element) => {
      element.dispatchEvent(new Event("cancel", { bubbles: true }));
    });
  }
}
_element = new WeakMap();
_multiple = new WeakMap();
_handled2 = new WeakMap();
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var NetworkManagerEvent;
(function(NetworkManagerEvent2) {
  NetworkManagerEvent2.Request = Symbol("NetworkManager.Request");
  NetworkManagerEvent2.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache");
  NetworkManagerEvent2.Response = Symbol("NetworkManager.Response");
  NetworkManagerEvent2.RequestFailed = Symbol("NetworkManager.RequestFailed");
  NetworkManagerEvent2.RequestFinished = Symbol("NetworkManager.RequestFinished");
})(NetworkManagerEvent || (NetworkManagerEvent = {}));
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugProtocolSend = debug$g("puppeteer:protocol:SEND ");
const debugProtocolReceive = debug$g("puppeteer:protocol:RECV ");
class Connection extends EventEmitter$2 {
  constructor(url, transport, delay = 0, timeout2) {
    super();
    __privateAdd(this, _onClose);
    __privateAdd(this, _url2, void 0);
    __privateAdd(this, _transport, void 0);
    __privateAdd(this, _delay, void 0);
    __privateAdd(this, _timeout2, void 0);
    __privateAdd(this, _sessions, /* @__PURE__ */ new Map());
    __privateAdd(this, _closed, false);
    __privateAdd(this, _manuallyAttached, /* @__PURE__ */ new Set());
    __privateAdd(this, _callbacks3, new CallbackRegistry());
    __privateSet(this, _url2, url);
    __privateSet(this, _delay, delay);
    __privateSet(this, _timeout2, timeout2 ?? 18e4);
    __privateSet(this, _transport, transport);
    __privateGet(this, _transport).onmessage = this.onMessage.bind(this);
    __privateGet(this, _transport).onclose = __privateMethod(this, _onClose, onClose_fn).bind(this);
  }
  static fromSession(session) {
    return session.connection();
  }
  /**
   * @internal
   */
  get delay() {
    return __privateGet(this, _delay);
  }
  get timeout() {
    return __privateGet(this, _timeout2);
  }
  /**
   * @internal
   */
  get _closed() {
    return __privateGet(this, _closed);
  }
  /**
   * @internal
   */
  get _sessions() {
    return __privateGet(this, _sessions);
  }
  /**
   * @param sessionId - The session id
   * @returns The current CDP session if it exists
   */
  session(sessionId) {
    return __privateGet(this, _sessions).get(sessionId) || null;
  }
  url() {
    return __privateGet(this, _url2);
  }
  send(method, params, options) {
    return this._rawSend(__privateGet(this, _callbacks3), method, params, void 0, options);
  }
  /**
   * @internal
   */
  _rawSend(callbacks, method, params, sessionId, options) {
    assert$1(!__privateGet(this, _closed), "Protocol error: Connection closed.");
    return callbacks.create(method, (options == null ? void 0 : options.timeout) ?? __privateGet(this, _timeout2), (id) => {
      const stringifiedMessage = JSON.stringify({
        method,
        params,
        id,
        sessionId
      });
      debugProtocolSend(stringifiedMessage);
      __privateGet(this, _transport).send(stringifiedMessage);
    });
  }
  /**
   * @internal
   */
  async closeBrowser() {
    await this.send("Browser.close");
  }
  /**
   * @internal
   */
  async onMessage(message2) {
    if (__privateGet(this, _delay)) {
      await new Promise((r2) => {
        return setTimeout(r2, __privateGet(this, _delay));
      });
    }
    debugProtocolReceive(message2);
    const object = JSON.parse(message2);
    if (object.method === "Target.attachedToTarget") {
      const sessionId = object.params.sessionId;
      const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId);
      __privateGet(this, _sessions).set(sessionId, session);
      this.emit(CDPSessionEvent.SessionAttached, session);
      const parentSession = __privateGet(this, _sessions).get(object.sessionId);
      if (parentSession) {
        parentSession.emit(CDPSessionEvent.SessionAttached, session);
      }
    } else if (object.method === "Target.detachedFromTarget") {
      const session = __privateGet(this, _sessions).get(object.params.sessionId);
      if (session) {
        session._onClosed();
        __privateGet(this, _sessions).delete(object.params.sessionId);
        this.emit(CDPSessionEvent.SessionDetached, session);
        const parentSession = __privateGet(this, _sessions).get(object.sessionId);
        if (parentSession) {
          parentSession.emit(CDPSessionEvent.SessionDetached, session);
        }
      }
    }
    if (object.sessionId) {
      const session = __privateGet(this, _sessions).get(object.sessionId);
      if (session) {
        session._onMessage(object);
      }
    } else if (object.id) {
      if (object.error) {
        __privateGet(this, _callbacks3).reject(object.id, createProtocolErrorMessage(object), object.error.message);
      } else {
        __privateGet(this, _callbacks3).resolve(object.id, object.result);
      }
    } else {
      this.emit(object.method, object.params);
    }
  }
  dispose() {
    __privateMethod(this, _onClose, onClose_fn).call(this);
    __privateGet(this, _transport).close();
  }
  /**
   * @internal
   */
  isAutoAttached(targetId) {
    return !__privateGet(this, _manuallyAttached).has(targetId);
  }
  /**
   * @internal
   */
  async _createSession(targetInfo, isAutoAttachEmulated = true) {
    if (!isAutoAttachEmulated) {
      __privateGet(this, _manuallyAttached).add(targetInfo.targetId);
    }
    const { sessionId } = await this.send("Target.attachToTarget", {
      targetId: targetInfo.targetId,
      flatten: true
    });
    __privateGet(this, _manuallyAttached).delete(targetInfo.targetId);
    const session = __privateGet(this, _sessions).get(sessionId);
    if (!session) {
      throw new Error("CDPSession creation failed.");
    }
    return session;
  }
  /**
   * @param targetInfo - The target info
   * @returns The CDP session that is created
   */
  async createSession(targetInfo) {
    return await this._createSession(targetInfo, false);
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const result = [];
    result.push(...__privateGet(this, _callbacks3).getPendingProtocolErrors());
    for (const session of __privateGet(this, _sessions).values()) {
      result.push(...session.getPendingProtocolErrors());
    }
    return result;
  }
}
_url2 = new WeakMap();
_transport = new WeakMap();
_delay = new WeakMap();
_timeout2 = new WeakMap();
_sessions = new WeakMap();
_closed = new WeakMap();
_manuallyAttached = new WeakMap();
_callbacks3 = new WeakMap();
_onClose = new WeakSet();
onClose_fn = function() {
  if (__privateGet(this, _closed)) {
    return;
  }
  __privateSet(this, _closed, true);
  __privateGet(this, _transport).onmessage = void 0;
  __privateGet(this, _transport).onclose = void 0;
  __privateGet(this, _callbacks3).clear();
  for (const session of __privateGet(this, _sessions).values()) {
    session._onClosed();
  }
  __privateGet(this, _sessions).clear();
  this.emit(CDPSessionEvent.Disconnected, void 0);
};
function isTargetClosedError(error) {
  return error instanceof TargetCloseError;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Coverage {
  constructor(client) {
    __privateAdd(this, _jsCoverage, void 0);
    __privateAdd(this, _cssCoverage, void 0);
    __privateSet(this, _jsCoverage, new JSCoverage(client));
    __privateSet(this, _cssCoverage, new CSSCoverage(client));
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateGet(this, _jsCoverage).updateClient(client);
    __privateGet(this, _cssCoverage).updateClient(client);
  }
  /**
   * @param options - Set of configurable options for coverage defaults to
   * `resetOnNavigation : true, reportAnonymousScripts : false,`
   * `includeRawScriptCoverage : false, useBlockCoverage : true`
   * @returns Promise that resolves when coverage is started.
   *
   * @remarks
   * Anonymous scripts are ones that don't have an associated url. These are
   * scripts that are dynamically created on the page using `eval` or
   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
   * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
   * comment is present, in which case that will the be URL).
   */
  async startJSCoverage(options = {}) {
    return await __privateGet(this, _jsCoverage).start(options);
  }
  /**
   * Promise that resolves to the array of coverage reports for
   * all scripts.
   *
   * @remarks
   * JavaScript Coverage doesn't include anonymous scripts by default.
   * However, scripts with sourceURLs are reported.
   */
  async stopJSCoverage() {
    return await __privateGet(this, _jsCoverage).stop();
  }
  /**
   * @param options - Set of configurable options for coverage, defaults to
   * `resetOnNavigation : true`
   * @returns Promise that resolves when coverage is started.
   */
  async startCSSCoverage(options = {}) {
    return await __privateGet(this, _cssCoverage).start(options);
  }
  /**
   * Promise that resolves to the array of coverage reports
   * for all stylesheets.
   *
   * @remarks
   * CSS Coverage doesn't include dynamically injected style tags
   * without sourceURLs.
   */
  async stopCSSCoverage() {
    return await __privateGet(this, _cssCoverage).stop();
  }
}
_jsCoverage = new WeakMap();
_cssCoverage = new WeakMap();
class JSCoverage {
  constructor(client) {
    __privateAdd(this, _onExecutionContextsCleared);
    __privateAdd(this, _onScriptParsed);
    __privateAdd(this, _client2, void 0);
    __privateAdd(this, _enabled, false);
    __privateAdd(this, _scriptURLs, /* @__PURE__ */ new Map());
    __privateAdd(this, _scriptSources, /* @__PURE__ */ new Map());
    __privateAdd(this, _subscriptions, void 0);
    __privateAdd(this, _resetOnNavigation, false);
    __privateAdd(this, _reportAnonymousScripts, false);
    __privateAdd(this, _includeRawScriptCoverage, false);
    __privateSet(this, _client2, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client2, client);
  }
  async start(options = {}) {
    assert$1(!__privateGet(this, _enabled), "JSCoverage is already enabled");
    const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
    __privateSet(this, _resetOnNavigation, resetOnNavigation);
    __privateSet(this, _reportAnonymousScripts, reportAnonymousScripts);
    __privateSet(this, _includeRawScriptCoverage, includeRawScriptCoverage);
    __privateSet(this, _enabled, true);
    __privateGet(this, _scriptURLs).clear();
    __privateGet(this, _scriptSources).clear();
    __privateSet(this, _subscriptions, new DisposableStack());
    const clientEmitter = __privateGet(this, _subscriptions).use(new EventEmitter$2(__privateGet(this, _client2)));
    clientEmitter.on("Debugger.scriptParsed", __privateMethod(this, _onScriptParsed, onScriptParsed_fn).bind(this));
    clientEmitter.on("Runtime.executionContextsCleared", __privateMethod(this, _onExecutionContextsCleared, onExecutionContextsCleared_fn).bind(this));
    await Promise.all([
      __privateGet(this, _client2).send("Profiler.enable"),
      __privateGet(this, _client2).send("Profiler.startPreciseCoverage", {
        callCount: __privateGet(this, _includeRawScriptCoverage),
        detailed: useBlockCoverage
      }),
      __privateGet(this, _client2).send("Debugger.enable"),
      __privateGet(this, _client2).send("Debugger.setSkipAllPauses", { skip: true })
    ]);
  }
  async stop() {
    var _a3;
    assert$1(__privateGet(this, _enabled), "JSCoverage is not enabled");
    __privateSet(this, _enabled, false);
    const result = await Promise.all([
      __privateGet(this, _client2).send("Profiler.takePreciseCoverage"),
      __privateGet(this, _client2).send("Profiler.stopPreciseCoverage"),
      __privateGet(this, _client2).send("Profiler.disable"),
      __privateGet(this, _client2).send("Debugger.disable")
    ]);
    (_a3 = __privateGet(this, _subscriptions)) == null ? void 0 : _a3.dispose();
    const coverage = [];
    const profileResponse = result[0];
    for (const entry of profileResponse.result) {
      let url = __privateGet(this, _scriptURLs).get(entry.scriptId);
      if (!url && __privateGet(this, _reportAnonymousScripts)) {
        url = "debugger://VM" + entry.scriptId;
      }
      const text = __privateGet(this, _scriptSources).get(entry.scriptId);
      if (text === void 0 || url === void 0) {
        continue;
      }
      const flattenRanges = [];
      for (const func of entry.functions) {
        flattenRanges.push(...func.ranges);
      }
      const ranges = convertToDisjointRanges(flattenRanges);
      if (!__privateGet(this, _includeRawScriptCoverage)) {
        coverage.push({ url, ranges, text });
      } else {
        coverage.push({ url, ranges, text, rawScriptCoverage: entry });
      }
    }
    return coverage;
  }
}
_client2 = new WeakMap();
_enabled = new WeakMap();
_scriptURLs = new WeakMap();
_scriptSources = new WeakMap();
_subscriptions = new WeakMap();
_resetOnNavigation = new WeakMap();
_reportAnonymousScripts = new WeakMap();
_includeRawScriptCoverage = new WeakMap();
_onExecutionContextsCleared = new WeakSet();
onExecutionContextsCleared_fn = function() {
  if (!__privateGet(this, _resetOnNavigation)) {
    return;
  }
  __privateGet(this, _scriptURLs).clear();
  __privateGet(this, _scriptSources).clear();
};
_onScriptParsed = new WeakSet();
onScriptParsed_fn = async function(event) {
  if (PuppeteerURL.isPuppeteerURL(event.url)) {
    return;
  }
  if (!event.url && !__privateGet(this, _reportAnonymousScripts)) {
    return;
  }
  try {
    const response = await __privateGet(this, _client2).send("Debugger.getScriptSource", {
      scriptId: event.scriptId
    });
    __privateGet(this, _scriptURLs).set(event.scriptId, event.url);
    __privateGet(this, _scriptSources).set(event.scriptId, response.scriptSource);
  } catch (error) {
    debugError(error);
  }
};
class CSSCoverage {
  constructor(client) {
    __privateAdd(this, _onExecutionContextsCleared2);
    __privateAdd(this, _onStyleSheet);
    __privateAdd(this, _client3, void 0);
    __privateAdd(this, _enabled2, false);
    __privateAdd(this, _stylesheetURLs, /* @__PURE__ */ new Map());
    __privateAdd(this, _stylesheetSources, /* @__PURE__ */ new Map());
    __privateAdd(this, _eventListeners, void 0);
    __privateAdd(this, _resetOnNavigation2, false);
    __privateSet(this, _client3, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client3, client);
  }
  async start(options = {}) {
    assert$1(!__privateGet(this, _enabled2), "CSSCoverage is already enabled");
    const { resetOnNavigation = true } = options;
    __privateSet(this, _resetOnNavigation2, resetOnNavigation);
    __privateSet(this, _enabled2, true);
    __privateGet(this, _stylesheetURLs).clear();
    __privateGet(this, _stylesheetSources).clear();
    __privateSet(this, _eventListeners, new DisposableStack());
    const clientEmitter = __privateGet(this, _eventListeners).use(new EventEmitter$2(__privateGet(this, _client3)));
    clientEmitter.on("CSS.styleSheetAdded", __privateMethod(this, _onStyleSheet, onStyleSheet_fn).bind(this));
    clientEmitter.on("Runtime.executionContextsCleared", __privateMethod(this, _onExecutionContextsCleared2, onExecutionContextsCleared_fn2).bind(this));
    await Promise.all([
      __privateGet(this, _client3).send("DOM.enable"),
      __privateGet(this, _client3).send("CSS.enable"),
      __privateGet(this, _client3).send("CSS.startRuleUsageTracking")
    ]);
  }
  async stop() {
    var _a3;
    assert$1(__privateGet(this, _enabled2), "CSSCoverage is not enabled");
    __privateSet(this, _enabled2, false);
    const ruleTrackingResponse = await __privateGet(this, _client3).send("CSS.stopRuleUsageTracking");
    await Promise.all([
      __privateGet(this, _client3).send("CSS.disable"),
      __privateGet(this, _client3).send("DOM.disable")
    ]);
    (_a3 = __privateGet(this, _eventListeners)) == null ? void 0 : _a3.dispose();
    const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
    for (const entry of ruleTrackingResponse.ruleUsage) {
      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
      if (!ranges) {
        ranges = [];
        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
      }
      ranges.push({
        startOffset: entry.startOffset,
        endOffset: entry.endOffset,
        count: entry.used ? 1 : 0
      });
    }
    const coverage = [];
    for (const styleSheetId of __privateGet(this, _stylesheetURLs).keys()) {
      const url = __privateGet(this, _stylesheetURLs).get(styleSheetId);
      assert$1(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
      const text = __privateGet(this, _stylesheetSources).get(styleSheetId);
      assert$1(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
      coverage.push({ url, ranges, text });
    }
    return coverage;
  }
}
_client3 = new WeakMap();
_enabled2 = new WeakMap();
_stylesheetURLs = new WeakMap();
_stylesheetSources = new WeakMap();
_eventListeners = new WeakMap();
_resetOnNavigation2 = new WeakMap();
_onExecutionContextsCleared2 = new WeakSet();
onExecutionContextsCleared_fn2 = function() {
  if (!__privateGet(this, _resetOnNavigation2)) {
    return;
  }
  __privateGet(this, _stylesheetURLs).clear();
  __privateGet(this, _stylesheetSources).clear();
};
_onStyleSheet = new WeakSet();
onStyleSheet_fn = async function(event) {
  const header = event.header;
  if (!header.sourceURL) {
    return;
  }
  try {
    const response = await __privateGet(this, _client3).send("CSS.getStyleSheetText", {
      styleSheetId: header.styleSheetId
    });
    __privateGet(this, _stylesheetURLs).set(header.styleSheetId, header.sourceURL);
    __privateGet(this, _stylesheetSources).set(header.styleSheetId, response.text);
  } catch (error) {
    debugError(error);
  }
};
function convertToDisjointRanges(nestedRanges) {
  const points = [];
  for (const range2 of nestedRanges) {
    points.push({ offset: range2.startOffset, type: 0, range: range2 });
    points.push({ offset: range2.endOffset, type: 1, range: range2 });
  }
  points.sort((a2, b2) => {
    if (a2.offset !== b2.offset) {
      return a2.offset - b2.offset;
    }
    if (a2.type !== b2.type) {
      return b2.type - a2.type;
    }
    const aLength = a2.range.endOffset - a2.range.startOffset;
    const bLength = b2.range.endOffset - b2.range.startOffset;
    if (a2.type === 0) {
      return bLength - aLength;
    }
    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0;
  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results[results.length - 1];
      if (lastResult && lastResult.end === lastOffset) {
        lastResult.end = point.offset;
      } else {
        results.push({ start: lastOffset, end: point.offset });
      }
    }
    lastOffset = point.offset;
    if (point.type === 0) {
      hitCountStack.push(point.range.count);
    } else {
      hitCountStack.pop();
    }
  }
  return results.filter((range2) => {
    return range2.end - range2.start > 0;
  });
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpDialog extends Dialog {
  constructor(client, type, message2, defaultValue = "") {
    super(type, message2, defaultValue);
    __privateAdd(this, _client4, void 0);
    __privateSet(this, _client4, client);
  }
  async handle(options) {
    await __privateGet(this, _client4).send("Page.handleJavaScriptDialog", {
      accept: options.accept,
      promptText: options.text
    });
  }
}
_client4 = new WeakMap();
var __runInitializers$4 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate$4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __setFunctionName$2 = function(f2, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
};
class EmulatedState {
  constructor(initialState, clientProvider, updater) {
    __privateAdd(this, _state, void 0);
    __privateAdd(this, _clientProvider, void 0);
    __privateAdd(this, _updater, void 0);
    __privateSet(this, _state, initialState);
    __privateSet(this, _clientProvider, clientProvider);
    __privateSet(this, _updater, updater);
    __privateGet(this, _clientProvider).registerState(this);
  }
  async setState(state) {
    __privateSet(this, _state, state);
    await this.sync();
  }
  get state() {
    return __privateGet(this, _state);
  }
  async sync() {
    await Promise.all(__privateGet(this, _clientProvider).clients().map((client) => {
      return __privateGet(this, _updater).call(this, client, __privateGet(this, _state));
    }));
  }
}
_state = new WeakMap();
_clientProvider = new WeakMap();
_updater = new WeakMap();
let EmulationManager = (() => {
  var _client16, _emulatingMobile, _hasTouch, _states, _viewportState, _idleOverridesState, _timezoneState, _visionDeficiencyState, _cpuThrottlingState, _mediaFeaturesState, _mediaTypeState, _geoLocationState, _defaultBackgroundColorState, _javascriptEnabledState, _secondaryClients, _applyViewport, applyViewport_get, _emulateIdleState, emulateIdleState_get, _emulateTimezone, emulateTimezone_get, _emulateVisionDeficiency, emulateVisionDeficiency_get, _emulateCpuThrottling, emulateCpuThrottling_get, _emulateMediaFeatures, emulateMediaFeatures_get, _emulateMediaType, emulateMediaType_get, _setGeolocation, setGeolocation_get, _setDefaultBackgroundColor, setDefaultBackgroundColor_get, _setJavaScriptEnabled, setJavaScriptEnabled_get, _a3;
  let _instanceExtraInitializers = [];
  let _private_applyViewport_decorators;
  let _private_applyViewport_descriptor;
  let _private_emulateIdleState_decorators;
  let _private_emulateIdleState_descriptor;
  let _private_emulateTimezone_decorators;
  let _private_emulateTimezone_descriptor;
  let _private_emulateVisionDeficiency_decorators;
  let _private_emulateVisionDeficiency_descriptor;
  let _private_emulateCpuThrottling_decorators;
  let _private_emulateCpuThrottling_descriptor;
  let _private_emulateMediaFeatures_decorators;
  let _private_emulateMediaFeatures_descriptor;
  let _private_emulateMediaType_decorators;
  let _private_emulateMediaType_descriptor;
  let _private_setGeolocation_decorators;
  let _private_setGeolocation_descriptor;
  let _private_setDefaultBackgroundColor_decorators;
  let _private_setDefaultBackgroundColor_descriptor;
  let _private_setJavaScriptEnabled_decorators;
  let _private_setJavaScriptEnabled_descriptor;
  return _a3 = class {
    constructor(client) {
      __privateAdd(this, _applyViewport);
      __privateAdd(this, _emulateIdleState);
      __privateAdd(this, _emulateTimezone);
      __privateAdd(this, _emulateVisionDeficiency);
      __privateAdd(this, _emulateCpuThrottling);
      __privateAdd(this, _emulateMediaFeatures);
      __privateAdd(this, _emulateMediaType);
      __privateAdd(this, _setGeolocation);
      __privateAdd(this, _setDefaultBackgroundColor);
      __privateAdd(this, _setJavaScriptEnabled);
      __privateAdd(this, _client16, (__runInitializers$4(this, _instanceExtraInitializers), void 0));
      __privateAdd(this, _emulatingMobile, false);
      __privateAdd(this, _hasTouch, false);
      __privateAdd(this, _states, []);
      __privateAdd(this, _viewportState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _applyViewport, applyViewport_get)));
      __privateAdd(this, _idleOverridesState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateIdleState, emulateIdleState_get)));
      __privateAdd(this, _timezoneState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateTimezone, emulateTimezone_get)));
      __privateAdd(this, _visionDeficiencyState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateVisionDeficiency, emulateVisionDeficiency_get)));
      __privateAdd(this, _cpuThrottlingState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateCpuThrottling, emulateCpuThrottling_get)));
      __privateAdd(this, _mediaFeaturesState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateMediaFeatures, emulateMediaFeatures_get)));
      __privateAdd(this, _mediaTypeState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _emulateMediaType, emulateMediaType_get)));
      __privateAdd(this, _geoLocationState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _setGeolocation, setGeolocation_get)));
      __privateAdd(this, _defaultBackgroundColorState, new EmulatedState({
        active: false
      }, this, __privateGet(this, _setDefaultBackgroundColor, setDefaultBackgroundColor_get)));
      __privateAdd(this, _javascriptEnabledState, new EmulatedState({
        javaScriptEnabled: true,
        active: false
      }, this, __privateGet(this, _setJavaScriptEnabled, setJavaScriptEnabled_get)));
      __privateAdd(this, _secondaryClients, /* @__PURE__ */ new Set());
      __privateSet(this, _client16, client);
    }
    updateClient(client) {
      __privateSet(this, _client16, client);
      __privateGet(this, _secondaryClients).delete(client);
    }
    registerState(state) {
      __privateGet(this, _states).push(state);
    }
    clients() {
      return [__privateGet(this, _client16), ...Array.from(__privateGet(this, _secondaryClients))];
    }
    async registerSpeculativeSession(client) {
      __privateGet(this, _secondaryClients).add(client);
      client.once(CDPSessionEvent.Disconnected, () => {
        __privateGet(this, _secondaryClients).delete(client);
      });
      void Promise.all(__privateGet(this, _states).map((s2) => {
        return s2.sync().catch(debugError);
      }));
    }
    get javascriptEnabled() {
      return __privateGet(this, _javascriptEnabledState).state.javaScriptEnabled;
    }
    async emulateViewport(viewport) {
      await __privateGet(this, _viewportState).setState({
        viewport,
        active: true
      });
      const mobile = viewport.isMobile || false;
      const hasTouch = viewport.hasTouch || false;
      const reloadNeeded = __privateGet(this, _emulatingMobile) !== mobile || __privateGet(this, _hasTouch) !== hasTouch;
      __privateSet(this, _emulatingMobile, mobile);
      __privateSet(this, _hasTouch, hasTouch);
      return reloadNeeded;
    }
    async emulateIdleState(overrides) {
      await __privateGet(this, _idleOverridesState).setState({
        active: true,
        overrides
      });
    }
    async emulateTimezone(timezoneId) {
      await __privateGet(this, _timezoneState).setState({
        timezoneId,
        active: true
      });
    }
    async emulateVisionDeficiency(type) {
      const visionDeficiencies = /* @__PURE__ */ new Set([
        "none",
        "achromatopsia",
        "blurredVision",
        "deuteranopia",
        "protanopia",
        "tritanopia"
      ]);
      assert$1(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
      await __privateGet(this, _visionDeficiencyState).setState({
        active: true,
        visionDeficiency: type
      });
    }
    async emulateCPUThrottling(factor) {
      assert$1(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
      await __privateGet(this, _cpuThrottlingState).setState({
        active: true,
        factor: factor ?? void 0
      });
    }
    async emulateMediaFeatures(features) {
      if (Array.isArray(features)) {
        for (const mediaFeature of features) {
          const name2 = mediaFeature.name;
          assert$1(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name2), "Unsupported media feature: " + name2);
        }
      }
      await __privateGet(this, _mediaFeaturesState).setState({
        active: true,
        mediaFeatures: features
      });
    }
    async emulateMediaType(type) {
      assert$1(type === "screen" || type === "print" || (type ?? void 0) === void 0, "Unsupported media type: " + type);
      await __privateGet(this, _mediaTypeState).setState({
        type,
        active: true
      });
    }
    async setGeolocation(options) {
      const { longitude, latitude, accuracy = 0 } = options;
      if (longitude < -180 || longitude > 180) {
        throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
      }
      if (latitude < -90 || latitude > 90) {
        throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
      }
      if (accuracy < 0) {
        throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
      }
      await __privateGet(this, _geoLocationState).setState({
        active: true,
        geoLocation: {
          longitude,
          latitude,
          accuracy
        }
      });
    }
    /**
     * Resets default white background
     */
    async resetDefaultBackgroundColor() {
      await __privateGet(this, _defaultBackgroundColorState).setState({
        active: true,
        color: void 0
      });
    }
    /**
     * Hides default white background
     */
    async setTransparentBackgroundColor() {
      await __privateGet(this, _defaultBackgroundColorState).setState({
        active: true,
        color: { r: 0, g: 0, b: 0, a: 0 }
      });
    }
    async setJavaScriptEnabled(enabled) {
      await __privateGet(this, _javascriptEnabledState).setState({
        active: true,
        javaScriptEnabled: enabled
      });
    }
  }, _client16 = new WeakMap(), _emulatingMobile = new WeakMap(), _hasTouch = new WeakMap(), _states = new WeakMap(), _viewportState = new WeakMap(), _idleOverridesState = new WeakMap(), _timezoneState = new WeakMap(), _visionDeficiencyState = new WeakMap(), _cpuThrottlingState = new WeakMap(), _mediaFeaturesState = new WeakMap(), _mediaTypeState = new WeakMap(), _geoLocationState = new WeakMap(), _defaultBackgroundColorState = new WeakMap(), _javascriptEnabledState = new WeakMap(), _secondaryClients = new WeakMap(), _applyViewport = new WeakSet(), applyViewport_get = function() {
    return _private_applyViewport_descriptor.value;
  }, _emulateIdleState = new WeakSet(), emulateIdleState_get = function() {
    return _private_emulateIdleState_descriptor.value;
  }, _emulateTimezone = new WeakSet(), emulateTimezone_get = function() {
    return _private_emulateTimezone_descriptor.value;
  }, _emulateVisionDeficiency = new WeakSet(), emulateVisionDeficiency_get = function() {
    return _private_emulateVisionDeficiency_descriptor.value;
  }, _emulateCpuThrottling = new WeakSet(), emulateCpuThrottling_get = function() {
    return _private_emulateCpuThrottling_descriptor.value;
  }, _emulateMediaFeatures = new WeakSet(), emulateMediaFeatures_get = function() {
    return _private_emulateMediaFeatures_descriptor.value;
  }, _emulateMediaType = new WeakSet(), emulateMediaType_get = function() {
    return _private_emulateMediaType_descriptor.value;
  }, _setGeolocation = new WeakSet(), setGeolocation_get = function() {
    return _private_setGeolocation_descriptor.value;
  }, _setDefaultBackgroundColor = new WeakSet(), setDefaultBackgroundColor_get = function() {
    return _private_setDefaultBackgroundColor_descriptor.value;
  }, _setJavaScriptEnabled = new WeakSet(), setJavaScriptEnabled_get = function() {
    return _private_setJavaScriptEnabled_descriptor.value;
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
    _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
    _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
    _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
    _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
    _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
    _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
    _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
    _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
    _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
    __esDecorate$4(_a3, _private_applyViewport_descriptor = { value: __setFunctionName$2(async function(client, viewportState) {
      if (!viewportState.viewport) {
        return;
      }
      const { viewport } = viewportState;
      const mobile = viewport.isMobile || false;
      const width = viewport.width;
      const height = viewport.height;
      const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
      const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
      const hasTouch = viewport.hasTouch || false;
      await Promise.all([
        client.send("Emulation.setDeviceMetricsOverride", {
          mobile,
          width,
          height,
          deviceScaleFactor,
          screenOrientation
        }).catch((err) => {
          if (err.message.includes("Target does not support metrics override")) {
            debugError(err);
            return;
          }
          throw err;
        }),
        client.send("Emulation.setTouchEmulationEnabled", {
          enabled: hasTouch
        })
      ]);
    }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: (obj) => __privateIn(_applyViewport, obj), get: (obj) => __privateGet(obj, _applyViewport, applyViewport_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_emulateIdleState_descriptor = { value: __setFunctionName$2(async function(client, idleStateState) {
      if (!idleStateState.active) {
        return;
      }
      if (idleStateState.overrides) {
        await client.send("Emulation.setIdleOverride", {
          isUserActive: idleStateState.overrides.isUserActive,
          isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
        });
      } else {
        await client.send("Emulation.clearIdleOverride");
      }
    }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: (obj) => __privateIn(_emulateIdleState, obj), get: (obj) => __privateGet(obj, _emulateIdleState, emulateIdleState_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_emulateTimezone_descriptor = { value: __setFunctionName$2(async function(client, timezoneState) {
      if (!timezoneState.active) {
        return;
      }
      try {
        await client.send("Emulation.setTimezoneOverride", {
          timezoneId: timezoneState.timezoneId || ""
        });
      } catch (error) {
        if (isErrorLike$1(error) && error.message.includes("Invalid timezone")) {
          throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
        }
        throw error;
      }
    }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: (obj) => __privateIn(_emulateTimezone, obj), get: (obj) => __privateGet(obj, _emulateTimezone, emulateTimezone_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName$2(async function(client, visionDeficiency) {
      if (!visionDeficiency.active) {
        return;
      }
      await client.send("Emulation.setEmulatedVisionDeficiency", {
        type: visionDeficiency.visionDeficiency || "none"
      });
    }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: (obj) => __privateIn(_emulateVisionDeficiency, obj), get: (obj) => __privateGet(obj, _emulateVisionDeficiency, emulateVisionDeficiency_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName$2(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setCPUThrottlingRate", {
        rate: state.factor ?? 1
      });
    }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: (obj) => __privateIn(_emulateCpuThrottling, obj), get: (obj) => __privateGet(obj, _emulateCpuThrottling, emulateCpuThrottling_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName$2(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setEmulatedMedia", {
        features: state.mediaFeatures
      });
    }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: (obj) => __privateIn(_emulateMediaFeatures, obj), get: (obj) => __privateGet(obj, _emulateMediaFeatures, emulateMediaFeatures_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_emulateMediaType_descriptor = { value: __setFunctionName$2(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setEmulatedMedia", {
        media: state.type || ""
      });
    }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: (obj) => __privateIn(_emulateMediaType, obj), get: (obj) => __privateGet(obj, _emulateMediaType, emulateMediaType_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_setGeolocation_descriptor = { value: __setFunctionName$2(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setGeolocationOverride", state.geoLocation ? {
        longitude: state.geoLocation.longitude,
        latitude: state.geoLocation.latitude,
        accuracy: state.geoLocation.accuracy
      } : void 0);
    }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: (obj) => __privateIn(_setGeolocation, obj), get: (obj) => __privateGet(obj, _setGeolocation, setGeolocation_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName$2(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setDefaultBackgroundColorOverride", {
        color: state.color
      });
    }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: (obj) => __privateIn(_setDefaultBackgroundColor, obj), get: (obj) => __privateGet(obj, _setDefaultBackgroundColor, setDefaultBackgroundColor_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$4(_a3, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName$2(async function(client, state) {
      if (!state.active) {
        return;
      }
      await client.send("Emulation.setScriptExecutionDisabled", {
        value: !state.javaScriptEnabled
      });
    }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: (obj) => __privateIn(_setJavaScriptEnabled, obj), get: (obj) => __privateGet(obj, _setJavaScriptEnabled, setJavaScriptEnabled_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3;
})();
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class FirefoxTargetManager extends EventEmitter$2 {
  constructor(connection, targetFactory, targetFilterCallback) {
    super();
    __privateAdd(this, _finishInitializationIfReady);
    __privateAdd(this, _connection3, void 0);
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    __privateAdd(this, _discoveredTargetsByTargetId, /* @__PURE__ */ new Map());
    /**
     * Keeps track of targets that were created via 'Target.targetCreated'
     * and which one are not filtered out by `targetFilterCallback`.
     *
     * The target is removed from here once it's been destroyed.
     */
    __privateAdd(this, _availableTargetsByTargetId, /* @__PURE__ */ new Map());
    /**
     * Tracks which sessions attach to which target.
     */
    __privateAdd(this, _availableTargetsBySessionId, /* @__PURE__ */ new Map());
    __privateAdd(this, _targetFilterCallback, void 0);
    __privateAdd(this, _targetFactory, void 0);
    __privateAdd(this, _attachedToTargetListenersBySession, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _initializeDeferred, Deferred.create());
    __privateAdd(this, _targetsIdsForInit, /* @__PURE__ */ new Set());
    __privateAdd(this, _onSessionDetached, (session) => {
      this.removeSessionListeners(session);
      __privateGet(this, _availableTargetsBySessionId).delete(session.id());
    });
    __privateAdd(this, _onTargetCreated, async (event) => {
      if (__privateGet(this, _discoveredTargetsByTargetId).has(event.targetInfo.targetId)) {
        return;
      }
      __privateGet(this, _discoveredTargetsByTargetId).set(event.targetInfo.targetId, event.targetInfo);
      if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
        const target2 = __privateGet(this, _targetFactory).call(this, event.targetInfo, void 0);
        target2._initialize();
        __privateGet(this, _availableTargetsByTargetId).set(event.targetInfo.targetId, target2);
        __privateMethod(this, _finishInitializationIfReady, finishInitializationIfReady_fn).call(this, target2._targetId);
        return;
      }
      const target = __privateGet(this, _targetFactory).call(this, event.targetInfo, void 0);
      if (__privateGet(this, _targetFilterCallback) && !__privateGet(this, _targetFilterCallback).call(this, target)) {
        __privateMethod(this, _finishInitializationIfReady, finishInitializationIfReady_fn).call(this, event.targetInfo.targetId);
        return;
      }
      target._initialize();
      __privateGet(this, _availableTargetsByTargetId).set(event.targetInfo.targetId, target);
      this.emit("targetAvailable", target);
      __privateMethod(this, _finishInitializationIfReady, finishInitializationIfReady_fn).call(this, target._targetId);
    });
    __privateAdd(this, _onTargetDestroyed, (event) => {
      __privateGet(this, _discoveredTargetsByTargetId).delete(event.targetId);
      __privateMethod(this, _finishInitializationIfReady, finishInitializationIfReady_fn).call(this, event.targetId);
      const target = __privateGet(this, _availableTargetsByTargetId).get(event.targetId);
      if (target) {
        this.emit("targetGone", target);
        __privateGet(this, _availableTargetsByTargetId).delete(event.targetId);
      }
    });
    __privateAdd(this, _onAttachedToTarget, async (parentSession, event) => {
      const targetInfo = event.targetInfo;
      const session = __privateGet(this, _connection3).session(event.sessionId);
      if (!session) {
        throw new Error(`Session ${event.sessionId} was not created.`);
      }
      const target = __privateGet(this, _availableTargetsByTargetId).get(targetInfo.targetId);
      assert$1(target, `Target ${targetInfo.targetId} is missing`);
      session._setTarget(target);
      this.setupAttachmentListeners(session);
      __privateGet(this, _availableTargetsBySessionId).set(session.id(), __privateGet(this, _availableTargetsByTargetId).get(targetInfo.targetId));
      parentSession.emit(CDPSessionEvent.Ready, session);
    });
    __privateSet(this, _connection3, connection);
    __privateSet(this, _targetFilterCallback, targetFilterCallback);
    __privateSet(this, _targetFactory, targetFactory);
    __privateGet(this, _connection3).on("Target.targetCreated", __privateGet(this, _onTargetCreated));
    __privateGet(this, _connection3).on("Target.targetDestroyed", __privateGet(this, _onTargetDestroyed));
    __privateGet(this, _connection3).on(CDPSessionEvent.SessionDetached, __privateGet(this, _onSessionDetached));
    this.setupAttachmentListeners(__privateGet(this, _connection3));
  }
  setupAttachmentListeners(session) {
    const listener = (event) => {
      return __privateGet(this, _onAttachedToTarget).call(this, session, event);
    };
    assert$1(!__privateGet(this, _attachedToTargetListenersBySession).has(session));
    __privateGet(this, _attachedToTargetListenersBySession).set(session, listener);
    session.on("Target.attachedToTarget", listener);
  }
  removeSessionListeners(session) {
    if (__privateGet(this, _attachedToTargetListenersBySession).has(session)) {
      session.off("Target.attachedToTarget", __privateGet(this, _attachedToTargetListenersBySession).get(session));
      __privateGet(this, _attachedToTargetListenersBySession).delete(session);
    }
  }
  getAvailableTargets() {
    return __privateGet(this, _availableTargetsByTargetId);
  }
  dispose() {
    __privateGet(this, _connection3).off("Target.targetCreated", __privateGet(this, _onTargetCreated));
    __privateGet(this, _connection3).off("Target.targetDestroyed", __privateGet(this, _onTargetDestroyed));
  }
  async initialize() {
    await __privateGet(this, _connection3).send("Target.setDiscoverTargets", {
      discover: true,
      filter: [{}]
    });
    __privateSet(this, _targetsIdsForInit, new Set(__privateGet(this, _discoveredTargetsByTargetId).keys()));
    await __privateGet(this, _initializeDeferred).valueOrThrow();
  }
}
_connection3 = new WeakMap();
_discoveredTargetsByTargetId = new WeakMap();
_availableTargetsByTargetId = new WeakMap();
_availableTargetsBySessionId = new WeakMap();
_targetFilterCallback = new WeakMap();
_targetFactory = new WeakMap();
_attachedToTargetListenersBySession = new WeakMap();
_initializeDeferred = new WeakMap();
_targetsIdsForInit = new WeakMap();
_onSessionDetached = new WeakMap();
_onTargetCreated = new WeakMap();
_onTargetDestroyed = new WeakMap();
_onAttachedToTarget = new WeakMap();
_finishInitializationIfReady = new WeakSet();
finishInitializationIfReady_fn = function(targetId) {
  __privateGet(this, _targetsIdsForInit).delete(targetId);
  if (__privateGet(this, _targetsIdsForInit).size === 0) {
    __privateGet(this, _initializeDeferred).resolve();
  }
};
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class DeviceRequestPromptDevice {
  /**
   * @internal
   */
  constructor(id, name2) {
    /**
     * Device id during a prompt.
     */
    __publicField(this, "id");
    /**
     * Device name as it appears in a prompt.
     */
    __publicField(this, "name");
    this.id = id;
    this.name = name2;
  }
}
class DeviceRequestPrompt {
  /**
   * @internal
   */
  constructor(client, timeoutSettings, firstEvent) {
    __privateAdd(this, _updateDevices);
    __privateAdd(this, _client5, void 0);
    __privateAdd(this, _timeoutSettings, void 0);
    __privateAdd(this, _id3, void 0);
    __privateAdd(this, _handled3, false);
    __privateAdd(this, _updateDevicesHandle, __privateMethod(this, _updateDevices, updateDevices_fn).bind(this));
    __privateAdd(this, _waitForDevicePromises, /* @__PURE__ */ new Set());
    /**
     * Current list of selectable devices.
     */
    __publicField(this, "devices", []);
    __privateSet(this, _client5, client);
    __privateSet(this, _timeoutSettings, timeoutSettings);
    __privateSet(this, _id3, firstEvent.id);
    __privateGet(this, _client5).on("DeviceAccess.deviceRequestPrompted", __privateGet(this, _updateDevicesHandle));
    __privateGet(this, _client5).on("Target.detachedFromTarget", () => {
      __privateSet(this, _client5, null);
    });
    __privateMethod(this, _updateDevices, updateDevices_fn).call(this, firstEvent);
  }
  /**
   * Resolve to the first device in the prompt matching a filter.
   */
  async waitForDevice(filter2, options = {}) {
    for (const device of this.devices) {
      if (filter2(device)) {
        return device;
      }
    }
    const { timeout: timeout2 = __privateGet(this, _timeoutSettings).timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout2}ms exceeded`,
      timeout: timeout2
    });
    const handle = { filter: filter2, promise: deferred };
    __privateGet(this, _waitForDevicePromises).add(handle);
    try {
      return await deferred.valueOrThrow();
    } finally {
      __privateGet(this, _waitForDevicePromises).delete(handle);
    }
  }
  /**
   * Select a device in the prompt's list.
   */
  async select(device) {
    assert$1(__privateGet(this, _client5) !== null, "Cannot select device through detached session!");
    assert$1(this.devices.includes(device), "Cannot select unknown device!");
    assert$1(!__privateGet(this, _handled3), "Cannot select DeviceRequestPrompt which is already handled!");
    __privateGet(this, _client5).off("DeviceAccess.deviceRequestPrompted", __privateGet(this, _updateDevicesHandle));
    __privateSet(this, _handled3, true);
    return await __privateGet(this, _client5).send("DeviceAccess.selectPrompt", {
      id: __privateGet(this, _id3),
      deviceId: device.id
    });
  }
  /**
   * Cancel the prompt.
   */
  async cancel() {
    assert$1(__privateGet(this, _client5) !== null, "Cannot cancel prompt through detached session!");
    assert$1(!__privateGet(this, _handled3), "Cannot cancel DeviceRequestPrompt which is already handled!");
    __privateGet(this, _client5).off("DeviceAccess.deviceRequestPrompted", __privateGet(this, _updateDevicesHandle));
    __privateSet(this, _handled3, true);
    return await __privateGet(this, _client5).send("DeviceAccess.cancelPrompt", { id: __privateGet(this, _id3) });
  }
}
_client5 = new WeakMap();
_timeoutSettings = new WeakMap();
_id3 = new WeakMap();
_handled3 = new WeakMap();
_updateDevicesHandle = new WeakMap();
_waitForDevicePromises = new WeakMap();
_updateDevices = new WeakSet();
updateDevices_fn = function(event) {
  if (event.id !== __privateGet(this, _id3)) {
    return;
  }
  for (const rawDevice of event.devices) {
    if (this.devices.some((device) => {
      return device.id === rawDevice.id;
    })) {
      continue;
    }
    const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
    this.devices.push(newDevice);
    for (const waitForDevicePromise of __privateGet(this, _waitForDevicePromises)) {
      if (waitForDevicePromise.filter(newDevice)) {
        waitForDevicePromise.promise.resolve(newDevice);
      }
    }
  }
};
class DeviceRequestPromptManager {
  /**
   * @internal
   */
  constructor(client, timeoutSettings) {
    /**
     * @internal
     */
    __privateAdd(this, _onDeviceRequestPrompted);
    __privateAdd(this, _client6, void 0);
    __privateAdd(this, _timeoutSettings2, void 0);
    __privateAdd(this, _deviceRequestPrompDeferreds, /* @__PURE__ */ new Set());
    __privateSet(this, _client6, client);
    __privateSet(this, _timeoutSettings2, timeoutSettings);
    __privateGet(this, _client6).on("DeviceAccess.deviceRequestPrompted", (event) => {
      __privateMethod(this, _onDeviceRequestPrompted, onDeviceRequestPrompted_fn).call(this, event);
    });
    __privateGet(this, _client6).on("Target.detachedFromTarget", () => {
      __privateSet(this, _client6, null);
    });
  }
  /**
   * Wait for device prompt created by an action like calling WebBluetooth's
   * requestDevice.
   */
  async waitForDevicePrompt(options = {}) {
    assert$1(__privateGet(this, _client6) !== null, "Cannot wait for device prompt through detached session!");
    const needsEnable = __privateGet(this, _deviceRequestPrompDeferreds).size === 0;
    let enablePromise;
    if (needsEnable) {
      enablePromise = __privateGet(this, _client6).send("DeviceAccess.enable");
    }
    const { timeout: timeout2 = __privateGet(this, _timeoutSettings2).timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout2}ms exceeded`,
      timeout: timeout2
    });
    __privateGet(this, _deviceRequestPrompDeferreds).add(deferred);
    try {
      const [result] = await Promise.all([
        deferred.valueOrThrow(),
        enablePromise
      ]);
      return result;
    } finally {
      __privateGet(this, _deviceRequestPrompDeferreds).delete(deferred);
    }
  }
}
_client6 = new WeakMap();
_timeoutSettings2 = new WeakMap();
_deviceRequestPrompDeferreds = new WeakMap();
_onDeviceRequestPrompted = new WeakSet();
onDeviceRequestPrompted_fn = function(event) {
  if (!__privateGet(this, _deviceRequestPrompDeferreds).size) {
    return;
  }
  assert$1(__privateGet(this, _client6) !== null);
  const devicePrompt = new DeviceRequestPrompt(__privateGet(this, _client6), __privateGet(this, _timeoutSettings2), event);
  for (const promise of __privateGet(this, _deviceRequestPrompDeferreds)) {
    promise.resolve(devicePrompt);
  }
  __privateGet(this, _deviceRequestPrompDeferreds).clear();
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function createEvaluationError(details) {
  let name2;
  let message2;
  if (!details.exception) {
    name2 = "Error";
    message2 = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name2 = detail.name;
    message2 = detail.message;
  }
  const messageHeight = message2.split("\n").length;
  const error = new Error(message2);
  error.name = name2;
  const stackLines = error.stack.split("\n");
  const messageLines = stackLines.splice(0, messageHeight);
  stackLines.shift();
  if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
    for (const frame of details.stackTrace.callFrames.reverse()) {
      if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
        const url = PuppeteerURL.parse(frame.url);
        stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
      } else {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
      }
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
const getErrorDetails = (details) => {
  var _a3, _b3, _c3, _d2;
  let name2 = "";
  let message2;
  const lines = ((_b3 = (_a3 = details.exception) == null ? void 0 : _a3.description) == null ? void 0 : _b3.split("\n    at ")) ?? [];
  const size = Math.min(((_c3 = details.stackTrace) == null ? void 0 : _c3.callFrames.length) ?? 0, lines.length - 1);
  lines.splice(-size, size);
  if ((_d2 = details.exception) == null ? void 0 : _d2.className) {
    name2 = details.exception.className;
  }
  message2 = lines.join("\n");
  if (name2 && message2.startsWith(`${name2}: `)) {
    message2 = message2.slice(name2.length + 2);
  }
  return { message: message2, name: name2 };
};
function createClientError(details) {
  let name2;
  let message2;
  if (!details.exception) {
    name2 = "Error";
    message2 = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name2 = detail.name;
    message2 = detail.message;
  }
  const error = new Error(message2);
  error.name = name2;
  const messageHeight = error.message.split("\n").length;
  const messageLines = error.stack.split("\n").splice(0, messageHeight);
  const stackLines = [];
  if (details.stackTrace) {
    for (const frame of details.stackTrace.callFrames) {
      stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error.stack = [...messageLines, ...stackLines].join("\n");
  return error;
}
function valueFromRemoteObject(remoteObject) {
  assert$1(!remoteObject.objectId, "Cannot extract value when objectId is given");
  if (remoteObject.unserializableValue) {
    if (remoteObject.type === "bigint") {
      return BigInt(remoteObject.unserializableValue.replace("n", ""));
    }
    switch (remoteObject.unserializableValue) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
    }
  }
  return remoteObject.value;
}
function addPageBinding(type, name2) {
  const callCdp = globalThis[name2];
  if (callCdp[Symbol.toStringTag] === "PuppeteerBinding") {
    return;
  }
  Object.assign(globalThis, {
    [name2](...args) {
      const callPuppeteer = globalThis[name2];
      callPuppeteer.args ?? (callPuppeteer.args = /* @__PURE__ */ new Map());
      callPuppeteer.callbacks ?? (callPuppeteer.callbacks = /* @__PURE__ */ new Map());
      const seq = (callPuppeteer.lastSeq ?? 0) + 1;
      callPuppeteer.lastSeq = seq;
      callPuppeteer.args.set(seq, args);
      callCdp(JSON.stringify({
        type,
        name: name2,
        seq,
        args,
        isTrivial: !args.some((value) => {
          return value instanceof Node;
        })
      }));
      return new Promise((resolve2, reject) => {
        callPuppeteer.callbacks.set(seq, {
          resolve(value) {
            callPuppeteer.args.delete(seq);
            resolve2(value);
          },
          reject(value) {
            callPuppeteer.args.delete(seq);
            reject(value);
          }
        });
      });
    }
  });
  globalThis[name2][Symbol.toStringTag] = "PuppeteerBinding";
}
function pageBindingInitString(type, name2) {
  return evaluationString(addPageBinding, type, name2);
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpJSHandle extends JSHandle {
  constructor(world, remoteObject) {
    super();
    __privateAdd(this, _disposed4, false);
    __privateAdd(this, _remoteObject, void 0);
    __privateAdd(this, _world2, void 0);
    __privateSet(this, _world2, world);
    __privateSet(this, _remoteObject, remoteObject);
  }
  get disposed() {
    return __privateGet(this, _disposed4);
  }
  get realm() {
    return __privateGet(this, _world2);
  }
  get client() {
    return this.realm.environment.client;
  }
  async jsonValue() {
    if (!__privateGet(this, _remoteObject).objectId) {
      return valueFromRemoteObject(__privateGet(this, _remoteObject));
    }
    const value = await this.evaluate((object) => {
      return object;
    });
    if (value === void 0) {
      throw new Error("Could not serialize referenced object");
    }
    return value;
  }
  /**
   * Either `null` or the handle itself if the handle is an
   * instance of {@link ElementHandle}.
   */
  asElement() {
    return null;
  }
  async dispose() {
    if (__privateGet(this, _disposed4)) {
      return;
    }
    __privateSet(this, _disposed4, true);
    await releaseObject(this.client, __privateGet(this, _remoteObject));
  }
  toString() {
    if (!__privateGet(this, _remoteObject).objectId) {
      return "JSHandle:" + valueFromRemoteObject(__privateGet(this, _remoteObject));
    }
    const type = __privateGet(this, _remoteObject).subtype || __privateGet(this, _remoteObject).type;
    return "JSHandle@" + type;
  }
  get id() {
    return __privateGet(this, _remoteObject).objectId;
  }
  remoteObject() {
    return __privateGet(this, _remoteObject);
  }
}
_disposed4 = new WeakMap();
_remoteObject = new WeakMap();
_world2 = new WeakMap();
async function releaseObject(client, remoteObject) {
  if (!remoteObject.objectId) {
    return;
  }
  await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
    debugError(error);
  });
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$3 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate$3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
const NON_ELEMENT_NODE_ROLES = /* @__PURE__ */ new Set(["StaticText", "InlineTextBox"]);
let CdpElementHandle = (() => {
  var _frameManager3, frameManager_get, _a4;
  var _a3, _b3;
  let _classSuper = ElementHandle;
  let _instanceExtraInitializers = [];
  let _contentFrame_decorators;
  let _scrollIntoView_decorators;
  let _uploadFile_decorators;
  let _autofill_decorators;
  return _a4 = class extends _classSuper {
    constructor(world, remoteObject) {
      super(new CdpJSHandle(world, remoteObject));
      __privateAdd(this, _frameManager3);
      __runInitializers$3(this, _instanceExtraInitializers);
    }
    get realm() {
      return this.handle.realm;
    }
    get client() {
      return this.handle.client;
    }
    remoteObject() {
      return this.handle.remoteObject();
    }
    get frame() {
      return this.realm.environment;
    }
    async contentFrame() {
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      if (typeof nodeInfo.node.frameId !== "string") {
        return null;
      }
      return __privateGet(this, _frameManager3, frameManager_get).frame(nodeInfo.node.frameId);
    }
    async scrollIntoView() {
      await this.assertConnectedElement();
      try {
        await this.client.send("DOM.scrollIntoViewIfNeeded", {
          objectId: this.id
        });
      } catch (error) {
        debugError(error);
        await super.scrollIntoView();
      }
    }
    async uploadFile(...filePaths) {
      const isMultiple = await this.evaluate((element) => {
        return element.multiple;
      });
      assert$1(filePaths.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
      let path2;
      try {
        path2 = await import("path");
      } catch (error) {
        if (error instanceof TypeError) {
          throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
        }
        throw error;
      }
      const files2 = filePaths.map((filePath) => {
        if (path2.win32.isAbsolute(filePath) || path2.posix.isAbsolute(filePath)) {
          return filePath;
        } else {
          return path2.resolve(filePath);
        }
      });
      if (files2.length === 0) {
        await this.evaluate((element) => {
          element.files = new DataTransfer().files;
          element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
          element.dispatchEvent(new Event("change", { bubbles: true }));
        });
        return;
      }
      const { node: { backendNodeId } } = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      await this.client.send("DOM.setFileInputFiles", {
        objectId: this.id,
        files: files2,
        backendNodeId
      });
    }
    async autofill(data2) {
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: this.handle.id
      });
      const fieldId = nodeInfo.node.backendNodeId;
      const frameId = this.frame._id;
      await this.client.send("Autofill.trigger", {
        fieldId,
        frameId,
        card: data2.creditCard
      });
    }
    async *queryAXTree(name2, role) {
      const { nodes } = await this.client.send("Accessibility.queryAXTree", {
        objectId: this.id,
        accessibleName: name2,
        role
      });
      const results = nodes.filter((node2) => {
        if (node2.ignored) {
          return false;
        }
        if (!node2.role) {
          return false;
        }
        if (NON_ELEMENT_NODE_ROLES.has(node2.role.value)) {
          return false;
        }
        return true;
      });
      return yield* AsyncIterableUtil.map(results, (node2) => {
        return this.realm.adoptBackendNode(node2.backendDOMNodeId);
      });
    }
  }, _frameManager3 = new WeakSet(), frameManager_get = function() {
    return this.frame._frameManager;
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _contentFrame_decorators = [throwIfDisposed()];
    _scrollIntoView_decorators = [throwIfDisposed(), (_a3 = ElementHandle).bindIsolatedHandle.bind(_a3)];
    _uploadFile_decorators = [throwIfDisposed(), (_b3 = ElementHandle).bindIsolatedHandle.bind(_b3)];
    _autofill_decorators = [throwIfDisposed()];
    __esDecorate$3(_a4, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$3(_a4, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$3(_a4, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: (obj) => "uploadFile" in obj, get: (obj) => obj.uploadFile }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$3(_a4, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a4, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a4;
})();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$2 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$2 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
const ariaQuerySelectorBinding = new Binding("__ariaQuerySelector", ARIAQueryHandler.queryOne);
const ariaQuerySelectorAllBinding = new Binding("__ariaQuerySelectorAll", async (element, selector) => {
  const results = ARIAQueryHandler.queryAll(element, selector);
  return await element.realm.evaluateHandle((...elements) => {
    return elements;
  }, ...await AsyncIterableUtil.collect(results));
});
class ExecutionContext extends EventEmitter$2 {
  constructor(client, contextPayload, world) {
    super();
    __privateAdd(this, _addBinding);
    __privateAdd(this, _onBindingCalled);
    __privateAdd(this, _onConsoleAPI);
    __privateAdd(this, _addBindingWithoutThrowing);
    __privateAdd(this, _evaluate);
    __privateAdd(this, _client7, void 0);
    __privateAdd(this, _world3, void 0);
    __privateAdd(this, _id4, void 0);
    __privateAdd(this, _name3, void 0);
    __privateAdd(this, _disposables, new DisposableStack());
    // Contains mapping from functions that should be bound to Puppeteer functions.
    __privateAdd(this, _bindings, /* @__PURE__ */ new Map());
    // If multiple waitFor are set up asynchronously, we need to wait for the
    // first one to set up the binding in the page before running the others.
    __privateAdd(this, _mutex2, new Mutex());
    __privateAdd(this, _bindingsInstalled, false);
    __privateAdd(this, _puppeteerUtil, void 0);
    __privateSet(this, _client7, client);
    __privateSet(this, _world3, world);
    __privateSet(this, _id4, contextPayload.id);
    if (contextPayload.name) {
      __privateSet(this, _name3, contextPayload.name);
    }
    const clientEmitter = __privateGet(this, _disposables).use(new EventEmitter$2(__privateGet(this, _client7)));
    clientEmitter.on("Runtime.bindingCalled", __privateMethod(this, _onBindingCalled, onBindingCalled_fn).bind(this));
    clientEmitter.on("Runtime.executionContextDestroyed", async (event) => {
      if (event.executionContextId === __privateGet(this, _id4)) {
        this[disposeSymbol]();
      }
    });
    clientEmitter.on("Runtime.executionContextsCleared", async () => {
      this[disposeSymbol]();
    });
    clientEmitter.on("Runtime.consoleAPICalled", __privateMethod(this, _onConsoleAPI, onConsoleAPI_fn).bind(this));
    clientEmitter.on(CDPSessionEvent.Disconnected, () => {
      this[disposeSymbol]();
    });
  }
  get id() {
    return __privateGet(this, _id4);
  }
  get puppeteerUtil() {
    let promise = Promise.resolve();
    if (!__privateGet(this, _bindingsInstalled)) {
      promise = Promise.all([
        __privateMethod(this, _addBindingWithoutThrowing, addBindingWithoutThrowing_fn).call(this, ariaQuerySelectorBinding),
        __privateMethod(this, _addBindingWithoutThrowing, addBindingWithoutThrowing_fn).call(this, ariaQuerySelectorAllBinding)
      ]);
      __privateSet(this, _bindingsInstalled, true);
    }
    scriptInjector.inject((script) => {
      if (__privateGet(this, _puppeteerUtil)) {
        void __privateGet(this, _puppeteerUtil).then((handle) => {
          void handle.dispose();
        });
      }
      __privateSet(this, _puppeteerUtil, promise.then(() => {
        return this.evaluateHandle(script);
      }));
    }, !__privateGet(this, _puppeteerUtil));
    return __privateGet(this, _puppeteerUtil);
  }
  /**
   * Evaluates the given function.
   *
   * @example
   *
   * ```ts
   * const executionContext = await page.mainFrame().executionContext();
   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
   * console.log(result); // prints "56"
   * ```
   *
   * @example
   * A string can also be passed in instead of a function:
   *
   * ```ts
   * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const oneHandle = await executionContext.evaluateHandle(() => 1);
   * const twoHandle = await executionContext.evaluateHandle(() => 2);
   * const result = await executionContext.evaluate(
   *   (a, b) => a + b,
   *   oneHandle,
   *   twoHandle
   * );
   * await oneHandle.dispose();
   * await twoHandle.dispose();
   * console.log(result); // prints '3'.
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns The result of evaluating the function. If the result is an object,
   * a vanilla object containing the serializable properties of the result is
   * returned.
   */
  async evaluate(pageFunction, ...args) {
    return await __privateMethod(this, _evaluate, evaluate_fn).call(this, true, pageFunction, ...args);
  }
  /**
   * Evaluates the given function.
   *
   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
   * handle to the result of the function.
   *
   * This method may be better suited if the object cannot be serialized (e.g.
   * `Map`) and requires further manipulation.
   *
   * @example
   *
   * ```ts
   * const context = await page.mainFrame().executionContext();
   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
   *   () => Promise.resolve(self)
   * );
   * ```
   *
   * @example
   * A string can also be passed in instead of a function.
   *
   * ```ts
   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const bodyHandle: ElementHandle<HTMLBodyElement> =
   *   await context.evaluateHandle(() => {
   *     return document.body;
   *   });
   * const stringHandle: JSHandle<string> = await context.evaluateHandle(
   *   body => body.innerHTML,
   *   body
   * );
   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
   * // Always dispose your garbage! :)
   * await bodyHandle.dispose();
   * await stringHandle.dispose();
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns A {@link JSHandle | handle} to the result of evaluating the
   * function. If the result is a `Node`, then this will return an
   * {@link ElementHandle | element handle}.
   */
  async evaluateHandle(pageFunction, ...args) {
    return await __privateMethod(this, _evaluate, evaluate_fn).call(this, false, pageFunction, ...args);
  }
  [disposeSymbol]() {
    __privateGet(this, _disposables).dispose();
    this.emit("disposed", void 0);
  }
}
_client7 = new WeakMap();
_world3 = new WeakMap();
_id4 = new WeakMap();
_name3 = new WeakMap();
_disposables = new WeakMap();
_bindings = new WeakMap();
_mutex2 = new WeakMap();
_addBinding = new WeakSet();
addBinding_fn = async function(binding) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    if (__privateGet(this, _bindings).has(binding.name)) {
      return;
    }
    const _2 = __addDisposableResource$2(env_1, await __privateGet(this, _mutex2).acquire(), false);
    try {
      await __privateGet(this, _client7).send("Runtime.addBinding", __privateGet(this, _name3) ? {
        name: binding.name,
        executionContextName: __privateGet(this, _name3)
      } : {
        name: binding.name,
        executionContextId: __privateGet(this, _id4)
      });
      await this.evaluate(addPageBinding, "internal", binding.name);
      __privateGet(this, _bindings).set(binding.name, binding);
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes("Execution context was destroyed")) {
          return;
        }
        if (error.message.includes("Cannot find context with specified id")) {
          return;
        }
      }
      debugError(error);
    }
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources$2(env_1);
  }
};
_onBindingCalled = new WeakSet();
onBindingCalled_fn = async function(event) {
  let payload;
  try {
    payload = JSON.parse(event.payload);
  } catch {
    return;
  }
  const { type, name: name2, seq, args, isTrivial } = payload;
  if (type !== "internal") {
    this.emit("bindingcalled", event);
    return;
  }
  if (!__privateGet(this, _bindings).has(name2)) {
    this.emit("bindingcalled", event);
    return;
  }
  try {
    if (event.executionContextId !== __privateGet(this, _id4)) {
      return;
    }
    const binding = __privateGet(this, _bindings).get(name2);
    await (binding == null ? void 0 : binding.run(this, seq, args, isTrivial));
  } catch (err) {
    debugError(err);
  }
};
_onConsoleAPI = new WeakSet();
onConsoleAPI_fn = function(event) {
  if (event.executionContextId !== __privateGet(this, _id4)) {
    return;
  }
  this.emit("consoleapicalled", event);
};
_bindingsInstalled = new WeakMap();
_puppeteerUtil = new WeakMap();
_addBindingWithoutThrowing = new WeakSet();
addBindingWithoutThrowing_fn = async function(binding) {
  try {
    await __privateMethod(this, _addBinding, addBinding_fn).call(this, binding);
  } catch (err) {
    debugError(err);
  }
};
_evaluate = new WeakSet();
evaluate_fn = async function(returnByValue, pageFunction, ...args) {
  var _a3;
  const sourceUrlComment = getSourceUrlComment(((_a3 = getSourcePuppeteerURLIfAvailable(pageFunction)) == null ? void 0 : _a3.toString()) ?? PuppeteerURL.INTERNAL_URL);
  if (isString(pageFunction)) {
    const contextId = __privateGet(this, _id4);
    const expression = pageFunction;
    const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}
${sourceUrlComment}
`;
    const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await __privateGet(this, _client7).send("Runtime.evaluate", {
      expression: expressionWithSourceUrl,
      contextId,
      returnByValue,
      awaitPromise: true,
      userGesture: true
    }).catch(rewriteError);
    if (exceptionDetails2) {
      throw createEvaluationError(exceptionDetails2);
    }
    return returnByValue ? valueFromRemoteObject(remoteObject2) : __privateGet(this, _world3).createCdpHandle(remoteObject2);
  }
  const functionDeclaration = stringifyFunction(pageFunction);
  const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
  let callFunctionOnPromise;
  try {
    callFunctionOnPromise = __privateGet(this, _client7).send("Runtime.callFunctionOn", {
      functionDeclaration: functionDeclarationWithSourceUrl,
      executionContextId: __privateGet(this, _id4),
      arguments: args.length ? await Promise.all(args.map(convertArgument.bind(this))) : [],
      returnByValue,
      awaitPromise: true,
      userGesture: true
    });
  } catch (error) {
    if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
      error.message += " Recursive objects are not allowed.";
    }
    throw error;
  }
  const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
  if (exceptionDetails) {
    throw createEvaluationError(exceptionDetails);
  }
  return returnByValue ? valueFromRemoteObject(remoteObject) : __privateGet(this, _world3).createCdpHandle(remoteObject);
  async function convertArgument(arg) {
    if (arg instanceof LazyArg) {
      arg = await arg.get(this);
    }
    if (typeof arg === "bigint") {
      return { unserializableValue: `${arg.toString()}n` };
    }
    if (Object.is(arg, -0)) {
      return { unserializableValue: "-0" };
    }
    if (Object.is(arg, Infinity)) {
      return { unserializableValue: "Infinity" };
    }
    if (Object.is(arg, -Infinity)) {
      return { unserializableValue: "-Infinity" };
    }
    if (Object.is(arg, NaN)) {
      return { unserializableValue: "NaN" };
    }
    const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;
    if (objectHandle) {
      if (objectHandle.realm !== __privateGet(this, _world3)) {
        throw new Error("JSHandles can be evaluated only in the context they were created!");
      }
      if (objectHandle.disposed) {
        throw new Error("JSHandle is disposed!");
      }
      if (objectHandle.remoteObject().unserializableValue) {
        return {
          unserializableValue: objectHandle.remoteObject().unserializableValue
        };
      }
      if (!objectHandle.remoteObject().objectId) {
        return { value: objectHandle.remoteObject().value };
      }
      return { objectId: objectHandle.remoteObject().objectId };
    }
    return { value: arg };
  }
};
const rewriteError = (error) => {
  if (error.message.includes("Object reference chain is too long")) {
    return { result: { type: "undefined" } };
  }
  if (error.message.includes("Object couldn't be returned by value")) {
    return { result: { type: "undefined" } };
  }
  if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  }
  throw error;
};
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var FrameManagerEvent;
(function(FrameManagerEvent2) {
  FrameManagerEvent2.FrameAttached = Symbol("FrameManager.FrameAttached");
  FrameManagerEvent2.FrameNavigated = Symbol("FrameManager.FrameNavigated");
  FrameManagerEvent2.FrameDetached = Symbol("FrameManager.FrameDetached");
  FrameManagerEvent2.FrameSwapped = Symbol("FrameManager.FrameSwapped");
  FrameManagerEvent2.LifecycleEvent = Symbol("FrameManager.LifecycleEvent");
  FrameManagerEvent2.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument");
  FrameManagerEvent2.ConsoleApiCalled = Symbol("FrameManager.ConsoleApiCalled");
  FrameManagerEvent2.BindingCalled = Symbol("FrameManager.BindingCalled");
})(FrameManagerEvent || (FrameManagerEvent = {}));
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class IsolatedWorld extends Realm {
  constructor(frameOrWorker, timeoutSettings) {
    super(timeoutSettings);
    __privateAdd(this, _onContextDisposed);
    __privateAdd(this, _onContextConsoleApiCalled);
    __privateAdd(this, _onContextBindingCalled);
    __privateAdd(this, _executionContext);
    /**
     * Waits for the next context to be set on the isolated world.
     */
    __privateAdd(this, _waitForExecutionContext);
    __privateAdd(this, _context, void 0);
    __privateAdd(this, _emitter2, new EventEmitter$2());
    __privateAdd(this, _frameOrWorker, void 0);
    __privateSet(this, _frameOrWorker, frameOrWorker);
  }
  get environment() {
    return __privateGet(this, _frameOrWorker);
  }
  get client() {
    return __privateGet(this, _frameOrWorker).client;
  }
  get emitter() {
    return __privateGet(this, _emitter2);
  }
  setContext(context2) {
    var _a3;
    (_a3 = __privateGet(this, _context)) == null ? void 0 : _a3[disposeSymbol]();
    context2.once("disposed", __privateMethod(this, _onContextDisposed, onContextDisposed_fn).bind(this));
    context2.on("consoleapicalled", __privateMethod(this, _onContextConsoleApiCalled, onContextConsoleApiCalled_fn).bind(this));
    context2.on("bindingcalled", __privateMethod(this, _onContextBindingCalled, onContextBindingCalled_fn).bind(this));
    __privateSet(this, _context, context2);
    __privateGet(this, _emitter2).emit("context", context2);
    void this.taskManager.rerunAll();
  }
  hasContext() {
    return !!__privateGet(this, _context);
  }
  get context() {
    return __privateGet(this, _context);
  }
  async evaluateHandle(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
    let context2 = __privateMethod(this, _executionContext, executionContext_fn).call(this);
    if (!context2) {
      context2 = await __privateMethod(this, _waitForExecutionContext, waitForExecutionContext_fn).call(this);
    }
    return await context2.evaluateHandle(pageFunction, ...args);
  }
  async evaluate(pageFunction, ...args) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
    let context2 = __privateMethod(this, _executionContext, executionContext_fn).call(this);
    if (!context2) {
      context2 = await __privateMethod(this, _waitForExecutionContext, waitForExecutionContext_fn).call(this);
    }
    return await context2.evaluate(pageFunction, ...args);
  }
  async adoptBackendNode(backendNodeId) {
    let context2 = __privateMethod(this, _executionContext, executionContext_fn).call(this);
    if (!context2) {
      context2 = await __privateMethod(this, _waitForExecutionContext, waitForExecutionContext_fn).call(this);
    }
    const { object } = await this.client.send("DOM.resolveNode", {
      backendNodeId,
      executionContextId: context2.id
    });
    return this.createCdpHandle(object);
  }
  async adoptHandle(handle) {
    if (handle.realm === this) {
      return await handle.evaluateHandle((value) => {
        return value;
      });
    }
    const nodeInfo = await this.client.send("DOM.describeNode", {
      objectId: handle.id
    });
    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
  }
  async transferHandle(handle) {
    if (handle.realm === this) {
      return handle;
    }
    if (handle.remoteObject().objectId === void 0) {
      return handle;
    }
    const info = await this.client.send("DOM.describeNode", {
      objectId: handle.remoteObject().objectId
    });
    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
    await handle.dispose();
    return newHandle;
  }
  /**
   * @internal
   */
  createCdpHandle(remoteObject) {
    if (remoteObject.subtype === "node") {
      return new CdpElementHandle(this, remoteObject);
    }
    return new CdpJSHandle(this, remoteObject);
  }
  [disposeSymbol]() {
    var _a3;
    (_a3 = __privateGet(this, _context)) == null ? void 0 : _a3[disposeSymbol]();
    __privateGet(this, _emitter2).emit("disposed", void 0);
    super[disposeSymbol]();
    __privateGet(this, _emitter2).removeAllListeners();
  }
}
_context = new WeakMap();
_emitter2 = new WeakMap();
_frameOrWorker = new WeakMap();
_onContextDisposed = new WeakSet();
onContextDisposed_fn = function() {
  __privateSet(this, _context, void 0);
  if ("clearDocumentHandle" in __privateGet(this, _frameOrWorker)) {
    __privateGet(this, _frameOrWorker).clearDocumentHandle();
  }
};
_onContextConsoleApiCalled = new WeakSet();
onContextConsoleApiCalled_fn = function(event) {
  __privateGet(this, _emitter2).emit("consoleapicalled", event);
};
_onContextBindingCalled = new WeakSet();
onContextBindingCalled_fn = function(event) {
  __privateGet(this, _emitter2).emit("bindingcalled", event);
};
_executionContext = new WeakSet();
executionContext_fn = function() {
  if (this.disposed) {
    throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
  }
  return __privateGet(this, _context);
};
_waitForExecutionContext = new WeakSet();
waitForExecutionContext_fn = async function() {
  const result = await firstValueFrom(fromEmitterEvent(__privateGet(this, _emitter2), "context").pipe(raceWith(fromEmitterEvent(__privateGet(this, _emitter2), "disposed").pipe(map(() => {
    throw new Error("Execution context was destroyed");
  })))));
  return result;
};
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const MAIN_WORLD = Symbol("mainWorld");
const PUPPETEER_WORLD = Symbol("puppeteerWorld");
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
  ["load", "load"],
  ["domcontentloaded", "DOMContentLoaded"],
  ["networkidle0", "networkIdle"],
  ["networkidle2", "networkAlmostIdle"]
]);
class LifecycleWatcher {
  constructor(networkManager, frame, waitUntil, timeout2) {
    __privateAdd(this, _onRequest);
    __privateAdd(this, _onRequestFailed);
    __privateAdd(this, _onResponse);
    __privateAdd(this, _onFrameDetached);
    __privateAdd(this, _navigatedWithinDocument);
    __privateAdd(this, _navigated);
    __privateAdd(this, _frameSwapped);
    __privateAdd(this, _checkLifecycleComplete);
    __privateAdd(this, _expectedLifecycle, void 0);
    __privateAdd(this, _frame, void 0);
    __privateAdd(this, _timeout3, void 0);
    __privateAdd(this, _navigationRequest, null);
    __privateAdd(this, _subscriptions2, new DisposableStack());
    __privateAdd(this, _initialLoaderId, void 0);
    __privateAdd(this, _terminationDeferred, void 0);
    __privateAdd(this, _sameDocumentNavigationDeferred, Deferred.create());
    __privateAdd(this, _lifecycleDeferred, Deferred.create());
    __privateAdd(this, _newDocumentNavigationDeferred, Deferred.create());
    __privateAdd(this, _hasSameDocumentNavigation, void 0);
    __privateAdd(this, _swapped, void 0);
    __privateAdd(this, _navigationResponseReceived, void 0);
    if (Array.isArray(waitUntil)) {
      waitUntil = waitUntil.slice();
    } else if (typeof waitUntil === "string") {
      waitUntil = [waitUntil];
    }
    __privateSet(this, _initialLoaderId, frame._loaderId);
    __privateSet(this, _expectedLifecycle, waitUntil.map((value) => {
      const protocolEvent = puppeteerToProtocolLifecycle.get(value);
      assert$1(protocolEvent, "Unknown value for options.waitUntil: " + value);
      return protocolEvent;
    }));
    __privateSet(this, _frame, frame);
    __privateSet(this, _timeout3, timeout2);
    const frameManagerEmitter = __privateGet(this, _subscriptions2).use(new EventEmitter$2(frame._frameManager));
    frameManagerEmitter.on(FrameManagerEvent.LifecycleEvent, __privateMethod(this, _checkLifecycleComplete, checkLifecycleComplete_fn).bind(this));
    const frameEmitter = __privateGet(this, _subscriptions2).use(new EventEmitter$2(frame));
    frameEmitter.on(FrameEvent.FrameNavigatedWithinDocument, __privateMethod(this, _navigatedWithinDocument, navigatedWithinDocument_fn).bind(this));
    frameEmitter.on(FrameEvent.FrameNavigated, __privateMethod(this, _navigated, navigated_fn).bind(this));
    frameEmitter.on(FrameEvent.FrameSwapped, __privateMethod(this, _frameSwapped, frameSwapped_fn).bind(this));
    frameEmitter.on(FrameEvent.FrameSwappedByActivation, __privateMethod(this, _frameSwapped, frameSwapped_fn).bind(this));
    frameEmitter.on(FrameEvent.FrameDetached, __privateMethod(this, _onFrameDetached, onFrameDetached_fn).bind(this));
    const networkManagerEmitter = __privateGet(this, _subscriptions2).use(new EventEmitter$2(networkManager));
    networkManagerEmitter.on(NetworkManagerEvent.Request, __privateMethod(this, _onRequest, onRequest_fn).bind(this));
    networkManagerEmitter.on(NetworkManagerEvent.Response, __privateMethod(this, _onResponse, onResponse_fn).bind(this));
    networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, __privateMethod(this, _onRequestFailed, onRequestFailed_fn).bind(this));
    __privateSet(this, _terminationDeferred, Deferred.create({
      timeout: __privateGet(this, _timeout3),
      message: `Navigation timeout of ${__privateGet(this, _timeout3)} ms exceeded`
    }));
    __privateMethod(this, _checkLifecycleComplete, checkLifecycleComplete_fn).call(this);
  }
  async navigationResponse() {
    var _a3;
    await ((_a3 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _a3.valueOrThrow());
    return __privateGet(this, _navigationRequest) ? __privateGet(this, _navigationRequest).response() : null;
  }
  sameDocumentNavigationPromise() {
    return __privateGet(this, _sameDocumentNavigationDeferred).valueOrThrow();
  }
  newDocumentNavigationPromise() {
    return __privateGet(this, _newDocumentNavigationDeferred).valueOrThrow();
  }
  lifecyclePromise() {
    return __privateGet(this, _lifecycleDeferred).valueOrThrow();
  }
  terminationPromise() {
    return __privateGet(this, _terminationDeferred).valueOrThrow();
  }
  dispose() {
    __privateGet(this, _subscriptions2).dispose();
    __privateGet(this, _terminationDeferred).resolve(new Error("LifecycleWatcher disposed"));
  }
}
_expectedLifecycle = new WeakMap();
_frame = new WeakMap();
_timeout3 = new WeakMap();
_navigationRequest = new WeakMap();
_subscriptions2 = new WeakMap();
_initialLoaderId = new WeakMap();
_terminationDeferred = new WeakMap();
_sameDocumentNavigationDeferred = new WeakMap();
_lifecycleDeferred = new WeakMap();
_newDocumentNavigationDeferred = new WeakMap();
_hasSameDocumentNavigation = new WeakMap();
_swapped = new WeakMap();
_navigationResponseReceived = new WeakMap();
_onRequest = new WeakSet();
onRequest_fn = function(request) {
  var _a3, _b3;
  if (request.frame() !== __privateGet(this, _frame) || !request.isNavigationRequest()) {
    return;
  }
  __privateSet(this, _navigationRequest, request);
  (_a3 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _a3.resolve();
  __privateSet(this, _navigationResponseReceived, Deferred.create());
  if (request.response() !== null) {
    (_b3 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _b3.resolve();
  }
};
_onRequestFailed = new WeakSet();
onRequestFailed_fn = function(request) {
  var _a3, _b3;
  if (((_a3 = __privateGet(this, _navigationRequest)) == null ? void 0 : _a3.id) !== request.id) {
    return;
  }
  (_b3 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _b3.resolve();
};
_onResponse = new WeakSet();
onResponse_fn = function(response) {
  var _a3, _b3;
  if (((_a3 = __privateGet(this, _navigationRequest)) == null ? void 0 : _a3.id) !== response.request().id) {
    return;
  }
  (_b3 = __privateGet(this, _navigationResponseReceived)) == null ? void 0 : _b3.resolve();
};
_onFrameDetached = new WeakSet();
onFrameDetached_fn = function(frame) {
  if (__privateGet(this, _frame) === frame) {
    __privateGet(this, _terminationDeferred).resolve(new Error("Navigating frame was detached"));
    return;
  }
  __privateMethod(this, _checkLifecycleComplete, checkLifecycleComplete_fn).call(this);
};
_navigatedWithinDocument = new WeakSet();
navigatedWithinDocument_fn = function() {
  __privateSet(this, _hasSameDocumentNavigation, true);
  __privateMethod(this, _checkLifecycleComplete, checkLifecycleComplete_fn).call(this);
};
_navigated = new WeakSet();
navigated_fn = function(navigationType) {
  if (navigationType === "BackForwardCacheRestore") {
    return __privateMethod(this, _frameSwapped, frameSwapped_fn).call(this);
  }
  __privateMethod(this, _checkLifecycleComplete, checkLifecycleComplete_fn).call(this);
};
_frameSwapped = new WeakSet();
frameSwapped_fn = function() {
  __privateSet(this, _swapped, true);
  __privateMethod(this, _checkLifecycleComplete, checkLifecycleComplete_fn).call(this);
};
_checkLifecycleComplete = new WeakSet();
checkLifecycleComplete_fn = function() {
  if (!checkLifecycle(__privateGet(this, _frame), __privateGet(this, _expectedLifecycle))) {
    return;
  }
  __privateGet(this, _lifecycleDeferred).resolve();
  if (__privateGet(this, _hasSameDocumentNavigation)) {
    __privateGet(this, _sameDocumentNavigationDeferred).resolve(void 0);
  }
  if (__privateGet(this, _swapped) || __privateGet(this, _frame)._loaderId !== __privateGet(this, _initialLoaderId)) {
    __privateGet(this, _newDocumentNavigationDeferred).resolve(void 0);
  }
  function checkLifecycle(frame, expectedLifecycle) {
    for (const event of expectedLifecycle) {
      if (!frame._lifecycleEvents.has(event)) {
        return false;
      }
    }
    for (const child of frame.childFrames()) {
      if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
        return false;
      }
    }
    return true;
  }
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers$2 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate$2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
let CdpFrame = (() => {
  var _url5, _detached, _client16, _onMainWorldConsoleApiCalled, onMainWorldConsoleApiCalled_fn, _onMainWorldBindingCalled, onMainWorldBindingCalled_fn, _deviceRequestPromptManager, deviceRequestPromptManager_fn, _a3;
  let _classSuper = Frame;
  let _instanceExtraInitializers = [];
  let _goto_decorators;
  let _waitForNavigation_decorators;
  let _setContent_decorators;
  let _waitForDevicePrompt_decorators;
  return _a3 = class extends _classSuper {
    constructor(frameManager, frameId, parentFrameId, client) {
      super();
      __privateAdd(this, _onMainWorldConsoleApiCalled);
      __privateAdd(this, _onMainWorldBindingCalled);
      __privateAdd(this, _deviceRequestPromptManager);
      __privateAdd(this, _url5, (__runInitializers$2(this, _instanceExtraInitializers), ""));
      __privateAdd(this, _detached, false);
      __privateAdd(this, _client16, void 0);
      __publicField(this, "_frameManager");
      __publicField(this, "_loaderId", "");
      __publicField(this, "_lifecycleEvents", /* @__PURE__ */ new Set());
      __publicField(this, "_id");
      __publicField(this, "_parentId");
      __publicField(this, "worlds");
      this._frameManager = frameManager;
      __privateSet(this, _url5, "");
      this._id = frameId;
      this._parentId = parentFrameId;
      __privateSet(this, _detached, false);
      __privateSet(this, _client16, client);
      this._loaderId = "";
      this.worlds = {
        [MAIN_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
        [PUPPETEER_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings)
      };
      this.on(FrameEvent.FrameSwappedByActivation, () => {
        this._onLoadingStarted();
        this._onLoadingStopped();
      });
      this.worlds[MAIN_WORLD].emitter.on("consoleapicalled", __privateMethod(this, _onMainWorldConsoleApiCalled, onMainWorldConsoleApiCalled_fn).bind(this));
      this.worlds[MAIN_WORLD].emitter.on("bindingcalled", __privateMethod(this, _onMainWorldBindingCalled, onMainWorldBindingCalled_fn).bind(this));
    }
    /**
     * This is used internally in DevTools.
     *
     * @internal
     */
    _client() {
      return __privateGet(this, _client16);
    }
    /**
     * Updates the frame ID with the new ID. This happens when the main frame is
     * replaced by a different frame.
     */
    updateId(id) {
      this._id = id;
    }
    updateClient(client) {
      __privateSet(this, _client16, client);
    }
    page() {
      return this._frameManager.page();
    }
    isOOPFrame() {
      return __privateGet(this, _client16) !== this._frameManager.client;
    }
    async goto(url, options = {}) {
      const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      let ensureNewDocumentNavigation = false;
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
      let error = await Deferred.race([
        navigate(__privateGet(this, _client16), url, referer, referrerPolicy, this._id),
        watcher.terminationPromise()
      ]);
      if (!error) {
        error = await Deferred.race([
          watcher.terminationPromise(),
          ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
        ]);
      }
      try {
        if (error) {
          throw error;
        }
        return await watcher.navigationResponse();
      } finally {
        watcher.dispose();
      }
      async function navigate(client, url2, referrer, referrerPolicy2, frameId) {
        try {
          const response = await client.send("Page.navigate", {
            url: url2,
            referrer,
            frameId,
            referrerPolicy: referrerPolicy2
          });
          ensureNewDocumentNavigation = !!response.loaderId;
          if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
            return null;
          }
          return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
        } catch (error2) {
          if (isErrorLike$1(error2)) {
            return error2;
          }
          throw error2;
        }
      }
    }
    async waitForNavigation(options = {}) {
      const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
      const error = await Deferred.race([
        watcher.terminationPromise(),
        ...options.ignoreSameDocumentNavigation ? [] : [watcher.sameDocumentNavigationPromise()],
        watcher.newDocumentNavigationPromise()
      ]);
      try {
        if (error) {
          throw error;
        }
        const result = await Deferred.race([watcher.terminationPromise(), watcher.navigationResponse()]);
        if (result instanceof Error) {
          throw error;
        }
        return result || null;
      } finally {
        watcher.dispose();
      }
    }
    get client() {
      return __privateGet(this, _client16);
    }
    mainRealm() {
      return this.worlds[MAIN_WORLD];
    }
    isolatedRealm() {
      return this.worlds[PUPPETEER_WORLD];
    }
    async setContent(html, options = {}) {
      const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      await this.setFrameContent(html);
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
      const error = await Deferred.race([
        watcher.terminationPromise(),
        watcher.lifecyclePromise()
      ]);
      watcher.dispose();
      if (error) {
        throw error;
      }
    }
    url() {
      return __privateGet(this, _url5);
    }
    parentFrame() {
      return this._frameManager._frameTree.parentFrame(this._id) || null;
    }
    childFrames() {
      return this._frameManager._frameTree.childFrames(this._id);
    }
    async waitForDevicePrompt(options = {}) {
      return await __privateMethod(this, _deviceRequestPromptManager, deviceRequestPromptManager_fn).call(this).waitForDevicePrompt(options);
    }
    _navigated(framePayload) {
      this._name = framePayload.name;
      __privateSet(this, _url5, `${framePayload.url}${framePayload.urlFragment || ""}`);
    }
    _navigatedWithinDocument(url) {
      __privateSet(this, _url5, url);
    }
    _onLifecycleEvent(loaderId, name2) {
      if (name2 === "init") {
        this._loaderId = loaderId;
        this._lifecycleEvents.clear();
      }
      this._lifecycleEvents.add(name2);
    }
    _onLoadingStopped() {
      this._lifecycleEvents.add("DOMContentLoaded");
      this._lifecycleEvents.add("load");
    }
    _onLoadingStarted() {
      this._hasStartedLoading = true;
    }
    get detached() {
      return __privateGet(this, _detached);
    }
    [(_goto_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _waitForDevicePrompt_decorators = [throwIfDetached], disposeSymbol)]() {
      if (__privateGet(this, _detached)) {
        return;
      }
      __privateSet(this, _detached, true);
      this.worlds[MAIN_WORLD][disposeSymbol]();
      this.worlds[PUPPETEER_WORLD][disposeSymbol]();
    }
    exposeFunction() {
      throw new UnsupportedOperation();
    }
  }, _url5 = new WeakMap(), _detached = new WeakMap(), _client16 = new WeakMap(), _onMainWorldConsoleApiCalled = new WeakSet(), onMainWorldConsoleApiCalled_fn = function(event) {
    this._frameManager.emit(FrameManagerEvent.ConsoleApiCalled, [
      this.worlds[MAIN_WORLD],
      event
    ]);
  }, _onMainWorldBindingCalled = new WeakSet(), onMainWorldBindingCalled_fn = function(event) {
    this._frameManager.emit(FrameManagerEvent.BindingCalled, [
      this.worlds[MAIN_WORLD],
      event
    ]);
  }, _deviceRequestPromptManager = new WeakSet(), deviceRequestPromptManager_fn = function() {
    const rootFrame = this.page().mainFrame();
    if (this.isOOPFrame() || rootFrame === null) {
      return this._frameManager._deviceRequestPromptManager(__privateGet(this, _client16));
    } else {
      return rootFrame._frameManager._deviceRequestPromptManager(__privateGet(this, _client16));
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    __esDecorate$2(_a3, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a3, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a3, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a3, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: (obj) => "waitForDevicePrompt" in obj, get: (obj) => obj.waitForDevicePrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3;
})();
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class FrameTree {
  constructor() {
    __privateAdd(this, _frames, /* @__PURE__ */ new Map());
    // frameID -> parentFrameID
    __privateAdd(this, _parentIds, /* @__PURE__ */ new Map());
    // frameID -> childFrameIDs
    __privateAdd(this, _childIds, /* @__PURE__ */ new Map());
    __privateAdd(this, _mainFrame, void 0);
    __privateAdd(this, _isMainFrameStale, false);
    __privateAdd(this, _waitRequests, /* @__PURE__ */ new Map());
  }
  getMainFrame() {
    return __privateGet(this, _mainFrame);
  }
  getById(frameId) {
    return __privateGet(this, _frames).get(frameId);
  }
  /**
   * Returns a promise that is resolved once the frame with
   * the given ID is added to the tree.
   */
  waitForFrame(frameId) {
    const frame = this.getById(frameId);
    if (frame) {
      return Promise.resolve(frame);
    }
    const deferred = Deferred.create();
    const callbacks = __privateGet(this, _waitRequests).get(frameId) || /* @__PURE__ */ new Set();
    callbacks.add(deferred);
    return deferred.valueOrThrow();
  }
  frames() {
    return Array.from(__privateGet(this, _frames).values());
  }
  addFrame(frame) {
    var _a3;
    __privateGet(this, _frames).set(frame._id, frame);
    if (frame._parentId) {
      __privateGet(this, _parentIds).set(frame._id, frame._parentId);
      if (!__privateGet(this, _childIds).has(frame._parentId)) {
        __privateGet(this, _childIds).set(frame._parentId, /* @__PURE__ */ new Set());
      }
      __privateGet(this, _childIds).get(frame._parentId).add(frame._id);
    } else if (!__privateGet(this, _mainFrame) || __privateGet(this, _isMainFrameStale)) {
      __privateSet(this, _mainFrame, frame);
      __privateSet(this, _isMainFrameStale, false);
    }
    (_a3 = __privateGet(this, _waitRequests).get(frame._id)) == null ? void 0 : _a3.forEach((request) => {
      return request.resolve(frame);
    });
  }
  removeFrame(frame) {
    var _a3;
    __privateGet(this, _frames).delete(frame._id);
    __privateGet(this, _parentIds).delete(frame._id);
    if (frame._parentId) {
      (_a3 = __privateGet(this, _childIds).get(frame._parentId)) == null ? void 0 : _a3.delete(frame._id);
    } else {
      __privateSet(this, _isMainFrameStale, true);
    }
  }
  childFrames(frameId) {
    const childIds = __privateGet(this, _childIds).get(frameId);
    if (!childIds) {
      return [];
    }
    return Array.from(childIds).map((id) => {
      return this.getById(id);
    }).filter((frame) => {
      return frame !== void 0;
    });
  }
  parentFrame(frameId) {
    const parentId = __privateGet(this, _parentIds).get(frameId);
    return parentId ? this.getById(parentId) : void 0;
  }
}
_frames = new WeakMap();
_parentIds = new WeakMap();
_childIds = new WeakMap();
_mainFrame = new WeakMap();
_isMainFrameStale = new WeakMap();
_waitRequests = new WeakMap();
class CdpHTTPRequest extends HTTPRequest {
  constructor(client, frame, interceptionId, allowInterception, data2, redirectChain) {
    super();
    __publicField(this, "id");
    __privateAdd(this, _client8, void 0);
    __privateAdd(this, _isNavigationRequest, void 0);
    __privateAdd(this, _url3, void 0);
    __privateAdd(this, _resourceType, void 0);
    __privateAdd(this, _method, void 0);
    __privateAdd(this, _hasPostData, false);
    __privateAdd(this, _postData, void 0);
    __privateAdd(this, _headers, {});
    __privateAdd(this, _frame2, void 0);
    __privateAdd(this, _initiator, void 0);
    __privateSet(this, _client8, client);
    this.id = data2.requestId;
    __privateSet(this, _isNavigationRequest, data2.requestId === data2.loaderId && data2.type === "Document");
    this._interceptionId = interceptionId;
    __privateSet(this, _url3, data2.request.url);
    __privateSet(this, _resourceType, (data2.type || "other").toLowerCase());
    __privateSet(this, _method, data2.request.method);
    __privateSet(this, _postData, data2.request.postData);
    __privateSet(this, _hasPostData, data2.request.hasPostData ?? false);
    __privateSet(this, _frame2, frame);
    this._redirectChain = redirectChain;
    __privateSet(this, _initiator, data2.initiator);
    this.interception.enabled = allowInterception;
    for (const [key, value] of Object.entries(data2.request.headers)) {
      __privateGet(this, _headers)[key.toLowerCase()] = value;
    }
  }
  get client() {
    return __privateGet(this, _client8);
  }
  url() {
    return __privateGet(this, _url3);
  }
  resourceType() {
    return __privateGet(this, _resourceType);
  }
  method() {
    return __privateGet(this, _method);
  }
  postData() {
    return __privateGet(this, _postData);
  }
  hasPostData() {
    return __privateGet(this, _hasPostData);
  }
  async fetchPostData() {
    try {
      const result = await __privateGet(this, _client8).send("Network.getRequestPostData", {
        requestId: this.id
      });
      return result.postData;
    } catch (err) {
      debugError(err);
      return;
    }
  }
  headers() {
    return __privateGet(this, _headers);
  }
  response() {
    return this._response;
  }
  frame() {
    return __privateGet(this, _frame2);
  }
  isNavigationRequest() {
    return __privateGet(this, _isNavigationRequest);
  }
  initiator() {
    return __privateGet(this, _initiator);
  }
  redirectChain() {
    return this._redirectChain.slice();
  }
  failure() {
    if (!this._failureText) {
      return null;
    }
    return {
      errorText: this._failureText
    };
  }
  /**
   * @internal
   */
  async _continue(overrides = {}) {
    const { url, method, postData, headers } = overrides;
    this.interception.handled = true;
    const postDataBinaryBase64 = postData ? Buffer.from(postData).toString("base64") : void 0;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
    }
    await __privateGet(this, _client8).send("Fetch.continueRequest", {
      requestId: this._interceptionId,
      url,
      method,
      postData: postDataBinaryBase64,
      headers: headers ? headersArray(headers) : void 0
    }).catch((error) => {
      this.interception.handled = false;
      return handleError(error);
    });
  }
  async _respond(response) {
    this.interception.handled = true;
    const responseBody = response.body && isString(response.body) ? Buffer.from(response.body) : response.body || null;
    const responseHeaders = {};
    if (response.headers) {
      for (const header of Object.keys(response.headers)) {
        const value = response.headers[header];
        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
          return String(item);
        }) : String(value);
      }
    }
    if (response.contentType) {
      responseHeaders["content-type"] = response.contentType;
    }
    if (responseBody && !("content-length" in responseHeaders)) {
      responseHeaders["content-length"] = String(Buffer.byteLength(responseBody));
    }
    const status = response.status || 200;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
    }
    await __privateGet(this, _client8).send("Fetch.fulfillRequest", {
      requestId: this._interceptionId,
      responseCode: status,
      responsePhrase: STATUS_TEXTS[status],
      responseHeaders: headersArray(responseHeaders),
      body: responseBody ? responseBody.toString("base64") : void 0
    }).catch((error) => {
      this.interception.handled = false;
      return handleError(error);
    });
  }
  async _abort(errorReason) {
    this.interception.handled = true;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
    }
    await __privateGet(this, _client8).send("Fetch.failRequest", {
      requestId: this._interceptionId,
      errorReason: errorReason || "Failed"
    }).catch(handleError);
  }
}
_client8 = new WeakMap();
_isNavigationRequest = new WeakMap();
_url3 = new WeakMap();
_resourceType = new WeakMap();
_method = new WeakMap();
_hasPostData = new WeakMap();
_postData = new WeakMap();
_headers = new WeakMap();
_frame2 = new WeakMap();
_initiator = new WeakMap();
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class SecurityDetails {
  /**
   * @internal
   */
  constructor(securityPayload) {
    __privateAdd(this, _subjectName, void 0);
    __privateAdd(this, _issuer, void 0);
    __privateAdd(this, _validFrom, void 0);
    __privateAdd(this, _validTo, void 0);
    __privateAdd(this, _protocol, void 0);
    __privateAdd(this, _sanList, void 0);
    __privateSet(this, _subjectName, securityPayload.subjectName);
    __privateSet(this, _issuer, securityPayload.issuer);
    __privateSet(this, _validFrom, securityPayload.validFrom);
    __privateSet(this, _validTo, securityPayload.validTo);
    __privateSet(this, _protocol, securityPayload.protocol);
    __privateSet(this, _sanList, securityPayload.sanList);
  }
  /**
   * The name of the issuer of the certificate.
   */
  issuer() {
    return __privateGet(this, _issuer);
  }
  /**
   * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
   * marking the start of the certificate's validity.
   */
  validFrom() {
    return __privateGet(this, _validFrom);
  }
  /**
   * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
   * marking the end of the certificate's validity.
   */
  validTo() {
    return __privateGet(this, _validTo);
  }
  /**
   * The security protocol being used, e.g. "TLS 1.2".
   */
  protocol() {
    return __privateGet(this, _protocol);
  }
  /**
   * The name of the subject to which the certificate was issued.
   */
  subjectName() {
    return __privateGet(this, _subjectName);
  }
  /**
   * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
   */
  subjectAlternativeNames() {
    return __privateGet(this, _sanList);
  }
}
_subjectName = new WeakMap();
_issuer = new WeakMap();
_validFrom = new WeakMap();
_validTo = new WeakMap();
_protocol = new WeakMap();
_sanList = new WeakMap();
class CdpHTTPResponse extends HTTPResponse {
  constructor(client, request, responsePayload, extraInfo) {
    super();
    __privateAdd(this, _parseStatusTextFromExtraInfo);
    __privateAdd(this, _client9, void 0);
    __privateAdd(this, _request, void 0);
    __privateAdd(this, _contentPromise, null);
    __privateAdd(this, _bodyLoadedDeferred, Deferred.create());
    __privateAdd(this, _remoteAddress, void 0);
    __privateAdd(this, _status, void 0);
    __privateAdd(this, _statusText, void 0);
    __privateAdd(this, _url4, void 0);
    __privateAdd(this, _fromDiskCache, void 0);
    __privateAdd(this, _fromServiceWorker, void 0);
    __privateAdd(this, _headers2, {});
    __privateAdd(this, _securityDetails, void 0);
    __privateAdd(this, _timing, void 0);
    __privateSet(this, _client9, client);
    __privateSet(this, _request, request);
    __privateSet(this, _remoteAddress, {
      ip: responsePayload.remoteIPAddress,
      port: responsePayload.remotePort
    });
    __privateSet(this, _statusText, __privateMethod(this, _parseStatusTextFromExtraInfo, parseStatusTextFromExtraInfo_fn).call(this, extraInfo) || responsePayload.statusText);
    __privateSet(this, _url4, request.url());
    __privateSet(this, _fromDiskCache, !!responsePayload.fromDiskCache);
    __privateSet(this, _fromServiceWorker, !!responsePayload.fromServiceWorker);
    __privateSet(this, _status, extraInfo ? extraInfo.statusCode : responsePayload.status);
    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
    for (const [key, value] of Object.entries(headers)) {
      __privateGet(this, _headers2)[key.toLowerCase()] = value;
    }
    __privateSet(this, _securityDetails, responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null);
    __privateSet(this, _timing, responsePayload.timing || null);
  }
  _resolveBody(err) {
    if (err) {
      return __privateGet(this, _bodyLoadedDeferred).reject(err);
    }
    return __privateGet(this, _bodyLoadedDeferred).resolve();
  }
  remoteAddress() {
    return __privateGet(this, _remoteAddress);
  }
  url() {
    return __privateGet(this, _url4);
  }
  status() {
    return __privateGet(this, _status);
  }
  statusText() {
    return __privateGet(this, _statusText);
  }
  headers() {
    return __privateGet(this, _headers2);
  }
  securityDetails() {
    return __privateGet(this, _securityDetails);
  }
  timing() {
    return __privateGet(this, _timing);
  }
  buffer() {
    if (!__privateGet(this, _contentPromise)) {
      __privateSet(this, _contentPromise, __privateGet(this, _bodyLoadedDeferred).valueOrThrow().then(async () => {
        try {
          const response = await __privateGet(this, _client9).send("Network.getResponseBody", {
            requestId: __privateGet(this, _request).id
          });
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        } catch (error) {
          if (error instanceof ProtocolError && error.originalMessage === "No resource with given identifier found") {
            throw new ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
          }
          throw error;
        }
      }));
    }
    return __privateGet(this, _contentPromise);
  }
  request() {
    return __privateGet(this, _request);
  }
  fromCache() {
    return __privateGet(this, _fromDiskCache) || __privateGet(this, _request)._fromMemoryCache;
  }
  fromServiceWorker() {
    return __privateGet(this, _fromServiceWorker);
  }
  frame() {
    return __privateGet(this, _request).frame();
  }
}
_client9 = new WeakMap();
_request = new WeakMap();
_contentPromise = new WeakMap();
_bodyLoadedDeferred = new WeakMap();
_remoteAddress = new WeakMap();
_status = new WeakMap();
_statusText = new WeakMap();
_url4 = new WeakMap();
_fromDiskCache = new WeakMap();
_fromServiceWorker = new WeakMap();
_headers2 = new WeakMap();
_securityDetails = new WeakMap();
_timing = new WeakMap();
_parseStatusTextFromExtraInfo = new WeakSet();
parseStatusTextFromExtraInfo_fn = function(extraInfo) {
  if (!extraInfo || !extraInfo.headersText) {
    return;
  }
  const firstLine = extraInfo.headersText.split("\r", 1)[0];
  if (!firstLine) {
    return;
  }
  const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
  if (!match) {
    return;
  }
  const statusText = match[1];
  if (!statusText) {
    return;
  }
  return statusText;
};
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class NetworkEventManager {
  constructor() {
    /**
     * There are four possible orders of events:
     * A. `_onRequestWillBeSent`
     * B. `_onRequestWillBeSent`, `_onRequestPaused`
     * C. `_onRequestPaused`, `_onRequestWillBeSent`
     * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
     * (see crbug.com/1196004)
     *
     * For `_onRequest` we need the event from `_onRequestWillBeSent` and
     * optionally the `interceptionId` from `_onRequestPaused`.
     *
     * If request interception is disabled, call `_onRequest` once per call to
     * `_onRequestWillBeSent`.
     * If request interception is enabled, call `_onRequest` once per call to
     * `_onRequestPaused` (once per `interceptionId`).
     *
     * Events are stored to allow for subsequent events to call `_onRequest`.
     *
     * Note that (chains of) redirect requests have the same `requestId` (!) as
     * the original request. We have to anticipate series of events like these:
     * A. `_onRequestWillBeSent`,
     * `_onRequestWillBeSent`, ...
     * B. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, ...
     * C. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, ...
     * D. `_onRequestPaused`, `_onRequestWillBeSent`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
     * (see crbug.com/1196004)
     */
    __privateAdd(this, _requestWillBeSentMap, /* @__PURE__ */ new Map());
    __privateAdd(this, _requestPausedMap, /* @__PURE__ */ new Map());
    __privateAdd(this, _httpRequestsMap, /* @__PURE__ */ new Map());
    /*
     * The below maps are used to reconcile Network.responseReceivedExtraInfo
     * events with their corresponding request. Each response and redirect
     * response gets an ExtraInfo event, and we don't know which will come first.
     * This means that we have to store a Response or an ExtraInfo for each
     * response, and emit the event when we get both of them. In addition, to
     * handle redirects, we have to make them Arrays to represent the chain of
     * events.
     */
    __privateAdd(this, _responseReceivedExtraInfoMap, /* @__PURE__ */ new Map());
    __privateAdd(this, _queuedRedirectInfoMap, /* @__PURE__ */ new Map());
    __privateAdd(this, _queuedEventGroupMap, /* @__PURE__ */ new Map());
  }
  forget(networkRequestId) {
    __privateGet(this, _requestWillBeSentMap).delete(networkRequestId);
    __privateGet(this, _requestPausedMap).delete(networkRequestId);
    __privateGet(this, _queuedEventGroupMap).delete(networkRequestId);
    __privateGet(this, _queuedRedirectInfoMap).delete(networkRequestId);
    __privateGet(this, _responseReceivedExtraInfoMap).delete(networkRequestId);
  }
  responseExtraInfo(networkRequestId) {
    if (!__privateGet(this, _responseReceivedExtraInfoMap).has(networkRequestId)) {
      __privateGet(this, _responseReceivedExtraInfoMap).set(networkRequestId, []);
    }
    return __privateGet(this, _responseReceivedExtraInfoMap).get(networkRequestId);
  }
  queuedRedirectInfo(fetchRequestId) {
    if (!__privateGet(this, _queuedRedirectInfoMap).has(fetchRequestId)) {
      __privateGet(this, _queuedRedirectInfoMap).set(fetchRequestId, []);
    }
    return __privateGet(this, _queuedRedirectInfoMap).get(fetchRequestId);
  }
  queueRedirectInfo(fetchRequestId, redirectInfo) {
    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
  }
  takeQueuedRedirectInfo(fetchRequestId) {
    return this.queuedRedirectInfo(fetchRequestId).shift();
  }
  inFlightRequestsCount() {
    let inFlightRequestCounter = 0;
    for (const request of __privateGet(this, _httpRequestsMap).values()) {
      if (!request.response()) {
        inFlightRequestCounter++;
      }
    }
    return inFlightRequestCounter;
  }
  storeRequestWillBeSent(networkRequestId, event) {
    __privateGet(this, _requestWillBeSentMap).set(networkRequestId, event);
  }
  getRequestWillBeSent(networkRequestId) {
    return __privateGet(this, _requestWillBeSentMap).get(networkRequestId);
  }
  forgetRequestWillBeSent(networkRequestId) {
    __privateGet(this, _requestWillBeSentMap).delete(networkRequestId);
  }
  getRequestPaused(networkRequestId) {
    return __privateGet(this, _requestPausedMap).get(networkRequestId);
  }
  forgetRequestPaused(networkRequestId) {
    __privateGet(this, _requestPausedMap).delete(networkRequestId);
  }
  storeRequestPaused(networkRequestId, event) {
    __privateGet(this, _requestPausedMap).set(networkRequestId, event);
  }
  getRequest(networkRequestId) {
    return __privateGet(this, _httpRequestsMap).get(networkRequestId);
  }
  storeRequest(networkRequestId, request) {
    __privateGet(this, _httpRequestsMap).set(networkRequestId, request);
  }
  forgetRequest(networkRequestId) {
    __privateGet(this, _httpRequestsMap).delete(networkRequestId);
  }
  getQueuedEventGroup(networkRequestId) {
    return __privateGet(this, _queuedEventGroupMap).get(networkRequestId);
  }
  queueEventGroup(networkRequestId, event) {
    __privateGet(this, _queuedEventGroupMap).set(networkRequestId, event);
  }
  forgetQueuedEventGroup(networkRequestId) {
    __privateGet(this, _queuedEventGroupMap).delete(networkRequestId);
  }
}
_requestWillBeSentMap = new WeakMap();
_requestPausedMap = new WeakMap();
_httpRequestsMap = new WeakMap();
_responseReceivedExtraInfoMap = new WeakMap();
_queuedRedirectInfoMap = new WeakMap();
_queuedEventGroupMap = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class NetworkManager extends EventEmitter$2 {
  constructor(frameManager) {
    super();
    __privateAdd(this, _removeClient);
    __privateAdd(this, _applyExtraHTTPHeaders);
    __privateAdd(this, _applyToAllClients);
    __privateAdd(this, _applyNetworkConditions);
    __privateAdd(this, _applyUserAgent);
    __privateAdd(this, _applyProtocolRequestInterception);
    __privateAdd(this, _applyProtocolCacheDisabled);
    __privateAdd(this, _onRequestWillBeSent);
    __privateAdd(this, _onAuthRequired);
    /**
     * CDP may send a Fetch.requestPaused without or before a
     * Network.requestWillBeSent
     *
     * CDP may send multiple Fetch.requestPaused
     * for the same Network.requestWillBeSent.
     */
    __privateAdd(this, _onRequestPaused);
    __privateAdd(this, _patchRequestEventHeaders);
    __privateAdd(this, _onRequestWithoutNetworkInstrumentation);
    __privateAdd(this, _onRequest2);
    __privateAdd(this, _onRequestServedFromCache);
    __privateAdd(this, _handleRequestRedirect);
    __privateAdd(this, _emitResponseEvent);
    __privateAdd(this, _onResponseReceived);
    __privateAdd(this, _onResponseReceivedExtraInfo);
    __privateAdd(this, _forgetRequest);
    __privateAdd(this, _onLoadingFinished);
    __privateAdd(this, _emitLoadingFinished);
    __privateAdd(this, _onLoadingFailed);
    __privateAdd(this, _emitLoadingFailed);
    __privateAdd(this, _frameManager, void 0);
    __privateAdd(this, _networkEventManager, new NetworkEventManager());
    __privateAdd(this, _extraHTTPHeaders, void 0);
    __privateAdd(this, _credentials, void 0);
    __privateAdd(this, _attemptedAuthentications, /* @__PURE__ */ new Set());
    __privateAdd(this, _userRequestInterceptionEnabled, false);
    __privateAdd(this, _protocolRequestInterceptionEnabled, false);
    __privateAdd(this, _userCacheDisabled, void 0);
    __privateAdd(this, _emulatedNetworkConditions, void 0);
    __privateAdd(this, _userAgent, void 0);
    __privateAdd(this, _userAgentMetadata, void 0);
    __privateAdd(this, _handlers3, [
      ["Fetch.requestPaused", __privateMethod(this, _onRequestPaused, onRequestPaused_fn)],
      ["Fetch.authRequired", __privateMethod(this, _onAuthRequired, onAuthRequired_fn)],
      ["Network.requestWillBeSent", __privateMethod(this, _onRequestWillBeSent, onRequestWillBeSent_fn)],
      ["Network.requestServedFromCache", __privateMethod(this, _onRequestServedFromCache, onRequestServedFromCache_fn)],
      ["Network.responseReceived", __privateMethod(this, _onResponseReceived, onResponseReceived_fn)],
      ["Network.loadingFinished", __privateMethod(this, _onLoadingFinished, onLoadingFinished_fn)],
      ["Network.loadingFailed", __privateMethod(this, _onLoadingFailed, onLoadingFailed_fn)],
      ["Network.responseReceivedExtraInfo", __privateMethod(this, _onResponseReceivedExtraInfo, onResponseReceivedExtraInfo_fn)],
      [CDPSessionEvent.Disconnected, __privateMethod(this, _removeClient, removeClient_fn)]
    ]);
    __privateAdd(this, _clients, /* @__PURE__ */ new Map());
    __privateSet(this, _frameManager, frameManager);
  }
  async addClient(client) {
    if (__privateGet(this, _clients).has(client)) {
      return;
    }
    const subscriptions = new DisposableStack();
    __privateGet(this, _clients).set(client, subscriptions);
    const clientEmitter = subscriptions.use(new EventEmitter$2(client));
    for (const [event, handler] of __privateGet(this, _handlers3)) {
      clientEmitter.on(event, (arg) => {
        return handler.bind(this)(client, arg);
      });
    }
    await Promise.all([
      client.send("Network.enable"),
      __privateMethod(this, _applyExtraHTTPHeaders, applyExtraHTTPHeaders_fn).call(this, client),
      __privateMethod(this, _applyNetworkConditions, applyNetworkConditions_fn).call(this, client),
      __privateMethod(this, _applyProtocolCacheDisabled, applyProtocolCacheDisabled_fn).call(this, client),
      __privateMethod(this, _applyProtocolRequestInterception, applyProtocolRequestInterception_fn).call(this, client),
      __privateMethod(this, _applyUserAgent, applyUserAgent_fn).call(this, client)
    ]);
  }
  async authenticate(credentials) {
    __privateSet(this, _credentials, credentials);
    const enabled = __privateGet(this, _userRequestInterceptionEnabled) || !!__privateGet(this, _credentials);
    if (enabled === __privateGet(this, _protocolRequestInterceptionEnabled)) {
      return;
    }
    __privateSet(this, _protocolRequestInterceptionEnabled, enabled);
    await __privateMethod(this, _applyToAllClients, applyToAllClients_fn).call(this, __privateMethod(this, _applyProtocolRequestInterception, applyProtocolRequestInterception_fn).bind(this));
  }
  async setExtraHTTPHeaders(headers) {
    const extraHTTPHeaders = {};
    for (const [key, value] of Object.entries(headers)) {
      assert$1(isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      extraHTTPHeaders[key.toLowerCase()] = value;
    }
    __privateSet(this, _extraHTTPHeaders, extraHTTPHeaders);
    await __privateMethod(this, _applyToAllClients, applyToAllClients_fn).call(this, __privateMethod(this, _applyExtraHTTPHeaders, applyExtraHTTPHeaders_fn).bind(this));
  }
  extraHTTPHeaders() {
    return Object.assign({}, __privateGet(this, _extraHTTPHeaders));
  }
  inFlightRequestsCount() {
    return __privateGet(this, _networkEventManager).inFlightRequestsCount();
  }
  async setOfflineMode(value) {
    if (!__privateGet(this, _emulatedNetworkConditions)) {
      __privateSet(this, _emulatedNetworkConditions, {
        offline: false,
        upload: -1,
        download: -1,
        latency: 0
      });
    }
    __privateGet(this, _emulatedNetworkConditions).offline = value;
    await __privateMethod(this, _applyToAllClients, applyToAllClients_fn).call(this, __privateMethod(this, _applyNetworkConditions, applyNetworkConditions_fn).bind(this));
  }
  async emulateNetworkConditions(networkConditions) {
    if (!__privateGet(this, _emulatedNetworkConditions)) {
      __privateSet(this, _emulatedNetworkConditions, {
        offline: false,
        upload: -1,
        download: -1,
        latency: 0
      });
    }
    __privateGet(this, _emulatedNetworkConditions).upload = networkConditions ? networkConditions.upload : -1;
    __privateGet(this, _emulatedNetworkConditions).download = networkConditions ? networkConditions.download : -1;
    __privateGet(this, _emulatedNetworkConditions).latency = networkConditions ? networkConditions.latency : 0;
    await __privateMethod(this, _applyToAllClients, applyToAllClients_fn).call(this, __privateMethod(this, _applyNetworkConditions, applyNetworkConditions_fn).bind(this));
  }
  async setUserAgent(userAgent, userAgentMetadata) {
    __privateSet(this, _userAgent, userAgent);
    __privateSet(this, _userAgentMetadata, userAgentMetadata);
    await __privateMethod(this, _applyToAllClients, applyToAllClients_fn).call(this, __privateMethod(this, _applyUserAgent, applyUserAgent_fn).bind(this));
  }
  async setCacheEnabled(enabled) {
    __privateSet(this, _userCacheDisabled, !enabled);
    await __privateMethod(this, _applyToAllClients, applyToAllClients_fn).call(this, __privateMethod(this, _applyProtocolCacheDisabled, applyProtocolCacheDisabled_fn).bind(this));
  }
  async setRequestInterception(value) {
    __privateSet(this, _userRequestInterceptionEnabled, value);
    const enabled = __privateGet(this, _userRequestInterceptionEnabled) || !!__privateGet(this, _credentials);
    if (enabled === __privateGet(this, _protocolRequestInterceptionEnabled)) {
      return;
    }
    __privateSet(this, _protocolRequestInterceptionEnabled, enabled);
    await __privateMethod(this, _applyToAllClients, applyToAllClients_fn).call(this, __privateMethod(this, _applyProtocolRequestInterception, applyProtocolRequestInterception_fn).bind(this));
  }
}
_frameManager = new WeakMap();
_networkEventManager = new WeakMap();
_extraHTTPHeaders = new WeakMap();
_credentials = new WeakMap();
_attemptedAuthentications = new WeakMap();
_userRequestInterceptionEnabled = new WeakMap();
_protocolRequestInterceptionEnabled = new WeakMap();
_userCacheDisabled = new WeakMap();
_emulatedNetworkConditions = new WeakMap();
_userAgent = new WeakMap();
_userAgentMetadata = new WeakMap();
_handlers3 = new WeakMap();
_clients = new WeakMap();
_removeClient = new WeakSet();
removeClient_fn = async function(client) {
  var _a3;
  (_a3 = __privateGet(this, _clients).get(client)) == null ? void 0 : _a3.dispose();
  __privateGet(this, _clients).delete(client);
};
_applyExtraHTTPHeaders = new WeakSet();
applyExtraHTTPHeaders_fn = async function(client) {
  if (__privateGet(this, _extraHTTPHeaders) === void 0) {
    return;
  }
  await client.send("Network.setExtraHTTPHeaders", {
    headers: __privateGet(this, _extraHTTPHeaders)
  });
};
_applyToAllClients = new WeakSet();
applyToAllClients_fn = async function(fn) {
  await Promise.all(Array.from(__privateGet(this, _clients).keys()).map((client) => {
    return fn(client);
  }));
};
_applyNetworkConditions = new WeakSet();
applyNetworkConditions_fn = async function(client) {
  if (__privateGet(this, _emulatedNetworkConditions) === void 0) {
    return;
  }
  await client.send("Network.emulateNetworkConditions", {
    offline: __privateGet(this, _emulatedNetworkConditions).offline,
    latency: __privateGet(this, _emulatedNetworkConditions).latency,
    uploadThroughput: __privateGet(this, _emulatedNetworkConditions).upload,
    downloadThroughput: __privateGet(this, _emulatedNetworkConditions).download
  });
};
_applyUserAgent = new WeakSet();
applyUserAgent_fn = async function(client) {
  if (__privateGet(this, _userAgent) === void 0) {
    return;
  }
  await client.send("Network.setUserAgentOverride", {
    userAgent: __privateGet(this, _userAgent),
    userAgentMetadata: __privateGet(this, _userAgentMetadata)
  });
};
_applyProtocolRequestInterception = new WeakSet();
applyProtocolRequestInterception_fn = async function(client) {
  if (__privateGet(this, _userCacheDisabled) === void 0) {
    __privateSet(this, _userCacheDisabled, false);
  }
  if (__privateGet(this, _protocolRequestInterceptionEnabled)) {
    await Promise.all([
      __privateMethod(this, _applyProtocolCacheDisabled, applyProtocolCacheDisabled_fn).call(this, client),
      client.send("Fetch.enable", {
        handleAuthRequests: true,
        patterns: [{ urlPattern: "*" }]
      })
    ]);
  } else {
    await Promise.all([
      __privateMethod(this, _applyProtocolCacheDisabled, applyProtocolCacheDisabled_fn).call(this, client),
      client.send("Fetch.disable")
    ]);
  }
};
_applyProtocolCacheDisabled = new WeakSet();
applyProtocolCacheDisabled_fn = async function(client) {
  if (__privateGet(this, _userCacheDisabled) === void 0) {
    return;
  }
  await client.send("Network.setCacheDisabled", {
    cacheDisabled: __privateGet(this, _userCacheDisabled)
  });
};
_onRequestWillBeSent = new WeakSet();
onRequestWillBeSent_fn = function(client, event) {
  if (__privateGet(this, _userRequestInterceptionEnabled) && !event.request.url.startsWith("data:")) {
    const { requestId: networkRequestId } = event;
    __privateGet(this, _networkEventManager).storeRequestWillBeSent(networkRequestId, event);
    const requestPausedEvent = __privateGet(this, _networkEventManager).getRequestPaused(networkRequestId);
    if (requestPausedEvent) {
      const { requestId: fetchRequestId } = requestPausedEvent;
      __privateMethod(this, _patchRequestEventHeaders, patchRequestEventHeaders_fn).call(this, event, requestPausedEvent);
      __privateMethod(this, _onRequest2, onRequest_fn2).call(this, client, event, fetchRequestId);
      __privateGet(this, _networkEventManager).forgetRequestPaused(networkRequestId);
    }
    return;
  }
  __privateMethod(this, _onRequest2, onRequest_fn2).call(this, client, event, void 0);
};
_onAuthRequired = new WeakSet();
onAuthRequired_fn = function(client, event) {
  let response = "Default";
  if (__privateGet(this, _attemptedAuthentications).has(event.requestId)) {
    response = "CancelAuth";
  } else if (__privateGet(this, _credentials)) {
    response = "ProvideCredentials";
    __privateGet(this, _attemptedAuthentications).add(event.requestId);
  }
  const { username, password } = __privateGet(this, _credentials) || {
    username: void 0,
    password: void 0
  };
  client.send("Fetch.continueWithAuth", {
    requestId: event.requestId,
    authChallengeResponse: { response, username, password }
  }).catch(debugError);
};
_onRequestPaused = new WeakSet();
onRequestPaused_fn = function(client, event) {
  if (!__privateGet(this, _userRequestInterceptionEnabled) && __privateGet(this, _protocolRequestInterceptionEnabled)) {
    client.send("Fetch.continueRequest", {
      requestId: event.requestId
    }).catch(debugError);
  }
  const { networkId: networkRequestId, requestId: fetchRequestId } = event;
  if (!networkRequestId) {
    __privateMethod(this, _onRequestWithoutNetworkInstrumentation, onRequestWithoutNetworkInstrumentation_fn).call(this, client, event);
    return;
  }
  const requestWillBeSentEvent = (() => {
    const requestWillBeSentEvent2 = __privateGet(this, _networkEventManager).getRequestWillBeSent(networkRequestId);
    if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
      __privateGet(this, _networkEventManager).forgetRequestWillBeSent(networkRequestId);
      return;
    }
    return requestWillBeSentEvent2;
  })();
  if (requestWillBeSentEvent) {
    __privateMethod(this, _patchRequestEventHeaders, patchRequestEventHeaders_fn).call(this, requestWillBeSentEvent, event);
    __privateMethod(this, _onRequest2, onRequest_fn2).call(this, client, requestWillBeSentEvent, fetchRequestId);
  } else {
    __privateGet(this, _networkEventManager).storeRequestPaused(networkRequestId, event);
  }
};
_patchRequestEventHeaders = new WeakSet();
patchRequestEventHeaders_fn = function(requestWillBeSentEvent, requestPausedEvent) {
  requestWillBeSentEvent.request.headers = {
    ...requestWillBeSentEvent.request.headers,
    // includes extra headers, like: Accept, Origin
    ...requestPausedEvent.request.headers
  };
};
_onRequestWithoutNetworkInstrumentation = new WeakSet();
onRequestWithoutNetworkInstrumentation_fn = function(client, event) {
  const frame = event.frameId ? __privateGet(this, _frameManager).frame(event.frameId) : null;
  const request = new CdpHTTPRequest(client, frame, event.requestId, __privateGet(this, _userRequestInterceptionEnabled), event, []);
  this.emit(NetworkManagerEvent.Request, request);
  void request.finalizeInterceptions();
};
_onRequest2 = new WeakSet();
onRequest_fn2 = function(client, event, fetchRequestId) {
  let redirectChain = [];
  if (event.redirectResponse) {
    let redirectResponseExtraInfo = null;
    if (event.redirectHasExtraInfo) {
      redirectResponseExtraInfo = __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).shift();
      if (!redirectResponseExtraInfo) {
        __privateGet(this, _networkEventManager).queueRedirectInfo(event.requestId, {
          event,
          fetchRequestId
        });
        return;
      }
    }
    const request2 = __privateGet(this, _networkEventManager).getRequest(event.requestId);
    if (request2) {
      __privateMethod(this, _handleRequestRedirect, handleRequestRedirect_fn).call(this, client, request2, event.redirectResponse, redirectResponseExtraInfo);
      redirectChain = request2._redirectChain;
    }
  }
  const frame = event.frameId ? __privateGet(this, _frameManager).frame(event.frameId) : null;
  const request = new CdpHTTPRequest(client, frame, fetchRequestId, __privateGet(this, _userRequestInterceptionEnabled), event, redirectChain);
  __privateGet(this, _networkEventManager).storeRequest(event.requestId, request);
  this.emit(NetworkManagerEvent.Request, request);
  void request.finalizeInterceptions();
};
_onRequestServedFromCache = new WeakSet();
onRequestServedFromCache_fn = function(_client16, event) {
  const request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
  if (request) {
    request._fromMemoryCache = true;
  }
  this.emit(NetworkManagerEvent.RequestServedFromCache, request);
};
_handleRequestRedirect = new WeakSet();
handleRequestRedirect_fn = function(client, request, responsePayload, extraInfo) {
  const response = new CdpHTTPResponse(client, request, responsePayload, extraInfo);
  request._response = response;
  request._redirectChain.push(request);
  response._resolveBody(new Error("Response body is unavailable for redirect responses"));
  __privateMethod(this, _forgetRequest, forgetRequest_fn).call(this, request, false);
  this.emit(NetworkManagerEvent.Response, response);
  this.emit(NetworkManagerEvent.RequestFinished, request);
};
_emitResponseEvent = new WeakSet();
emitResponseEvent_fn = function(client, responseReceived, extraInfo) {
  const request = __privateGet(this, _networkEventManager).getRequest(responseReceived.requestId);
  if (!request) {
    return;
  }
  const extraInfos = __privateGet(this, _networkEventManager).responseExtraInfo(responseReceived.requestId);
  if (extraInfos.length) {
    debugError(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
  }
  if (responseReceived.response.fromDiskCache) {
    extraInfo = null;
  }
  const response = new CdpHTTPResponse(client, request, responseReceived.response, extraInfo);
  request._response = response;
  this.emit(NetworkManagerEvent.Response, response);
};
_onResponseReceived = new WeakSet();
onResponseReceived_fn = function(client, event) {
  const request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
  let extraInfo = null;
  if (request && !request._fromMemoryCache && event.hasExtraInfo) {
    extraInfo = __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).shift();
    if (!extraInfo) {
      __privateGet(this, _networkEventManager).queueEventGroup(event.requestId, {
        responseReceivedEvent: event
      });
      return;
    }
  }
  __privateMethod(this, _emitResponseEvent, emitResponseEvent_fn).call(this, client, event, extraInfo);
};
_onResponseReceivedExtraInfo = new WeakSet();
onResponseReceivedExtraInfo_fn = function(client, event) {
  const redirectInfo = __privateGet(this, _networkEventManager).takeQueuedRedirectInfo(event.requestId);
  if (redirectInfo) {
    __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).push(event);
    __privateMethod(this, _onRequest2, onRequest_fn2).call(this, client, redirectInfo.event, redirectInfo.fetchRequestId);
    return;
  }
  const queuedEvents = __privateGet(this, _networkEventManager).getQueuedEventGroup(event.requestId);
  if (queuedEvents) {
    __privateGet(this, _networkEventManager).forgetQueuedEventGroup(event.requestId);
    __privateMethod(this, _emitResponseEvent, emitResponseEvent_fn).call(this, client, queuedEvents.responseReceivedEvent, event);
    if (queuedEvents.loadingFinishedEvent) {
      __privateMethod(this, _emitLoadingFinished, emitLoadingFinished_fn).call(this, queuedEvents.loadingFinishedEvent);
    }
    if (queuedEvents.loadingFailedEvent) {
      __privateMethod(this, _emitLoadingFailed, emitLoadingFailed_fn).call(this, queuedEvents.loadingFailedEvent);
    }
    return;
  }
  __privateGet(this, _networkEventManager).responseExtraInfo(event.requestId).push(event);
};
_forgetRequest = new WeakSet();
forgetRequest_fn = function(request, events) {
  const requestId = request.id;
  const interceptionId = request._interceptionId;
  __privateGet(this, _networkEventManager).forgetRequest(requestId);
  interceptionId !== void 0 && __privateGet(this, _attemptedAuthentications).delete(interceptionId);
  if (events) {
    __privateGet(this, _networkEventManager).forget(requestId);
  }
};
_onLoadingFinished = new WeakSet();
onLoadingFinished_fn = function(_client16, event) {
  const queuedEvents = __privateGet(this, _networkEventManager).getQueuedEventGroup(event.requestId);
  if (queuedEvents) {
    queuedEvents.loadingFinishedEvent = event;
  } else {
    __privateMethod(this, _emitLoadingFinished, emitLoadingFinished_fn).call(this, event);
  }
};
_emitLoadingFinished = new WeakSet();
emitLoadingFinished_fn = function(event) {
  var _a3;
  const request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
  if (!request) {
    return;
  }
  if (request.response()) {
    (_a3 = request.response()) == null ? void 0 : _a3._resolveBody();
  }
  __privateMethod(this, _forgetRequest, forgetRequest_fn).call(this, request, true);
  this.emit(NetworkManagerEvent.RequestFinished, request);
};
_onLoadingFailed = new WeakSet();
onLoadingFailed_fn = function(_client16, event) {
  const queuedEvents = __privateGet(this, _networkEventManager).getQueuedEventGroup(event.requestId);
  if (queuedEvents) {
    queuedEvents.loadingFailedEvent = event;
  } else {
    __privateMethod(this, _emitLoadingFailed, emitLoadingFailed_fn).call(this, event);
  }
};
_emitLoadingFailed = new WeakSet();
emitLoadingFailed_fn = function(event) {
  const request = __privateGet(this, _networkEventManager).getRequest(event.requestId);
  if (!request) {
    return;
  }
  request._failureText = event.errorText;
  const response = request.response();
  if (response) {
    response._resolveBody();
  }
  __privateMethod(this, _forgetRequest, forgetRequest_fn).call(this, request, true);
  this.emit(NetworkManagerEvent.RequestFailed, request);
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const TIME_FOR_WAITING_FOR_SWAP = 100;
class FrameManager extends EventEmitter$2 {
  constructor(client, page, timeoutSettings) {
    super();
    /**
     * Called when the frame's client is disconnected. We don't know if the
     * disconnect means that the frame is removed or if it will be replaced by a
     * new frame. Therefore, we wait for a swap event.
     */
    __privateAdd(this, _onClientDisconnect);
    __privateAdd(this, _onLifecycleEvent);
    __privateAdd(this, _onFrameStartedLoading);
    __privateAdd(this, _onFrameStoppedLoading);
    __privateAdd(this, _handleFrameTree);
    __privateAdd(this, _onFrameAttached);
    __privateAdd(this, _onFrameNavigated);
    __privateAdd(this, _createIsolatedWorld);
    __privateAdd(this, _onFrameNavigatedWithinDocument);
    __privateAdd(this, _onFrameDetached2);
    __privateAdd(this, _onExecutionContextCreated);
    __privateAdd(this, _removeFramesRecursively);
    __privateAdd(this, _page, void 0);
    __privateAdd(this, _networkManager, void 0);
    __privateAdd(this, _timeoutSettings3, void 0);
    __privateAdd(this, _isolatedWorlds, /* @__PURE__ */ new Set());
    __privateAdd(this, _client10, void 0);
    __publicField(this, "_frameTree", new FrameTree());
    /**
     * Set of frame IDs stored to indicate if a frame has received a
     * frameNavigated event so that frame tree responses could be ignored as the
     * frameNavigated event usually contains the latest information.
     */
    __privateAdd(this, _frameNavigatedReceived, /* @__PURE__ */ new Set());
    __privateAdd(this, _deviceRequestPromptManagerMap, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _frameTreeHandled, void 0);
    __privateSet(this, _client10, client);
    __privateSet(this, _page, page);
    __privateSet(this, _networkManager, new NetworkManager(this));
    __privateSet(this, _timeoutSettings3, timeoutSettings);
    this.setupEventListeners(__privateGet(this, _client10));
    client.once(CDPSessionEvent.Disconnected, () => {
      __privateMethod(this, _onClientDisconnect, onClientDisconnect_fn).call(this).catch(debugError);
    });
  }
  get timeoutSettings() {
    return __privateGet(this, _timeoutSettings3);
  }
  get networkManager() {
    return __privateGet(this, _networkManager);
  }
  get client() {
    return __privateGet(this, _client10);
  }
  /**
   * When the main frame is replaced by another main frame,
   * we maintain the main frame object identity while updating
   * its frame tree and ID.
   */
  async swapFrameTree(client) {
    __privateSet(this, _client10, client);
    assert$1(__privateGet(this, _client10) instanceof CdpCDPSession, "CDPSession is not an instance of CDPSessionImpl.");
    const frame = this._frameTree.getMainFrame();
    if (frame) {
      __privateGet(this, _frameNavigatedReceived).add(__privateGet(this, _client10)._target()._targetId);
      this._frameTree.removeFrame(frame);
      frame.updateId(__privateGet(this, _client10)._target()._targetId);
      this._frameTree.addFrame(frame);
      frame.updateClient(client);
    }
    this.setupEventListeners(client);
    client.once(CDPSessionEvent.Disconnected, () => {
      __privateMethod(this, _onClientDisconnect, onClientDisconnect_fn).call(this).catch(debugError);
    });
    await this.initialize(client);
    await __privateGet(this, _networkManager).addClient(client);
    if (frame) {
      frame.emit(FrameEvent.FrameSwappedByActivation, void 0);
    }
  }
  async registerSpeculativeSession(client) {
    await __privateGet(this, _networkManager).addClient(client);
  }
  setupEventListeners(session) {
    session.on("Page.frameAttached", async (event) => {
      var _a3;
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      __privateMethod(this, _onFrameAttached, onFrameAttached_fn).call(this, session, event.frameId, event.parentFrameId);
    });
    session.on("Page.frameNavigated", async (event) => {
      var _a3;
      __privateGet(this, _frameNavigatedReceived).add(event.frame.id);
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      void __privateMethod(this, _onFrameNavigated, onFrameNavigated_fn).call(this, event.frame, event.type);
    });
    session.on("Page.navigatedWithinDocument", async (event) => {
      var _a3;
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      __privateMethod(this, _onFrameNavigatedWithinDocument, onFrameNavigatedWithinDocument_fn).call(this, event.frameId, event.url);
    });
    session.on("Page.frameDetached", async (event) => {
      var _a3;
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      __privateMethod(this, _onFrameDetached2, onFrameDetached_fn2).call(this, event.frameId, event.reason);
    });
    session.on("Page.frameStartedLoading", async (event) => {
      var _a3;
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      __privateMethod(this, _onFrameStartedLoading, onFrameStartedLoading_fn).call(this, event.frameId);
    });
    session.on("Page.frameStoppedLoading", async (event) => {
      var _a3;
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      __privateMethod(this, _onFrameStoppedLoading, onFrameStoppedLoading_fn).call(this, event.frameId);
    });
    session.on("Runtime.executionContextCreated", async (event) => {
      var _a3;
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      __privateMethod(this, _onExecutionContextCreated, onExecutionContextCreated_fn).call(this, event.context, session);
    });
    session.on("Page.lifecycleEvent", async (event) => {
      var _a3;
      await ((_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.valueOrThrow());
      __privateMethod(this, _onLifecycleEvent, onLifecycleEvent_fn).call(this, event);
    });
  }
  async initialize(client) {
    var _a3, _b3;
    try {
      (_a3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a3.resolve();
      __privateSet(this, _frameTreeHandled, Deferred.create());
      await Promise.all([
        __privateGet(this, _networkManager).addClient(client),
        client.send("Page.enable"),
        client.send("Page.getFrameTree").then(({ frameTree }) => {
          var _a4;
          __privateMethod(this, _handleFrameTree, handleFrameTree_fn).call(this, client, frameTree);
          (_a4 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _a4.resolve();
        }),
        client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
        client.send("Runtime.enable").then(() => {
          return __privateMethod(this, _createIsolatedWorld, createIsolatedWorld_fn).call(this, client, UTILITY_WORLD_NAME);
        })
      ]);
    } catch (error) {
      (_b3 = __privateGet(this, _frameTreeHandled)) == null ? void 0 : _b3.resolve();
      if (isErrorLike$1(error) && isTargetClosedError(error)) {
        return;
      }
      throw error;
    }
  }
  page() {
    return __privateGet(this, _page);
  }
  mainFrame() {
    const mainFrame = this._frameTree.getMainFrame();
    assert$1(mainFrame, "Requesting main frame too early!");
    return mainFrame;
  }
  frames() {
    return Array.from(this._frameTree.frames());
  }
  frame(frameId) {
    return this._frameTree.getById(frameId) || null;
  }
  onAttachedToTarget(target) {
    if (target._getTargetInfo().type !== "iframe") {
      return;
    }
    const frame = this.frame(target._getTargetInfo().targetId);
    if (frame) {
      frame.updateClient(target._session());
    }
    this.setupEventListeners(target._session());
    void this.initialize(target._session());
  }
  _deviceRequestPromptManager(client) {
    let manager = __privateGet(this, _deviceRequestPromptManagerMap).get(client);
    if (manager === void 0) {
      manager = new DeviceRequestPromptManager(client, __privateGet(this, _timeoutSettings3));
      __privateGet(this, _deviceRequestPromptManagerMap).set(client, manager);
    }
    return manager;
  }
}
_page = new WeakMap();
_networkManager = new WeakMap();
_timeoutSettings3 = new WeakMap();
_isolatedWorlds = new WeakMap();
_client10 = new WeakMap();
_frameNavigatedReceived = new WeakMap();
_deviceRequestPromptManagerMap = new WeakMap();
_frameTreeHandled = new WeakMap();
_onClientDisconnect = new WeakSet();
onClientDisconnect_fn = async function() {
  const mainFrame = this._frameTree.getMainFrame();
  if (!mainFrame) {
    return;
  }
  for (const child of mainFrame.childFrames()) {
    __privateMethod(this, _removeFramesRecursively, removeFramesRecursively_fn).call(this, child);
  }
  const swapped = Deferred.create({
    timeout: TIME_FOR_WAITING_FOR_SWAP,
    message: "Frame was not swapped"
  });
  mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {
    swapped.resolve();
  });
  try {
    await swapped.valueOrThrow();
  } catch (err) {
    __privateMethod(this, _removeFramesRecursively, removeFramesRecursively_fn).call(this, mainFrame);
  }
};
_onLifecycleEvent = new WeakSet();
onLifecycleEvent_fn = function(event) {
  const frame = this.frame(event.frameId);
  if (!frame) {
    return;
  }
  frame._onLifecycleEvent(event.loaderId, event.name);
  this.emit(FrameManagerEvent.LifecycleEvent, frame);
  frame.emit(FrameEvent.LifecycleEvent, void 0);
};
_onFrameStartedLoading = new WeakSet();
onFrameStartedLoading_fn = function(frameId) {
  const frame = this.frame(frameId);
  if (!frame) {
    return;
  }
  frame._onLoadingStarted();
};
_onFrameStoppedLoading = new WeakSet();
onFrameStoppedLoading_fn = function(frameId) {
  const frame = this.frame(frameId);
  if (!frame) {
    return;
  }
  frame._onLoadingStopped();
  this.emit(FrameManagerEvent.LifecycleEvent, frame);
  frame.emit(FrameEvent.LifecycleEvent, void 0);
};
_handleFrameTree = new WeakSet();
handleFrameTree_fn = function(session, frameTree) {
  if (frameTree.frame.parentId) {
    __privateMethod(this, _onFrameAttached, onFrameAttached_fn).call(this, session, frameTree.frame.id, frameTree.frame.parentId);
  }
  if (!__privateGet(this, _frameNavigatedReceived).has(frameTree.frame.id)) {
    void __privateMethod(this, _onFrameNavigated, onFrameNavigated_fn).call(this, frameTree.frame, "Navigation");
  } else {
    __privateGet(this, _frameNavigatedReceived).delete(frameTree.frame.id);
  }
  if (!frameTree.childFrames) {
    return;
  }
  for (const child of frameTree.childFrames) {
    __privateMethod(this, _handleFrameTree, handleFrameTree_fn).call(this, session, child);
  }
};
_onFrameAttached = new WeakSet();
onFrameAttached_fn = function(session, frameId, parentFrameId) {
  let frame = this.frame(frameId);
  if (frame) {
    if (session && frame.isOOPFrame()) {
      frame.updateClient(session);
    }
    return;
  }
  frame = new CdpFrame(this, frameId, parentFrameId, session);
  this._frameTree.addFrame(frame);
  this.emit(FrameManagerEvent.FrameAttached, frame);
};
_onFrameNavigated = new WeakSet();
onFrameNavigated_fn = async function(framePayload, navigationType) {
  const frameId = framePayload.id;
  const isMainFrame = !framePayload.parentId;
  let frame = this._frameTree.getById(frameId);
  if (frame) {
    for (const child of frame.childFrames()) {
      __privateMethod(this, _removeFramesRecursively, removeFramesRecursively_fn).call(this, child);
    }
  }
  if (isMainFrame) {
    if (frame) {
      this._frameTree.removeFrame(frame);
      frame._id = frameId;
    } else {
      frame = new CdpFrame(this, frameId, void 0, __privateGet(this, _client10));
    }
    this._frameTree.addFrame(frame);
  }
  frame = await this._frameTree.waitForFrame(frameId);
  frame._navigated(framePayload);
  this.emit(FrameManagerEvent.FrameNavigated, frame);
  frame.emit(FrameEvent.FrameNavigated, navigationType);
};
_createIsolatedWorld = new WeakSet();
createIsolatedWorld_fn = async function(session, name2) {
  const key = `${session.id()}:${name2}`;
  if (__privateGet(this, _isolatedWorlds).has(key)) {
    return;
  }
  await session.send("Page.addScriptToEvaluateOnNewDocument", {
    source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
    worldName: name2
  });
  await Promise.all(this.frames().filter((frame) => {
    return frame.client === session;
  }).map((frame) => {
    return session.send("Page.createIsolatedWorld", {
      frameId: frame._id,
      worldName: name2,
      grantUniveralAccess: true
    }).catch(debugError);
  }));
  __privateGet(this, _isolatedWorlds).add(key);
};
_onFrameNavigatedWithinDocument = new WeakSet();
onFrameNavigatedWithinDocument_fn = function(frameId, url) {
  const frame = this.frame(frameId);
  if (!frame) {
    return;
  }
  frame._navigatedWithinDocument(url);
  this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);
  frame.emit(FrameEvent.FrameNavigatedWithinDocument, void 0);
  this.emit(FrameManagerEvent.FrameNavigated, frame);
  frame.emit(FrameEvent.FrameNavigated, "Navigation");
};
_onFrameDetached2 = new WeakSet();
onFrameDetached_fn2 = function(frameId, reason) {
  const frame = this.frame(frameId);
  if (!frame) {
    return;
  }
  switch (reason) {
    case "remove":
      __privateMethod(this, _removeFramesRecursively, removeFramesRecursively_fn).call(this, frame);
      break;
    case "swap":
      this.emit(FrameManagerEvent.FrameSwapped, frame);
      frame.emit(FrameEvent.FrameSwapped, void 0);
      break;
  }
};
_onExecutionContextCreated = new WeakSet();
onExecutionContextCreated_fn = function(contextPayload, session) {
  const auxData = contextPayload.auxData;
  const frameId = auxData && auxData.frameId;
  const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
  let world;
  if (frame) {
    if (frame.client !== session) {
      return;
    }
    if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
      world = frame.worlds[MAIN_WORLD];
    } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[PUPPETEER_WORLD].hasContext()) {
      world = frame.worlds[PUPPETEER_WORLD];
    }
  }
  if (!world) {
    return;
  }
  const context2 = new ExecutionContext((frame == null ? void 0 : frame.client) || __privateGet(this, _client10), contextPayload, world);
  world.setContext(context2);
};
_removeFramesRecursively = new WeakSet();
removeFramesRecursively_fn = function(frame) {
  for (const child of frame.childFrames()) {
    __privateMethod(this, _removeFramesRecursively, removeFramesRecursively_fn).call(this, child);
  }
  frame[disposeSymbol]();
  this._frameTree.removeFrame(frame);
  this.emit(FrameManagerEvent.FrameDetached, frame);
  frame.emit(FrameEvent.FrameDetached, frame);
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _keyDefinitions = {
  "0": { keyCode: 48, key: "0", code: "Digit0" },
  "1": { keyCode: 49, key: "1", code: "Digit1" },
  "2": { keyCode: 50, key: "2", code: "Digit2" },
  "3": { keyCode: 51, key: "3", code: "Digit3" },
  "4": { keyCode: 52, key: "4", code: "Digit4" },
  "5": { keyCode: 53, key: "5", code: "Digit5" },
  "6": { keyCode: 54, key: "6", code: "Digit6" },
  "7": { keyCode: 55, key: "7", code: "Digit7" },
  "8": { keyCode: 56, key: "8", code: "Digit8" },
  "9": { keyCode: 57, key: "9", code: "Digit9" },
  Power: { key: "Power", code: "Power" },
  Eject: { key: "Eject", code: "Eject" },
  Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
  Help: { keyCode: 6, code: "Help", key: "Help" },
  Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
  Tab: { keyCode: 9, code: "Tab", key: "Tab" },
  Numpad5: {
    keyCode: 12,
    shiftKeyCode: 101,
    key: "Clear",
    code: "Numpad5",
    shiftKey: "5",
    location: 3
  },
  NumpadEnter: {
    keyCode: 13,
    code: "NumpadEnter",
    key: "Enter",
    text: "\r",
    location: 3
  },
  Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
  ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
  ControlLeft: {
    keyCode: 17,
    code: "ControlLeft",
    key: "Control",
    location: 1
  },
  ControlRight: {
    keyCode: 17,
    code: "ControlRight",
    key: "Control",
    location: 2
  },
  AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
  AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
  Pause: { keyCode: 19, code: "Pause", key: "Pause" },
  CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
  Escape: { keyCode: 27, code: "Escape", key: "Escape" },
  Convert: { keyCode: 28, code: "Convert", key: "Convert" },
  NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
  Space: { keyCode: 32, code: "Space", key: " " },
  Numpad9: {
    keyCode: 33,
    shiftKeyCode: 105,
    key: "PageUp",
    code: "Numpad9",
    shiftKey: "9",
    location: 3
  },
  PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
  Numpad3: {
    keyCode: 34,
    shiftKeyCode: 99,
    key: "PageDown",
    code: "Numpad3",
    shiftKey: "3",
    location: 3
  },
  PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
  End: { keyCode: 35, code: "End", key: "End" },
  Numpad1: {
    keyCode: 35,
    shiftKeyCode: 97,
    key: "End",
    code: "Numpad1",
    shiftKey: "1",
    location: 3
  },
  Home: { keyCode: 36, code: "Home", key: "Home" },
  Numpad7: {
    keyCode: 36,
    shiftKeyCode: 103,
    key: "Home",
    code: "Numpad7",
    shiftKey: "7",
    location: 3
  },
  ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
  Numpad4: {
    keyCode: 37,
    shiftKeyCode: 100,
    key: "ArrowLeft",
    code: "Numpad4",
    shiftKey: "4",
    location: 3
  },
  Numpad8: {
    keyCode: 38,
    shiftKeyCode: 104,
    key: "ArrowUp",
    code: "Numpad8",
    shiftKey: "8",
    location: 3
  },
  ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
  ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
  Numpad6: {
    keyCode: 39,
    shiftKeyCode: 102,
    key: "ArrowRight",
    code: "Numpad6",
    shiftKey: "6",
    location: 3
  },
  Numpad2: {
    keyCode: 40,
    shiftKeyCode: 98,
    key: "ArrowDown",
    code: "Numpad2",
    shiftKey: "2",
    location: 3
  },
  ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
  Select: { keyCode: 41, code: "Select", key: "Select" },
  Open: { keyCode: 43, code: "Open", key: "Execute" },
  PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
  Insert: { keyCode: 45, code: "Insert", key: "Insert" },
  Numpad0: {
    keyCode: 45,
    shiftKeyCode: 96,
    key: "Insert",
    code: "Numpad0",
    shiftKey: "0",
    location: 3
  },
  Delete: { keyCode: 46, code: "Delete", key: "Delete" },
  NumpadDecimal: {
    keyCode: 46,
    shiftKeyCode: 110,
    code: "NumpadDecimal",
    key: "\0",
    shiftKey: ".",
    location: 3
  },
  Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
  Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
  Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
  Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
  Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
  Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
  Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
  Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
  Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
  Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
  KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
  KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
  KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
  KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
  KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
  KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
  KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
  KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
  KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
  KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
  KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
  KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
  KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
  KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
  KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
  KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
  KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
  KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
  KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
  KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
  KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
  KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
  KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
  KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
  KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
  KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
  MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
  MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
  ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
  NumpadMultiply: {
    keyCode: 106,
    code: "NumpadMultiply",
    key: "*",
    location: 3
  },
  NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
  NumpadSubtract: {
    keyCode: 109,
    code: "NumpadSubtract",
    key: "-",
    location: 3
  },
  NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
  F1: { keyCode: 112, code: "F1", key: "F1" },
  F2: { keyCode: 113, code: "F2", key: "F2" },
  F3: { keyCode: 114, code: "F3", key: "F3" },
  F4: { keyCode: 115, code: "F4", key: "F4" },
  F5: { keyCode: 116, code: "F5", key: "F5" },
  F6: { keyCode: 117, code: "F6", key: "F6" },
  F7: { keyCode: 118, code: "F7", key: "F7" },
  F8: { keyCode: 119, code: "F8", key: "F8" },
  F9: { keyCode: 120, code: "F9", key: "F9" },
  F10: { keyCode: 121, code: "F10", key: "F10" },
  F11: { keyCode: 122, code: "F11", key: "F11" },
  F12: { keyCode: 123, code: "F12", key: "F12" },
  F13: { keyCode: 124, code: "F13", key: "F13" },
  F14: { keyCode: 125, code: "F14", key: "F14" },
  F15: { keyCode: 126, code: "F15", key: "F15" },
  F16: { keyCode: 127, code: "F16", key: "F16" },
  F17: { keyCode: 128, code: "F17", key: "F17" },
  F18: { keyCode: 129, code: "F18", key: "F18" },
  F19: { keyCode: 130, code: "F19", key: "F19" },
  F20: { keyCode: 131, code: "F20", key: "F20" },
  F21: { keyCode: 132, code: "F21", key: "F21" },
  F22: { keyCode: 133, code: "F22", key: "F22" },
  F23: { keyCode: 134, code: "F23", key: "F23" },
  F24: { keyCode: 135, code: "F24", key: "F24" },
  NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
  ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
  AudioVolumeMute: {
    keyCode: 173,
    code: "AudioVolumeMute",
    key: "AudioVolumeMute"
  },
  AudioVolumeDown: {
    keyCode: 174,
    code: "AudioVolumeDown",
    key: "AudioVolumeDown"
  },
  AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
  MediaTrackNext: {
    keyCode: 176,
    code: "MediaTrackNext",
    key: "MediaTrackNext"
  },
  MediaTrackPrevious: {
    keyCode: 177,
    code: "MediaTrackPrevious",
    key: "MediaTrackPrevious"
  },
  MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
  MediaPlayPause: {
    keyCode: 179,
    code: "MediaPlayPause",
    key: "MediaPlayPause"
  },
  Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
  Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
  NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
  Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
  Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
  Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
  Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
  Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
  BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
  Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
  BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
  Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
  AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
  Props: { keyCode: 247, code: "Props", key: "CrSel" },
  Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
  Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
  Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
  Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
  Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
  Accept: { keyCode: 30, key: "Accept" },
  ModeChange: { keyCode: 31, key: "ModeChange" },
  " ": { keyCode: 32, key: " ", code: "Space" },
  Print: { keyCode: 42, key: "Print" },
  Execute: { keyCode: 43, key: "Execute", code: "Open" },
  "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
  a: { keyCode: 65, key: "a", code: "KeyA" },
  b: { keyCode: 66, key: "b", code: "KeyB" },
  c: { keyCode: 67, key: "c", code: "KeyC" },
  d: { keyCode: 68, key: "d", code: "KeyD" },
  e: { keyCode: 69, key: "e", code: "KeyE" },
  f: { keyCode: 70, key: "f", code: "KeyF" },
  g: { keyCode: 71, key: "g", code: "KeyG" },
  h: { keyCode: 72, key: "h", code: "KeyH" },
  i: { keyCode: 73, key: "i", code: "KeyI" },
  j: { keyCode: 74, key: "j", code: "KeyJ" },
  k: { keyCode: 75, key: "k", code: "KeyK" },
  l: { keyCode: 76, key: "l", code: "KeyL" },
  m: { keyCode: 77, key: "m", code: "KeyM" },
  n: { keyCode: 78, key: "n", code: "KeyN" },
  o: { keyCode: 79, key: "o", code: "KeyO" },
  p: { keyCode: 80, key: "p", code: "KeyP" },
  q: { keyCode: 81, key: "q", code: "KeyQ" },
  r: { keyCode: 82, key: "r", code: "KeyR" },
  s: { keyCode: 83, key: "s", code: "KeyS" },
  t: { keyCode: 84, key: "t", code: "KeyT" },
  u: { keyCode: 85, key: "u", code: "KeyU" },
  v: { keyCode: 86, key: "v", code: "KeyV" },
  w: { keyCode: 87, key: "w", code: "KeyW" },
  x: { keyCode: 88, key: "x", code: "KeyX" },
  y: { keyCode: 89, key: "y", code: "KeyY" },
  z: { keyCode: 90, key: "z", code: "KeyZ" },
  Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
  "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
  "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
  "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
  "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
  ";": { keyCode: 186, key: ";", code: "Semicolon" },
  "=": { keyCode: 187, key: "=", code: "Equal" },
  ",": { keyCode: 188, key: ",", code: "Comma" },
  ".": { keyCode: 190, key: ".", code: "Period" },
  "`": { keyCode: 192, key: "`", code: "Backquote" },
  "[": { keyCode: 219, key: "[", code: "BracketLeft" },
  "\\": { keyCode: 220, key: "\\", code: "Backslash" },
  "]": { keyCode: 221, key: "]", code: "BracketRight" },
  "'": { keyCode: 222, key: "'", code: "Quote" },
  Attn: { keyCode: 246, key: "Attn" },
  CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
  ExSel: { keyCode: 248, key: "ExSel" },
  EraseEof: { keyCode: 249, key: "EraseEof" },
  Play: { keyCode: 250, key: "Play" },
  ZoomOut: { keyCode: 251, key: "ZoomOut" },
  ")": { keyCode: 48, key: ")", code: "Digit0" },
  "!": { keyCode: 49, key: "!", code: "Digit1" },
  "@": { keyCode: 50, key: "@", code: "Digit2" },
  "#": { keyCode: 51, key: "#", code: "Digit3" },
  $: { keyCode: 52, key: "$", code: "Digit4" },
  "%": { keyCode: 53, key: "%", code: "Digit5" },
  "^": { keyCode: 54, key: "^", code: "Digit6" },
  "&": { keyCode: 55, key: "&", code: "Digit7" },
  "(": { keyCode: 57, key: "(", code: "Digit9" },
  A: { keyCode: 65, key: "A", code: "KeyA" },
  B: { keyCode: 66, key: "B", code: "KeyB" },
  C: { keyCode: 67, key: "C", code: "KeyC" },
  D: { keyCode: 68, key: "D", code: "KeyD" },
  E: { keyCode: 69, key: "E", code: "KeyE" },
  F: { keyCode: 70, key: "F", code: "KeyF" },
  G: { keyCode: 71, key: "G", code: "KeyG" },
  H: { keyCode: 72, key: "H", code: "KeyH" },
  I: { keyCode: 73, key: "I", code: "KeyI" },
  J: { keyCode: 74, key: "J", code: "KeyJ" },
  K: { keyCode: 75, key: "K", code: "KeyK" },
  L: { keyCode: 76, key: "L", code: "KeyL" },
  M: { keyCode: 77, key: "M", code: "KeyM" },
  N: { keyCode: 78, key: "N", code: "KeyN" },
  O: { keyCode: 79, key: "O", code: "KeyO" },
  P: { keyCode: 80, key: "P", code: "KeyP" },
  Q: { keyCode: 81, key: "Q", code: "KeyQ" },
  R: { keyCode: 82, key: "R", code: "KeyR" },
  S: { keyCode: 83, key: "S", code: "KeyS" },
  T: { keyCode: 84, key: "T", code: "KeyT" },
  U: { keyCode: 85, key: "U", code: "KeyU" },
  V: { keyCode: 86, key: "V", code: "KeyV" },
  W: { keyCode: 87, key: "W", code: "KeyW" },
  X: { keyCode: 88, key: "X", code: "KeyX" },
  Y: { keyCode: 89, key: "Y", code: "KeyY" },
  Z: { keyCode: 90, key: "Z", code: "KeyZ" },
  ":": { keyCode: 186, key: ":", code: "Semicolon" },
  "<": { keyCode: 188, key: "<", code: "Comma" },
  _: { keyCode: 189, key: "_", code: "Minus" },
  ">": { keyCode: 190, key: ">", code: "Period" },
  "?": { keyCode: 191, key: "?", code: "Slash" },
  "~": { keyCode: 192, key: "~", code: "Backquote" },
  "{": { keyCode: 219, key: "{", code: "BracketLeft" },
  "|": { keyCode: 220, key: "|", code: "Backslash" },
  "}": { keyCode: 221, key: "}", code: "BracketRight" },
  '"': { keyCode: 222, key: '"', code: "Quote" },
  SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
  SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
  Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
  Call: { key: "Call", code: "Call", location: 4 },
  EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
  VolumeDown: {
    keyCode: 182,
    key: "VolumeDown",
    code: "VolumeDown",
    location: 4
  },
  VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class CdpKeyboard extends Keyboard {
  constructor(client) {
    super();
    __privateAdd(this, _modifierBit);
    __privateAdd(this, _keyDescriptionForString);
    __privateAdd(this, _client11, void 0);
    __privateAdd(this, _pressedKeys, /* @__PURE__ */ new Set());
    __publicField(this, "_modifiers", 0);
    __privateSet(this, _client11, client);
  }
  updateClient(client) {
    __privateSet(this, _client11, client);
  }
  async down(key, options = {
    text: void 0,
    commands: []
  }) {
    const description2 = __privateMethod(this, _keyDescriptionForString, keyDescriptionForString_fn).call(this, key);
    const autoRepeat = __privateGet(this, _pressedKeys).has(description2.code);
    __privateGet(this, _pressedKeys).add(description2.code);
    this._modifiers |= __privateMethod(this, _modifierBit, modifierBit_fn).call(this, description2.key);
    const text = options.text === void 0 ? description2.text : options.text;
    await __privateGet(this, _client11).send("Input.dispatchKeyEvent", {
      type: text ? "keyDown" : "rawKeyDown",
      modifiers: this._modifiers,
      windowsVirtualKeyCode: description2.keyCode,
      code: description2.code,
      key: description2.key,
      text,
      unmodifiedText: text,
      autoRepeat,
      location: description2.location,
      isKeypad: description2.location === 3,
      commands: options.commands
    });
  }
  async up(key) {
    const description2 = __privateMethod(this, _keyDescriptionForString, keyDescriptionForString_fn).call(this, key);
    this._modifiers &= ~__privateMethod(this, _modifierBit, modifierBit_fn).call(this, description2.key);
    __privateGet(this, _pressedKeys).delete(description2.code);
    await __privateGet(this, _client11).send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: this._modifiers,
      key: description2.key,
      windowsVirtualKeyCode: description2.keyCode,
      code: description2.code,
      location: description2.location
    });
  }
  async sendCharacter(char) {
    await __privateGet(this, _client11).send("Input.insertText", { text: char });
  }
  charIsKey(char) {
    return !!_keyDefinitions[char];
  }
  async type(text, options = {}) {
    const delay = options.delay || void 0;
    for (const char of text) {
      if (this.charIsKey(char)) {
        await this.press(char, { delay });
      } else {
        if (delay) {
          await new Promise((f2) => {
            return setTimeout(f2, delay);
          });
        }
        await this.sendCharacter(char);
      }
    }
  }
  async press(key, options = {}) {
    const { delay = null } = options;
    await this.down(key, options);
    if (delay) {
      await new Promise((f2) => {
        return setTimeout(f2, options.delay);
      });
    }
    await this.up(key);
  }
}
_client11 = new WeakMap();
_pressedKeys = new WeakMap();
_modifierBit = new WeakSet();
modifierBit_fn = function(key) {
  if (key === "Alt") {
    return 1;
  }
  if (key === "Control") {
    return 2;
  }
  if (key === "Meta") {
    return 4;
  }
  if (key === "Shift") {
    return 8;
  }
  return 0;
};
_keyDescriptionForString = new WeakSet();
keyDescriptionForString_fn = function(keyString) {
  const shift = this._modifiers & 8;
  const description2 = {
    key: "",
    keyCode: 0,
    code: "",
    text: "",
    location: 0
  };
  const definition = _keyDefinitions[keyString];
  assert$1(definition, `Unknown key: "${keyString}"`);
  if (definition.key) {
    description2.key = definition.key;
  }
  if (shift && definition.shiftKey) {
    description2.key = definition.shiftKey;
  }
  if (definition.keyCode) {
    description2.keyCode = definition.keyCode;
  }
  if (shift && definition.shiftKeyCode) {
    description2.keyCode = definition.shiftKeyCode;
  }
  if (definition.code) {
    description2.code = definition.code;
  }
  if (definition.location) {
    description2.location = definition.location;
  }
  if (description2.key.length === 1) {
    description2.text = description2.key;
  }
  if (definition.text) {
    description2.text = definition.text;
  }
  if (shift && definition.shiftText) {
    description2.text = definition.shiftText;
  }
  if (this._modifiers & ~8) {
    description2.text = "";
  }
  return description2;
};
const getFlag = (button) => {
  switch (button) {
    case MouseButton.Left:
      return 1;
    case MouseButton.Right:
      return 2;
    case MouseButton.Middle:
      return 4;
    case MouseButton.Back:
      return 8;
    case MouseButton.Forward:
      return 16;
  }
};
const getButtonFromPressedButtons = (buttons) => {
  if (buttons & 1) {
    return MouseButton.Left;
  } else if (buttons & 2) {
    return MouseButton.Right;
  } else if (buttons & 4) {
    return MouseButton.Middle;
  } else if (buttons & 8) {
    return MouseButton.Back;
  } else if (buttons & 16) {
    return MouseButton.Forward;
  }
  return "none";
};
class CdpMouse extends Mouse {
  constructor(client, keyboard) {
    super();
    __privateAdd(this, _state2);
    __privateAdd(this, _createTransaction);
    /**
     * This is a shortcut for a typical update, commit/rollback lifecycle based on
     * the error of the action.
     */
    __privateAdd(this, _withTransaction);
    __privateAdd(this, _client12, void 0);
    __privateAdd(this, _keyboard, void 0);
    __privateAdd(this, __state, {
      position: { x: 0, y: 0 },
      buttons: 0
    });
    // Transactions can run in parallel, so we store each of thme in this array.
    __privateAdd(this, _transactions, []);
    __privateSet(this, _client12, client);
    __privateSet(this, _keyboard, keyboard);
  }
  updateClient(client) {
    __privateSet(this, _client12, client);
  }
  async reset() {
    const actions = [];
    for (const [flag, button] of [
      [1, MouseButton.Left],
      [4, MouseButton.Middle],
      [2, MouseButton.Right],
      [16, MouseButton.Forward],
      [8, MouseButton.Back]
    ]) {
      if (__privateGet(this, _state2, state_get).buttons & flag) {
        actions.push(this.up({ button }));
      }
    }
    if (__privateGet(this, _state2, state_get).position.x !== 0 || __privateGet(this, _state2, state_get).position.y !== 0) {
      actions.push(this.move(0, 0));
    }
    await Promise.all(actions);
  }
  async move(x2, y2, options = {}) {
    const { steps = 1 } = options;
    const from2 = __privateGet(this, _state2, state_get).position;
    const to = { x: x2, y: y2 };
    for (let i2 = 1; i2 <= steps; i2++) {
      await __privateMethod(this, _withTransaction, withTransaction_fn).call(this, (updateState) => {
        updateState({
          position: {
            x: from2.x + (to.x - from2.x) * (i2 / steps),
            y: from2.y + (to.y - from2.y) * (i2 / steps)
          }
        });
        const { buttons, position } = __privateGet(this, _state2, state_get);
        return __privateGet(this, _client12).send("Input.dispatchMouseEvent", {
          type: "mouseMoved",
          modifiers: __privateGet(this, _keyboard)._modifiers,
          buttons,
          button: getButtonFromPressedButtons(buttons),
          ...position
        });
      });
    }
  }
  async down(options = {}) {
    const { button = MouseButton.Left, clickCount = 1 } = options;
    const flag = getFlag(button);
    if (!flag) {
      throw new Error(`Unsupported mouse button: ${button}`);
    }
    if (__privateGet(this, _state2, state_get).buttons & flag) {
      throw new Error(`'${button}' is already pressed.`);
    }
    await __privateMethod(this, _withTransaction, withTransaction_fn).call(this, (updateState) => {
      updateState({
        buttons: __privateGet(this, _state2, state_get).buttons | flag
      });
      const { buttons, position } = __privateGet(this, _state2, state_get);
      return __privateGet(this, _client12).send("Input.dispatchMouseEvent", {
        type: "mousePressed",
        modifiers: __privateGet(this, _keyboard)._modifiers,
        clickCount,
        buttons,
        button,
        ...position
      });
    });
  }
  async up(options = {}) {
    const { button = MouseButton.Left, clickCount = 1 } = options;
    const flag = getFlag(button);
    if (!flag) {
      throw new Error(`Unsupported mouse button: ${button}`);
    }
    if (!(__privateGet(this, _state2, state_get).buttons & flag)) {
      throw new Error(`'${button}' is not pressed.`);
    }
    await __privateMethod(this, _withTransaction, withTransaction_fn).call(this, (updateState) => {
      updateState({
        buttons: __privateGet(this, _state2, state_get).buttons & ~flag
      });
      const { buttons, position } = __privateGet(this, _state2, state_get);
      return __privateGet(this, _client12).send("Input.dispatchMouseEvent", {
        type: "mouseReleased",
        modifiers: __privateGet(this, _keyboard)._modifiers,
        clickCount,
        buttons,
        button,
        ...position
      });
    });
  }
  async click(x2, y2, options = {}) {
    const { delay, count = 1, clickCount = count } = options;
    if (count < 1) {
      throw new Error("Click must occur a positive number of times.");
    }
    const actions = [this.move(x2, y2)];
    if (clickCount === count) {
      for (let i2 = 1; i2 < count; ++i2) {
        actions.push(this.down({ ...options, clickCount: i2 }), this.up({ ...options, clickCount: i2 }));
      }
    }
    actions.push(this.down({ ...options, clickCount }));
    if (typeof delay === "number") {
      await Promise.all(actions);
      actions.length = 0;
      await new Promise((resolve2) => {
        setTimeout(resolve2, delay);
      });
    }
    actions.push(this.up({ ...options, clickCount }));
    await Promise.all(actions);
  }
  async wheel(options = {}) {
    const { deltaX = 0, deltaY = 0 } = options;
    const { position, buttons } = __privateGet(this, _state2, state_get);
    await __privateGet(this, _client12).send("Input.dispatchMouseEvent", {
      type: "mouseWheel",
      pointerType: "mouse",
      modifiers: __privateGet(this, _keyboard)._modifiers,
      deltaY,
      deltaX,
      buttons,
      ...position
    });
  }
  async drag(start, target) {
    const promise = new Promise((resolve2) => {
      __privateGet(this, _client12).once("Input.dragIntercepted", (event) => {
        return resolve2(event.data);
      });
    });
    await this.move(start.x, start.y);
    await this.down();
    await this.move(target.x, target.y);
    return await promise;
  }
  async dragEnter(target, data2) {
    await __privateGet(this, _client12).send("Input.dispatchDragEvent", {
      type: "dragEnter",
      x: target.x,
      y: target.y,
      modifiers: __privateGet(this, _keyboard)._modifiers,
      data: data2
    });
  }
  async dragOver(target, data2) {
    await __privateGet(this, _client12).send("Input.dispatchDragEvent", {
      type: "dragOver",
      x: target.x,
      y: target.y,
      modifiers: __privateGet(this, _keyboard)._modifiers,
      data: data2
    });
  }
  async drop(target, data2) {
    await __privateGet(this, _client12).send("Input.dispatchDragEvent", {
      type: "drop",
      x: target.x,
      y: target.y,
      modifiers: __privateGet(this, _keyboard)._modifiers,
      data: data2
    });
  }
  async dragAndDrop(start, target, options = {}) {
    const { delay = null } = options;
    const data2 = await this.drag(start, target);
    await this.dragEnter(target, data2);
    await this.dragOver(target, data2);
    if (delay) {
      await new Promise((resolve2) => {
        return setTimeout(resolve2, delay);
      });
    }
    await this.drop(target, data2);
    await this.up();
  }
}
_client12 = new WeakMap();
_keyboard = new WeakMap();
__state = new WeakMap();
_state2 = new WeakSet();
state_get = function() {
  return Object.assign({ ...__privateGet(this, __state) }, ...__privateGet(this, _transactions));
};
_transactions = new WeakMap();
_createTransaction = new WeakSet();
createTransaction_fn = function() {
  const transaction = {};
  __privateGet(this, _transactions).push(transaction);
  const popTransaction = () => {
    __privateGet(this, _transactions).splice(__privateGet(this, _transactions).indexOf(transaction), 1);
  };
  return {
    update: (updates) => {
      Object.assign(transaction, updates);
    },
    commit: () => {
      __privateSet(this, __state, { ...__privateGet(this, __state), ...transaction });
      popTransaction();
    },
    rollback: popTransaction
  };
};
_withTransaction = new WeakSet();
withTransaction_fn = async function(action) {
  const { update, commit, rollback } = __privateMethod(this, _createTransaction, createTransaction_fn).call(this);
  try {
    await action(update);
    commit();
  } catch (error) {
    rollback();
    throw error;
  }
};
class CdpTouchscreen extends Touchscreen {
  constructor(client, keyboard) {
    super();
    __privateAdd(this, _client13, void 0);
    __privateAdd(this, _keyboard2, void 0);
    __privateSet(this, _client13, client);
    __privateSet(this, _keyboard2, keyboard);
  }
  updateClient(client) {
    __privateSet(this, _client13, client);
  }
  async touchStart(x2, y2) {
    await __privateGet(this, _client13).send("Input.dispatchTouchEvent", {
      type: "touchStart",
      touchPoints: [
        {
          x: Math.round(x2),
          y: Math.round(y2),
          radiusX: 0.5,
          radiusY: 0.5,
          force: 0.5
        }
      ],
      modifiers: __privateGet(this, _keyboard2)._modifiers
    });
  }
  async touchMove(x2, y2) {
    await __privateGet(this, _client13).send("Input.dispatchTouchEvent", {
      type: "touchMove",
      touchPoints: [
        {
          x: Math.round(x2),
          y: Math.round(y2),
          radiusX: 0.5,
          radiusY: 0.5,
          force: 0.5
        }
      ],
      modifiers: __privateGet(this, _keyboard2)._modifiers
    });
  }
  async touchEnd() {
    await __privateGet(this, _client13).send("Input.dispatchTouchEvent", {
      type: "touchEnd",
      touchPoints: [],
      modifiers: __privateGet(this, _keyboard2)._modifiers
    });
  }
}
_client13 = new WeakMap();
_keyboard2 = new WeakMap();
class Tracing {
  /**
   * @internal
   */
  constructor(client) {
    __privateAdd(this, _client14, void 0);
    __privateAdd(this, _recording, false);
    __privateAdd(this, _path, void 0);
    __privateSet(this, _client14, client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    __privateSet(this, _client14, client);
  }
  /**
   * Starts a trace for the current page.
   * @remarks
   * Only one trace can be active at a time per browser.
   *
   * @param options - Optional `TracingOptions`.
   */
  async start(options = {}) {
    assert$1(!__privateGet(this, _recording), "Cannot start recording trace while already recording trace.");
    const defaultCategories = [
      "-*",
      "devtools.timeline",
      "v8.execute",
      "disabled-by-default-devtools.timeline",
      "disabled-by-default-devtools.timeline.frame",
      "toplevel",
      "blink.console",
      "blink.user_timing",
      "latencyInfo",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-v8.cpu_profiler"
    ];
    const { path: path2, screenshots = false, categories = defaultCategories } = options;
    if (screenshots) {
      categories.push("disabled-by-default-devtools.screenshot");
    }
    const excludedCategories = categories.filter((cat) => {
      return cat.startsWith("-");
    }).map((cat) => {
      return cat.slice(1);
    });
    const includedCategories = categories.filter((cat) => {
      return !cat.startsWith("-");
    });
    __privateSet(this, _path, path2);
    __privateSet(this, _recording, true);
    await __privateGet(this, _client14).send("Tracing.start", {
      transferMode: "ReturnAsStream",
      traceConfig: {
        excludedCategories,
        includedCategories
      }
    });
  }
  /**
   * Stops a trace started with the `start` method.
   * @returns Promise which resolves to buffer with trace data.
   */
  async stop() {
    const contentDeferred = Deferred.create();
    __privateGet(this, _client14).once("Tracing.tracingComplete", async (event) => {
      try {
        assert$1(event.stream, 'Missing "stream"');
        const readable = await getReadableFromProtocolStream(__privateGet(this, _client14), event.stream);
        const buffer = await getReadableAsBuffer(readable, __privateGet(this, _path));
        contentDeferred.resolve(buffer ?? void 0);
      } catch (error) {
        if (isErrorLike$1(error)) {
          contentDeferred.reject(error);
        } else {
          contentDeferred.reject(new Error(`Unknown error: ${error}`));
        }
      }
    });
    await __privateGet(this, _client14).send("Tracing.end");
    __privateSet(this, _recording, false);
    return await contentDeferred.valueOrThrow();
  }
}
_client14 = new WeakMap();
_recording = new WeakMap();
_path = new WeakMap();
class CdpWebWorker extends WebWorker {
  constructor(client, url, targetId, targetType, consoleAPICalled, exceptionThrown) {
    super(url);
    __privateAdd(this, _world4, void 0);
    __privateAdd(this, _client15, void 0);
    __privateAdd(this, _id5, void 0);
    __privateAdd(this, _targetType2, void 0);
    __privateSet(this, _id5, targetId);
    __privateSet(this, _client15, client);
    __privateSet(this, _targetType2, targetType);
    __privateSet(this, _world4, new IsolatedWorld(this, new TimeoutSettings()));
    __privateGet(this, _client15).once("Runtime.executionContextCreated", async (event) => {
      __privateGet(this, _world4).setContext(new ExecutionContext(client, event.context, __privateGet(this, _world4)));
    });
    __privateGet(this, _world4).emitter.on("consoleapicalled", async (event) => {
      try {
        return consoleAPICalled(event.type, event.args.map((object) => {
          return new CdpJSHandle(__privateGet(this, _world4), object);
        }), event.stackTrace);
      } catch (err) {
        debugError(err);
      }
    });
    __privateGet(this, _client15).on("Runtime.exceptionThrown", exceptionThrown);
    __privateGet(this, _client15).once(CDPSessionEvent.Disconnected, () => {
      __privateGet(this, _world4).dispose();
    });
    __privateGet(this, _client15).send("Runtime.enable").catch(debugError);
  }
  mainRealm() {
    return __privateGet(this, _world4);
  }
  get client() {
    return __privateGet(this, _client15);
  }
  async close() {
    var _a3, _b3;
    switch (__privateGet(this, _targetType2)) {
      case exports.TargetType.SERVICE_WORKER:
      case exports.TargetType.SHARED_WORKER: {
        await ((_a3 = this.client.connection()) == null ? void 0 : _a3.send("Target.closeTarget", {
          targetId: __privateGet(this, _id5)
        }));
        await ((_b3 = this.client.connection()) == null ? void 0 : _b3.send("Target.detachFromTarget", {
          sessionId: this.client.id()
        }));
        break;
      }
      default:
        await this.evaluate(() => {
          self.close();
        });
    }
  }
}
_world4 = new WeakMap();
_client15 = new WeakMap();
_id5 = new WeakMap();
_targetType2 = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource$1 = function(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
};
var __disposeResources$1 = /* @__PURE__ */ function(SuppressedError2) {
  return function(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new SuppressedError2(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  };
}(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
});
function convertConsoleMessageLevel(method) {
  switch (method) {
    case "warning":
      return "warn";
    default:
      return method;
  }
}
const _CdpPage = class _CdpPage extends Page {
  constructor(client, target) {
    super();
    __privateAdd(this, _onActivation);
    __privateAdd(this, _onSecondaryTarget);
    /**
     * Sets up listeners for the primary target. The primary target can change
     * during a navigation to a prerended page.
     */
    __privateAdd(this, _setupPrimaryTargetListeners);
    __privateAdd(this, _initialize);
    __privateAdd(this, _onFileChooser);
    __privateAdd(this, _onTargetCrashed);
    __privateAdd(this, _onLogEntryAdded);
    __privateAdd(this, _emitMetrics);
    __privateAdd(this, _buildMetricsObject);
    __privateAdd(this, _handleException);
    __privateAdd(this, _onConsoleAPI2);
    __privateAdd(this, _onBindingCalled2);
    __privateAdd(this, _addConsoleMessage);
    __privateAdd(this, _onDialog);
    __privateAdd(this, _go);
    __privateAdd(this, _closed2, false);
    __privateAdd(this, _targetManager, void 0);
    __privateAdd(this, _primaryTargetClient, void 0);
    __privateAdd(this, _primaryTarget, void 0);
    __privateAdd(this, _tabTargetClient, void 0);
    __privateAdd(this, _tabTarget, void 0);
    __privateAdd(this, _keyboard3, void 0);
    __privateAdd(this, _mouse, void 0);
    __privateAdd(this, _touchscreen, void 0);
    __privateAdd(this, _accessibility, void 0);
    __privateAdd(this, _frameManager2, void 0);
    __privateAdd(this, _emulationManager, void 0);
    __privateAdd(this, _tracing, void 0);
    __privateAdd(this, _bindings2, /* @__PURE__ */ new Map());
    __privateAdd(this, _exposedFunctions, /* @__PURE__ */ new Map());
    __privateAdd(this, _coverage, void 0);
    __privateAdd(this, _viewport, void 0);
    __privateAdd(this, _workers, /* @__PURE__ */ new Map());
    __privateAdd(this, _fileChooserDeferreds, /* @__PURE__ */ new Set());
    __privateAdd(this, _sessionCloseDeferred, Deferred.create());
    __privateAdd(this, _serviceWorkerBypassed, false);
    __privateAdd(this, _userDragInterceptionEnabled, false);
    __privateAdd(this, _frameManagerHandlers, [
      [
        FrameManagerEvent.FrameAttached,
        (frame) => {
          this.emit("frameattached", frame);
        }
      ],
      [
        FrameManagerEvent.FrameDetached,
        (frame) => {
          this.emit("framedetached", frame);
        }
      ],
      [
        FrameManagerEvent.FrameNavigated,
        (frame) => {
          this.emit("framenavigated", frame);
        }
      ]
    ]);
    __privateAdd(this, _networkManagerHandlers, [
      [
        NetworkManagerEvent.Request,
        (request) => {
          this.emit("request", request);
        }
      ],
      [
        NetworkManagerEvent.RequestServedFromCache,
        (request) => {
          this.emit("requestservedfromcache", request);
        }
      ],
      [
        NetworkManagerEvent.Response,
        (response) => {
          this.emit("response", response);
        }
      ],
      [
        NetworkManagerEvent.RequestFailed,
        (request) => {
          this.emit("requestfailed", request);
        }
      ],
      [
        NetworkManagerEvent.RequestFinished,
        (request) => {
          this.emit("requestfinished", request);
        }
      ]
    ]);
    __privateAdd(this, _sessionHandlers, [
      [
        CDPSessionEvent.Disconnected,
        () => {
          __privateGet(this, _sessionCloseDeferred).reject(new TargetCloseError("Target closed"));
        }
      ],
      [
        "Page.domContentEventFired",
        () => {
          return this.emit("domcontentloaded", void 0);
        }
      ],
      [
        "Page.loadEventFired",
        () => {
          return this.emit("load", void 0);
        }
      ],
      ["Page.javascriptDialogOpening", __privateMethod(this, _onDialog, onDialog_fn).bind(this)],
      ["Runtime.exceptionThrown", __privateMethod(this, _handleException, handleException_fn).bind(this)],
      ["Inspector.targetCrashed", __privateMethod(this, _onTargetCrashed, onTargetCrashed_fn).bind(this)],
      ["Performance.metrics", __privateMethod(this, _emitMetrics, emitMetrics_fn).bind(this)],
      ["Log.entryAdded", __privateMethod(this, _onLogEntryAdded, onLogEntryAdded_fn).bind(this)],
      ["Page.fileChooserOpened", __privateMethod(this, _onFileChooser, onFileChooser_fn).bind(this)]
    ]);
    __privateAdd(this, _onDetachedFromTarget, (target) => {
      var _a3;
      const sessionId = (_a3 = target._session()) == null ? void 0 : _a3.id();
      const worker = __privateGet(this, _workers).get(sessionId);
      if (!worker) {
        return;
      }
      __privateGet(this, _workers).delete(sessionId);
      this.emit("workerdestroyed", worker);
    });
    __privateAdd(this, _onAttachedToTarget2, (session) => {
      assert$1(session instanceof CdpCDPSession);
      __privateGet(this, _frameManager2).onAttachedToTarget(session._target());
      if (session._target()._getTargetInfo().type === "worker") {
        const worker = new CdpWebWorker(session, session._target().url(), session._target()._targetId, session._target().type(), __privateMethod(this, _addConsoleMessage, addConsoleMessage_fn).bind(this), __privateMethod(this, _handleException, handleException_fn).bind(this));
        __privateGet(this, _workers).set(session.id(), worker);
        this.emit("workercreated", worker);
      }
      session.on(CDPSessionEvent.Ready, __privateGet(this, _onAttachedToTarget2));
    });
    __privateSet(this, _primaryTargetClient, client);
    __privateSet(this, _tabTargetClient, client.parentSession());
    assert$1(__privateGet(this, _tabTargetClient), "Tab target session is not defined.");
    __privateSet(this, _tabTarget, __privateGet(this, _tabTargetClient)._target());
    assert$1(__privateGet(this, _tabTarget), "Tab target is not defined.");
    __privateSet(this, _primaryTarget, target);
    __privateSet(this, _targetManager, target._targetManager());
    __privateSet(this, _keyboard3, new CdpKeyboard(client));
    __privateSet(this, _mouse, new CdpMouse(client, __privateGet(this, _keyboard3)));
    __privateSet(this, _touchscreen, new CdpTouchscreen(client, __privateGet(this, _keyboard3)));
    __privateSet(this, _accessibility, new Accessibility(client));
    __privateSet(this, _frameManager2, new FrameManager(client, this, this._timeoutSettings));
    __privateSet(this, _emulationManager, new EmulationManager(client));
    __privateSet(this, _tracing, new Tracing(client));
    __privateSet(this, _coverage, new Coverage(client));
    __privateSet(this, _viewport, null);
    for (const [eventName, handler] of __privateGet(this, _frameManagerHandlers)) {
      __privateGet(this, _frameManager2).on(eventName, handler);
    }
    __privateGet(this, _frameManager2).on(FrameManagerEvent.ConsoleApiCalled, ([world, event]) => {
      __privateMethod(this, _onConsoleAPI2, onConsoleAPI_fn2).call(this, world, event);
    });
    __privateGet(this, _frameManager2).on(FrameManagerEvent.BindingCalled, ([world, event]) => {
      void __privateMethod(this, _onBindingCalled2, onBindingCalled_fn2).call(this, world, event);
    });
    for (const [eventName, handler] of __privateGet(this, _networkManagerHandlers)) {
      __privateGet(this, _frameManager2).networkManager.on(eventName, handler);
    }
    __privateGet(this, _tabTargetClient).on(CDPSessionEvent.Swapped, __privateMethod(this, _onActivation, onActivation_fn).bind(this));
    __privateGet(this, _tabTargetClient).on(CDPSessionEvent.Ready, __privateMethod(this, _onSecondaryTarget, onSecondaryTarget_fn).bind(this));
    __privateGet(this, _targetManager).on("targetGone", __privateGet(this, _onDetachedFromTarget));
    __privateGet(this, _tabTarget)._isClosedDeferred.valueOrThrow().then(() => {
      __privateGet(this, _targetManager).off("targetGone", __privateGet(this, _onDetachedFromTarget));
      this.emit("close", void 0);
      __privateSet(this, _closed2, true);
    }).catch(debugError);
    __privateMethod(this, _setupPrimaryTargetListeners, setupPrimaryTargetListeners_fn).call(this);
  }
  static async _create(client, target, defaultViewport) {
    var _a3;
    const page = new _CdpPage(client, target);
    await __privateMethod(_a3 = page, _initialize, initialize_fn).call(_a3);
    if (defaultViewport) {
      try {
        await page.setViewport(defaultViewport);
      } catch (err) {
        if (isErrorLike$1(err) && isTargetClosedError(err)) {
          debugError(err);
        } else {
          throw err;
        }
      }
    }
    return page;
  }
  _client() {
    return __privateGet(this, _primaryTargetClient);
  }
  isServiceWorkerBypassed() {
    return __privateGet(this, _serviceWorkerBypassed);
  }
  isDragInterceptionEnabled() {
    return __privateGet(this, _userDragInterceptionEnabled);
  }
  isJavaScriptEnabled() {
    return __privateGet(this, _emulationManager).javascriptEnabled;
  }
  async waitForFileChooser(options = {}) {
    const needsEnable = __privateGet(this, _fileChooserDeferreds).size === 0;
    const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`FileChooser\` failed: ${timeout2}ms exceeded`,
      timeout: timeout2
    });
    __privateGet(this, _fileChooserDeferreds).add(deferred);
    let enablePromise;
    if (needsEnable) {
      enablePromise = __privateGet(this, _primaryTargetClient).send("Page.setInterceptFileChooserDialog", {
        enabled: true
      });
    }
    try {
      const [result] = await Promise.all([
        deferred.valueOrThrow(),
        enablePromise
      ]);
      return result;
    } catch (error) {
      __privateGet(this, _fileChooserDeferreds).delete(deferred);
      throw error;
    }
  }
  async setGeolocation(options) {
    return await __privateGet(this, _emulationManager).setGeolocation(options);
  }
  target() {
    return __privateGet(this, _primaryTarget);
  }
  browser() {
    return __privateGet(this, _primaryTarget).browser();
  }
  browserContext() {
    return __privateGet(this, _primaryTarget).browserContext();
  }
  mainFrame() {
    return __privateGet(this, _frameManager2).mainFrame();
  }
  get keyboard() {
    return __privateGet(this, _keyboard3);
  }
  get touchscreen() {
    return __privateGet(this, _touchscreen);
  }
  get coverage() {
    return __privateGet(this, _coverage);
  }
  get tracing() {
    return __privateGet(this, _tracing);
  }
  get accessibility() {
    return __privateGet(this, _accessibility);
  }
  frames() {
    return __privateGet(this, _frameManager2).frames();
  }
  workers() {
    return Array.from(__privateGet(this, _workers).values());
  }
  async setRequestInterception(value) {
    return await __privateGet(this, _frameManager2).networkManager.setRequestInterception(value);
  }
  async setBypassServiceWorker(bypass) {
    __privateSet(this, _serviceWorkerBypassed, bypass);
    return await __privateGet(this, _primaryTargetClient).send("Network.setBypassServiceWorker", { bypass });
  }
  async setDragInterception(enabled) {
    __privateSet(this, _userDragInterceptionEnabled, enabled);
    return await __privateGet(this, _primaryTargetClient).send("Input.setInterceptDrags", {
      enabled
    });
  }
  async setOfflineMode(enabled) {
    return await __privateGet(this, _frameManager2).networkManager.setOfflineMode(enabled);
  }
  async emulateNetworkConditions(networkConditions) {
    return await __privateGet(this, _frameManager2).networkManager.emulateNetworkConditions(networkConditions);
  }
  setDefaultNavigationTimeout(timeout2) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
  }
  setDefaultTimeout(timeout2) {
    this._timeoutSettings.setDefaultTimeout(timeout2);
  }
  getDefaultTimeout() {
    return this._timeoutSettings.timeout();
  }
  async queryObjects(prototypeHandle) {
    assert$1(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
    assert$1(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
    const response = await this.mainFrame().client.send("Runtime.queryObjects", {
      prototypeObjectId: prototypeHandle.id
    });
    return this.mainFrame().mainRealm().createCdpHandle(response.objects);
  }
  async cookies(...urls) {
    const originalCookies = (await __privateGet(this, _primaryTargetClient).send("Network.getCookies", {
      urls: urls.length ? urls : [this.url()]
    })).cookies;
    const unsupportedCookieAttributes = ["sourcePort"];
    const filterUnsupportedAttributes = (cookie) => {
      for (const attr of unsupportedCookieAttributes) {
        delete cookie[attr];
      }
      return cookie;
    };
    return originalCookies.map(filterUnsupportedAttributes);
  }
  async deleteCookie(...cookies) {
    const pageURL = this.url();
    for (const cookie of cookies) {
      const item = Object.assign({}, cookie);
      if (!cookie.url && pageURL.startsWith("http")) {
        item.url = pageURL;
      }
      await __privateGet(this, _primaryTargetClient).send("Network.deleteCookies", item);
    }
  }
  async setCookie(...cookies) {
    const pageURL = this.url();
    const startsWithHTTP = pageURL.startsWith("http");
    const items = cookies.map((cookie) => {
      const item = Object.assign({}, cookie);
      if (!item.url && startsWithHTTP) {
        item.url = pageURL;
      }
      assert$1(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
      assert$1(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
      return item;
    });
    await this.deleteCookie(...items);
    if (items.length) {
      await __privateGet(this, _primaryTargetClient).send("Network.setCookies", {
        cookies: items
      });
    }
  }
  async exposeFunction(name2, pptrFunction) {
    if (__privateGet(this, _bindings2).has(name2)) {
      throw new Error(`Failed to add page binding with name ${name2}: window['${name2}'] already exists!`);
    }
    let binding;
    switch (typeof pptrFunction) {
      case "function":
        binding = new Binding(name2, pptrFunction);
        break;
      default:
        binding = new Binding(name2, pptrFunction.default);
        break;
    }
    __privateGet(this, _bindings2).set(name2, binding);
    const expression = pageBindingInitString("exposedFun", name2);
    await __privateGet(this, _primaryTargetClient).send("Runtime.addBinding", { name: name2 });
    const { identifier } = await __privateGet(this, _primaryTargetClient).send("Page.addScriptToEvaluateOnNewDocument", {
      source: expression
    });
    __privateGet(this, _exposedFunctions).set(name2, identifier);
    await Promise.all(this.frames().map((frame) => {
      if (frame !== this.mainFrame() && !frame._hasStartedLoading) {
        return;
      }
      return frame.evaluate(expression).catch(debugError);
    }));
  }
  async removeExposedFunction(name2) {
    const exposedFun = __privateGet(this, _exposedFunctions).get(name2);
    if (!exposedFun) {
      throw new Error(`Failed to remove page binding with name ${name2}: window['${name2}'] does not exists!`);
    }
    await __privateGet(this, _primaryTargetClient).send("Runtime.removeBinding", { name: name2 });
    await this.removeScriptToEvaluateOnNewDocument(exposedFun);
    await Promise.all(this.frames().map((frame) => {
      if (frame !== this.mainFrame() && !frame._hasStartedLoading) {
        return;
      }
      return frame.evaluate((name3) => {
        globalThis[name3] = void 0;
      }, name2).catch(debugError);
    }));
    __privateGet(this, _exposedFunctions).delete(name2);
    __privateGet(this, _bindings2).delete(name2);
  }
  async authenticate(credentials) {
    return await __privateGet(this, _frameManager2).networkManager.authenticate(credentials);
  }
  async setExtraHTTPHeaders(headers) {
    return await __privateGet(this, _frameManager2).networkManager.setExtraHTTPHeaders(headers);
  }
  async setUserAgent(userAgent, userAgentMetadata) {
    return await __privateGet(this, _frameManager2).networkManager.setUserAgent(userAgent, userAgentMetadata);
  }
  async metrics() {
    const response = await __privateGet(this, _primaryTargetClient).send("Performance.getMetrics");
    return __privateMethod(this, _buildMetricsObject, buildMetricsObject_fn).call(this, response.metrics);
  }
  async reload(options) {
    const [result] = await Promise.all([
      this.waitForNavigation({
        ...options,
        ignoreSameDocumentNavigation: true
      }),
      __privateGet(this, _primaryTargetClient).send("Page.reload")
    ]);
    return result;
  }
  async createCDPSession() {
    return await this.target().createCDPSession();
  }
  async goBack(options = {}) {
    return await __privateMethod(this, _go, go_fn).call(this, -1, options);
  }
  async goForward(options = {}) {
    return await __privateMethod(this, _go, go_fn).call(this, 1, options);
  }
  async bringToFront() {
    await __privateGet(this, _primaryTargetClient).send("Page.bringToFront");
  }
  async setJavaScriptEnabled(enabled) {
    return await __privateGet(this, _emulationManager).setJavaScriptEnabled(enabled);
  }
  async setBypassCSP(enabled) {
    await __privateGet(this, _primaryTargetClient).send("Page.setBypassCSP", { enabled });
  }
  async emulateMediaType(type) {
    return await __privateGet(this, _emulationManager).emulateMediaType(type);
  }
  async emulateCPUThrottling(factor) {
    return await __privateGet(this, _emulationManager).emulateCPUThrottling(factor);
  }
  async emulateMediaFeatures(features) {
    return await __privateGet(this, _emulationManager).emulateMediaFeatures(features);
  }
  async emulateTimezone(timezoneId) {
    return await __privateGet(this, _emulationManager).emulateTimezone(timezoneId);
  }
  async emulateIdleState(overrides) {
    return await __privateGet(this, _emulationManager).emulateIdleState(overrides);
  }
  async emulateVisionDeficiency(type) {
    return await __privateGet(this, _emulationManager).emulateVisionDeficiency(type);
  }
  async setViewport(viewport) {
    const needsReload = await __privateGet(this, _emulationManager).emulateViewport(viewport);
    __privateSet(this, _viewport, viewport);
    if (needsReload) {
      await this.reload();
    }
  }
  viewport() {
    return __privateGet(this, _viewport);
  }
  async evaluateOnNewDocument(pageFunction, ...args) {
    const source2 = evaluationString(pageFunction, ...args);
    const { identifier } = await __privateGet(this, _primaryTargetClient).send("Page.addScriptToEvaluateOnNewDocument", {
      source: source2
    });
    return { identifier };
  }
  async removeScriptToEvaluateOnNewDocument(identifier) {
    await __privateGet(this, _primaryTargetClient).send("Page.removeScriptToEvaluateOnNewDocument", {
      identifier
    });
  }
  async setCacheEnabled(enabled = true) {
    await __privateGet(this, _frameManager2).networkManager.setCacheEnabled(enabled);
  }
  async _screenshot(options) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const { fromSurface, omitBackground, optimizeForSpeed, quality, clip: userClip, type, captureBeyondViewport } = options;
      const isFirefox = this.target()._targetManager() instanceof FirefoxTargetManager;
      const stack = __addDisposableResource$1(env_2, new AsyncDisposableStack(), true);
      if (!isFirefox && omitBackground && (type === "png" || type === "webp")) {
        await __privateGet(this, _emulationManager).setTransparentBackgroundColor();
        stack.defer(async () => {
          await __privateGet(this, _emulationManager).resetDefaultBackgroundColor().catch(debugError);
        });
      }
      let clip = userClip;
      if (clip && !captureBeyondViewport) {
        const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {
          const { height, pageLeft: x2, pageTop: y2, width } = window.visualViewport;
          return { x: x2, y: y2, height, width };
        });
        clip = getIntersectionRect(clip, viewport);
      }
      const { data: data2 } = await __privateGet(this, _primaryTargetClient).send("Page.captureScreenshot", {
        format: type,
        ...optimizeForSpeed ? { optimizeForSpeed } : {},
        ...quality !== void 0 ? { quality: Math.round(quality) } : {},
        ...clip ? { clip: { ...clip, scale: clip.scale ?? 1 } } : {},
        ...!fromSurface ? { fromSurface } : {},
        captureBeyondViewport
      });
      return data2;
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      const result_1 = __disposeResources$1(env_2);
      if (result_1)
        await result_1;
    }
  }
  async createPDFStream(options = {}) {
    const { timeout: ms2 = this._timeoutSettings.timeout() } = options;
    const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, tagged: generateTaggedPDF, outline: generateDocumentOutline } = parsePDFOptions(options);
    if (omitBackground) {
      await __privateGet(this, _emulationManager).setTransparentBackgroundColor();
    }
    await firstValueFrom(from$1(this.mainFrame().isolatedRealm().evaluate(() => {
      return document.fonts.ready;
    })).pipe(raceWith(timeout(ms2))));
    const printCommandPromise = __privateGet(this, _primaryTargetClient).send("Page.printToPDF", {
      transferMode: "ReturnAsStream",
      landscape,
      displayHeaderFooter,
      headerTemplate,
      footerTemplate,
      printBackground,
      scale,
      paperWidth,
      paperHeight,
      marginTop: margin.top,
      marginBottom: margin.bottom,
      marginLeft: margin.left,
      marginRight: margin.right,
      pageRanges,
      preferCSSPageSize,
      generateTaggedPDF,
      generateDocumentOutline
    });
    const result = await firstValueFrom(from$1(printCommandPromise).pipe(raceWith(timeout(ms2))));
    if (omitBackground) {
      await __privateGet(this, _emulationManager).resetDefaultBackgroundColor();
    }
    assert$1(result.stream, "`stream` is missing from `Page.printToPDF");
    return await getReadableFromProtocolStream(__privateGet(this, _primaryTargetClient), result.stream);
  }
  async pdf(options = {}) {
    const { path: path2 = void 0 } = options;
    const readable = await this.createPDFStream(options);
    const buffer = await getReadableAsBuffer(readable, path2);
    assert$1(buffer, "Could not create buffer");
    return buffer;
  }
  async close(options = { runBeforeUnload: void 0 }) {
    const connection = __privateGet(this, _primaryTargetClient).connection();
    assert$1(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
    const runBeforeUnload = !!options.runBeforeUnload;
    if (runBeforeUnload) {
      await __privateGet(this, _primaryTargetClient).send("Page.close");
    } else {
      await connection.send("Target.closeTarget", {
        targetId: __privateGet(this, _primaryTarget)._targetId
      });
      await __privateGet(this, _tabTarget)._isClosedDeferred.valueOrThrow();
    }
  }
  isClosed() {
    return __privateGet(this, _closed2);
  }
  get mouse() {
    return __privateGet(this, _mouse);
  }
  /**
   * This method is typically coupled with an action that triggers a device
   * request from an api such as WebBluetooth.
   *
   * :::caution
   *
   * This must be called before the device request is made. It will not return a
   * currently active device prompt.
   *
   * :::
   *
   * @example
   *
   * ```ts
   * const [devicePrompt] = Promise.all([
   *   page.waitForDevicePrompt(),
   *   page.click('#connect-bluetooth'),
   * ]);
   * await devicePrompt.select(
   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
   * );
   * ```
   */
  async waitForDevicePrompt(options = {}) {
    return await this.mainFrame().waitForDevicePrompt(options);
  }
};
_closed2 = new WeakMap();
_targetManager = new WeakMap();
_primaryTargetClient = new WeakMap();
_primaryTarget = new WeakMap();
_tabTargetClient = new WeakMap();
_tabTarget = new WeakMap();
_keyboard3 = new WeakMap();
_mouse = new WeakMap();
_touchscreen = new WeakMap();
_accessibility = new WeakMap();
_frameManager2 = new WeakMap();
_emulationManager = new WeakMap();
_tracing = new WeakMap();
_bindings2 = new WeakMap();
_exposedFunctions = new WeakMap();
_coverage = new WeakMap();
_viewport = new WeakMap();
_workers = new WeakMap();
_fileChooserDeferreds = new WeakMap();
_sessionCloseDeferred = new WeakMap();
_serviceWorkerBypassed = new WeakMap();
_userDragInterceptionEnabled = new WeakMap();
_frameManagerHandlers = new WeakMap();
_networkManagerHandlers = new WeakMap();
_sessionHandlers = new WeakMap();
_onActivation = new WeakSet();
onActivation_fn = async function(newSession) {
  __privateSet(this, _primaryTargetClient, newSession);
  assert$1(__privateGet(this, _primaryTargetClient) instanceof CdpCDPSession, "CDPSession is not instance of CDPSessionImpl");
  __privateSet(this, _primaryTarget, __privateGet(this, _primaryTargetClient)._target());
  assert$1(__privateGet(this, _primaryTarget), "Missing target on swap");
  __privateGet(this, _keyboard3).updateClient(newSession);
  __privateGet(this, _mouse).updateClient(newSession);
  __privateGet(this, _touchscreen).updateClient(newSession);
  __privateGet(this, _accessibility).updateClient(newSession);
  __privateGet(this, _emulationManager).updateClient(newSession);
  __privateGet(this, _tracing).updateClient(newSession);
  __privateGet(this, _coverage).updateClient(newSession);
  await __privateGet(this, _frameManager2).swapFrameTree(newSession);
  __privateMethod(this, _setupPrimaryTargetListeners, setupPrimaryTargetListeners_fn).call(this);
};
_onSecondaryTarget = new WeakSet();
onSecondaryTarget_fn = async function(session) {
  assert$1(session instanceof CdpCDPSession);
  if (session._target()._subtype() !== "prerender") {
    return;
  }
  __privateGet(this, _frameManager2).registerSpeculativeSession(session).catch(debugError);
  __privateGet(this, _emulationManager).registerSpeculativeSession(session).catch(debugError);
};
_setupPrimaryTargetListeners = new WeakSet();
setupPrimaryTargetListeners_fn = function() {
  __privateGet(this, _primaryTargetClient).on(CDPSessionEvent.Ready, __privateGet(this, _onAttachedToTarget2));
  for (const [eventName, handler] of __privateGet(this, _sessionHandlers)) {
    __privateGet(this, _primaryTargetClient).on(eventName, handler);
  }
};
_onDetachedFromTarget = new WeakMap();
_onAttachedToTarget2 = new WeakMap();
_initialize = new WeakSet();
initialize_fn = async function() {
  try {
    await Promise.all([
      __privateGet(this, _frameManager2).initialize(__privateGet(this, _primaryTargetClient)),
      __privateGet(this, _primaryTargetClient).send("Performance.enable"),
      __privateGet(this, _primaryTargetClient).send("Log.enable")
    ]);
  } catch (err) {
    if (isErrorLike$1(err) && isTargetClosedError(err)) {
      debugError(err);
    } else {
      throw err;
    }
  }
};
_onFileChooser = new WeakSet();
onFileChooser_fn = async function(event) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    if (!__privateGet(this, _fileChooserDeferreds).size) {
      return;
    }
    const frame = __privateGet(this, _frameManager2).frame(event.frameId);
    assert$1(frame, "This should never happen.");
    const handle = __addDisposableResource$1(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);
    const fileChooser = new FileChooser(handle.move(), event);
    for (const promise of __privateGet(this, _fileChooserDeferreds)) {
      promise.resolve(fileChooser);
    }
    __privateGet(this, _fileChooserDeferreds).clear();
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources$1(env_1);
  }
};
_onTargetCrashed = new WeakSet();
onTargetCrashed_fn = function() {
  this.emit("error", new Error("Page crashed!"));
};
_onLogEntryAdded = new WeakSet();
onLogEntryAdded_fn = function(event) {
  const { level, text, args, source: source2, url, lineNumber } = event.entry;
  if (args) {
    args.map((arg) => {
      void releaseObject(__privateGet(this, _primaryTargetClient), arg);
    });
  }
  if (source2 !== "worker") {
    this.emit("console", new ConsoleMessage(convertConsoleMessageLevel(level), text, [], [{ url, lineNumber }]));
  }
};
_emitMetrics = new WeakSet();
emitMetrics_fn = function(event) {
  this.emit("metrics", {
    title: event.title,
    metrics: __privateMethod(this, _buildMetricsObject, buildMetricsObject_fn).call(this, event.metrics)
  });
};
_buildMetricsObject = new WeakSet();
buildMetricsObject_fn = function(metrics) {
  const result = {};
  for (const metric of metrics || []) {
    if (supportedMetrics.has(metric.name)) {
      result[metric.name] = metric.value;
    }
  }
  return result;
};
_handleException = new WeakSet();
handleException_fn = function(exception) {
  this.emit("pageerror", createClientError(exception.exceptionDetails));
};
_onConsoleAPI2 = new WeakSet();
onConsoleAPI_fn2 = function(world, event) {
  const values = event.args.map((arg) => {
    return world.createCdpHandle(arg);
  });
  __privateMethod(this, _addConsoleMessage, addConsoleMessage_fn).call(this, convertConsoleMessageLevel(event.type), values, event.stackTrace);
};
_onBindingCalled2 = new WeakSet();
onBindingCalled_fn2 = async function(world, event) {
  let payload;
  try {
    payload = JSON.parse(event.payload);
  } catch {
    return;
  }
  const { type, name: name2, seq, args, isTrivial } = payload;
  if (type !== "exposedFun") {
    return;
  }
  const context2 = world.context;
  if (!context2) {
    return;
  }
  const binding = __privateGet(this, _bindings2).get(name2);
  await (binding == null ? void 0 : binding.run(context2, seq, args, isTrivial));
};
_addConsoleMessage = new WeakSet();
addConsoleMessage_fn = function(eventType, args, stackTrace) {
  if (!this.listenerCount(
    "console"
    /* PageEvent.Console */
  )) {
    args.forEach((arg) => {
      return arg.dispose();
    });
    return;
  }
  const textTokens = [];
  for (const arg of args) {
    const remoteObject = arg.remoteObject();
    if (remoteObject.objectId) {
      textTokens.push(arg.toString());
    } else {
      textTokens.push(valueFromRemoteObject(remoteObject));
    }
  }
  const stackTraceLocations = [];
  if (stackTrace) {
    for (const callFrame of stackTrace.callFrames) {
      stackTraceLocations.push({
        url: callFrame.url,
        lineNumber: callFrame.lineNumber,
        columnNumber: callFrame.columnNumber
      });
    }
  }
  const message2 = new ConsoleMessage(convertConsoleMessageLevel(eventType), textTokens.join(" "), args, stackTraceLocations);
  this.emit("console", message2);
};
_onDialog = new WeakSet();
onDialog_fn = function(event) {
  const type = validateDialogType(event.type);
  const dialog = new CdpDialog(__privateGet(this, _primaryTargetClient), type, event.message, event.defaultPrompt);
  this.emit("dialog", dialog);
};
_go = new WeakSet();
go_fn = async function(delta, options) {
  const history = await __privateGet(this, _primaryTargetClient).send("Page.getNavigationHistory");
  const entry = history.entries[history.currentIndex + delta];
  if (!entry) {
    return null;
  }
  const result = await Promise.all([
    this.waitForNavigation(options),
    __privateGet(this, _primaryTargetClient).send("Page.navigateToHistoryEntry", {
      entryId: entry.id
    })
  ]);
  return result[0];
};
let CdpPage = _CdpPage;
const supportedMetrics = /* @__PURE__ */ new Set([
  "Timestamp",
  "Documents",
  "Frames",
  "JSEventListeners",
  "Nodes",
  "LayoutCount",
  "RecalcStyleCount",
  "LayoutDuration",
  "RecalcStyleDuration",
  "ScriptDuration",
  "TaskDuration",
  "JSHeapUsedSize",
  "JSHeapTotalSize"
]);
function getIntersectionRect(clip, viewport) {
  const x2 = Math.max(clip.x, viewport.x);
  const y2 = Math.max(clip.y, viewport.y);
  return {
    x: x2,
    y: y2,
    width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x2, 0),
    height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y2, 0)
  };
}
/**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var InitializationStatus;
(function(InitializationStatus2) {
  InitializationStatus2["SUCCESS"] = "success";
  InitializationStatus2["ABORTED"] = "aborted";
})(InitializationStatus || (InitializationStatus = {}));
class CdpTarget extends Target {
  /**
   * To initialize the target for use, call initialize.
   *
   * @internal
   */
  constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
    super();
    __privateAdd(this, _browserContext, void 0);
    __privateAdd(this, _session, void 0);
    __privateAdd(this, _targetInfo, void 0);
    __privateAdd(this, _targetManager2, void 0);
    __privateAdd(this, _sessionFactory, void 0);
    __publicField(this, "_initializedDeferred", Deferred.create());
    __publicField(this, "_isClosedDeferred", Deferred.create());
    __publicField(this, "_targetId");
    __privateSet(this, _session, session);
    __privateSet(this, _targetManager2, targetManager);
    __privateSet(this, _targetInfo, targetInfo);
    __privateSet(this, _browserContext, browserContext);
    this._targetId = targetInfo.targetId;
    __privateSet(this, _sessionFactory, sessionFactory);
    if (__privateGet(this, _session) && __privateGet(this, _session) instanceof CdpCDPSession) {
      __privateGet(this, _session)._setTarget(this);
    }
  }
  async asPage() {
    const session = this._session();
    if (!session) {
      return await this.createCDPSession().then((client) => {
        return CdpPage._create(client, this, null);
      });
    }
    return await CdpPage._create(session, this, null);
  }
  _subtype() {
    return __privateGet(this, _targetInfo).subtype;
  }
  _session() {
    return __privateGet(this, _session);
  }
  _sessionFactory() {
    if (!__privateGet(this, _sessionFactory)) {
      throw new Error("sessionFactory is not initialized");
    }
    return __privateGet(this, _sessionFactory);
  }
  createCDPSession() {
    if (!__privateGet(this, _sessionFactory)) {
      throw new Error("sessionFactory is not initialized");
    }
    return __privateGet(this, _sessionFactory).call(this, false).then((session) => {
      session._setTarget(this);
      return session;
    });
  }
  url() {
    return __privateGet(this, _targetInfo).url;
  }
  type() {
    const type = __privateGet(this, _targetInfo).type;
    switch (type) {
      case "page":
        return exports.TargetType.PAGE;
      case "background_page":
        return exports.TargetType.BACKGROUND_PAGE;
      case "service_worker":
        return exports.TargetType.SERVICE_WORKER;
      case "shared_worker":
        return exports.TargetType.SHARED_WORKER;
      case "browser":
        return exports.TargetType.BROWSER;
      case "webview":
        return exports.TargetType.WEBVIEW;
      case "tab":
        return exports.TargetType.TAB;
      default:
        return exports.TargetType.OTHER;
    }
  }
  _targetManager() {
    if (!__privateGet(this, _targetManager2)) {
      throw new Error("targetManager is not initialized");
    }
    return __privateGet(this, _targetManager2);
  }
  _getTargetInfo() {
    return __privateGet(this, _targetInfo);
  }
  browser() {
    if (!__privateGet(this, _browserContext)) {
      throw new Error("browserContext is not initialized");
    }
    return __privateGet(this, _browserContext).browser();
  }
  browserContext() {
    if (!__privateGet(this, _browserContext)) {
      throw new Error("browserContext is not initialized");
    }
    return __privateGet(this, _browserContext);
  }
  opener() {
    const { openerId } = __privateGet(this, _targetInfo);
    if (!openerId) {
      return;
    }
    return this.browser().targets().find((target) => {
      return target._targetId === openerId;
    });
  }
  _targetInfoChanged(targetInfo) {
    __privateSet(this, _targetInfo, targetInfo);
    this._checkIfInitialized();
  }
  _initialize() {
    this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
  }
  _isTargetExposed() {
    return this.type() !== exports.TargetType.TAB && !this._subtype();
  }
  _checkIfInitialized() {
    if (!this._initializedDeferred.resolved()) {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
  }
}
_browserContext = new WeakMap();
_session = new WeakMap();
_targetInfo = new WeakMap();
_targetManager2 = new WeakMap();
_sessionFactory = new WeakMap();
const _PageTarget = class _PageTarget extends CdpTarget {
  constructor(targetInfo, session, browserContext, targetManager, sessionFactory, defaultViewport) {
    super(targetInfo, session, browserContext, targetManager, sessionFactory);
    __privateAdd(this, _defaultViewport, void 0);
    __publicField(this, "pagePromise");
    __privateSet(this, _defaultViewport, defaultViewport ?? void 0);
  }
  _initialize() {
    this._initializedDeferred.valueOrThrow().then(async (result) => {
      if (result === InitializationStatus.ABORTED) {
        return;
      }
      const opener = this.opener();
      if (!(opener instanceof _PageTarget)) {
        return;
      }
      if (!opener || !opener.pagePromise || this.type() !== "page") {
        return true;
      }
      const openerPage = await opener.pagePromise;
      if (!openerPage.listenerCount(
        "popup"
        /* PageEvent.Popup */
      )) {
        return true;
      }
      const popupPage = await this.page();
      openerPage.emit("popup", popupPage);
      return true;
    }).catch(debugError);
    this._checkIfInitialized();
  }
  async page() {
    if (!this.pagePromise) {
      const session = this._session();
      this.pagePromise = (session ? Promise.resolve(session) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        false
      )).then((client) => {
        return CdpPage._create(client, this, __privateGet(this, _defaultViewport) ?? null);
      });
    }
    return await this.pagePromise ?? null;
  }
  _checkIfInitialized() {
    if (this._initializedDeferred.resolved()) {
      return;
    }
    if (this._getTargetInfo().url !== "") {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
  }
};
_defaultViewport = new WeakMap();
let PageTarget = _PageTarget;
class DevToolsTarget extends PageTarget {
}
class WorkerTarget extends CdpTarget {
  constructor() {
    super(...arguments);
    __privateAdd(this, _workerPromise, void 0);
  }
  async worker() {
    if (!__privateGet(this, _workerPromise)) {
      const session = this._session();
      __privateSet(this, _workerPromise, (session ? Promise.resolve(session) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        false
      )).then((client) => {
        return new CdpWebWorker(
          client,
          this._getTargetInfo().url,
          this._targetId,
          this.type(),
          () => {
          },
          () => {
          }
          /* exceptionThrown */
        );
      }));
    }
    return await __privateGet(this, _workerPromise);
  }
}
_workerPromise = new WeakMap();
class OtherTarget extends CdpTarget {
}
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function isPageTargetBecomingPrimary(target, newTargetInfo) {
  return Boolean(target._subtype()) && !newTargetInfo.subtype;
}
class ChromeTargetManager extends EventEmitter$2 {
  constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {
    super();
    __privateAdd(this, _setupAttachmentListeners);
    __privateAdd(this, _removeAttachmentListeners);
    __privateAdd(this, _finishInitializationIfReady2);
    __privateAdd(this, _connection4, void 0);
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    __privateAdd(this, _discoveredTargetsByTargetId2, /* @__PURE__ */ new Map());
    /**
     * A target is added to this map once ChromeTargetManager has created
     * a Target and attached at least once to it.
     */
    __privateAdd(this, _attachedTargetsByTargetId, /* @__PURE__ */ new Map());
    /**
     * Tracks which sessions attach to which target.
     */
    __privateAdd(this, _attachedTargetsBySessionId, /* @__PURE__ */ new Map());
    /**
     * If a target was filtered out by `targetFilterCallback`, we still receive
     * events about it from CDP, but we don't forward them to the rest of Puppeteer.
     */
    __privateAdd(this, _ignoredTargets, /* @__PURE__ */ new Set());
    __privateAdd(this, _targetFilterCallback2, void 0);
    __privateAdd(this, _targetFactory2, void 0);
    __privateAdd(this, _attachedToTargetListenersBySession2, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _detachedFromTargetListenersBySession, /* @__PURE__ */ new WeakMap());
    __privateAdd(this, _initializeDeferred2, Deferred.create());
    __privateAdd(this, _targetsIdsForInit2, /* @__PURE__ */ new Set());
    __privateAdd(this, _waitForInitiallyDiscoveredTargets, true);
    __privateAdd(this, _discoveryFilter, [{}]);
    __privateAdd(this, _storeExistingTargetsForInit, () => {
      if (!__privateGet(this, _waitForInitiallyDiscoveredTargets)) {
        return;
      }
      for (const [targetId, targetInfo] of __privateGet(this, _discoveredTargetsByTargetId2).entries()) {
        const targetForFilter = new CdpTarget(targetInfo, void 0, void 0, this, void 0);
        if ((!__privateGet(this, _targetFilterCallback2) || __privateGet(this, _targetFilterCallback2).call(this, targetForFilter)) && targetInfo.type !== "browser") {
          __privateGet(this, _targetsIdsForInit2).add(targetId);
        }
      }
    });
    __privateAdd(this, _onSessionDetached2, (session) => {
      __privateMethod(this, _removeAttachmentListeners, removeAttachmentListeners_fn).call(this, session);
    });
    __privateAdd(this, _onTargetCreated2, async (event) => {
      __privateGet(this, _discoveredTargetsByTargetId2).set(event.targetInfo.targetId, event.targetInfo);
      this.emit("targetDiscovered", event.targetInfo);
      if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
        if (__privateGet(this, _attachedTargetsByTargetId).has(event.targetInfo.targetId)) {
          return;
        }
        const target = __privateGet(this, _targetFactory2).call(this, event.targetInfo, void 0);
        target._initialize();
        __privateGet(this, _attachedTargetsByTargetId).set(event.targetInfo.targetId, target);
      }
    });
    __privateAdd(this, _onTargetDestroyed2, (event) => {
      const targetInfo = __privateGet(this, _discoveredTargetsByTargetId2).get(event.targetId);
      __privateGet(this, _discoveredTargetsByTargetId2).delete(event.targetId);
      __privateMethod(this, _finishInitializationIfReady2, finishInitializationIfReady_fn2).call(this, event.targetId);
      if ((targetInfo == null ? void 0 : targetInfo.type) === "service_worker" && __privateGet(this, _attachedTargetsByTargetId).has(event.targetId)) {
        const target = __privateGet(this, _attachedTargetsByTargetId).get(event.targetId);
        if (target) {
          this.emit("targetGone", target);
          __privateGet(this, _attachedTargetsByTargetId).delete(event.targetId);
        }
      }
    });
    __privateAdd(this, _onTargetInfoChanged, (event) => {
      var _a3;
      __privateGet(this, _discoveredTargetsByTargetId2).set(event.targetInfo.targetId, event.targetInfo);
      if (__privateGet(this, _ignoredTargets).has(event.targetInfo.targetId) || !__privateGet(this, _attachedTargetsByTargetId).has(event.targetInfo.targetId) || !event.targetInfo.attached) {
        return;
      }
      const target = __privateGet(this, _attachedTargetsByTargetId).get(event.targetInfo.targetId);
      if (!target) {
        return;
      }
      const previousURL = target.url();
      const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;
      if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
        const session = target == null ? void 0 : target._session();
        assert$1(session, "Target that is being activated is missing a CDPSession.");
        (_a3 = session.parentSession()) == null ? void 0 : _a3.emit(CDPSessionEvent.Swapped, session);
      }
      target._targetInfoChanged(event.targetInfo);
      if (wasInitialized && previousURL !== target.url()) {
        this.emit("targetChanged", {
          target,
          wasInitialized,
          previousURL
        });
      }
    });
    __privateAdd(this, _onAttachedToTarget3, async (parentSession, event) => {
      const targetInfo = event.targetInfo;
      const session = __privateGet(this, _connection4).session(event.sessionId);
      if (!session) {
        throw new Error(`Session ${event.sessionId} was not created.`);
      }
      const silentDetach = async () => {
        await session.send("Runtime.runIfWaitingForDebugger").catch(debugError);
        await parentSession.send("Target.detachFromTarget", {
          sessionId: session.id()
        }).catch(debugError);
      };
      if (!__privateGet(this, _connection4).isAutoAttached(targetInfo.targetId)) {
        return;
      }
      if (targetInfo.type === "service_worker") {
        __privateMethod(this, _finishInitializationIfReady2, finishInitializationIfReady_fn2).call(this, targetInfo.targetId);
        await silentDetach();
        if (__privateGet(this, _attachedTargetsByTargetId).has(targetInfo.targetId)) {
          return;
        }
        const target2 = __privateGet(this, _targetFactory2).call(this, targetInfo);
        target2._initialize();
        __privateGet(this, _attachedTargetsByTargetId).set(targetInfo.targetId, target2);
        this.emit("targetAvailable", target2);
        return;
      }
      const isExistingTarget = __privateGet(this, _attachedTargetsByTargetId).has(targetInfo.targetId);
      const target = isExistingTarget ? __privateGet(this, _attachedTargetsByTargetId).get(targetInfo.targetId) : __privateGet(this, _targetFactory2).call(this, targetInfo, session, parentSession instanceof CDPSession ? parentSession : void 0);
      if (__privateGet(this, _targetFilterCallback2) && !__privateGet(this, _targetFilterCallback2).call(this, target)) {
        __privateGet(this, _ignoredTargets).add(targetInfo.targetId);
        __privateMethod(this, _finishInitializationIfReady2, finishInitializationIfReady_fn2).call(this, targetInfo.targetId);
        await silentDetach();
        return;
      }
      __privateMethod(this, _setupAttachmentListeners, setupAttachmentListeners_fn).call(this, session);
      if (isExistingTarget) {
        session._setTarget(target);
        __privateGet(this, _attachedTargetsBySessionId).set(session.id(), __privateGet(this, _attachedTargetsByTargetId).get(targetInfo.targetId));
      } else {
        target._initialize();
        __privateGet(this, _attachedTargetsByTargetId).set(targetInfo.targetId, target);
        __privateGet(this, _attachedTargetsBySessionId).set(session.id(), target);
      }
      parentSession.emit(CDPSessionEvent.Ready, session);
      __privateGet(this, _targetsIdsForInit2).delete(target._targetId);
      if (!isExistingTarget) {
        this.emit("targetAvailable", target);
      }
      __privateMethod(this, _finishInitializationIfReady2, finishInitializationIfReady_fn2).call(this);
      await Promise.all([
        session.send("Target.setAutoAttach", {
          waitForDebuggerOnStart: true,
          flatten: true,
          autoAttach: true,
          filter: __privateGet(this, _discoveryFilter)
        }),
        session.send("Runtime.runIfWaitingForDebugger")
      ]).catch(debugError);
    });
    __privateAdd(this, _onDetachedFromTarget2, (_parentSession, event) => {
      const target = __privateGet(this, _attachedTargetsBySessionId).get(event.sessionId);
      __privateGet(this, _attachedTargetsBySessionId).delete(event.sessionId);
      if (!target) {
        return;
      }
      __privateGet(this, _attachedTargetsByTargetId).delete(target._targetId);
      this.emit("targetGone", target);
    });
    __privateSet(this, _connection4, connection);
    __privateSet(this, _targetFilterCallback2, targetFilterCallback);
    __privateSet(this, _targetFactory2, targetFactory);
    __privateSet(this, _waitForInitiallyDiscoveredTargets, waitForInitiallyDiscoveredTargets);
    __privateGet(this, _connection4).on("Target.targetCreated", __privateGet(this, _onTargetCreated2));
    __privateGet(this, _connection4).on("Target.targetDestroyed", __privateGet(this, _onTargetDestroyed2));
    __privateGet(this, _connection4).on("Target.targetInfoChanged", __privateGet(this, _onTargetInfoChanged));
    __privateGet(this, _connection4).on(CDPSessionEvent.SessionDetached, __privateGet(this, _onSessionDetached2));
    __privateMethod(this, _setupAttachmentListeners, setupAttachmentListeners_fn).call(this, __privateGet(this, _connection4));
  }
  async initialize() {
    await __privateGet(this, _connection4).send("Target.setDiscoverTargets", {
      discover: true,
      filter: __privateGet(this, _discoveryFilter)
    });
    __privateGet(this, _storeExistingTargetsForInit).call(this);
    await __privateGet(this, _connection4).send("Target.setAutoAttach", {
      waitForDebuggerOnStart: true,
      flatten: true,
      autoAttach: true,
      filter: [
        {
          type: "page",
          exclude: true
        },
        ...__privateGet(this, _discoveryFilter)
      ]
    });
    __privateMethod(this, _finishInitializationIfReady2, finishInitializationIfReady_fn2).call(this);
    await __privateGet(this, _initializeDeferred2).valueOrThrow();
  }
  dispose() {
    __privateGet(this, _connection4).off("Target.targetCreated", __privateGet(this, _onTargetCreated2));
    __privateGet(this, _connection4).off("Target.targetDestroyed", __privateGet(this, _onTargetDestroyed2));
    __privateGet(this, _connection4).off("Target.targetInfoChanged", __privateGet(this, _onTargetInfoChanged));
    __privateGet(this, _connection4).off(CDPSessionEvent.SessionDetached, __privateGet(this, _onSessionDetached2));
    __privateMethod(this, _removeAttachmentListeners, removeAttachmentListeners_fn).call(this, __privateGet(this, _connection4));
  }
  getAvailableTargets() {
    return __privateGet(this, _attachedTargetsByTargetId);
  }
}
_connection4 = new WeakMap();
_discoveredTargetsByTargetId2 = new WeakMap();
_attachedTargetsByTargetId = new WeakMap();
_attachedTargetsBySessionId = new WeakMap();
_ignoredTargets = new WeakMap();
_targetFilterCallback2 = new WeakMap();
_targetFactory2 = new WeakMap();
_attachedToTargetListenersBySession2 = new WeakMap();
_detachedFromTargetListenersBySession = new WeakMap();
_initializeDeferred2 = new WeakMap();
_targetsIdsForInit2 = new WeakMap();
_waitForInitiallyDiscoveredTargets = new WeakMap();
_discoveryFilter = new WeakMap();
_storeExistingTargetsForInit = new WeakMap();
_setupAttachmentListeners = new WeakSet();
setupAttachmentListeners_fn = function(session) {
  const listener = (event) => {
    void __privateGet(this, _onAttachedToTarget3).call(this, session, event);
  };
  assert$1(!__privateGet(this, _attachedToTargetListenersBySession2).has(session));
  __privateGet(this, _attachedToTargetListenersBySession2).set(session, listener);
  session.on("Target.attachedToTarget", listener);
  const detachedListener = (event) => {
    return __privateGet(this, _onDetachedFromTarget2).call(this, session, event);
  };
  assert$1(!__privateGet(this, _detachedFromTargetListenersBySession).has(session));
  __privateGet(this, _detachedFromTargetListenersBySession).set(session, detachedListener);
  session.on("Target.detachedFromTarget", detachedListener);
};
_removeAttachmentListeners = new WeakSet();
removeAttachmentListeners_fn = function(session) {
  const listener = __privateGet(this, _attachedToTargetListenersBySession2).get(session);
  if (listener) {
    session.off("Target.attachedToTarget", listener);
    __privateGet(this, _attachedToTargetListenersBySession2).delete(session);
  }
  if (__privateGet(this, _detachedFromTargetListenersBySession).has(session)) {
    session.off("Target.detachedFromTarget", __privateGet(this, _detachedFromTargetListenersBySession).get(session));
    __privateGet(this, _detachedFromTargetListenersBySession).delete(session);
  }
};
_onSessionDetached2 = new WeakMap();
_onTargetCreated2 = new WeakMap();
_onTargetDestroyed2 = new WeakMap();
_onTargetInfoChanged = new WeakMap();
_onAttachedToTarget3 = new WeakMap();
_finishInitializationIfReady2 = new WeakSet();
finishInitializationIfReady_fn2 = function(targetId) {
  targetId !== void 0 && __privateGet(this, _targetsIdsForInit2).delete(targetId);
  if (__privateGet(this, _targetsIdsForInit2).size === 0) {
    __privateGet(this, _initializeDeferred2).resolve();
  }
};
_onDetachedFromTarget2 = new WeakMap();
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _CdpBrowser = class _CdpBrowser extends Browser$1 {
  constructor(product, connection, contextIds, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
    super();
    __privateAdd(this, _setIsPageTargetCallback);
    __privateAdd(this, _getVersion);
    __publicField(this, "protocol", "cdp");
    __privateAdd(this, _defaultViewport2, void 0);
    __privateAdd(this, _process, void 0);
    __privateAdd(this, _connection5, void 0);
    __privateAdd(this, _closeCallback, void 0);
    __privateAdd(this, _targetFilterCallback3, void 0);
    __privateAdd(this, _isPageTargetCallback, void 0);
    __privateAdd(this, _defaultContext, void 0);
    __privateAdd(this, _contexts, /* @__PURE__ */ new Map());
    __privateAdd(this, _targetManager3, void 0);
    __privateAdd(this, _emitDisconnected, () => {
      this.emit("disconnected", void 0);
    });
    __privateAdd(this, _createTarget, (targetInfo, session) => {
      var _a3;
      const { browserContextId } = targetInfo;
      const context2 = browserContextId && __privateGet(this, _contexts).has(browserContextId) ? __privateGet(this, _contexts).get(browserContextId) : __privateGet(this, _defaultContext);
      if (!context2) {
        throw new Error("Missing browser context");
      }
      const createSession = (isAutoAttachEmulated) => {
        return __privateGet(this, _connection5)._createSession(targetInfo, isAutoAttachEmulated);
      };
      const otherTarget = new OtherTarget(targetInfo, session, context2, __privateGet(this, _targetManager3), createSession);
      if ((_a3 = targetInfo.url) == null ? void 0 : _a3.startsWith("devtools://")) {
        return new DevToolsTarget(targetInfo, session, context2, __privateGet(this, _targetManager3), createSession, __privateGet(this, _defaultViewport2) ?? null);
      }
      if (__privateGet(this, _isPageTargetCallback).call(this, otherTarget)) {
        return new PageTarget(targetInfo, session, context2, __privateGet(this, _targetManager3), createSession, __privateGet(this, _defaultViewport2) ?? null);
      }
      if (targetInfo.type === "service_worker" || targetInfo.type === "shared_worker") {
        return new WorkerTarget(targetInfo, session, context2, __privateGet(this, _targetManager3), createSession);
      }
      return otherTarget;
    });
    __privateAdd(this, _onAttachedToTarget4, async (target) => {
      if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
        this.emit("targetcreated", target);
        target.browserContext().emit("targetcreated", target);
      }
    });
    __privateAdd(this, _onDetachedFromTarget3, async (target) => {
      target._initializedDeferred.resolve(InitializationStatus.ABORTED);
      target._isClosedDeferred.resolve();
      if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
        this.emit("targetdestroyed", target);
        target.browserContext().emit("targetdestroyed", target);
      }
    });
    __privateAdd(this, _onTargetChanged, ({ target }) => {
      this.emit("targetchanged", target);
      target.browserContext().emit("targetchanged", target);
    });
    __privateAdd(this, _onTargetDiscovered, (targetInfo) => {
      this.emit("targetdiscovered", targetInfo);
    });
    product = product || "chrome";
    __privateSet(this, _defaultViewport2, defaultViewport);
    __privateSet(this, _process, process2);
    __privateSet(this, _connection5, connection);
    __privateSet(this, _closeCallback, closeCallback || (() => {
    }));
    __privateSet(this, _targetFilterCallback3, targetFilterCallback || (() => {
      return true;
    }));
    __privateMethod(this, _setIsPageTargetCallback, setIsPageTargetCallback_fn).call(this, isPageTargetCallback);
    if (product === "firefox") {
      __privateSet(this, _targetManager3, new FirefoxTargetManager(connection, __privateGet(this, _createTarget), __privateGet(this, _targetFilterCallback3)));
    } else {
      __privateSet(this, _targetManager3, new ChromeTargetManager(connection, __privateGet(this, _createTarget), __privateGet(this, _targetFilterCallback3), waitForInitiallyDiscoveredTargets));
    }
    __privateSet(this, _defaultContext, new CdpBrowserContext(__privateGet(this, _connection5), this));
    for (const contextId of contextIds) {
      __privateGet(this, _contexts).set(contextId, new CdpBrowserContext(__privateGet(this, _connection5), this, contextId));
    }
  }
  static async _create(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
    const browser2 = new _CdpBrowser(product, connection, contextIds, defaultViewport, process2, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets);
    if (ignoreHTTPSErrors) {
      await connection.send("Security.setIgnoreCertificateErrors", {
        ignore: true
      });
    }
    await browser2._attach();
    return browser2;
  }
  async _attach() {
    __privateGet(this, _connection5).on(CDPSessionEvent.Disconnected, __privateGet(this, _emitDisconnected));
    __privateGet(this, _targetManager3).on("targetAvailable", __privateGet(this, _onAttachedToTarget4));
    __privateGet(this, _targetManager3).on("targetGone", __privateGet(this, _onDetachedFromTarget3));
    __privateGet(this, _targetManager3).on("targetChanged", __privateGet(this, _onTargetChanged));
    __privateGet(this, _targetManager3).on("targetDiscovered", __privateGet(this, _onTargetDiscovered));
    await __privateGet(this, _targetManager3).initialize();
  }
  _detach() {
    __privateGet(this, _connection5).off(CDPSessionEvent.Disconnected, __privateGet(this, _emitDisconnected));
    __privateGet(this, _targetManager3).off("targetAvailable", __privateGet(this, _onAttachedToTarget4));
    __privateGet(this, _targetManager3).off("targetGone", __privateGet(this, _onDetachedFromTarget3));
    __privateGet(this, _targetManager3).off("targetChanged", __privateGet(this, _onTargetChanged));
    __privateGet(this, _targetManager3).off("targetDiscovered", __privateGet(this, _onTargetDiscovered));
  }
  process() {
    return __privateGet(this, _process) ?? null;
  }
  _targetManager() {
    return __privateGet(this, _targetManager3);
  }
  _getIsPageTargetCallback() {
    return __privateGet(this, _isPageTargetCallback);
  }
  async createBrowserContext(options = {}) {
    const { proxyServer, proxyBypassList } = options;
    const { browserContextId } = await __privateGet(this, _connection5).send("Target.createBrowserContext", {
      proxyServer,
      proxyBypassList: proxyBypassList && proxyBypassList.join(",")
    });
    const context2 = new CdpBrowserContext(__privateGet(this, _connection5), this, browserContextId);
    __privateGet(this, _contexts).set(browserContextId, context2);
    return context2;
  }
  browserContexts() {
    return [__privateGet(this, _defaultContext), ...Array.from(__privateGet(this, _contexts).values())];
  }
  defaultBrowserContext() {
    return __privateGet(this, _defaultContext);
  }
  async _disposeContext(contextId) {
    if (!contextId) {
      return;
    }
    await __privateGet(this, _connection5).send("Target.disposeBrowserContext", {
      browserContextId: contextId
    });
    __privateGet(this, _contexts).delete(contextId);
  }
  wsEndpoint() {
    return __privateGet(this, _connection5).url();
  }
  async newPage() {
    return await __privateGet(this, _defaultContext).newPage();
  }
  async _createPageInContext(contextId) {
    const { targetId } = await __privateGet(this, _connection5).send("Target.createTarget", {
      url: "about:blank",
      browserContextId: contextId || void 0
    });
    const target = await this.waitForTarget((t2) => {
      return t2._targetId === targetId;
    });
    if (!target) {
      throw new Error(`Missing target for page (id = ${targetId})`);
    }
    const initialized = await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS;
    if (!initialized) {
      throw new Error(`Failed to create target for page (id = ${targetId})`);
    }
    const page = await target.page();
    if (!page) {
      throw new Error(`Failed to create a page for context (id = ${contextId})`);
    }
    return page;
  }
  targets() {
    return Array.from(__privateGet(this, _targetManager3).getAvailableTargets().values()).filter((target) => {
      return target._isTargetExposed() && target._initializedDeferred.value() === InitializationStatus.SUCCESS;
    });
  }
  target() {
    const browserTarget = this.targets().find((target) => {
      return target.type() === "browser";
    });
    if (!browserTarget) {
      throw new Error("Browser target is not found");
    }
    return browserTarget;
  }
  async version() {
    const version2 = await __privateMethod(this, _getVersion, getVersion_fn).call(this);
    return version2.product;
  }
  async userAgent() {
    const version2 = await __privateMethod(this, _getVersion, getVersion_fn).call(this);
    return version2.userAgent;
  }
  async close() {
    await __privateGet(this, _closeCallback).call(null);
    await this.disconnect();
  }
  disconnect() {
    __privateGet(this, _targetManager3).dispose();
    __privateGet(this, _connection5).dispose();
    this._detach();
    return Promise.resolve();
  }
  get connected() {
    return !__privateGet(this, _connection5)._closed;
  }
  get debugInfo() {
    return {
      pendingProtocolErrors: __privateGet(this, _connection5).getPendingProtocolErrors()
    };
  }
};
_defaultViewport2 = new WeakMap();
_process = new WeakMap();
_connection5 = new WeakMap();
_closeCallback = new WeakMap();
_targetFilterCallback3 = new WeakMap();
_isPageTargetCallback = new WeakMap();
_defaultContext = new WeakMap();
_contexts = new WeakMap();
_targetManager3 = new WeakMap();
_emitDisconnected = new WeakMap();
_setIsPageTargetCallback = new WeakSet();
setIsPageTargetCallback_fn = function(isPageTargetCallback) {
  __privateSet(this, _isPageTargetCallback, isPageTargetCallback || ((target) => {
    return target.type() === "page" || target.type() === "background_page" || target.type() === "webview";
  }));
};
_createTarget = new WeakMap();
_onAttachedToTarget4 = new WeakMap();
_onDetachedFromTarget3 = new WeakMap();
_onTargetChanged = new WeakMap();
_onTargetDiscovered = new WeakMap();
_getVersion = new WeakSet();
getVersion_fn = function() {
  return __privateGet(this, _connection5).send("Browser.getVersion");
};
let CdpBrowser = _CdpBrowser;
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
async function _connectToCdpBrowser(connectionTransport, url, options) {
  const { ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout } = options;
  const connection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
  const version2 = await connection.send("Browser.getVersion");
  const product = version2.product.toLowerCase().includes("firefox") ? "firefox" : "chrome";
  const { browserContextIds } = await connection.send("Target.getBrowserContexts");
  const browser2 = await CdpBrowser._create(product || "chrome", connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, void 0, () => {
    return connection.send("Browser.close").catch(debugError);
  }, targetFilter, isPageTarget);
  return browser2;
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const knownDevices = [
  {
    name: "Blackberry PlayBook",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 600,
      height: 1024,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Blackberry PlayBook landscape",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 1024,
      height: 600,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "BlackBerry Z30",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "BlackBerry Z30 landscape",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Note 3",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Note 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Note II",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Note II landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S III",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S III landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S5",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S8",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 740,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S8 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 740,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S9+",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 320,
      height: 658,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S9+ landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 658,
      height: 320,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Tab S4",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 712,
      height: 1138,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Tab S4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 1138,
      height: 712,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad (gen 6)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad (gen 6) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad (gen 7)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 810,
      height: 1080,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad (gen 7) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1080,
      height: 810,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Mini",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Mini landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Pro",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 1366,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Pro landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1366,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Pro 11",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 834,
      height: 1194,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Pro 11 landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1194,
      height: 834,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 4",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 320,
      height: 480,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 4 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 480,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 5",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 5 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 6",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 6 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 6 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 6 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 7",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 7 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 7 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 7 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 8",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 8 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 8 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 8 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone SE",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone SE landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone X",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone X landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone XR",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone XR landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 828,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 828,
      height: 414,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "JioPhone 2",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 240,
      height: 320,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "JioPhone 2 landscape",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 320,
      height: 240,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Kindle Fire HDX",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Kindle Fire HDX landscape",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "LG Optimus L70",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "LG Optimus L70 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Microsoft Lumia 550",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Microsoft Lumia 950",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Microsoft Lumia 950 landscape",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 10",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 10 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 4",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 5",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 5X",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 5X landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 6",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 6 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 6P",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 6P landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 7",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 600,
      height: 960,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 7 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 960,
      height: 600,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nokia Lumia 520",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 320,
      height: 533,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nokia Lumia 520 landscape",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 533,
      height: 320,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nokia N9",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 480,
      height: 854,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nokia N9 landscape",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 854,
      height: 480,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 2",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 731,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 2 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 731,
      height: 411,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 2 XL",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 823,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 2 XL landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 823,
      height: 411,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 3",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 786,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 786,
      height: 393,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 4",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 4a (5G)",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 4a (5G) landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 5",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 851,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 851,
      height: 393,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Moto G4",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Moto G4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }
];
const knownDevicesByName = {};
for (const device of knownDevices) {
  knownDevicesByName[device.name] = device;
}
Object.freeze(knownDevicesByName);
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
async function _connectToBiDiBrowser(connectionTransport, url, options) {
  const { ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT } = options;
  const { bidiConnection, closeCallback } = await getBiDiConnection(connectionTransport, url, options);
  const BiDi = await Promise.resolve().then(() => require(
    /* webpackIgnore: true */
    "./bidi-CcyBpVJ6.js"
  ));
  const bidiBrowser = await BiDi.BidiBrowser.create({
    connection: bidiConnection,
    closeCallback,
    process: void 0,
    defaultViewport,
    ignoreHTTPSErrors
  });
  return bidiBrowser;
}
async function getBiDiConnection(connectionTransport, url, options) {
  const BiDi = await Promise.resolve().then(() => require(
    /* webpackIgnore: true */
    "./bidi-CcyBpVJ6.js"
  ));
  const { ignoreHTTPSErrors = false, slowMo = 0, protocolTimeout } = options;
  const pureBidiConnection = new BiDi.BidiConnection(url, connectionTransport, slowMo, protocolTimeout);
  try {
    const result = await pureBidiConnection.send("session.status", {});
    if ("type" in result && result.type === "success") {
      return {
        bidiConnection: pureBidiConnection,
        closeCallback: async () => {
          await pureBidiConnection.send("browser.close", {}).catch(debugError);
        }
      };
    }
  } catch (e2) {
    if (!(e2 instanceof ProtocolError)) {
      throw e2;
    }
  }
  pureBidiConnection.unbind();
  const cdpConnection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
  const version2 = await cdpConnection.send("Browser.getVersion");
  if (version2.product.toLowerCase().includes("firefox")) {
    throw new UnsupportedOperation("Firefox is not supported in BiDi over CDP mode.");
  }
  const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection, {
    acceptInsecureCerts: ignoreHTTPSErrors
  });
  return {
    bidiConnection: bidiOverCdpConnection,
    closeCallback: async () => {
      await cdpConnection.send("Browser.close").catch(debugError);
    }
  };
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const getWebSocketTransportClass = async () => {
  return isNode ? (await Promise.resolve().then(() => NodeWebSocketTransport$1)).NodeWebSocketTransport : (await Promise.resolve().then(() => require("./BrowserWebSocketTransport-CBrQMxh1.js"))).BrowserWebSocketTransport;
};
async function _connectToBrowser(options) {
  const { connectionTransport, endpointUrl } = await getConnectionTransport(options);
  if (options.protocol === "webDriverBiDi") {
    const bidiBrowser = await _connectToBiDiBrowser(connectionTransport, endpointUrl, options);
    return bidiBrowser;
  } else {
    const cdpBrowser = await _connectToCdpBrowser(connectionTransport, endpointUrl, options);
    return cdpBrowser;
  }
}
async function getConnectionTransport(options) {
  const { browserWSEndpoint, browserURL, transport, headers = {} } = options;
  assert$1(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
  if (transport) {
    return { connectionTransport: transport, endpointUrl: "" };
  } else if (browserWSEndpoint) {
    const WebSocketClass = await getWebSocketTransportClass();
    const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
    return {
      connectionTransport,
      endpointUrl: browserWSEndpoint
    };
  } else if (browserURL) {
    const connectionURL = await getWSEndpoint(browserURL);
    const WebSocketClass = await getWebSocketTransportClass();
    const connectionTransport = await WebSocketClass.create(connectionURL);
    return {
      connectionTransport,
      endpointUrl: connectionURL
    };
  }
  throw new Error("Invalid connection options");
}
async function getWSEndpoint(browserURL) {
  const endpointURL = new URL("/json/version", browserURL);
  try {
    const result = await globalThis.fetch(endpointURL.toString(), {
      method: "GET"
    });
    if (!result.ok) {
      throw new Error(`HTTP ${result.statusText}`);
    }
    const data2 = await result.json();
    return data2.webSocketDebuggerUrl;
  } catch (error) {
    if (isErrorLike$1(error)) {
      error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;
    }
    throw error;
  }
}
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class Puppeteer {
  /**
   * @internal
   */
  constructor(settings) {
    /**
     * @internal
     */
    __publicField(this, "_isPuppeteerCore");
    /**
     * @internal
     */
    __publicField(this, "_changedProduct", false);
    this._isPuppeteerCore = settings.isPuppeteerCore;
    this.connect = this.connect.bind(this);
  }
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is only
   * allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```
   * puppeteer.registerCustomQueryHandler('text', {  });
   * const aHandle = await page.$('text/');
   * ```
   *
   * @param name - The name that the custom query handler will be registered
   * under.
   * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
   * to register.
   *
   * @public
   */
  static registerCustomQueryHandler(name2, queryHandler) {
    return this.customQueryHandlers.register(name2, queryHandler);
  }
  /**
   * Unregisters a custom query handler for a given name.
   */
  static unregisterCustomQueryHandler(name2) {
    return this.customQueryHandlers.unregister(name2);
  }
  /**
   * Gets the names of all custom query handlers.
   */
  static customQueryHandlerNames() {
    return this.customQueryHandlers.names();
  }
  /**
   * Unregisters all custom query handlers.
   */
  static clearCustomQueryHandlers() {
    return this.customQueryHandlers.clear();
  }
  /**
   * This method attaches Puppeteer to an existing browser instance.
   *
   * @remarks
   *
   * @param options - Set of configurable options to set on the browser.
   * @returns Promise which resolves to browser instance.
   */
  connect(options) {
    return _connectToBrowser(options);
  }
}
/**
 * Operations for {@link CustomQueryHandler | custom query handlers}. See
 * {@link CustomQueryHandlerRegistry}.
 *
 * @internal
 */
__publicField(Puppeteer, "customQueryHandlers", customQueryHandlers);
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const PUPPETEER_REVISIONS = Object.freeze({
  chrome: "125.0.6422.60",
  "chrome-headless-shell": "125.0.6422.60",
  firefox: "latest"
});
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var Browser2;
(function(Browser3) {
  Browser3["CHROME"] = "chrome";
  Browser3["CHROMEHEADLESSSHELL"] = "chrome-headless-shell";
  Browser3["CHROMIUM"] = "chromium";
  Browser3["FIREFOX"] = "firefox";
  Browser3["CHROMEDRIVER"] = "chromedriver";
})(Browser2 || (Browser2 = {}));
var BrowserPlatform;
(function(BrowserPlatform2) {
  BrowserPlatform2["LINUX"] = "linux";
  BrowserPlatform2["MAC"] = "mac";
  BrowserPlatform2["MAC_ARM"] = "mac_arm";
  BrowserPlatform2["WIN32"] = "win32";
  BrowserPlatform2["WIN64"] = "win64";
})(BrowserPlatform || (BrowserPlatform = {}));
var BrowserTag;
(function(BrowserTag2) {
  BrowserTag2["CANARY"] = "canary";
  BrowserTag2["NIGHTLY"] = "nightly";
  BrowserTag2["BETA"] = "beta";
  BrowserTag2["DEV"] = "dev";
  BrowserTag2["DEVEDITION"] = "devedition";
  BrowserTag2["STABLE"] = "stable";
  BrowserTag2["ESR"] = "esr";
  BrowserTag2["LATEST"] = "latest";
})(BrowserTag || (BrowserTag = {}));
var ChromeReleaseChannel;
(function(ChromeReleaseChannel2) {
  ChromeReleaseChannel2["STABLE"] = "stable";
  ChromeReleaseChannel2["DEV"] = "dev";
  ChromeReleaseChannel2["CANARY"] = "canary";
  ChromeReleaseChannel2["BETA"] = "beta";
})(ChromeReleaseChannel || (ChromeReleaseChannel = {}));
var re$3 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$8 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$f = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1$c = debug$f;
(function(module2, exports2) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$8;
  const debug2 = debug_1$c;
  exports2 = module2.exports = {};
  const re2 = exports2.re = [];
  const safeRe = exports2.safeRe = [];
  const src2 = exports2.src = [];
  const t2 = exports2.t = {};
  let R2 = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  const createToken = (name2, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index2 = R2++;
    debug2(name2, index2, value);
    t2[name2] = index2;
    src2[index2] = value;
    re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NUMERICIDENTIFIER]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NUMERICIDENTIFIERLOOSE]}|${src2[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src2[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t2.COERCEPLAIN] + `(?:${src2[t2.PRERELEASE]})?(?:${src2[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("COERCERTLFULL", src2[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$3, re$3.exports);
var reExports = re$3.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a2, b2) => {
  const anum = numeric.test(a2);
  const bnum = numeric.test(b2);
  if (anum && bnum) {
    a2 = +a2;
    b2 = +b2;
  }
  return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
};
const rcompareIdentifiers = (a2, b2) => compareIdentifiers$1(b2, a2);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$e = debug_1$c;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$8;
const { safeRe: re$2, t: t$2 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version2, options) {
    options = parseOptions(options);
    if (version2 instanceof SemVer) {
      if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
        return version2;
      } else {
        version2 = version2.version;
      }
    } else if (typeof version2 !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
    }
    if (version2.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug$e("SemVer", version2, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version2.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version2}`);
    }
    this.raw = version2;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$e("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a2 = this.prerelease[i2];
      const b2 = other.prerelease[i2];
      debug$e("prerelease compare", i2, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i2 = 0;
    do {
      const a2 = this.build[i2];
      const b2 = other.build[i2];
      debug$e("prerelease compare", i2, a2, b2);
      if (a2 === void 0 && b2 === void 0) {
        return 0;
      } else if (b2 === void 0) {
        return 1;
      } else if (a2 === void 0) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i2);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
var semver$2 = SemVer$d;
const SemVer$c = semver$2;
const parse$6 = (version2, options, throwErrors = false) => {
  if (version2 instanceof SemVer$c) {
    return version2;
  }
  try {
    return new SemVer$c(version2, options);
  } catch (er) {
    if (!throwErrors) {
      return null;
    }
    throw er;
  }
};
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version2, options) => {
  const v2 = parse$5(version2, options);
  return v2 ? v2.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version2, options) => {
  const s2 = parse$4(version2.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$2;
const inc$1 = (version2, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version2 instanceof SemVer$b ? version2.version : version2,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v12 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v12.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v12 : v2;
  const lowVersion = v1Higher ? v2 : v12;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (highVersion.patch) {
      return "patch";
    }
    if (highVersion.minor) {
      return "minor";
    }
    return "major";
  }
  const prefix = highHasPre ? "pre" : "";
  if (v12.major !== v2.major) {
    return prefix + "major";
  }
  if (v12.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v12.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$2;
const major$1 = (a2, loose) => new SemVer$a(a2, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$2;
const minor$1 = (a2, loose) => new SemVer$9(a2, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$2;
const patch$3 = (a2, loose) => new SemVer$8(a2, loose).patch;
var patch_1 = patch$3;
const parse$2 = parse_1;
const prerelease$1 = (version2, options) => {
  const parsed = parse$2(version2, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$2;
const compare$c = (a2, b2, loose) => new SemVer$7(a2, loose).compare(new SemVer$7(b2, loose));
var compare_1 = compare$c;
const compare$b = compare_1;
const rcompare$1 = (a2, b2, loose) => compare$b(b2, a2, loose);
var rcompare_1 = rcompare$1;
const compare$a = compare_1;
const compareLoose$1 = (a2, b2) => compare$a(a2, b2, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$2;
const compareBuild$3 = (a2, b2, loose) => {
  const versionA = new SemVer$6(a2, loose);
  const versionB = new SemVer$6(b2, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$2(a2, b2, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a2, b2) => compareBuild$1(b2, a2, loose));
var rsort_1 = rsort$1;
const compare$9 = compare_1;
const gt$5 = (a2, b2, loose) => compare$9(a2, b2, loose) > 0;
var gt_1 = gt$5;
const compare$8 = compare_1;
const lt$4 = (a2, b2, loose) => compare$8(a2, b2, loose) < 0;
var lt_1 = lt$4;
const compare$7 = compare_1;
const eq$2 = (a2, b2, loose) => compare$7(a2, b2, loose) === 0;
var eq_1 = eq$2;
const compare$6 = compare_1;
const neq$2 = (a2, b2, loose) => compare$6(a2, b2, loose) !== 0;
var neq_1 = neq$2;
const compare$5 = compare_1;
const gte$3 = (a2, b2, loose) => compare$5(a2, b2, loose) >= 0;
var gte_1 = gte$3;
const compare$4 = compare_1;
const lte$3 = (a2, b2, loose) => compare$4(a2, b2, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$4 = gt_1;
const gte$2 = gte_1;
const lt$3 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a2, op, b2, loose) => {
  switch (op) {
    case "===":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 === b2;
    case "!==":
      if (typeof a2 === "object") {
        a2 = a2.version;
      }
      if (typeof b2 === "object") {
        b2 = b2.version;
      }
      return a2 !== b2;
    case "":
    case "=":
    case "==":
      return eq$1(a2, b2, loose);
    case "!=":
      return neq$1(a2, b2, loose);
    case ">":
      return gt$4(a2, b2, loose);
    case ">=":
      return gte$2(a2, b2, loose);
    case "<":
      return lt$3(a2, b2, loose);
    case "<=":
      return lte$2(a2, b2, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$2;
const parse$1 = parse_1;
const { safeRe: re$1, t: t$1 } = reExports;
const coerce$1 = (version2, options) => {
  if (version2 instanceof SemVer$5) {
    return version2;
  }
  if (typeof version2 === "number") {
    version2 = String(version2);
  }
  if (typeof version2 !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version2.match(options.includePrerelease ? re$1[t$1.COERCEFULL] : re$1[t$1.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re$1[t$1.COERCERTLFULL] : re$1[t$1.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build2 = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build2}`, options);
};
var coerce_1 = coerce$1;
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node$1;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      self2.push(arguments[i2]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node2) {
  if (node2.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node2.next;
  var prev = node2.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node2 === this.head) {
    this.head = next;
  }
  if (node2 === this.tail) {
    this.tail = prev;
  }
  node2.list.length--;
  node2.next = null;
  node2.prev = null;
  node2.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node2) {
  if (node2 === this.head) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var head = this.head;
  node2.list = this;
  node2.next = head;
  if (head) {
    head.prev = node2;
  }
  this.head = node2;
  if (!this.tail) {
    this.tail = node2;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node2) {
  if (node2 === this.tail) {
    return;
  }
  if (node2.list) {
    node2.list.removeNode(node2);
  }
  var tail = this.tail;
  node2.list = this;
  node2.prev = tail;
  if (tail) {
    tail.next = node2;
  }
  this.tail = node2;
  if (!this.head) {
    this.head = node2;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    push(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    unshift(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i2 = 0; walker !== null; i2++) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n2) {
  for (var i2 = 0, walker = this.head; walker !== null && i2 < n2; i2++) {
    walker = walker.next;
  }
  if (i2 === n2 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n2) {
  for (var i2 = 0, walker = this.tail; walker !== null && i2 < n2; i2++) {
    walker = walker.prev;
  }
  if (i2 === n2 && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = 0; walker !== null; i2++) {
    acc = fn(acc, walker.value, i2);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = this.length - 1; walker !== null; i2--) {
    acc = fn(acc, walker.value, i2);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.head; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < from2; i2++) {
    walker = walker.next;
  }
  for (; walker !== null && i2 < to; i2++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from2, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from2 = from2 || 0;
  if (from2 < 0) {
    from2 += this.length;
  }
  var ret = new Yallist$1();
  if (to < from2 || to < 0) {
    return ret;
  }
  if (from2 < 0) {
    from2 = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
    walker = walker.prev;
  }
  for (; walker !== null && i2 > from2; i2--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i2 = 0; walker && i2 < deleteCount; i2++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i2 = 0; i2 < nodes.length; i2++) {
    walker = insert(this, walker, nodes[i2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p2 = walker.prev;
    walker.prev = walker.next;
    walker.next = p2;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node2, value) {
  var inserted = node2 === self2.head ? new Node$1(value, null, node2, self2) : new Node$1(value, node2, node2.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node$1(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node$1(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node$1(value, prev, next, list) {
  if (!(this instanceof Node$1)) {
    return new Node$1(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
let LRUCache$1 = class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k2) => k2.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k2) => k2.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node2 = this[CACHE].get(key);
      const item = node2.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry$1(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node2 = this[LRU_LIST].tail;
    if (!node2)
      return null;
    del(this, node2);
    return node2.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l2 = arr.length - 1; l2 >= 0; l2--) {
      const hit = arr[l2];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
};
const get = (self2, key, doUse) => {
  const node2 = self2[CACHE].get(key);
  if (node2) {
    const hit = node2.value;
    if (isStale(self2, hit)) {
      del(self2, node2);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node2.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node2);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node2) => {
  if (node2) {
    const hit = node2.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node2);
  }
};
let Entry$1 = class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
};
const forEachStep = (self2, fn, node2, thisp) => {
  let hit = node2.value;
  if (isStale(self2, hit)) {
    del(self2, node2);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache$1 = LRUCache$1;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range;
  hasRequiredRange = 1;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first2 = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first2];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lruCache$1;
  const cache = new LRU({ max: 1e3 });
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1$c;
  const SemVer3 = semver$2;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$8;
  const isNullSet = (c2) => c2.value === "<0.0.0-0";
  const isAny = (c2) => c2.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r2 = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r2, (_2, M2, m2, p2, pr) => {
      debug2("tilde", comp, _2, M2, m2, p2, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
      } else if (isX(p2)) {
        ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M2}.${m2}.${p2} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r2 = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_2, M2, m2, p2, pr) => {
      debug2("caret", comp, _2, M2, m2, p2, pr);
      let ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`;
      } else if (isX(p2)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m2}.0${z2} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.0${z2} <${+M2 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p2}-${pr} <${+M2 + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p2} <${+M2 + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r2, (ret, gtlt, M2, m2, p2, pr) => {
      debug2("xRange", comp, ret, gtlt, M2, m2, p2, pr);
      const xM = isX(M2);
      const xm = xM || isX(m2);
      const xp = xm || isX(p2);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p2 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p2 = 0;
          } else {
            m2 = +m2 + 1;
            p2 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M2}.${m2}.${p2}${pr}`;
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from2 = "";
    } else if (isX(fm)) {
      from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from2 = `>=${from2}`;
    } else {
      from2 = `>=${from2}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from2} ${to}`.trim();
  };
  const testSet = (set, version2, options) => {
    for (let i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version2)) {
        return false;
      }
    }
    if (version2.prerelease.length && !options.includePrerelease) {
      for (let i2 = 0; i2 < set.length; i2++) {
        debug2(set[i2].semver);
        if (set[i2].semver === Comparator2.ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          const allowed = set[i2].semver;
          if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY2 || version2 === ANY2) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer3(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version2, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1$c;
  const SemVer3 = semver$2;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version2, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version2);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$2;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v2) => {
    if (rangeObj.test(v2)) {
      if (!max || maxSV.compare(v2) === -1) {
        max = v2;
        maxSV = new SemVer$4(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$2;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v2) => {
    if (rangeObj.test(v2)) {
      if (!min || minSV.compare(v2) === 1) {
        min = v2;
        minSV = new SemVer$3(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$2;
const Range$5 = requireRange();
const gt$3 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$3(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$3(minver, setMin))) {
      minver = setMin;
    }
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$2;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$2 = gt_1;
const lt$2 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version2, range2, hilo, options) => {
  version2 = new SemVer$1(version2, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$2;
      ltefn = lte$1;
      ltfn = lt$2;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$2;
      ltefn = gte$1;
      ltfn = gt$2;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(version2, range2, options)) {
    return false;
  }
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version2, range2, options) => outside$2(version2, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version2, range2, options) => outside$1(version2, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$3 = compare_1;
var simplify = (versions, range2, options) => {
  const set = [];
  let first2 = null;
  let prev = null;
  const v2 = versions.sort((a2, b2) => compare$3(a2, b2, options));
  for (const version2 of v2) {
    const included = satisfies$2(version2, range2, options);
    if (included) {
      prev = version2;
      if (!first2) {
        first2 = version2;
      }
    } else {
      if (prev) {
        set.push([first2, prev]);
      }
      prev = null;
      first2 = null;
    }
  }
  if (first2) {
    set.push([first2, null]);
  }
  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v2[0]) {
      ranges.push("*");
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v2[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$2 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c2 of sub) {
    if (c2.operator === ">" || c2.operator === ">=") {
      gt2 = higherGT(gt2, c2, options);
    } else if (c2.operator === "<" || c2.operator === "<=") {
      lt2 = lowerLT(lt2, c2, options);
    } else {
      eqSet.add(c2.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$2(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c2 of dom) {
      if (!satisfies$1(eq2, String(c2), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c2 of dom) {
    hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
    hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c2.operator === ">" || c2.operator === ">=") {
        higher = higherGT(gt2, c2, options);
        if (higher === c2 && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c2.operator === "<" || c2.operator === "<=") {
        lower = lowerLT(lt2, c2, options);
        if (lower === c2 && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c2), options)) {
        return false;
      }
    }
    if (!c2.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a2, b2, options) => {
  if (!a2) {
    return b2;
  }
  const comp = compare$2(a2.semver, b2.semver, options);
  return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
};
const lowerLT = (a2, b2, options) => {
  if (!a2) {
    return b2;
  }
  const comp = compare$2(a2.semver, b2.semver, options);
  return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants$7 = constants$8;
const SemVer2 = semver$2;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch$2 = patch_1;
const prerelease = prerelease_1;
const compare$1 = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch: patch$2,
  prerelease,
  compare: compare$1,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt: gt$1,
  lt: lt$1,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants$7.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$7.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
const semver$1 = /* @__PURE__ */ getDefaultExportFromCjs(semver);
var dist$f = {};
const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const hasAbortController = typeof AbortController === "function";
const AC = hasAbortController ? AbortController : class AbortController2 {
  constructor() {
    this.signal = new AS();
  }
  abort(reason = new Error("This operation was aborted")) {
    this.signal.reason = this.signal.reason || reason;
    this.signal.aborted = true;
    this.signal.dispatchEvent({
      type: "abort",
      target: this.signal
    });
  }
};
const hasAbortSignal = typeof AbortSignal === "function";
const hasACAbortSignal = typeof AC.AbortSignal === "function";
const AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
  constructor() {
    this.reason = void 0;
    this.aborted = false;
    this._listeners = [];
  }
  dispatchEvent(e2) {
    if (e2.type === "abort") {
      this.aborted = true;
      this.onabort(e2);
      this._listeners.forEach((f2) => f2(e2), this);
    }
  }
  onabort() {
  }
  addEventListener(ev, fn) {
    if (ev === "abort") {
      this._listeners.push(fn);
    }
  }
  removeEventListener(ev, fn) {
    if (ev === "abort") {
      this._listeners = this._listeners.filter((f2) => f2 !== fn);
    }
  }
};
const warned = /* @__PURE__ */ new Set();
const deprecatedOption = (opt, instead) => {
  const code2 = `LRU_CACHE_OPTION_${opt}`;
  if (shouldWarn(code2)) {
    warn(code2, `${opt} option`, `options.${instead}`, LRUCache2);
  }
};
const deprecatedMethod = (method, instead) => {
  const code2 = `LRU_CACHE_METHOD_${method}`;
  if (shouldWarn(code2)) {
    const { prototype } = LRUCache2;
    const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, method);
    warn(code2, `${method} method`, `cache.${instead}()`, get2);
  }
};
const deprecatedProperty = (field, instead) => {
  const code2 = `LRU_CACHE_PROPERTY_${field}`;
  if (shouldWarn(code2)) {
    const { prototype } = LRUCache2;
    const { get: get2 } = Object.getOwnPropertyDescriptor(prototype, field);
    warn(code2, `${field} property`, `cache.${instead}`, get2);
  }
};
const emitWarning = (...a2) => {
  typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a2) : console.error(...a2);
};
const shouldWarn = (code2) => !warned.has(code2);
const warn = (code2, what, instead, fn) => {
  warned.add(code2);
  const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
  emitWarning(msg, "DeprecationWarning", code2, fn);
};
const isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2);
const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}
class Stack {
  constructor(max) {
    if (max === 0) {
      return [];
    }
    const UintArray = getUintArray(max);
    this.heap = new UintArray(max);
    this.length = 0;
  }
  push(n2) {
    this.heap[this.length++] = n2;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class LRUCache2 {
  constructor(options = {}) {
    const {
      max = 0,
      ttl,
      ttlResolution = 1,
      ttlAutopurge,
      updateAgeOnGet,
      updateAgeOnHas,
      allowStale,
      dispose,
      disposeAfter,
      noDisposeOnSet,
      noUpdateTTL,
      maxSize = 0,
      maxEntrySize = 0,
      sizeCalculation,
      fetchMethod,
      fetchContext,
      noDeleteOnFetchRejection,
      noDeleteOnStaleGet,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort
    } = options;
    const { length, maxAge, stale } = options instanceof LRUCache2 ? {} : options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.max = max;
    this.maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.maxSize;
    this.sizeCalculation = sizeCalculation || length;
    if (this.sizeCalculation) {
      if (!this.maxSize && !this.maxEntrySize) {
        throw new TypeError(
          "cannot set sizeCalculation without setting maxSize or maxEntrySize"
        );
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    this.fetchMethod = fetchMethod || null;
    if (this.fetchMethod && typeof this.fetchMethod !== "function") {
      throw new TypeError(
        "fetchMethod must be a function if specified"
      );
    }
    this.fetchContext = fetchContext;
    if (!this.fetchMethod && fetchContext !== void 0) {
      throw new TypeError(
        "cannot set fetchContext without fetchMethod"
      );
    }
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyList = new Array(max).fill(null);
    this.valList = new Array(max).fill(null);
    this.next = new UintArray(max);
    this.prev = new UintArray(max);
    this.head = 0;
    this.tail = 0;
    this.free = new Stack(max);
    this.initialFill = 1;
    this.size = 0;
    if (typeof dispose === "function") {
      this.dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.disposeAfter = disposeAfter;
      this.disposed = [];
    } else {
      this.disposeAfter = null;
      this.disposed = null;
    }
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.maxSize !== 0) {
        if (!isPosInt(this.maxSize)) {
          throw new TypeError(
            "maxSize must be a positive integer if specified"
          );
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError(
          "maxEntrySize must be a positive integer if specified"
        );
      }
      this.initializeSizeTracking();
    }
    this.allowStale = !!allowStale || !!stale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || maxAge || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError(
          "ttl must be a positive integer if specified"
        );
      }
      this.initializeTTLTracking();
    }
    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
      throw new TypeError(
        "At least one of max, maxSize, or ttl is required"
      );
    }
    if (!this.ttlAutopurge && !this.max && !this.maxSize) {
      const code2 = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code2)) {
        warned.add(code2);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code2, LRUCache2);
      }
    }
    if (stale) {
      deprecatedOption("stale", "allowStale");
    }
    if (maxAge) {
      deprecatedOption("maxAge", "ttl");
    }
    if (length) {
      deprecatedOption("length", "sizeCalculation");
    }
  }
  getRemainingTTL(key) {
    return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
  }
  initializeTTLTracking() {
    this.ttls = new ZeroArray(this.max);
    this.starts = new ZeroArray(this.max);
    this.setItemTTL = (index2, ttl, start = perf.now()) => {
      this.starts[index2] = ttl !== 0 ? start : 0;
      this.ttls[index2] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t2 = setTimeout(() => {
          if (this.isStale(index2)) {
            this.delete(this.keyList[index2]);
          }
        }, ttl + 1);
        if (t2.unref) {
          t2.unref();
        }
      }
    };
    this.updateItemAge = (index2) => {
      this.starts[index2] = this.ttls[index2] !== 0 ? perf.now() : 0;
    };
    this.statusTTL = (status, index2) => {
      if (status) {
        status.ttl = this.ttls[index2];
        status.start = this.starts[index2];
        status.now = cachedNow || getNow();
        status.remainingTTL = status.now + status.ttl - status.start;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n2 = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n2;
        const t2 = setTimeout(
          () => cachedNow = 0,
          this.ttlResolution
        );
        if (t2.unref) {
          t2.unref();
        }
      }
      return n2;
    };
    this.getRemainingTTL = (key) => {
      const index2 = this.keyMap.get(key);
      if (index2 === void 0) {
        return 0;
      }
      return this.ttls[index2] === 0 || this.starts[index2] === 0 ? Infinity : this.starts[index2] + this.ttls[index2] - (cachedNow || getNow());
    };
    this.isStale = (index2) => {
      return this.ttls[index2] !== 0 && this.starts[index2] !== 0 && (cachedNow || getNow()) - this.starts[index2] > this.ttls[index2];
    };
  }
  updateItemAge(_index) {
  }
  statusTTL(_status2, _index) {
  }
  setItemTTL(_index, _ttl, _start) {
  }
  isStale(_index) {
    return false;
  }
  initializeSizeTracking() {
    this.calculatedSize = 0;
    this.sizes = new ZeroArray(this.max);
    this.removeItemSize = (index2) => {
      this.calculatedSize -= this.sizes[index2];
      this.sizes[index2] = 0;
    };
    this.requireSize = (k2, v2, size, sizeCalculation) => {
      if (this.isBackgroundFetch(v2)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v2, k2);
          if (!isPosInt(size)) {
            throw new TypeError(
              "sizeCalculation return invalid (expect positive integer)"
            );
          }
        } else {
          throw new TypeError(
            "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
          );
        }
      }
      return size;
    };
    this.addItemSize = (index2, size, status) => {
      this.sizes[index2] = size;
      if (this.maxSize) {
        const maxSize = this.maxSize - this.sizes[index2];
        while (this.calculatedSize > maxSize) {
          this.evict(true);
        }
      }
      this.calculatedSize += this.sizes[index2];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.calculatedSize;
      }
    };
  }
  removeItemSize(_index) {
  }
  addItemSize(_index, _size) {
  }
  requireSize(_k, _v, size, sizeCalculation) {
    if (size || sizeCalculation) {
      throw new TypeError(
        "cannot set size without setting maxSize or maxEntrySize on cache"
      );
    }
  }
  *indexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i2 = this.tail; true; ) {
        if (!this.isValidIndex(i2)) {
          break;
        }
        if (allowStale || !this.isStale(i2)) {
          yield i2;
        }
        if (i2 === this.head) {
          break;
        } else {
          i2 = this.prev[i2];
        }
      }
    }
  }
  *rindexes({ allowStale = this.allowStale } = {}) {
    if (this.size) {
      for (let i2 = this.head; true; ) {
        if (!this.isValidIndex(i2)) {
          break;
        }
        if (allowStale || !this.isStale(i2)) {
          yield i2;
        }
        if (i2 === this.tail) {
          break;
        } else {
          i2 = this.next[i2];
        }
      }
    }
  }
  isValidIndex(index2) {
    return index2 !== void 0 && this.keyMap.get(this.keyList[index2]) === index2;
  }
  *entries() {
    for (const i2 of this.indexes()) {
      if (this.valList[i2] !== void 0 && this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
        yield [this.keyList[i2], this.valList[i2]];
      }
    }
  }
  *rentries() {
    for (const i2 of this.rindexes()) {
      if (this.valList[i2] !== void 0 && this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
        yield [this.keyList[i2], this.valList[i2]];
      }
    }
  }
  *keys() {
    for (const i2 of this.indexes()) {
      if (this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
        yield this.keyList[i2];
      }
    }
  }
  *rkeys() {
    for (const i2 of this.rindexes()) {
      if (this.keyList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
        yield this.keyList[i2];
      }
    }
  }
  *values() {
    for (const i2 of this.indexes()) {
      if (this.valList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
        yield this.valList[i2];
      }
    }
  }
  *rvalues() {
    for (const i2 of this.rindexes()) {
      if (this.valList[i2] !== void 0 && !this.isBackgroundFetch(this.valList[i2])) {
        yield this.valList[i2];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  find(fn, getOptions) {
    for (const i2 of this.indexes()) {
      const v2 = this.valList[i2];
      const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      if (fn(value, this.keyList[i2], this)) {
        return this.get(this.keyList[i2], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i2 of this.indexes()) {
      const v2 = this.valList[i2];
      const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.keyList[i2], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i2 of this.rindexes()) {
      const v2 = this.valList[i2];
      const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.keyList[i2], this);
    }
  }
  get prune() {
    deprecatedMethod("prune", "purgeStale");
    return this.purgeStale;
  }
  purgeStale() {
    let deleted = false;
    for (const i2 of this.rindexes({ allowStale: true })) {
      if (this.isStale(i2)) {
        this.delete(this.keyList[i2]);
        deleted = true;
      }
    }
    return deleted;
  }
  dump() {
    const arr = [];
    for (const i2 of this.indexes({ allowStale: true })) {
      const key = this.keyList[i2];
      const v2 = this.valList[i2];
      const value = this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      const entry = { value };
      if (this.ttls) {
        entry.ttl = this.ttls[i2];
        const age = perf.now() - this.starts[i2];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.sizes) {
        entry.size = this.sizes[i2];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  dispose(_v, _k, _reason) {
  }
  set(k2, v2, {
    ttl = this.ttl,
    start,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
    status
  } = {}) {
    size = this.requireSize(k2, v2, size, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k2);
      return this;
    }
    let index2 = this.size === 0 ? void 0 : this.keyMap.get(k2);
    if (index2 === void 0) {
      index2 = this.newIndex();
      this.keyList[index2] = k2;
      this.valList[index2] = v2;
      this.keyMap.set(k2, index2);
      this.next[this.tail] = index2;
      this.prev[index2] = this.tail;
      this.tail = index2;
      this.size++;
      this.addItemSize(index2, size, status);
      if (status) {
        status.set = "add";
      }
      noUpdateTTL = false;
    } else {
      this.moveToTail(index2);
      const oldVal = this.valList[index2];
      if (v2 !== oldVal) {
        if (this.isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else {
          if (!noDisposeOnSet) {
            this.dispose(oldVal, k2, "set");
            if (this.disposeAfter) {
              this.disposed.push([oldVal, k2, "set"]);
            }
          }
        }
        this.removeItemSize(index2);
        this.valList[index2] = v2;
        this.addItemSize(index2, size, status);
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
      this.initializeTTLTracking();
    }
    if (!noUpdateTTL) {
      this.setItemTTL(index2, ttl, start);
    }
    this.statusTTL(status, index2);
    if (this.disposeAfter) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
    return this;
  }
  newIndex() {
    if (this.size === 0) {
      return this.tail;
    }
    if (this.size === this.max && this.max !== 0) {
      return this.evict(false);
    }
    if (this.free.length !== 0) {
      return this.free.pop();
    }
    return this.initialFill++;
  }
  pop() {
    if (this.size) {
      const val = this.valList[this.head];
      this.evict(true);
      return val;
    }
  }
  evict(free) {
    const head = this.head;
    const k2 = this.keyList[head];
    const v2 = this.valList[head];
    if (this.isBackgroundFetch(v2)) {
      v2.__abortController.abort(new Error("evicted"));
    } else {
      this.dispose(v2, k2, "evict");
      if (this.disposeAfter) {
        this.disposed.push([v2, k2, "evict"]);
      }
    }
    this.removeItemSize(head);
    if (free) {
      this.keyList[head] = null;
      this.valList[head] = null;
      this.free.push(head);
    }
    this.head = this.next[head];
    this.keyMap.delete(k2);
    this.size--;
    return head;
  }
  has(k2, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
    const index2 = this.keyMap.get(k2);
    if (index2 !== void 0) {
      if (!this.isStale(index2)) {
        if (updateAgeOnHas) {
          this.updateItemAge(index2);
        }
        if (status)
          status.has = "hit";
        this.statusTTL(status, index2);
        return true;
      } else if (status) {
        status.has = "stale";
        this.statusTTL(status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  // like get(), but without any LRU updating or TTL expiration
  peek(k2, { allowStale = this.allowStale } = {}) {
    const index2 = this.keyMap.get(k2);
    if (index2 !== void 0 && (allowStale || !this.isStale(index2))) {
      const v2 = this.valList[index2];
      return this.isBackgroundFetch(v2) ? v2.__staleWhileFetching : v2;
    }
  }
  backgroundFetch(k2, index2, options, context2) {
    const v2 = index2 === void 0 ? void 0 : this.valList[index2];
    if (this.isBackgroundFetch(v2)) {
      return v2;
    }
    const ac = new AC();
    if (options.signal) {
      options.signal.addEventListener(
        "abort",
        () => ac.abort(options.signal.reason)
      );
    }
    const fetchOpts = {
      signal: ac.signal,
      options,
      context: context2
    };
    const cb = (v7, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v7 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      if (this.valList[index2] === p2) {
        if (v7 === void 0) {
          if (p2.__staleWhileFetching) {
            this.valList[index2] = p2.__staleWhileFetching;
          } else {
            this.delete(k2);
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k2, v7, fetchOpts.options);
        }
      }
      return v7;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      if (this.valList[index2] === p2) {
        const del2 = !noDelete || p2.__staleWhileFetching === void 0;
        if (del2) {
          this.delete(k2);
        } else if (!allowStaleAborted) {
          this.valList[index2] = p2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && p2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return p2.__staleWhileFetching;
      } else if (p2.__returned === p2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      this.fetchMethod(k2, v2, fetchOpts).then((v7) => res(v7), rej);
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res();
          if (options.allowStaleOnFetchAbort) {
            res = (v7) => cb(v7, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p2 = new Promise(pcall).then(cb, eb);
    p2.__abortController = ac;
    p2.__staleWhileFetching = v2;
    p2.__returned = null;
    if (index2 === void 0) {
      this.set(k2, p2, { ...fetchOpts.options, status: void 0 });
      index2 = this.keyMap.get(k2);
    } else {
      this.valList[index2] = p2;
    }
    return p2;
  }
  isBackgroundFetch(p2) {
    return p2 && typeof p2 === "object" && typeof p2.then === "function" && Object.prototype.hasOwnProperty.call(
      p2,
      "__staleWhileFetching"
    ) && Object.prototype.hasOwnProperty.call(p2, "__returned") && (p2.__returned === p2 || p2.__returned === null);
  }
  // this takes the union of get() and set() opts, because it does both
  async fetch(k2, {
    // get options
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    noDeleteOnStaleGet = this.noDeleteOnStaleGet,
    // set options
    ttl = this.ttl,
    noDisposeOnSet = this.noDisposeOnSet,
    size = 0,
    sizeCalculation = this.sizeCalculation,
    noUpdateTTL = this.noUpdateTTL,
    // fetch exclusive options
    noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
    allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
    ignoreFetchAbort = this.ignoreFetchAbort,
    allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
    fetchContext = this.fetchContext,
    forceRefresh = false,
    status,
    signal
  } = {}) {
    if (!this.fetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = this.keyMap.get(k2);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p2 = this.backgroundFetch(k2, index2, options, fetchContext);
      return p2.__returned = p2;
    } else {
      const v2 = this.valList[index2];
      if (this.isBackgroundFetch(v2)) {
        const stale = allowStale && v2.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v2.__staleWhileFetching : v2.__returned = v2;
      }
      const isStale2 = this.isStale(index2);
      if (!forceRefresh && !isStale2) {
        if (status)
          status.fetch = "hit";
        this.moveToTail(index2);
        if (updateAgeOnGet) {
          this.updateItemAge(index2);
        }
        this.statusTTL(status, index2);
        return v2;
      }
      const p2 = this.backgroundFetch(k2, index2, options, fetchContext);
      const hasStale = p2.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = hasStale && isStale2 ? "stale" : "refresh";
        if (staleVal && isStale2)
          status.returnedStale = true;
      }
      return staleVal ? p2.__staleWhileFetching : p2.__returned = p2;
    }
  }
  get(k2, {
    allowStale = this.allowStale,
    updateAgeOnGet = this.updateAgeOnGet,
    noDeleteOnStaleGet = this.noDeleteOnStaleGet,
    status
  } = {}) {
    const index2 = this.keyMap.get(k2);
    if (index2 !== void 0) {
      const value = this.valList[index2];
      const fetching = this.isBackgroundFetch(value);
      this.statusTTL(status, index2);
      if (this.isStale(index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k2);
          }
          if (status)
            status.returnedStale = allowStale;
          return allowStale ? value : void 0;
        } else {
          if (status) {
            status.returnedStale = allowStale && value.__staleWhileFetching !== void 0;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.moveToTail(index2);
        if (updateAgeOnGet) {
          this.updateItemAge(index2);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  connect(p2, n2) {
    this.prev[n2] = p2;
    this.next[p2] = n2;
  }
  moveToTail(index2) {
    if (index2 !== this.tail) {
      if (index2 === this.head) {
        this.head = this.next[index2];
      } else {
        this.connect(this.prev[index2], this.next[index2]);
      }
      this.connect(this.tail, index2);
      this.tail = index2;
    }
  }
  get del() {
    deprecatedMethod("del", "delete");
    return this.delete;
  }
  delete(k2) {
    let deleted = false;
    if (this.size !== 0) {
      const index2 = this.keyMap.get(k2);
      if (index2 !== void 0) {
        deleted = true;
        if (this.size === 1) {
          this.clear();
        } else {
          this.removeItemSize(index2);
          const v2 = this.valList[index2];
          if (this.isBackgroundFetch(v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else {
            this.dispose(v2, k2, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v2, k2, "delete"]);
            }
          }
          this.keyMap.delete(k2);
          this.keyList[index2] = null;
          this.valList[index2] = null;
          if (index2 === this.tail) {
            this.tail = this.prev[index2];
          } else if (index2 === this.head) {
            this.head = this.next[index2];
          } else {
            this.next[this.prev[index2]] = this.next[index2];
            this.prev[this.next[index2]] = this.prev[index2];
          }
          this.size--;
          this.free.push(index2);
        }
      }
    }
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
    return deleted;
  }
  clear() {
    for (const index2 of this.rindexes({ allowStale: true })) {
      const v2 = this.valList[index2];
      if (this.isBackgroundFetch(v2)) {
        v2.__abortController.abort(new Error("deleted"));
      } else {
        const k2 = this.keyList[index2];
        this.dispose(v2, k2, "delete");
        if (this.disposeAfter) {
          this.disposed.push([v2, k2, "delete"]);
        }
      }
    }
    this.keyMap.clear();
    this.valList.fill(null);
    this.keyList.fill(null);
    if (this.ttls) {
      this.ttls.fill(0);
      this.starts.fill(0);
    }
    if (this.sizes) {
      this.sizes.fill(0);
    }
    this.head = 0;
    this.tail = 0;
    this.initialFill = 1;
    this.free.length = 0;
    this.calculatedSize = 0;
    this.size = 0;
    if (this.disposed) {
      while (this.disposed.length) {
        this.disposeAfter(...this.disposed.shift());
      }
    }
  }
  get reset() {
    deprecatedMethod("reset", "clear");
    return this.clear;
  }
  get length() {
    deprecatedProperty("length", "size");
    return this.size;
  }
  static get AbortController() {
    return AC;
  }
  static get AbortSignal() {
    return AS;
  }
}
var lruCache = LRUCache2;
var dist$e = {};
var helpers$5 = {};
var __createBinding$d = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$d = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$d = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$d(result, mod, k2);
  }
  __setModuleDefault$d(result, mod);
  return result;
};
Object.defineProperty(helpers$5, "__esModule", { value: true });
helpers$5.req = helpers$5.json = helpers$5.toBuffer = void 0;
const http$3 = __importStar$d(require$$0$2);
const https$4 = __importStar$d(require$$1);
async function toBuffer$3(stream2) {
  let length = 0;
  const chunks = [];
  for await (const chunk of stream2) {
    length += chunk.length;
    chunks.push(chunk);
  }
  return Buffer.concat(chunks, length);
}
helpers$5.toBuffer = toBuffer$3;
async function json$3(stream2) {
  const buf = await toBuffer$3(stream2);
  const str = buf.toString("utf8");
  try {
    return JSON.parse(str);
  } catch (_err) {
    const err = _err;
    err.message += ` (input: ${str})`;
    throw err;
  }
}
helpers$5.json = json$3;
function req$2(url, opts = {}) {
  const href = typeof url === "string" ? url : url.href;
  const req2 = (href.startsWith("https:") ? https$4 : http$3).request(url, opts);
  const promise = new Promise((resolve2, reject) => {
    req2.once("response", resolve2).once("error", reject).end();
  });
  req2.then = promise.then.bind(promise);
  return req2;
}
helpers$5.req = req$2;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Agent = void 0;
  const net2 = __importStar2(require$$0$1);
  const http2 = __importStar2(require$$0$2);
  const https_12 = require$$1;
  __exportStar2(helpers$5, exports2);
  const INTERNAL = Symbol("AgentBaseInternalState");
  class Agent extends http2.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name2) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name2]) {
        this.sockets[name2] = [];
      }
      const fakeSocket = new net2.Socket({ writable: false });
      this.sockets[name2].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name2, socket) {
      if (!this.sockets[name2] || socket === null) {
        return;
      }
      const sockets = this.sockets[name2];
      const index2 = sockets.indexOf(socket);
      if (index2 !== -1) {
        sockets.splice(index2, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name2];
        }
      }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_12.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req2, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name2 = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name2);
      Promise.resolve().then(() => this.connect(req2, connectOpts)).then((socket) => {
        this.decrementSockets(name2, fakeSocket);
        if (socket instanceof http2.Agent) {
          return socket.addRequest(req2, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req2, options, cb);
      }, (err) => {
        this.decrementSockets(name2, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = void 0;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v2;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v2;
      }
    }
  }
  exports2.Agent = Agent;
})(dist$e);
var src = { exports: {} };
var browser$1 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w2;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n2, name2) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
var common$4;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common$4;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0; i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
        if (createDebug.skips[i2].test(name2)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
        if (createDebug.names[i2].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$4 = setup;
  return common$4;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$1.exports;
  hasRequiredBrowser = 1;
  (function(module2, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag)
    return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor)
    return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os$1 = os;
  const hasFlag2 = requireHasFlag();
  const env2 = process.env;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false")) {
    forceColor = false;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream2) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (stream2 && !stream2.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os$1.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node.exports;
  hasRequiredNode = 1;
  (function(module2, exports2) {
    const tty = require$$0$3;
    const util2 = require$$4;
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k2) => {
        return k2.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    module2.exports = requireCommon()(exports2);
    const { formatters } = module2.exports;
    formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v2, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
const debug$d = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: debug$d
}, Symbol.toStringTag, { value: "Module" }));
var proxyFromEnv = {};
var parseUrl = require$$5$1.parse;
var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s2) {
  return s2.length <= this.length && this.indexOf(s2, this.length - s2.length) !== -1;
};
function getProxyForUrl(url) {
  var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
    return "";
  }
  proto = proto.split(":", 1)[0];
  hostname = hostname.replace(/:\d*$/, "");
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return "";
  }
  var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
  if (proxy && proxy.indexOf("://") === -1) {
    proxy = proto + "://" + proxy;
  }
  return proxy;
}
function shouldProxy(hostname, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
}
proxyFromEnv.getProxyForUrl = getProxyForUrl;
var dist$d = {};
var dist$c = {};
var helpers$4 = {};
var __createBinding$c = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$c = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$c = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$c(result, mod, k2);
  }
  __setModuleDefault$c(result, mod);
  return result;
};
Object.defineProperty(helpers$4, "__esModule", { value: true });
helpers$4.req = helpers$4.json = helpers$4.toBuffer = void 0;
const http$2 = __importStar$c(require$$0$2);
const https$3 = __importStar$c(require$$1);
async function toBuffer$2(stream2) {
  let length = 0;
  const chunks = [];
  for await (const chunk of stream2) {
    length += chunk.length;
    chunks.push(chunk);
  }
  return Buffer.concat(chunks, length);
}
helpers$4.toBuffer = toBuffer$2;
async function json$2(stream2) {
  const buf = await toBuffer$2(stream2);
  const str = buf.toString("utf8");
  try {
    return JSON.parse(str);
  } catch (_err) {
    const err = _err;
    err.message += ` (input: ${str})`;
    throw err;
  }
}
helpers$4.json = json$2;
function req$1(url, opts = {}) {
  const href = typeof url === "string" ? url : url.href;
  const req2 = (href.startsWith("https:") ? https$3 : http$2).request(url, opts);
  const promise = new Promise((resolve2, reject) => {
    req2.once("response", resolve2).once("error", reject).end();
  });
  req2.then = promise.then.bind(promise);
  return req2;
}
helpers$4.req = req$1;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Agent = void 0;
  const net2 = __importStar2(require$$0$1);
  const http2 = __importStar2(require$$0$2);
  const https_12 = require$$1;
  __exportStar2(helpers$4, exports2);
  const INTERNAL = Symbol("AgentBaseInternalState");
  class Agent extends http2.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name2) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name2]) {
        this.sockets[name2] = [];
      }
      const fakeSocket = new net2.Socket({ writable: false });
      this.sockets[name2].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name2, socket) {
      if (!this.sockets[name2] || socket === null) {
        return;
      }
      const sockets = this.sockets[name2];
      const index2 = sockets.indexOf(socket);
      if (index2 !== -1) {
        sockets.splice(index2, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name2];
        }
      }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_12.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req2, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name2 = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name2);
      Promise.resolve().then(() => this.connect(req2, connectOpts)).then((socket) => {
        this.decrementSockets(name2, fakeSocket);
        if (socket instanceof http2.Agent) {
          return socket.addRequest(req2, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req2, options, cb);
      }, (err) => {
        this.decrementSockets(name2, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = void 0;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v2;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v2;
      }
    }
  }
  exports2.Agent = Agent;
})(dist$c);
var dist$b = {};
var __createBinding$b = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$b = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$b = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$b(result, mod, k2);
  }
  __setModuleDefault$b(result, mod);
  return result;
};
var __importDefault$d = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$b, "__esModule", { value: true });
dist$b.HttpProxyAgent = void 0;
const net$6 = __importStar$b(require$$0$1);
const tls$5 = __importStar$b(require$$1$1);
const debug_1$b = __importDefault$d(srcExports);
const events_1$2 = require$$3$2;
const agent_base_1$5 = dist$c;
const url_1$6 = require$$5$1;
const debug$c = (0, debug_1$b.default)("http-proxy-agent");
let HttpProxyAgent$1 = class HttpProxyAgent extends agent_base_1$5.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.proxy = typeof proxy === "string" ? new url_1$6.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug$c("Creating new HttpProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      ...opts ? omit$4(opts, "headers") : null,
      host,
      port
    };
  }
  addRequest(req2, opts) {
    req2._header = null;
    this.setRequestProps(req2, opts);
    super.addRequest(req2, opts);
  }
  setRequestProps(req2, opts) {
    const { proxy } = this;
    const protocol = opts.secureEndpoint ? "https:" : "http:";
    const hostname = req2.getHeader("host") || "localhost";
    const base = `${protocol}//${hostname}`;
    const url = new url_1$6.URL(req2.path, base);
    if (opts.port !== 80) {
      url.port = String(opts.port);
    }
    req2.path = String(url);
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      const value = headers[name2];
      if (value) {
        req2.setHeader(name2, value);
      }
    }
  }
  async connect(req2, opts) {
    req2._header = null;
    if (!req2.path.includes("://")) {
      this.setRequestProps(req2, opts);
    }
    let first2;
    let endOfHeaders;
    debug$c("Regenerating stored HTTP header string for request");
    req2._implicitHeader();
    if (req2.outputData && req2.outputData.length > 0) {
      debug$c("Patching connection write() output buffer with updated header");
      first2 = req2.outputData[0].data;
      endOfHeaders = first2.indexOf("\r\n\r\n") + 4;
      req2.outputData[0].data = req2._header + first2.substring(endOfHeaders);
      debug$c("Output buffer: %o", req2.outputData[0].data);
    }
    let socket;
    if (this.proxy.protocol === "https:") {
      debug$c("Creating `tls.Socket`: %o", this.connectOpts);
      socket = tls$5.connect(this.connectOpts);
    } else {
      debug$c("Creating `net.Socket`: %o", this.connectOpts);
      socket = net$6.connect(this.connectOpts);
    }
    await (0, events_1$2.once)(socket, "connect");
    return socket;
  }
};
HttpProxyAgent$1.protocols = ["http", "https"];
dist$b.HttpProxyAgent = HttpProxyAgent$1;
function omit$4(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var dist$a = {};
var parseProxyResponse$3 = {};
var __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(parseProxyResponse$3, "__esModule", { value: true });
parseProxyResponse$3.parseProxyResponse = void 0;
const debug_1$a = __importDefault$c(srcExports);
const debug$b = (0, debug_1$a.default)("https-proxy-agent:parse-proxy-response");
function parseProxyResponse$2(socket) {
  return new Promise((resolve2, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b2 = socket.read();
      if (b2)
        ondata(b2);
      else
        socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug$b("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug$b("onerror %o", err);
      reject(err);
    }
    function ondata(b2) {
      buffers.push(b2);
      buffersLength += b2.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug$b("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +firstLineParts[1];
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header of headerParts) {
        if (!header)
          continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === "string") {
          headers[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key] = value;
        }
      }
      debug$b("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve2({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}
parseProxyResponse$3.parseProxyResponse = parseProxyResponse$2;
var __createBinding$a = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$a = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$a = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$a(result, mod, k2);
  }
  __setModuleDefault$a(result, mod);
  return result;
};
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$a, "__esModule", { value: true });
dist$a.HttpsProxyAgent = void 0;
const net$5 = __importStar$a(require$$0$1);
const tls$4 = __importStar$a(require$$1$1);
const assert_1$1 = __importDefault$b(require$$2);
const debug_1$9 = __importDefault$b(srcExports);
const agent_base_1$4 = dist$c;
const url_1$5 = require$$5$1;
const parse_proxy_response_1$1 = parseProxyResponse$3;
const debug$a = (0, debug_1$9.default)("https-proxy-agent");
let HttpsProxyAgent$1 = class HttpsProxyAgent extends agent_base_1$4.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.options = { path: void 0 };
    this.proxy = typeof proxy === "string" ? new url_1$5.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug$a("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit$3(opts, "headers") : null,
      host,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req2, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug$a("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls$4.connect({
        ...this.connectOpts,
        servername: servername && net$5.isIP(servername) ? void 0 : servername
      });
    } else {
      debug$a("Creating `net.Socket`: %o", this.connectOpts);
      socket = net$5.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net$5.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      payload += `${name2}: ${headers[name2]}\r
`;
    }
    const proxyResponsePromise = (0, parse_proxy_response_1$1.parseProxyResponse)(socket);
    socket.write(`${payload}\r
`);
    const { connect, buffered } = await proxyResponsePromise;
    req2.emit("proxyConnect", connect);
    this.emit("proxyConnect", connect, req2);
    if (connect.statusCode === 200) {
      req2.once("socket", resume$1);
      if (opts.secureEndpoint) {
        debug$a("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls$4.connect({
          ...omit$3(opts, "host", "path", "port"),
          socket,
          servername: net$5.isIP(servername) ? void 0 : servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net$5.Socket({ writable: false });
    fakeSocket.readable = true;
    req2.once("socket", (s2) => {
      debug$a("Replaying proxy buffer for failed request");
      (0, assert_1$1.default)(s2.listenerCount("data") > 0);
      s2.push(buffered);
      s2.push(null);
    });
    return fakeSocket;
  }
};
HttpsProxyAgent$1.protocols = ["http", "https"];
dist$a.HttpsProxyAgent = HttpsProxyAgent$1;
function resume$1(socket) {
  socket.resume();
}
function omit$3(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var dist$9 = {};
var build$3 = {};
var socksclient = {};
var smartbuffer = {};
var utils$3 = {};
Object.defineProperty(utils$3, "__esModule", { value: true });
const buffer_1 = require$$0$4;
const ERRORS$1 = {
  INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
  INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
  INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
  INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
  INVALID_OFFSET: "An invalid offset value was provided.",
  INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
  INVALID_LENGTH: "An invalid length value was provided.",
  INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
  INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
  INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
  INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
  INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
};
utils$3.ERRORS = ERRORS$1;
function checkEncoding(encoding) {
  if (!buffer_1.Buffer.isEncoding(encoding)) {
    throw new Error(ERRORS$1.INVALID_ENCODING);
  }
}
utils$3.checkEncoding = checkEncoding;
function isFiniteInteger(value) {
  return typeof value === "number" && isFinite(value) && isInteger(value);
}
utils$3.isFiniteInteger = isFiniteInteger;
function checkOffsetOrLengthValue(value, offset) {
  if (typeof value === "number") {
    if (!isFiniteInteger(value) || value < 0) {
      throw new Error(offset ? ERRORS$1.INVALID_OFFSET : ERRORS$1.INVALID_LENGTH);
    }
  } else {
    throw new Error(offset ? ERRORS$1.INVALID_OFFSET_NON_NUMBER : ERRORS$1.INVALID_LENGTH_NON_NUMBER);
  }
}
function checkLengthValue(length) {
  checkOffsetOrLengthValue(length, false);
}
utils$3.checkLengthValue = checkLengthValue;
function checkOffsetValue(offset) {
  checkOffsetOrLengthValue(offset, true);
}
utils$3.checkOffsetValue = checkOffsetValue;
function checkTargetOffset(offset, buff) {
  if (offset < 0 || offset > buff.length) {
    throw new Error(ERRORS$1.INVALID_TARGET_OFFSET);
  }
}
utils$3.checkTargetOffset = checkTargetOffset;
function isInteger(value) {
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
}
function bigIntAndBufferInt64Check(bufferMethod) {
  if (typeof BigInt === "undefined") {
    throw new Error("Platform does not support JS BigInt type.");
  }
  if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
    throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
  }
}
utils$3.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
Object.defineProperty(smartbuffer, "__esModule", { value: true });
const utils_1 = utils$3;
const DEFAULT_SMARTBUFFER_SIZE = 4096;
const DEFAULT_SMARTBUFFER_ENCODING = "utf8";
class SmartBuffer {
  /**
   * Creates a new SmartBuffer instance.
   *
   * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
   */
  constructor(options) {
    this.length = 0;
    this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
    this._writeOffset = 0;
    this._readOffset = 0;
    if (SmartBuffer.isSmartBufferOptions(options)) {
      if (options.encoding) {
        utils_1.checkEncoding(options.encoding);
        this._encoding = options.encoding;
      }
      if (options.size) {
        if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
          this._buff = Buffer.allocUnsafe(options.size);
        } else {
          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
        }
      } else if (options.buff) {
        if (Buffer.isBuffer(options.buff)) {
          this._buff = options.buff;
          this.length = options.buff.length;
        } else {
          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
        }
      } else {
        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
      }
    } else {
      if (typeof options !== "undefined") {
        throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
      }
      this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
    }
  }
  /**
   * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
   *
   * @param size { Number } The size of the internal Buffer.
   * @param encoding { String } The BufferEncoding to use for strings.
   *
   * @return { SmartBuffer }
   */
  static fromSize(size, encoding) {
    return new this({
      size,
      encoding
    });
  }
  /**
   * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
   *
   * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
   * @param encoding { String } The BufferEncoding to use for strings.
   *
   * @return { SmartBuffer }
   */
  static fromBuffer(buff, encoding) {
    return new this({
      buff,
      encoding
    });
  }
  /**
   * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
   *
   * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
   */
  static fromOptions(options) {
    return new this(options);
  }
  /**
   * Type checking function that determines if an object is a SmartBufferOptions object.
   */
  static isSmartBufferOptions(options) {
    const castOptions = options;
    return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
  }
  // Signed integers
  /**
   * Reads an Int8 value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt8(offset) {
    return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
  }
  /**
   * Reads an Int16BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt16BE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
  }
  /**
   * Reads an Int16LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt16LE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
  }
  /**
   * Reads an Int32BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt32BE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
  }
  /**
   * Reads an Int32LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt32LE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
  }
  /**
   * Reads a BigInt64BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigInt64BE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
    return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
  }
  /**
   * Reads a BigInt64LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigInt64LE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
    return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
  }
  /**
   * Writes an Int8 value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt8(value, offset) {
    this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
    return this;
  }
  /**
   * Inserts an Int8 value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt8(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
  }
  /**
   * Writes an Int16BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt16BE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
  }
  /**
   * Inserts an Int16BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt16BE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
  }
  /**
   * Writes an Int16LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt16LE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
  }
  /**
   * Inserts an Int16LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt16LE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
  }
  /**
   * Writes an Int32BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt32BE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
  }
  /**
   * Inserts an Int32BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt32BE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
  }
  /**
   * Writes an Int32LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt32LE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
  }
  /**
   * Inserts an Int32LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt32LE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
  }
  /**
   * Writes a BigInt64BE value to the current write position (or at optional offset).
   *
   * @param value { BigInt } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigInt64BE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
    return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
  }
  /**
   * Inserts a BigInt64BE value at the given offset value.
   *
   * @param value { BigInt } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigInt64BE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
    return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
  }
  /**
   * Writes a BigInt64LE value to the current write position (or at optional offset).
   *
   * @param value { BigInt } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigInt64LE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
    return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
  }
  /**
   * Inserts a Int64LE value at the given offset value.
   *
   * @param value { BigInt } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigInt64LE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
    return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
  }
  // Unsigned Integers
  /**
   * Reads an UInt8 value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt8(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
  }
  /**
   * Reads an UInt16BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt16BE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
  }
  /**
   * Reads an UInt16LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt16LE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
  }
  /**
   * Reads an UInt32BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt32BE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
  }
  /**
   * Reads an UInt32LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt32LE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
  }
  /**
   * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigUInt64BE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
    return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
  }
  /**
   * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigUInt64LE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
    return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
  }
  /**
   * Writes an UInt8 value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt8(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
  }
  /**
   * Inserts an UInt8 value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt8(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
  }
  /**
   * Writes an UInt16BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt16BE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
  }
  /**
   * Inserts an UInt16BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt16BE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
  }
  /**
   * Writes an UInt16LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt16LE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
  }
  /**
   * Inserts an UInt16LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt16LE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
  }
  /**
   * Writes an UInt32BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt32BE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
  }
  /**
   * Inserts an UInt32BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt32BE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
  }
  /**
   * Writes an UInt32LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt32LE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
  }
  /**
   * Inserts an UInt32LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt32LE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
  }
  /**
   * Writes a BigUInt64BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigUInt64BE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
    return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
  }
  /**
   * Inserts a BigUInt64BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigUInt64BE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
    return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
  }
  /**
   * Writes a BigUInt64LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigUInt64LE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
    return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
  }
  /**
   * Inserts a BigUInt64LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigUInt64LE(value, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
    return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
  }
  // Floating Point
  /**
   * Reads an FloatBE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readFloatBE(offset) {
    return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
  }
  /**
   * Reads an FloatLE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readFloatLE(offset) {
    return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
  }
  /**
   * Writes a FloatBE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeFloatBE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
  }
  /**
   * Inserts a FloatBE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertFloatBE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
  }
  /**
   * Writes a FloatLE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeFloatLE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
  }
  /**
   * Inserts a FloatLE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertFloatLE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
  }
  // Double Floating Point
  /**
   * Reads an DoublEBE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readDoubleBE(offset) {
    return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
  }
  /**
   * Reads an DoubleLE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readDoubleLE(offset) {
    return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
  }
  /**
   * Writes a DoubleBE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeDoubleBE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
  }
  /**
   * Inserts a DoubleBE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertDoubleBE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
  }
  /**
   * Writes a DoubleLE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeDoubleLE(value, offset) {
    return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
  }
  /**
   * Inserts a DoubleLE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertDoubleLE(value, offset) {
    return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
  }
  // Strings
  /**
   * Reads a String from the current read position.
   *
   * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
   *             the string (Defaults to instance level encoding).
   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
   *
   * @return { String }
   */
  readString(arg1, encoding) {
    let lengthVal;
    if (typeof arg1 === "number") {
      utils_1.checkLengthValue(arg1);
      lengthVal = Math.min(arg1, this.length - this._readOffset);
    } else {
      encoding = arg1;
      lengthVal = this.length - this._readOffset;
    }
    if (typeof encoding !== "undefined") {
      utils_1.checkEncoding(encoding);
    }
    const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
    this._readOffset += lengthVal;
    return value;
  }
  /**
   * Inserts a String
   *
   * @param value { String } The String value to insert.
   * @param offset { Number } The offset to insert the string at.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  insertString(value, offset, encoding) {
    utils_1.checkOffsetValue(offset);
    return this._handleString(value, true, offset, encoding);
  }
  /**
   * Writes a String
   *
   * @param value { String } The String value to write.
   * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  writeString(value, arg2, encoding) {
    return this._handleString(value, false, arg2, encoding);
  }
  /**
   * Reads a null-terminated String from the current read position.
   *
   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
   *
   * @return { String }
   */
  readStringNT(encoding) {
    if (typeof encoding !== "undefined") {
      utils_1.checkEncoding(encoding);
    }
    let nullPos = this.length;
    for (let i2 = this._readOffset; i2 < this.length; i2++) {
      if (this._buff[i2] === 0) {
        nullPos = i2;
        break;
      }
    }
    const value = this._buff.slice(this._readOffset, nullPos);
    this._readOffset = nullPos + 1;
    return value.toString(encoding || this._encoding);
  }
  /**
   * Inserts a null-terminated String.
   *
   * @param value { String } The String value to write.
   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  insertStringNT(value, offset, encoding) {
    utils_1.checkOffsetValue(offset);
    this.insertString(value, offset, encoding);
    this.insertUInt8(0, offset + value.length);
    return this;
  }
  /**
   * Writes a null-terminated String.
   *
   * @param value { String } The String value to write.
   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  writeStringNT(value, arg2, encoding) {
    this.writeString(value, arg2, encoding);
    this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
    return this;
  }
  // Buffers
  /**
   * Reads a Buffer from the internal read position.
   *
   * @param length { Number } The length of data to read as a Buffer.
   *
   * @return { Buffer }
   */
  readBuffer(length) {
    if (typeof length !== "undefined") {
      utils_1.checkLengthValue(length);
    }
    const lengthVal = typeof length === "number" ? length : this.length;
    const endPoint = Math.min(this.length, this._readOffset + lengthVal);
    const value = this._buff.slice(this._readOffset, endPoint);
    this._readOffset = endPoint;
    return value;
  }
  /**
   * Writes a Buffer to the current write position.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  insertBuffer(value, offset) {
    utils_1.checkOffsetValue(offset);
    return this._handleBuffer(value, true, offset);
  }
  /**
   * Writes a Buffer to the current write position.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  writeBuffer(value, offset) {
    return this._handleBuffer(value, false, offset);
  }
  /**
   * Reads a null-terminated Buffer from the current read poisiton.
   *
   * @return { Buffer }
   */
  readBufferNT() {
    let nullPos = this.length;
    for (let i2 = this._readOffset; i2 < this.length; i2++) {
      if (this._buff[i2] === 0) {
        nullPos = i2;
        break;
      }
    }
    const value = this._buff.slice(this._readOffset, nullPos);
    this._readOffset = nullPos + 1;
    return value;
  }
  /**
   * Inserts a null-terminated Buffer.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  insertBufferNT(value, offset) {
    utils_1.checkOffsetValue(offset);
    this.insertBuffer(value, offset);
    this.insertUInt8(0, offset + value.length);
    return this;
  }
  /**
   * Writes a null-terminated Buffer.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  writeBufferNT(value, offset) {
    if (typeof offset !== "undefined") {
      utils_1.checkOffsetValue(offset);
    }
    this.writeBuffer(value, offset);
    this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
    return this;
  }
  /**
   * Clears the SmartBuffer instance to its original empty state.
   */
  clear() {
    this._writeOffset = 0;
    this._readOffset = 0;
    this.length = 0;
    return this;
  }
  /**
   * Gets the remaining data left to be read from the SmartBuffer instance.
   *
   * @return { Number }
   */
  remaining() {
    return this.length - this._readOffset;
  }
  /**
   * Gets the current read offset value of the SmartBuffer instance.
   *
   * @return { Number }
   */
  get readOffset() {
    return this._readOffset;
  }
  /**
   * Sets the read offset value of the SmartBuffer instance.
   *
   * @param offset { Number } - The offset value to set.
   */
  set readOffset(offset) {
    utils_1.checkOffsetValue(offset);
    utils_1.checkTargetOffset(offset, this);
    this._readOffset = offset;
  }
  /**
   * Gets the current write offset value of the SmartBuffer instance.
   *
   * @return { Number }
   */
  get writeOffset() {
    return this._writeOffset;
  }
  /**
   * Sets the write offset value of the SmartBuffer instance.
   *
   * @param offset { Number } - The offset value to set.
   */
  set writeOffset(offset) {
    utils_1.checkOffsetValue(offset);
    utils_1.checkTargetOffset(offset, this);
    this._writeOffset = offset;
  }
  /**
   * Gets the currently set string encoding of the SmartBuffer instance.
   *
   * @return { BufferEncoding } The string Buffer encoding currently set.
   */
  get encoding() {
    return this._encoding;
  }
  /**
   * Sets the string encoding of the SmartBuffer instance.
   *
   * @param encoding { BufferEncoding } The string Buffer encoding to set.
   */
  set encoding(encoding) {
    utils_1.checkEncoding(encoding);
    this._encoding = encoding;
  }
  /**
   * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
   *
   * @return { Buffer } The Buffer value.
   */
  get internalBuffer() {
    return this._buff;
  }
  /**
   * Gets the value of the internal managed Buffer (Includes managed data only)
   *
   * @param { Buffer }
   */
  toBuffer() {
    return this._buff.slice(0, this.length);
  }
  /**
   * Gets the String value of the internal managed Buffer
   *
   * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
   */
  toString(encoding) {
    const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
    utils_1.checkEncoding(encodingVal);
    return this._buff.toString(encodingVal, 0, this.length);
  }
  /**
   * Destroys the SmartBuffer instance.
   */
  destroy() {
    this.clear();
    return this;
  }
  /**
   * Handles inserting and writing strings.
   *
   * @param value { String } The String value to insert.
   * @param isInsert { Boolean } True if inserting a string, false if writing.
   * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   */
  _handleString(value, isInsert, arg3, encoding) {
    let offsetVal = this._writeOffset;
    let encodingVal = this._encoding;
    if (typeof arg3 === "number") {
      offsetVal = arg3;
    } else if (typeof arg3 === "string") {
      utils_1.checkEncoding(arg3);
      encodingVal = arg3;
    }
    if (typeof encoding === "string") {
      utils_1.checkEncoding(encoding);
      encodingVal = encoding;
    }
    const byteLength2 = Buffer.byteLength(value, encodingVal);
    if (isInsert) {
      this.ensureInsertable(byteLength2, offsetVal);
    } else {
      this._ensureWriteable(byteLength2, offsetVal);
    }
    this._buff.write(value, offsetVal, byteLength2, encodingVal);
    if (isInsert) {
      this._writeOffset += byteLength2;
    } else {
      if (typeof arg3 === "number") {
        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength2);
      } else {
        this._writeOffset += byteLength2;
      }
    }
    return this;
  }
  /**
   * Handles writing or insert of a Buffer.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   */
  _handleBuffer(value, isInsert, offset) {
    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
    if (isInsert) {
      this.ensureInsertable(value.length, offsetVal);
    } else {
      this._ensureWriteable(value.length, offsetVal);
    }
    value.copy(this._buff, offsetVal);
    if (isInsert) {
      this._writeOffset += value.length;
    } else {
      if (typeof offset === "number") {
        this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
      } else {
        this._writeOffset += value.length;
      }
    }
    return this;
  }
  /**
   * Ensures that the internal Buffer is large enough to read data.
   *
   * @param length { Number } The length of the data that needs to be read.
   * @param offset { Number } The offset of the data that needs to be read.
   */
  ensureReadable(length, offset) {
    let offsetVal = this._readOffset;
    if (typeof offset !== "undefined") {
      utils_1.checkOffsetValue(offset);
      offsetVal = offset;
    }
    if (offsetVal < 0 || offsetVal + length > this.length) {
      throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
    }
  }
  /**
   * Ensures that the internal Buffer is large enough to insert data.
   *
   * @param dataLength { Number } The length of the data that needs to be written.
   * @param offset { Number } The offset of the data to be written.
   */
  ensureInsertable(dataLength, offset) {
    utils_1.checkOffsetValue(offset);
    this._ensureCapacity(this.length + dataLength);
    if (offset < this.length) {
      this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
    }
    if (offset + dataLength > this.length) {
      this.length = offset + dataLength;
    } else {
      this.length += dataLength;
    }
  }
  /**
   * Ensures that the internal Buffer is large enough to write data.
   *
   * @param dataLength { Number } The length of the data that needs to be written.
   * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
   */
  _ensureWriteable(dataLength, offset) {
    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
    this._ensureCapacity(offsetVal + dataLength);
    if (offsetVal + dataLength > this.length) {
      this.length = offsetVal + dataLength;
    }
  }
  /**
   * Ensures that the internal Buffer is large enough to write at least the given amount of data.
   *
   * @param minLength { Number } The minimum length of the data needs to be written.
   */
  _ensureCapacity(minLength) {
    const oldLength = this._buff.length;
    if (minLength > oldLength) {
      let data2 = this._buff;
      let newLength = oldLength * 3 / 2 + 1;
      if (newLength < minLength) {
        newLength = minLength;
      }
      this._buff = Buffer.allocUnsafe(newLength);
      data2.copy(this._buff, 0, 0, oldLength);
    }
  }
  /**
   * Reads a numeric number value using the provided function.
   *
   * @typeparam T { number | bigint } The type of the value to be read
   *
   * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
   * @param byteSize { Number } The number of bytes read.
   * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
   *
   * @returns { T } the number value
   */
  _readNumberValue(func, byteSize, offset) {
    this.ensureReadable(byteSize, offset);
    const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
    if (typeof offset === "undefined") {
      this._readOffset += byteSize;
    }
    return value;
  }
  /**
   * Inserts a numeric number value based on the given offset and value.
   *
   * @typeparam T { number | bigint } The type of the value to be written
   *
   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
   * @param byteSize { Number } The number of bytes written.
   * @param value { T } The number value to write.
   * @param offset { Number } the offset to write the number at (REQUIRED).
   *
   * @returns SmartBuffer this buffer
   */
  _insertNumberValue(func, byteSize, value, offset) {
    utils_1.checkOffsetValue(offset);
    this.ensureInsertable(byteSize, offset);
    func.call(this._buff, value, offset);
    this._writeOffset += byteSize;
    return this;
  }
  /**
   * Writes a numeric number value based on the given offset and value.
   *
   * @typeparam T { number | bigint } The type of the value to be written
   *
   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
   * @param byteSize { Number } The number of bytes written.
   * @param value { T } The number value to write.
   * @param offset { Number } the offset to write the number at (REQUIRED).
   *
   * @returns SmartBuffer this buffer
   */
  _writeNumberValue(func, byteSize, value, offset) {
    if (typeof offset === "number") {
      if (offset < 0) {
        throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
      }
      utils_1.checkOffsetValue(offset);
    }
    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
    this._ensureWriteable(byteSize, offsetVal);
    func.call(this._buff, value, offsetVal);
    if (typeof offset === "number") {
      this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
    } else {
      this._writeOffset += byteSize;
    }
    return this;
  }
}
smartbuffer.SmartBuffer = SmartBuffer;
var constants$6 = {};
Object.defineProperty(constants$6, "__esModule", { value: true });
constants$6.SOCKS5_NO_ACCEPTABLE_AUTH = constants$6.SOCKS5_CUSTOM_AUTH_END = constants$6.SOCKS5_CUSTOM_AUTH_START = constants$6.SOCKS_INCOMING_PACKET_SIZES = constants$6.SocksClientState = constants$6.Socks5Response = constants$6.Socks5HostType = constants$6.Socks5Auth = constants$6.Socks4Response = constants$6.SocksCommand = constants$6.ERRORS = constants$6.DEFAULT_TIMEOUT = void 0;
const DEFAULT_TIMEOUT = 3e4;
constants$6.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
const ERRORS = {
  InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
  InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
  InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
  InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
  InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
  InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
  InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
  InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
  InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
  InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
  NegotiationError: "Negotiation error",
  SocketClosed: "Socket closed",
  ProxyConnectionTimedOut: "Proxy connection timed out",
  InternalError: "SocksClient internal error (this should not happen)",
  InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
  Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
  InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
  Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
  InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
  InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
  InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
  InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
  Socks5AuthenticationFailed: "Socks5 Authentication failed",
  InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
  InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
  InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
  Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
};
constants$6.ERRORS = ERRORS;
const SOCKS_INCOMING_PACKET_SIZES = {
  Socks5InitialHandshakeResponse: 2,
  Socks5UserPassAuthenticationResponse: 2,
  // Command response + incoming connection (bind)
  Socks5ResponseHeader: 5,
  // We need at least 5 to read the hostname length, then we wait for the address+port information.
  Socks5ResponseIPv4: 10,
  // 4 header + 4 ip + 2 port
  Socks5ResponseIPv6: 22,
  // 4 header + 16 ip + 2 port
  Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
  // 4 header + 1 host length + host + 2 port
  // Command response + incoming connection (bind)
  Socks4Response: 8
  // 2 header + 2 port + 4 ip
};
constants$6.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
var SocksCommand;
(function(SocksCommand2) {
  SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
  SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
  SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
})(SocksCommand || (constants$6.SocksCommand = SocksCommand = {}));
var Socks4Response;
(function(Socks4Response2) {
  Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
  Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
  Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
  Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
})(Socks4Response || (constants$6.Socks4Response = Socks4Response = {}));
var Socks5Auth;
(function(Socks5Auth2) {
  Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
  Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
  Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
})(Socks5Auth || (constants$6.Socks5Auth = Socks5Auth = {}));
const SOCKS5_CUSTOM_AUTH_START = 128;
constants$6.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
const SOCKS5_CUSTOM_AUTH_END = 254;
constants$6.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
const SOCKS5_NO_ACCEPTABLE_AUTH = 255;
constants$6.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
var Socks5Response;
(function(Socks5Response2) {
  Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
  Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
  Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
  Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
  Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
  Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
  Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
  Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
  Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
})(Socks5Response || (constants$6.Socks5Response = Socks5Response = {}));
var Socks5HostType;
(function(Socks5HostType2) {
  Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
  Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
  Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
})(Socks5HostType || (constants$6.Socks5HostType = Socks5HostType = {}));
var SocksClientState;
(function(SocksClientState2) {
  SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
  SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
  SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
  SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
  SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
  SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
  SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
  SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
  SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
  SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
  SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
  SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
  SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
})(SocksClientState || (constants$6.SocksClientState = SocksClientState = {}));
var helpers$3 = {};
var util$6 = {};
Object.defineProperty(util$6, "__esModule", { value: true });
util$6.shuffleArray = util$6.SocksClientError = void 0;
class SocksClientError extends Error {
  constructor(message2, options) {
    super(message2);
    this.options = options;
  }
}
util$6.SocksClientError = SocksClientError;
function shuffleArray(array) {
  for (let i2 = array.length - 1; i2 > 0; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    [array[i2], array[j2]] = [array[j2], array[i2]];
  }
}
util$6.shuffleArray = shuffleArray;
var ipAddress = {};
var ipv4 = {};
var common$3 = {};
Object.defineProperty(common$3, "__esModule", { value: true });
common$3.isCorrect = common$3.isInSubnet = void 0;
function isInSubnet(address) {
  if (this.subnetMask < address.subnetMask) {
    return false;
  }
  if (this.mask(address.subnetMask) === address.mask()) {
    return true;
  }
  return false;
}
common$3.isInSubnet = isInSubnet;
function isCorrect(defaultBits) {
  return function() {
    if (this.addressMinusSuffix !== this.correctForm()) {
      return false;
    }
    if (this.subnetMask === defaultBits && !this.parsedSubnet) {
      return true;
    }
    return this.parsedSubnet === String(this.subnetMask);
  };
}
common$3.isCorrect = isCorrect;
var constants$5 = {};
Object.defineProperty(constants$5, "__esModule", { value: true });
constants$5.RE_SUBNET_STRING = constants$5.RE_ADDRESS = constants$5.GROUPS = constants$5.BITS = void 0;
constants$5.BITS = 32;
constants$5.GROUPS = 4;
constants$5.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
constants$5.RE_SUBNET_STRING = /\/\d{1,2}$/;
var addressError = {};
Object.defineProperty(addressError, "__esModule", { value: true });
addressError.AddressError = void 0;
class AddressError extends Error {
  constructor(message2, parseMessage) {
    super(message2);
    this.name = "AddressError";
    if (parseMessage !== null) {
      this.parseMessage = parseMessage;
    }
  }
}
addressError.AddressError = AddressError;
var jsbn = { exports: {} };
(function(module2, exports2) {
  (function() {
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a2, b2, c2) {
      if (a2 != null)
        if ("number" == typeof a2)
          this.fromNumber(a2, b2, c2);
        else if (b2 == null && "string" != typeof a2)
          this.fromString(a2, 256);
        else
          this.fromString(a2, b2);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x2, w2, j2, c2, n2) {
      while (--n2 >= 0) {
        var v2 = x2 * this[i2++] + w2[j2] + c2;
        c2 = Math.floor(v2 / 67108864);
        w2[j2++] = v2 & 67108863;
      }
      return c2;
    }
    function am2(i2, x2, w2, j2, c2, n2) {
      var xl = x2 & 32767, xh = x2 >> 15;
      while (--n2 >= 0) {
        var l2 = this[i2] & 32767;
        var h2 = this[i2++] >> 15;
        var m2 = xh * l2 + h2 * xl;
        l2 = xl * l2 + ((m2 & 32767) << 15) + w2[j2] + (c2 & 1073741823);
        c2 = (l2 >>> 30) + (m2 >>> 15) + xh * h2 + (c2 >>> 30);
        w2[j2++] = l2 & 1073741823;
      }
      return c2;
    }
    function am3(i2, x2, w2, j2, c2, n2) {
      var xl = x2 & 16383, xh = x2 >> 14;
      while (--n2 >= 0) {
        var l2 = this[i2] & 16383;
        var h2 = this[i2++] >> 14;
        var m2 = xh * l2 + h2 * xl;
        l2 = xl * l2 + ((m2 & 16383) << 14) + w2[j2] + c2;
        c2 = (l2 >> 28) + (m2 >> 14) + xh * h2;
        w2[j2++] = l2 & 268435455;
      }
      return c2;
    }
    var inBrowser = typeof navigator !== "undefined";
    if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr, vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n2) {
      return BI_RM.charAt(n2);
    }
    function intAt(s2, i2) {
      var c2 = BI_RC[s2.charCodeAt(i2)];
      return c2 == null ? -1 : c2;
    }
    function bnpCopyTo(r2) {
      for (var i2 = this.t - 1; i2 >= 0; --i2)
        r2[i2] = this[i2];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x2) {
      this.t = 1;
      this.s = x2 < 0 ? -1 : 0;
      if (x2 > 0)
        this[0] = x2;
      else if (x2 < -1)
        this[0] = x2 + this.DV;
      else
        this.t = 0;
    }
    function nbv(i2) {
      var r2 = nbi();
      r2.fromInt(i2);
      return r2;
    }
    function bnpFromString(s2, b2) {
      var k2;
      if (b2 == 16)
        k2 = 4;
      else if (b2 == 8)
        k2 = 3;
      else if (b2 == 256)
        k2 = 8;
      else if (b2 == 2)
        k2 = 1;
      else if (b2 == 32)
        k2 = 5;
      else if (b2 == 4)
        k2 = 2;
      else {
        this.fromRadix(s2, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s2.length, mi = false, sh = 0;
      while (--i2 >= 0) {
        var x2 = k2 == 8 ? s2[i2] & 255 : intAt(s2, i2);
        if (x2 < 0) {
          if (s2.charAt(i2) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this[this.t++] = x2;
        else if (sh + k2 > this.DB) {
          this[this.t - 1] |= (x2 & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x2 >> this.DB - sh;
        } else
          this[this.t - 1] |= x2 << sh;
        sh += k2;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k2 == 8 && (s2[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c2 = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c2)
        --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0)
        return "-" + this.negate().toString(b2);
      var k2;
      if (b2 == 16)
        k2 = 4;
      else if (b2 == 8)
        k2 = 3;
      else if (b2 == 2)
        k2 = 1;
      else if (b2 == 32)
        k2 = 5;
      else if (b2 == 4)
        k2 = 2;
      else
        return this.toRadix(b2);
      var km = (1 << k2) - 1, d2, m2 = false, r2 = "", i2 = this.t;
      var p2 = this.DB - i2 * this.DB % k2;
      if (i2-- > 0) {
        if (p2 < this.DB && (d2 = this[i2] >> p2) > 0) {
          m2 = true;
          r2 = int2char(d2);
        }
        while (i2 >= 0) {
          if (p2 < k2) {
            d2 = (this[i2] & (1 << p2) - 1) << k2 - p2;
            d2 |= this[--i2] >> (p2 += this.DB - k2);
          } else {
            d2 = this[i2] >> (p2 -= k2) & km;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if (d2 > 0)
            m2 = true;
          if (m2)
            r2 += int2char(d2);
        }
      }
      return m2 ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a2) {
      var r2 = this.s - a2.s;
      if (r2 != 0)
        return r2;
      var i2 = this.t;
      r2 = i2 - a2.t;
      if (r2 != 0)
        return this.s < 0 ? -r2 : r2;
      while (--i2 >= 0)
        if ((r2 = this[i2] - a2[i2]) != 0)
          return r2;
      return 0;
    }
    function nbits(x2) {
      var r2 = 1, t3;
      if ((t3 = x2 >>> 16) != 0) {
        x2 = t3;
        r2 += 16;
      }
      if ((t3 = x2 >> 8) != 0) {
        x2 = t3;
        r2 += 8;
      }
      if ((t3 = x2 >> 4) != 0) {
        x2 = t3;
        r2 += 4;
      }
      if ((t3 = x2 >> 2) != 0) {
        x2 = t3;
        r2 += 2;
      }
      if ((t3 = x2 >> 1) != 0) {
        x2 = t3;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n2, r2) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2)
        r2[i2 + n2] = this[i2];
      for (i2 = n2 - 1; i2 >= 0; --i2)
        r2[i2] = 0;
      r2.t = this.t + n2;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n2, r2) {
      for (var i2 = n2; i2 < this.t; ++i2)
        r2[i2 - n2] = this[i2];
      r2.t = Math.max(this.t - n2, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n2, r2) {
      var bs = n2 % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n2 / this.DB), c2 = this.s << bs & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r2[i2 + ds + 1] = this[i2] >> cbs | c2;
        c2 = (this[i2] & bm) << bs;
      }
      for (i2 = ds - 1; i2 >= 0; --i2)
        r2[i2] = 0;
      r2[ds] = c2;
      r2.t = this.t + ds + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n2, r2) {
      r2.s = this.s;
      var ds = Math.floor(n2 / this.DB);
      if (ds >= this.t) {
        r2.t = 0;
        return;
      }
      var bs = n2 % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r2[0] = this[ds] >> bs;
      for (var i2 = ds + 1; i2 < this.t; ++i2) {
        r2[i2 - ds - 1] |= (this[i2] & bm) << cbs;
        r2[i2 - ds] = this[i2] >> bs;
      }
      if (bs > 0)
        r2[this.t - ds - 1] |= (this.s & bm) << cbs;
      r2.t = this.t - ds;
      r2.clamp();
    }
    function bnpSubTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this[i2] - a2[i2];
        r2[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 -= a2.s;
        while (i2 < this.t) {
          c2 += this[i2];
          r2[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 -= a2[i2];
          r2[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 -= a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 < -1)
        r2[i2++] = this.DV + c2;
      else if (c2 > 0)
        r2[i2++] = c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnpMultiplyTo(a2, r2) {
      var x2 = this.abs(), y2 = a2.abs();
      var i2 = x2.t;
      r2.t = i2 + y2.t;
      while (--i2 >= 0)
        r2[i2] = 0;
      for (i2 = 0; i2 < y2.t; ++i2)
        r2[i2 + x2.t] = x2.am(0, y2[i2], r2, i2, 0, x2.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a2.s)
        BigInteger.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x2 = this.abs();
      var i2 = r2.t = 2 * x2.t;
      while (--i2 >= 0)
        r2[i2] = 0;
      for (i2 = 0; i2 < x2.t - 1; ++i2) {
        var c2 = x2.am(i2, x2[i2], r2, 2 * i2, 0, 1);
        if ((r2[i2 + x2.t] += x2.am(i2 + 1, 2 * x2[i2], r2, 2 * i2 + 1, c2, x2.t - i2 - 1)) >= x2.DV) {
          r2[i2 + x2.t] -= x2.DV;
          r2[i2 + x2.t + 1] = 1;
        }
      }
      if (r2.t > 0)
        r2[r2.t - 1] += x2.am(i2, x2[i2], r2, 2 * i2, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m2, q2, r2) {
      var pm = m2.abs();
      if (pm.t <= 0)
        return;
      var pt2 = this.abs();
      if (pt2.t < pm.t) {
        if (q2 != null)
          q2.fromInt(0);
        if (r2 != null)
          this.copyTo(r2);
        return;
      }
      if (r2 == null)
        r2 = nbi();
      var y2 = nbi(), ts = this.s, ms2 = m2.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y2);
        pt2.lShiftTo(nsh, r2);
      } else {
        pm.copyTo(y2);
        pt2.copyTo(r2);
      }
      var ys = y2.t;
      var y0 = y2[ys - 1];
      if (y0 == 0)
        return;
      var yt2 = y0 * (1 << this.F1) + (ys > 1 ? y2[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
      var i2 = r2.t, j2 = i2 - ys, t3 = q2 == null ? nbi() : q2;
      y2.dlShiftTo(j2, t3);
      if (r2.compareTo(t3) >= 0) {
        r2[r2.t++] = 1;
        r2.subTo(t3, r2);
      }
      BigInteger.ONE.dlShiftTo(ys, t3);
      t3.subTo(y2, y2);
      while (y2.t < ys)
        y2[y2.t++] = 0;
      while (--j2 >= 0) {
        var qd = r2[--i2] == y0 ? this.DM : Math.floor(r2[i2] * d1 + (r2[i2 - 1] + e2) * d2);
        if ((r2[i2] += y2.am(0, qd, r2, j2, 0, ys)) < qd) {
          y2.dlShiftTo(j2, t3);
          r2.subTo(t3, r2);
          while (r2[i2] < --qd)
            r2.subTo(t3, r2);
        }
      }
      if (q2 != null) {
        r2.drShiftTo(ys, q2);
        if (ts != ms2)
          BigInteger.ZERO.subTo(q2, q2);
      }
      r2.t = ys;
      r2.clamp();
      if (nsh > 0)
        r2.rShiftTo(nsh, r2);
      if (ts < 0)
        BigInteger.ZERO.subTo(r2, r2);
    }
    function bnMod(a2) {
      var r2 = nbi();
      this.abs().divRemTo(a2, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
        a2.subTo(r2, r2);
      return r2;
    }
    function Classic(m2) {
      this.m = m2;
    }
    function cConvert(x2) {
      if (x2.s < 0 || x2.compareTo(this.m) >= 0)
        return x2.mod(this.m);
      else
        return x2;
    }
    function cRevert(x2) {
      return x2;
    }
    function cReduce(x2) {
      x2.divRemTo(this.m, null, x2);
    }
    function cMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    function cSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x2 = this[0];
      if ((x2 & 1) == 0)
        return 0;
      var y2 = x2 & 3;
      y2 = y2 * (2 - (x2 & 15) * y2) & 15;
      y2 = y2 * (2 - (x2 & 255) * y2) & 255;
      y2 = y2 * (2 - ((x2 & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x2 * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    function Montgomery(m2) {
      this.m = m2;
      this.mp = m2.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m2.DB - 15) - 1;
      this.mt2 = 2 * m2.t;
    }
    function montConvert(x2) {
      var r2 = nbi();
      x2.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x2.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x2) {
      var r2 = nbi();
      x2.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x2) {
      while (x2.t <= this.mt2)
        x2[x2.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j2 = x2[i2] & 32767;
        var u0 = j2 * this.mpl + ((j2 * this.mph + (x2[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
        j2 = i2 + this.m.t;
        x2[j2] += this.m.am(0, u0, x2, i2, 0, this.m.t);
        while (x2[j2] >= x2.DV) {
          x2[j2] -= x2.DV;
          x2[++j2]++;
        }
      }
      x2.clamp();
      x2.drShiftTo(this.m.t, x2);
      if (x2.compareTo(this.m) >= 0)
        x2.subTo(this.m, x2);
    }
    function montSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e2, z3) {
      if (e2 > 4294967295 || e2 < 1)
        return BigInteger.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z3.convert(this), i2 = nbits(e2) - 1;
      g2.copyTo(r2);
      while (--i2 >= 0) {
        z3.sqrTo(r2, r22);
        if ((e2 & 1 << i2) > 0)
          z3.mulTo(r22, g2, r2);
        else {
          var t3 = r2;
          r2 = r22;
          r22 = t3;
        }
      }
      return z3.revert(r2);
    }
    function bnModPowInt(e2, m2) {
      var z3;
      if (e2 < 256 || m2.isEven())
        z3 = new Classic(m2);
      else
        z3 = new Montgomery(m2);
      return this.exp(e2, z3);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t == 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null)
        b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36)
        return "0";
      var cs = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs);
      var d2 = nbv(a2), y2 = nbi(), z3 = nbi(), r2 = "";
      this.divRemTo(d2, y2, z3);
      while (y2.signum() > 0) {
        r2 = (a2 + z3.intValue()).toString(b2).substr(1) + r2;
        y2.divRemTo(d2, y2, z3);
      }
      return z3.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s2, b2) {
      this.fromInt(0);
      if (b2 == null)
        b2 = 10;
      var cs = this.chunkSize(b2);
      var d2 = Math.pow(b2, cs), mi = false, j2 = 0, w2 = 0;
      for (var i2 = 0; i2 < s2.length; ++i2) {
        var x2 = intAt(s2, i2);
        if (x2 < 0) {
          if (s2.charAt(i2) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w2 = b2 * w2 + x2;
        if (++j2 >= cs) {
          this.dMultiply(d2);
          this.dAddOffset(w2, 0);
          j2 = 0;
          w2 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b2, j2));
        this.dAddOffset(w2, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a2, b2, c2) {
      if ("number" == typeof b2) {
        if (a2 < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a2, c2);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2)
              this.subTo(BigInteger.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x2 = new Array(), t3 = a2 & 7;
        x2.length = (a2 >> 3) + 1;
        b2.nextBytes(x2);
        if (t3 > 0)
          x2[0] &= (1 << t3) - 1;
        else
          x2[0] = 0;
        this.fromString(x2, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p2 = this.DB - i2 * this.DB % 8, d2, k2 = 0;
      if (i2-- > 0) {
        if (p2 < this.DB && (d2 = this[i2] >> p2) != (this.s & this.DM) >> p2)
          r2[k2++] = d2 | this.s << this.DB - p2;
        while (i2 >= 0) {
          if (p2 < 8) {
            d2 = (this[i2] & (1 << p2) - 1) << 8 - p2;
            d2 |= this[--i2] >> (p2 += this.DB - 8);
          } else {
            d2 = this[i2] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if ((d2 & 128) != 0)
            d2 |= -256;
          if (k2 == 0 && (this.s & 128) != (d2 & 128))
            ++k2;
          if (k2 > 0 || d2 != this.s)
            r2[k2++] = d2;
        }
      }
      return r2;
    }
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    function bnpBitwiseTo(a2, op, r2) {
      var i2, f2, m2 = Math.min(a2.t, this.t);
      for (i2 = 0; i2 < m2; ++i2)
        r2[i2] = op(this[i2], a2[i2]);
      if (a2.t < this.t) {
        f2 = a2.s & this.DM;
        for (i2 = m2; i2 < this.t; ++i2)
          r2[i2] = op(this[i2], f2);
        r2.t = this.t;
      } else {
        f2 = this.s & this.DM;
        for (i2 = m2; i2 < a2.t; ++i2)
          r2[i2] = op(f2, a2[i2]);
        r2.t = a2.t;
      }
      r2.s = op(this.s, a2.s);
      r2.clamp();
    }
    function op_and(x2, y2) {
      return x2 & y2;
    }
    function bnAnd(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_and, r2);
      return r2;
    }
    function op_or(x2, y2) {
      return x2 | y2;
    }
    function bnOr(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_or, r2);
      return r2;
    }
    function op_xor(x2, y2) {
      return x2 ^ y2;
    }
    function bnXor(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_xor, r2);
      return r2;
    }
    function op_andnot(x2, y2) {
      return x2 & ~y2;
    }
    function bnAndNot(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i2 = 0; i2 < this.t; ++i2)
        r2[i2] = this.DM & ~this[i2];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n2) {
      var r2 = nbi();
      if (n2 < 0)
        this.rShiftTo(-n2, r2);
      else
        this.lShiftTo(n2, r2);
      return r2;
    }
    function bnShiftRight(n2) {
      var r2 = nbi();
      if (n2 < 0)
        this.lShiftTo(-n2, r2);
      else
        this.rShiftTo(n2, r2);
      return r2;
    }
    function lbit(x2) {
      if (x2 == 0)
        return -1;
      var r2 = 0;
      if ((x2 & 65535) == 0) {
        x2 >>= 16;
        r2 += 16;
      }
      if ((x2 & 255) == 0) {
        x2 >>= 8;
        r2 += 8;
      }
      if ((x2 & 15) == 0) {
        x2 >>= 4;
        r2 += 4;
      }
      if ((x2 & 3) == 0) {
        x2 >>= 2;
        r2 += 2;
      }
      if ((x2 & 1) == 0)
        ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this[i2] != 0)
          return i2 * this.DB + lbit(this[i2]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x2) {
      var r2 = 0;
      while (x2 != 0) {
        x2 &= x2 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x2 = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2)
        r2 += cbit(this[i2] ^ x2);
      return r2;
    }
    function bnTestBit(n2) {
      var j2 = Math.floor(n2 / this.DB);
      if (j2 >= this.t)
        return this.s != 0;
      return (this[j2] & 1 << n2 % this.DB) != 0;
    }
    function bnpChangeBit(n2, op) {
      var r2 = BigInteger.ONE.shiftLeft(n2);
      this.bitwiseTo(r2, op, r2);
      return r2;
    }
    function bnSetBit(n2) {
      return this.changeBit(n2, op_or);
    }
    function bnClearBit(n2) {
      return this.changeBit(n2, op_andnot);
    }
    function bnFlipBit(n2) {
      return this.changeBit(n2, op_xor);
    }
    function bnpAddTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this[i2] + a2[i2];
        r2[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 += a2.s;
        while (i2 < this.t) {
          c2 += this[i2];
          r2[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 += a2[i2];
          r2[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 > 0)
        r2[i2++] = c2;
      else if (c2 < -1)
        r2[i2++] = this.DV + c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnAdd(a2) {
      var r2 = nbi();
      this.addTo(a2, r2);
      return r2;
    }
    function bnSubtract(a2) {
      var r2 = nbi();
      this.subTo(a2, r2);
      return r2;
    }
    function bnMultiply(a2) {
      var r2 = nbi();
      this.multiplyTo(a2, r2);
      return r2;
    }
    function bnSquare() {
      var r2 = nbi();
      this.squareTo(r2);
      return r2;
    }
    function bnDivide(a2) {
      var r2 = nbi();
      this.divRemTo(a2, r2, null);
      return r2;
    }
    function bnRemainder(a2) {
      var r2 = nbi();
      this.divRemTo(a2, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a2) {
      var q2 = nbi(), r2 = nbi();
      this.divRemTo(a2, q2, r2);
      return new Array(q2, r2);
    }
    function bnpDMultiply(n2) {
      this[this.t] = this.am(0, n2 - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n2, w2) {
      if (n2 == 0)
        return;
      while (this.t <= w2)
        this[this.t++] = 0;
      this[w2] += n2;
      while (this[w2] >= this.DV) {
        this[w2] -= this.DV;
        if (++w2 >= this.t)
          this[this.t++] = 0;
        ++this[w2];
      }
    }
    function NullExp() {
    }
    function nNop(x2) {
      return x2;
    }
    function nMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
    }
    function nSqrTo(x2, r2) {
      x2.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e2) {
      return this.exp(e2, new NullExp());
    }
    function bnpMultiplyLowerTo(a2, n2, r2) {
      var i2 = Math.min(this.t + a2.t, n2);
      r2.s = 0;
      r2.t = i2;
      while (i2 > 0)
        r2[--i2] = 0;
      var j2;
      for (j2 = r2.t - this.t; i2 < j2; ++i2)
        r2[i2 + this.t] = this.am(0, a2[i2], r2, i2, 0, this.t);
      for (j2 = Math.min(a2.t, n2); i2 < j2; ++i2)
        this.am(0, a2[i2], r2, i2, 0, n2 - i2);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a2, n2, r2) {
      --n2;
      var i2 = r2.t = this.t + a2.t - n2;
      r2.s = 0;
      while (--i2 >= 0)
        r2[i2] = 0;
      for (i2 = Math.max(n2 - this.t, 0); i2 < a2.t; ++i2)
        r2[this.t + i2 - n2] = this.am(n2 - i2, a2[i2], r2, 0, 0, this.t + i2 - n2);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m2) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
      this.mu = this.r2.divide(m2);
      this.m = m2;
    }
    function barrettConvert(x2) {
      if (x2.s < 0 || x2.t > 2 * this.m.t)
        return x2.mod(this.m);
      else if (x2.compareTo(this.m) < 0)
        return x2;
      else {
        var r2 = nbi();
        x2.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x2) {
      return x2;
    }
    function barrettReduce(x2) {
      x2.drShiftTo(this.m.t - 1, this.r2);
      if (x2.t > this.m.t + 1) {
        x2.t = this.m.t + 1;
        x2.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x2.compareTo(this.r2) < 0)
        x2.dAddOffset(1, this.m.t + 1);
      x2.subTo(this.r2, x2);
      while (x2.compareTo(this.m) >= 0)
        x2.subTo(this.m, x2);
    }
    function barrettSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e2, m2) {
      var i2 = e2.bitLength(), k2, r2 = nbv(1), z3;
      if (i2 <= 0)
        return r2;
      else if (i2 < 18)
        k2 = 1;
      else if (i2 < 48)
        k2 = 3;
      else if (i2 < 144)
        k2 = 4;
      else if (i2 < 768)
        k2 = 5;
      else
        k2 = 6;
      if (i2 < 8)
        z3 = new Classic(m2);
      else if (m2.isEven())
        z3 = new Barrett(m2);
      else
        z3 = new Montgomery(m2);
      var g2 = new Array(), n2 = 3, k1 = k2 - 1, km = (1 << k2) - 1;
      g2[1] = z3.convert(this);
      if (k2 > 1) {
        var g22 = nbi();
        z3.sqrTo(g2[1], g22);
        while (n2 <= km) {
          g2[n2] = nbi();
          z3.mulTo(g22, g2[n2 - 2], g2[n2]);
          n2 += 2;
        }
      }
      var j2 = e2.t - 1, w2, is1 = true, r22 = nbi(), t3;
      i2 = nbits(e2[j2]) - 1;
      while (j2 >= 0) {
        if (i2 >= k1)
          w2 = e2[j2] >> i2 - k1 & km;
        else {
          w2 = (e2[j2] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j2 > 0)
            w2 |= e2[j2 - 1] >> this.DB + i2 - k1;
        }
        n2 = k2;
        while ((w2 & 1) == 0) {
          w2 >>= 1;
          --n2;
        }
        if ((i2 -= n2) < 0) {
          i2 += this.DB;
          --j2;
        }
        if (is1) {
          g2[w2].copyTo(r2);
          is1 = false;
        } else {
          while (n2 > 1) {
            z3.sqrTo(r2, r22);
            z3.sqrTo(r22, r2);
            n2 -= 2;
          }
          if (n2 > 0)
            z3.sqrTo(r2, r22);
          else {
            t3 = r2;
            r2 = r22;
            r22 = t3;
          }
          z3.mulTo(r22, g2[w2], r2);
        }
        while (j2 >= 0 && (e2[j2] & 1 << i2) == 0) {
          z3.sqrTo(r2, r22);
          t3 = r2;
          r2 = r22;
          r22 = t3;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j2;
          }
        }
      }
      return z3.revert(r2);
    }
    function bnGCD(a2) {
      var x2 = this.s < 0 ? this.negate() : this.clone();
      var y2 = a2.s < 0 ? a2.negate() : a2.clone();
      if (x2.compareTo(y2) < 0) {
        var t3 = x2;
        x2 = y2;
        y2 = t3;
      }
      var i2 = x2.getLowestSetBit(), g2 = y2.getLowestSetBit();
      if (g2 < 0)
        return x2;
      if (i2 < g2)
        g2 = i2;
      if (g2 > 0) {
        x2.rShiftTo(g2, x2);
        y2.rShiftTo(g2, y2);
      }
      while (x2.signum() > 0) {
        if ((i2 = x2.getLowestSetBit()) > 0)
          x2.rShiftTo(i2, x2);
        if ((i2 = y2.getLowestSetBit()) > 0)
          y2.rShiftTo(i2, y2);
        if (x2.compareTo(y2) >= 0) {
          x2.subTo(y2, x2);
          x2.rShiftTo(1, x2);
        } else {
          y2.subTo(x2, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g2 > 0)
        y2.lShiftTo(g2, y2);
      return y2;
    }
    function bnpModInt(n2) {
      if (n2 <= 0)
        return 0;
      var d2 = this.DV % n2, r2 = this.s < 0 ? n2 - 1 : 0;
      if (this.t > 0)
        if (d2 == 0)
          r2 = this[0] % n2;
        else
          for (var i2 = this.t - 1; i2 >= 0; --i2)
            r2 = (d2 * r2 + this[i2]) % n2;
      return r2;
    }
    function bnModInverse(m2) {
      var ac = m2.isEven();
      if (this.isEven() && ac || m2.signum() == 0)
        return BigInteger.ZERO;
      var u2 = m2.clone(), v2 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c2 = nbv(0), d2 = nbv(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m2, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven())
            b2.subTo(m2, b2);
          b2.rShiftTo(1, b2);
        }
        while (v2.isEven()) {
          v2.rShiftTo(1, v2);
          if (ac) {
            if (!c2.isEven() || !d2.isEven()) {
              c2.addTo(this, c2);
              d2.subTo(m2, d2);
            }
            c2.rShiftTo(1, c2);
          } else if (!d2.isEven())
            d2.subTo(m2, d2);
          d2.rShiftTo(1, d2);
        }
        if (u2.compareTo(v2) >= 0) {
          u2.subTo(v2, u2);
          if (ac)
            a2.subTo(c2, a2);
          b2.subTo(d2, b2);
        } else {
          v2.subTo(u2, v2);
          if (ac)
            c2.subTo(a2, c2);
          d2.subTo(b2, d2);
        }
      }
      if (v2.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d2.compareTo(m2) >= 0)
        return d2.subtract(m2);
      if (d2.signum() < 0)
        d2.addTo(m2, d2);
      else
        return d2;
      if (d2.signum() < 0)
        return d2.add(m2);
      else
        return d2;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t3) {
      var i2, x2 = this.abs();
      if (x2.t == 1 && x2[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x2[0] == lowprimes[i2])
            return true;
        return false;
      }
      if (x2.isEven())
        return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m2 = lowprimes[i2], j2 = i2 + 1;
        while (j2 < lowprimes.length && m2 < lplim)
          m2 *= lowprimes[j2++];
        m2 = x2.modInt(m2);
        while (i2 < j2)
          if (m2 % lowprimes[i2++] == 0)
            return false;
      }
      return x2.millerRabin(t3);
    }
    function bnpMillerRabin(t3) {
      var n1 = this.subtract(BigInteger.ONE);
      var k2 = n1.getLowestSetBit();
      if (k2 <= 0)
        return false;
      var r2 = n1.shiftRight(k2);
      t3 = t3 + 1 >> 1;
      if (t3 > lowprimes.length)
        t3 = lowprimes.length;
      var a2 = nbi();
      for (var i2 = 0; i2 < t3; ++i2) {
        a2.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y2 = a2.modPow(r2, this);
        if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n1) != 0) {
          var j2 = 1;
          while (j2++ < k2 && y2.compareTo(n1) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y2.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    BigInteger.prototype.Barrett = Barrett;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x2) {
      rng_pool[rng_pptr++] ^= x2 & 255;
      rng_pool[rng_pptr++] ^= x2 >> 8 & 255;
      rng_pool[rng_pptr++] ^= x2 >> 16 & 255;
      rng_pool[rng_pptr++] ^= x2 >> 24 & 255;
      if (rng_pptr >= rng_psize)
        rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int((/* @__PURE__ */ new Date()).getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array();
      rng_pptr = 0;
      var t2;
      if (typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t2 = 0; t2 < 32; ++t2)
            rng_pool[rng_pptr++] = ua[t2];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var z2 = window.crypto.random(32);
          for (t2 = 0; t2 < z2.length; ++t2)
            rng_pool[rng_pptr++] = z2.charCodeAt(t2) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t2 = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t2 >>> 8;
        rng_pool[rng_pptr++] = t2 & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i2;
      for (i2 = 0; i2 < ba.length; ++i2)
        ba[i2] = rng_get_byte();
    }
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array();
    }
    function ARC4init(key) {
      var i2, j2, t3;
      for (i2 = 0; i2 < 256; ++i2)
        this.S[i2] = i2;
      j2 = 0;
      for (i2 = 0; i2 < 256; ++i2) {
        j2 = j2 + this.S[i2] + key[i2 % key.length] & 255;
        t3 = this.S[i2];
        this.S[i2] = this.S[j2];
        this.S[j2] = t3;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t3;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      t3 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t3;
      return this.S[t3 + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour();
    }
    var rng_psize = 256;
    {
      module2.exports = {
        default: BigInteger,
        BigInteger,
        SecureRandom
      };
    }
  }).call(commonjsGlobal);
})(jsbn);
var jsbnExports = jsbn.exports;
var sprintf = {};
(function(exports2) {
  !function() {
    var re2 = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf2(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf2.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i2, k2, ph, pad, pad_character, pad_length, is_positive, sign;
      for (i2 = 0; i2 < tree_length; i2++) {
        if (typeof parse_tree[i2] === "string") {
          output += parse_tree[i2];
        } else if (typeof parse_tree[i2] === "object") {
          ph = parse_tree[i2];
          if (ph.keys) {
            arg = argv[cursor];
            for (k2 = 0; k2 < ph.keys.length; k2++) {
              if (arg == void 0) {
                throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k2], ph.keys[k2 - 1]));
              }
              arg = arg[ph.keys[k2]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re2.not_type.test(ph.type) && re2.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re2.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
          }
          if (re2.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re2.json.test(ph.type)) {
            output += arg;
          } else {
            if (re2.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign = is_positive ? "+" : "-";
              arg = arg.toString().replace(re2.sign, "");
            } else {
              sign = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign + arg).length;
            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = /* @__PURE__ */ Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = re2.text.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        } else if ((match = re2.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match = re2.placeholder.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = re2.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re2.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re2.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push(
            {
              placeholder: match[0],
              param_no: match[1],
              keys: match[2],
              sign: match[3],
              pad_char: match[4],
              align: match[5],
              width: match[6],
              precision: match[7],
              type: match[8]
            }
          );
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    {
      exports2["sprintf"] = sprintf2;
      exports2["vsprintf"] = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf2;
      window["vsprintf"] = vsprintf;
    }
  }();
})(sprintf);
var __createBinding$9 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$9 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$9 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$9(result, mod, k2);
  }
  __setModuleDefault$9(result, mod);
  return result;
};
Object.defineProperty(ipv4, "__esModule", { value: true });
ipv4.Address4 = void 0;
const common$2 = __importStar$9(common$3);
const constants$4 = __importStar$9(constants$5);
const address_error_1$1 = addressError;
const jsbn_1$1 = jsbnExports;
const sprintf_js_1$3 = sprintf;
class Address4 {
  constructor(address) {
    this.groups = constants$4.GROUPS;
    this.parsedAddress = [];
    this.parsedSubnet = "";
    this.subnet = "/32";
    this.subnetMask = 32;
    this.v4 = true;
    this.isCorrect = common$2.isCorrect(constants$4.BITS);
    this.isInSubnet = common$2.isInSubnet;
    this.address = address;
    const subnet = constants$4.RE_SUBNET_STRING.exec(address);
    if (subnet) {
      this.parsedSubnet = subnet[0].replace("/", "");
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = `/${this.subnetMask}`;
      if (this.subnetMask < 0 || this.subnetMask > constants$4.BITS) {
        throw new address_error_1$1.AddressError("Invalid subnet mask.");
      }
      address = address.replace(constants$4.RE_SUBNET_STRING, "");
    }
    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(address);
  }
  static isValid(address) {
    try {
      new Address4(address);
      return true;
    } catch (e2) {
      return false;
    }
  }
  /*
   * Parses a v4 address
   */
  parse(address) {
    const groups = address.split(".");
    if (!address.match(constants$4.RE_ADDRESS)) {
      throw new address_error_1$1.AddressError("Invalid IPv4 address.");
    }
    return groups;
  }
  /**
   * Returns the correct form of an address
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  correctForm() {
    return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
  }
  /**
   * Converts a hex string to an IPv4 address object
   * @memberof Address4
   * @static
   * @param {string} hex - a hex string to convert
   * @returns {Address4}
   */
  static fromHex(hex) {
    const padded = hex.replace(/:/g, "").padStart(8, "0");
    const groups = [];
    let i2;
    for (i2 = 0; i2 < 8; i2 += 2) {
      const h2 = padded.slice(i2, i2 + 2);
      groups.push(parseInt(h2, 16));
    }
    return new Address4(groups.join("."));
  }
  /**
   * Converts an integer into a IPv4 address object
   * @memberof Address4
   * @static
   * @param {integer} integer - a number to convert
   * @returns {Address4}
   */
  static fromInteger(integer) {
    return Address4.fromHex(integer.toString(16));
  }
  /**
   * Return an address from in-addr.arpa form
   * @memberof Address4
   * @static
   * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
   * @returns {Adress4}
   * @example
   * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
   * address.correctForm(); // '192.0.2.42'
   */
  static fromArpa(arpaFormAddress) {
    const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
    const address = leader.split(".").reverse().join(".");
    return new Address4(address);
  }
  /**
   * Converts an IPv4 address object to a hex string
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  toHex() {
    return this.parsedAddress.map((part) => (0, sprintf_js_1$3.sprintf)("%02x", parseInt(part, 10))).join(":");
  }
  /**
   * Converts an IPv4 address object to an array of bytes
   * @memberof Address4
   * @instance
   * @returns {Array}
   */
  toArray() {
    return this.parsedAddress.map((part) => parseInt(part, 10));
  }
  /**
   * Converts an IPv4 address object to an IPv6 address group
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  toGroup6() {
    const output = [];
    let i2;
    for (i2 = 0; i2 < constants$4.GROUPS; i2 += 2) {
      const hex = (0, sprintf_js_1$3.sprintf)("%02x%02x", parseInt(this.parsedAddress[i2], 10), parseInt(this.parsedAddress[i2 + 1], 10));
      output.push((0, sprintf_js_1$3.sprintf)("%x", parseInt(hex, 16)));
    }
    return output.join(":");
  }
  /**
   * Returns the address as a BigInteger
   * @memberof Address4
   * @instance
   * @returns {BigInteger}
   */
  bigInteger() {
    return new jsbn_1$1.BigInteger(this.parsedAddress.map((n2) => (0, sprintf_js_1$3.sprintf)("%02x", parseInt(n2, 10))).join(""), 16);
  }
  /**
   * Helper function getting start address.
   * @memberof Address4
   * @instance
   * @returns {BigInteger}
   */
  _startAddress() {
    return new jsbn_1$1.BigInteger(this.mask() + "0".repeat(constants$4.BITS - this.subnetMask), 2);
  }
  /**
   * The first address in the range given by this address' subnet.
   * Often referred to as the Network Address.
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  startAddress() {
    return Address4.fromBigInteger(this._startAddress());
  }
  /**
   * The first host address in the range given by this address's subnet ie
   * the first address after the Network Address
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  startAddressExclusive() {
    const adjust = new jsbn_1$1.BigInteger("1");
    return Address4.fromBigInteger(this._startAddress().add(adjust));
  }
  /**
   * Helper function getting end address.
   * @memberof Address4
   * @instance
   * @returns {BigInteger}
   */
  _endAddress() {
    return new jsbn_1$1.BigInteger(this.mask() + "1".repeat(constants$4.BITS - this.subnetMask), 2);
  }
  /**
   * The last address in the range given by this address' subnet
   * Often referred to as the Broadcast
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  endAddress() {
    return Address4.fromBigInteger(this._endAddress());
  }
  /**
   * The last host address in the range given by this address's subnet ie
   * the last address prior to the Broadcast Address
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  endAddressExclusive() {
    const adjust = new jsbn_1$1.BigInteger("1");
    return Address4.fromBigInteger(this._endAddress().subtract(adjust));
  }
  /**
   * Converts a BigInteger to a v4 address object
   * @memberof Address4
   * @static
   * @param {BigInteger} bigInteger - a BigInteger to convert
   * @returns {Address4}
   */
  static fromBigInteger(bigInteger) {
    return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
  }
  /**
   * Returns the first n bits of the address, defaulting to the
   * subnet mask
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  mask(mask) {
    if (mask === void 0) {
      mask = this.subnetMask;
    }
    return this.getBitsBase2(0, mask);
  }
  /**
   * Returns the bits in the given range as a base-2 string
   * @memberof Address4
   * @instance
   * @returns {string}
   */
  getBitsBase2(start, end) {
    return this.binaryZeroPad().slice(start, end);
  }
  /**
   * Return the reversed ip6.arpa form of the address
   * @memberof Address4
   * @param {Object} options
   * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
   * @instance
   * @returns {String}
   */
  reverseForm(options) {
    if (!options) {
      options = {};
    }
    const reversed = this.correctForm().split(".").reverse().join(".");
    if (options.omitSuffix) {
      return reversed;
    }
    return (0, sprintf_js_1$3.sprintf)("%s.in-addr.arpa.", reversed);
  }
  /**
   * Returns true if the given address is a multicast address
   * @memberof Address4
   * @instance
   * @returns {boolean}
   */
  isMulticast() {
    return this.isInSubnet(new Address4("224.0.0.0/4"));
  }
  /**
   * Returns a zero-padded base-2 string representation of the address
   * @memberof Address4
   * @instance
   * @returns {string}
   */
  binaryZeroPad() {
    return this.bigInteger().toString(2).padStart(constants$4.BITS, "0");
  }
  /**
   * Groups an IPv4 address for inclusion at the end of an IPv6 address
   * @returns {String}
   */
  groupForV6() {
    const segments = this.parsedAddress;
    return this.address.replace(constants$4.RE_ADDRESS, (0, sprintf_js_1$3.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
  }
}
ipv4.Address4 = Address4;
var ipv6 = {};
var constants$3 = {};
Object.defineProperty(constants$3, "__esModule", { value: true });
constants$3.RE_URL_WITH_PORT = constants$3.RE_URL = constants$3.RE_ZONE_STRING = constants$3.RE_SUBNET_STRING = constants$3.RE_BAD_ADDRESS = constants$3.RE_BAD_CHARACTERS = constants$3.TYPES = constants$3.SCOPES = constants$3.GROUPS = constants$3.BITS = void 0;
constants$3.BITS = 128;
constants$3.GROUPS = 8;
constants$3.SCOPES = {
  0: "Reserved",
  1: "Interface local",
  2: "Link local",
  4: "Admin local",
  5: "Site local",
  8: "Organization local",
  14: "Global",
  15: "Reserved"
};
constants$3.TYPES = {
  "ff01::1/128": "Multicast (All nodes on this interface)",
  "ff01::2/128": "Multicast (All routers on this interface)",
  "ff02::1/128": "Multicast (All nodes on this link)",
  "ff02::2/128": "Multicast (All routers on this link)",
  "ff05::2/128": "Multicast (All routers in this site)",
  "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
  "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
  "ff02::9/128": "Multicast (RIP routers)",
  "ff02::a/128": "Multicast (EIGRP routers)",
  "ff02::d/128": "Multicast (PIM routers)",
  "ff02::16/128": "Multicast (MLDv2 reports)",
  "ff01::fb/128": "Multicast (mDNSv6)",
  "ff02::fb/128": "Multicast (mDNSv6)",
  "ff05::fb/128": "Multicast (mDNSv6)",
  "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
  "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
  "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
  "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
  "::/128": "Unspecified",
  "::1/128": "Loopback",
  "ff00::/8": "Multicast",
  "fe80::/10": "Link-local unicast"
};
constants$3.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
constants$3.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
constants$3.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
constants$3.RE_ZONE_STRING = /%.*$/;
constants$3.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
constants$3.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
var helpers$2 = {};
Object.defineProperty(helpers$2, "__esModule", { value: true });
helpers$2.simpleGroup = helpers$2.spanLeadingZeroes = helpers$2.spanAll = helpers$2.spanAllZeroes = void 0;
const sprintf_js_1$2 = sprintf;
function spanAllZeroes(s2) {
  return s2.replace(/(0+)/g, '<span class="zero">$1</span>');
}
helpers$2.spanAllZeroes = spanAllZeroes;
function spanAll(s2, offset = 0) {
  const letters = s2.split("");
  return letters.map(
    (n2, i2) => (0, sprintf_js_1$2.sprintf)('<span class="digit value-%s position-%d">%s</span>', n2, i2 + offset, spanAllZeroes(n2))
    // XXX Use #base-2 .value-0 instead?
  ).join("");
}
helpers$2.spanAll = spanAll;
function spanLeadingZeroesSimple(group) {
  return group.replace(/^(0+)/, '<span class="zero">$1</span>');
}
function spanLeadingZeroes(address) {
  const groups = address.split(":");
  return groups.map((g2) => spanLeadingZeroesSimple(g2)).join(":");
}
helpers$2.spanLeadingZeroes = spanLeadingZeroes;
function simpleGroup(addressString, offset = 0) {
  const groups = addressString.split(":");
  return groups.map((g2, i2) => {
    if (/group-v4/.test(g2)) {
      return g2;
    }
    return (0, sprintf_js_1$2.sprintf)('<span class="hover-group group-%d">%s</span>', i2 + offset, spanLeadingZeroesSimple(g2));
  });
}
helpers$2.simpleGroup = simpleGroup;
var regularExpressions = {};
var __createBinding$8 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$8 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$8 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$8(result, mod, k2);
  }
  __setModuleDefault$8(result, mod);
  return result;
};
Object.defineProperty(regularExpressions, "__esModule", { value: true });
regularExpressions.possibleElisions = regularExpressions.simpleRegularExpression = regularExpressions.ADDRESS_BOUNDARY = regularExpressions.padGroup = regularExpressions.groupPossibilities = void 0;
const v6 = __importStar$8(constants$3);
const sprintf_js_1$1 = sprintf;
function groupPossibilities(possibilities) {
  return (0, sprintf_js_1$1.sprintf)("(%s)", possibilities.join("|"));
}
regularExpressions.groupPossibilities = groupPossibilities;
function padGroup(group) {
  if (group.length < 4) {
    return (0, sprintf_js_1$1.sprintf)("0{0,%d}%s", 4 - group.length, group);
  }
  return group;
}
regularExpressions.padGroup = padGroup;
regularExpressions.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
function simpleRegularExpression(groups) {
  const zeroIndexes = [];
  groups.forEach((group, i2) => {
    const groupInteger = parseInt(group, 16);
    if (groupInteger === 0) {
      zeroIndexes.push(i2);
    }
  });
  const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i2) => {
    if (i2 === zeroIndex) {
      const elision = i2 === 0 || i2 === v6.GROUPS - 1 ? ":" : "";
      return groupPossibilities([padGroup(group), elision]);
    }
    return padGroup(group);
  }).join(":"));
  possibilities.push(groups.map(padGroup).join(":"));
  return groupPossibilities(possibilities);
}
regularExpressions.simpleRegularExpression = simpleRegularExpression;
function possibleElisions(elidedGroups, moreLeft, moreRight) {
  const left2 = moreLeft ? "" : ":";
  const right2 = moreRight ? "" : ":";
  const possibilities = [];
  if (!moreLeft && !moreRight) {
    possibilities.push("::");
  }
  if (moreLeft && moreRight) {
    possibilities.push("");
  }
  if (moreRight && !moreLeft || !moreRight && moreLeft) {
    possibilities.push(":");
  }
  possibilities.push((0, sprintf_js_1$1.sprintf)("%s(:0{1,4}){1,%d}", left2, elidedGroups - 1));
  possibilities.push((0, sprintf_js_1$1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right2));
  possibilities.push((0, sprintf_js_1$1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
  for (let groups = 1; groups < elidedGroups - 1; groups++) {
    for (let position = 1; position < elidedGroups - groups; position++) {
      possibilities.push((0, sprintf_js_1$1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
    }
  }
  return groupPossibilities(possibilities);
}
regularExpressions.possibleElisions = possibleElisions;
var __createBinding$7 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$7 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$7 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$7(result, mod, k2);
  }
  __setModuleDefault$7(result, mod);
  return result;
};
Object.defineProperty(ipv6, "__esModule", { value: true });
ipv6.Address6 = void 0;
const common$1 = __importStar$7(common$3);
const constants4 = __importStar$7(constants$5);
const constants6 = __importStar$7(constants$3);
const helpers$1 = __importStar$7(helpers$2);
const ipv4_1 = ipv4;
const regular_expressions_1 = regularExpressions;
const address_error_1 = addressError;
const jsbn_1 = jsbnExports;
const sprintf_js_1 = sprintf;
function assert(condition) {
  if (!condition) {
    throw new Error("Assertion failed.");
  }
}
function addCommas(number) {
  const r2 = /(\d+)(\d{3})/;
  while (r2.test(number)) {
    number = number.replace(r2, "$1,$2");
  }
  return number;
}
function spanLeadingZeroes4(n2) {
  n2 = n2.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
  n2 = n2.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
  return n2;
}
function compact(address, slice) {
  const s1 = [];
  const s2 = [];
  let i2;
  for (i2 = 0; i2 < address.length; i2++) {
    if (i2 < slice[0]) {
      s1.push(address[i2]);
    } else if (i2 > slice[1]) {
      s2.push(address[i2]);
    }
  }
  return s1.concat(["compact"]).concat(s2);
}
function paddedHex(octet) {
  return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
}
function unsignByte(b2) {
  return b2 & 255;
}
class Address6 {
  constructor(address, optionalGroups) {
    this.addressMinusSuffix = "";
    this.parsedSubnet = "";
    this.subnet = "/128";
    this.subnetMask = 128;
    this.v4 = false;
    this.zone = "";
    this.isInSubnet = common$1.isInSubnet;
    this.isCorrect = common$1.isCorrect(constants6.BITS);
    if (optionalGroups === void 0) {
      this.groups = constants6.GROUPS;
    } else {
      this.groups = optionalGroups;
    }
    this.address = address;
    const subnet = constants6.RE_SUBNET_STRING.exec(address);
    if (subnet) {
      this.parsedSubnet = subnet[0].replace("/", "");
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = `/${this.subnetMask}`;
      if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
        throw new address_error_1.AddressError("Invalid subnet mask.");
      }
      address = address.replace(constants6.RE_SUBNET_STRING, "");
    } else if (/\//.test(address)) {
      throw new address_error_1.AddressError("Invalid subnet mask.");
    }
    const zone = constants6.RE_ZONE_STRING.exec(address);
    if (zone) {
      this.zone = zone[0];
      address = address.replace(constants6.RE_ZONE_STRING, "");
    }
    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(this.addressMinusSuffix);
  }
  static isValid(address) {
    try {
      new Address6(address);
      return true;
    } catch (e2) {
      return false;
    }
  }
  /**
   * Convert a BigInteger to a v6 address object
   * @memberof Address6
   * @static
   * @param {BigInteger} bigInteger - a BigInteger to convert
   * @returns {Address6}
   * @example
   * var bigInteger = new BigInteger('1000000000000');
   * var address = Address6.fromBigInteger(bigInteger);
   * address.correctForm(); // '::e8:d4a5:1000'
   */
  static fromBigInteger(bigInteger) {
    const hex = bigInteger.toString(16).padStart(32, "0");
    const groups = [];
    let i2;
    for (i2 = 0; i2 < constants6.GROUPS; i2++) {
      groups.push(hex.slice(i2 * 4, (i2 + 1) * 4));
    }
    return new Address6(groups.join(":"));
  }
  /**
   * Convert a URL (with optional port number) to an address object
   * @memberof Address6
   * @static
   * @param {string} url - a URL with optional port number
   * @example
   * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
   * addressAndPort.address.correctForm(); // 'ffff::'
   * addressAndPort.port; // 8080
   */
  static fromURL(url) {
    let host;
    let port = null;
    let result;
    if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
      result = constants6.RE_URL_WITH_PORT.exec(url);
      if (result === null) {
        return {
          error: "failed to parse address with port",
          address: null,
          port: null
        };
      }
      host = result[1];
      port = result[2];
    } else if (url.indexOf("/") !== -1) {
      url = url.replace(/^[a-z0-9]+:\/\//, "");
      result = constants6.RE_URL.exec(url);
      if (result === null) {
        return {
          error: "failed to parse address from URL",
          address: null,
          port: null
        };
      }
      host = result[1];
    } else {
      host = url;
    }
    if (port) {
      port = parseInt(port, 10);
      if (port < 0 || port > 65536) {
        port = null;
      }
    } else {
      port = null;
    }
    return {
      address: new Address6(host),
      port
    };
  }
  /**
   * Create an IPv6-mapped address given an IPv4 address
   * @memberof Address6
   * @static
   * @param {string} address - An IPv4 address string
   * @returns {Address6}
   * @example
   * var address = Address6.fromAddress4('192.168.0.1');
   * address.correctForm(); // '::ffff:c0a8:1'
   * address.to4in6(); // '::ffff:192.168.0.1'
   */
  static fromAddress4(address) {
    const address4 = new ipv4_1.Address4(address);
    const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
    return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
  }
  /**
   * Return an address from ip6.arpa form
   * @memberof Address6
   * @static
   * @param {string} arpaFormAddress - an 'ip6.arpa' form address
   * @returns {Adress6}
   * @example
   * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
   * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
   */
  static fromArpa(arpaFormAddress) {
    let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
    const semicolonAmount = 7;
    if (address.length !== 63) {
      throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
    }
    const parts = address.split(".").reverse();
    for (let i2 = semicolonAmount; i2 > 0; i2--) {
      const insertIndex = i2 * 4;
      parts.splice(insertIndex, 0, ":");
    }
    address = parts.join("");
    return new Address6(address);
  }
  /**
   * Return the Microsoft UNC transcription of the address
   * @memberof Address6
   * @instance
   * @returns {String} the Microsoft UNC transcription of the address
   */
  microsoftTranscription() {
    return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
  }
  /**
   * Return the first n bits of the address, defaulting to the subnet mask
   * @memberof Address6
   * @instance
   * @param {number} [mask=subnet] - the number of bits to mask
   * @returns {String} the first n bits of the address as a string
   */
  mask(mask = this.subnetMask) {
    return this.getBitsBase2(0, mask);
  }
  /**
   * Return the number of possible subnets of a given size in the address
   * @memberof Address6
   * @instance
   * @param {number} [size=128] - the subnet size
   * @returns {String}
   */
  // TODO: probably useful to have a numeric version of this too
  possibleSubnets(subnetSize = 128) {
    const availableBits = constants6.BITS - this.subnetMask;
    const subnetBits = Math.abs(subnetSize - constants6.BITS);
    const subnetPowers = availableBits - subnetBits;
    if (subnetPowers < 0) {
      return "0";
    }
    return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
  }
  /**
   * Helper function getting start address.
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  _startAddress() {
    return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
  }
  /**
   * The first address in the range given by this address' subnet
   * Often referred to as the Network Address.
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  startAddress() {
    return Address6.fromBigInteger(this._startAddress());
  }
  /**
   * The first host address in the range given by this address's subnet ie
   * the first address after the Network Address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  startAddressExclusive() {
    const adjust = new jsbn_1.BigInteger("1");
    return Address6.fromBigInteger(this._startAddress().add(adjust));
  }
  /**
   * Helper function getting end address.
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  _endAddress() {
    return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
  }
  /**
   * The last address in the range given by this address' subnet
   * Often referred to as the Broadcast
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  endAddress() {
    return Address6.fromBigInteger(this._endAddress());
  }
  /**
   * The last host address in the range given by this address's subnet ie
   * the last address prior to the Broadcast Address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  endAddressExclusive() {
    const adjust = new jsbn_1.BigInteger("1");
    return Address6.fromBigInteger(this._endAddress().subtract(adjust));
  }
  /**
   * Return the scope of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getScope() {
    let scope2 = constants6.SCOPES[this.getBits(12, 16).intValue()];
    if (this.getType() === "Global unicast" && scope2 !== "Link local") {
      scope2 = "Global";
    }
    return scope2 || "Unknown";
  }
  /**
   * Return the type of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getType() {
    for (const subnet of Object.keys(constants6.TYPES)) {
      if (this.isInSubnet(new Address6(subnet))) {
        return constants6.TYPES[subnet];
      }
    }
    return "Global unicast";
  }
  /**
   * Return the bits in the given range as a BigInteger
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  getBits(start, end) {
    return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
  }
  /**
   * Return the bits in the given range as a base-2 string
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsBase2(start, end) {
    return this.binaryZeroPad().slice(start, end);
  }
  /**
   * Return the bits in the given range as a base-16 string
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsBase16(start, end) {
    const length = end - start;
    if (length % 4 !== 0) {
      throw new Error("Length of bits to retrieve must be divisible by four");
    }
    return this.getBits(start, end).toString(16).padStart(length / 4, "0");
  }
  /**
   * Return the bits that are set past the subnet mask length
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsPastSubnet() {
    return this.getBitsBase2(this.subnetMask, constants6.BITS);
  }
  /**
   * Return the reversed ip6.arpa form of the address
   * @memberof Address6
   * @param {Object} options
   * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
   * @instance
   * @returns {String}
   */
  reverseForm(options) {
    if (!options) {
      options = {};
    }
    const characters = Math.floor(this.subnetMask / 4);
    const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
    if (characters > 0) {
      if (options.omitSuffix) {
        return reversed;
      }
      return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
    }
    if (options.omitSuffix) {
      return "";
    }
    return "ip6.arpa.";
  }
  /**
   * Return the correct form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  correctForm() {
    let i2;
    let groups = [];
    let zeroCounter = 0;
    const zeroes = [];
    for (i2 = 0; i2 < this.parsedAddress.length; i2++) {
      const value = parseInt(this.parsedAddress[i2], 16);
      if (value === 0) {
        zeroCounter++;
      }
      if (value !== 0 && zeroCounter > 0) {
        if (zeroCounter > 1) {
          zeroes.push([i2 - zeroCounter, i2 - 1]);
        }
        zeroCounter = 0;
      }
    }
    if (zeroCounter > 1) {
      zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
    }
    const zeroLengths = zeroes.map((n2) => n2[1] - n2[0] + 1);
    if (zeroes.length > 0) {
      const index2 = zeroLengths.indexOf(Math.max(...zeroLengths));
      groups = compact(this.parsedAddress, zeroes[index2]);
    } else {
      groups = this.parsedAddress;
    }
    for (i2 = 0; i2 < groups.length; i2++) {
      if (groups[i2] !== "compact") {
        groups[i2] = parseInt(groups[i2], 16).toString(16);
      }
    }
    let correct = groups.join(":");
    correct = correct.replace(/^compact$/, "::");
    correct = correct.replace(/^compact|compact$/, ":");
    correct = correct.replace(/compact/, "");
    return correct;
  }
  /**
   * Return a zero-padded base-2 string representation of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   * @example
   * var address = new Address6('2001:4860:4001:803::1011');
   * address.binaryZeroPad();
   * // '0010000000000001010010000110000001000000000000010000100000000011
   * //  0000000000000000000000000000000000000000000000000001000000010001'
   */
  binaryZeroPad() {
    return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
  }
  // TODO: Improve the semantics of this helper function
  parse4in6(address) {
    const groups = address.split(":");
    const lastGroup = groups.slice(-1)[0];
    const address4 = lastGroup.match(constants4.RE_ADDRESS);
    if (address4) {
      this.parsedAddress4 = address4[0];
      this.address4 = new ipv4_1.Address4(this.parsedAddress4);
      for (let i2 = 0; i2 < this.address4.groups; i2++) {
        if (/^0[0-9]+/.test(this.address4.parsedAddress[i2])) {
          throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
        }
      }
      this.v4 = true;
      groups[groups.length - 1] = this.address4.toGroup6();
      address = groups.join(":");
    }
    return address;
  }
  // TODO: Make private?
  parse(address) {
    address = this.parse4in6(address);
    const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
    if (badCharacters) {
      throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
    }
    const badAddress = address.match(constants6.RE_BAD_ADDRESS);
    if (badAddress) {
      throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
    }
    let groups = [];
    const halves = address.split("::");
    if (halves.length === 2) {
      let first2 = halves[0].split(":");
      let last2 = halves[1].split(":");
      if (first2.length === 1 && first2[0] === "") {
        first2 = [];
      }
      if (last2.length === 1 && last2[0] === "") {
        last2 = [];
      }
      const remaining = this.groups - (first2.length + last2.length);
      if (!remaining) {
        throw new address_error_1.AddressError("Error parsing groups");
      }
      this.elidedGroups = remaining;
      this.elisionBegin = first2.length;
      this.elisionEnd = first2.length + this.elidedGroups;
      groups = groups.concat(first2);
      for (let i2 = 0; i2 < remaining; i2++) {
        groups.push("0");
      }
      groups = groups.concat(last2);
    } else if (halves.length === 1) {
      groups = address.split(":");
      this.elidedGroups = 0;
    } else {
      throw new address_error_1.AddressError("Too many :: groups found");
    }
    groups = groups.map((group) => (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)));
    if (groups.length !== this.groups) {
      throw new address_error_1.AddressError("Incorrect number of groups found");
    }
    return groups;
  }
  /**
   * Return the canonical form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  canonicalForm() {
    return this.parsedAddress.map(paddedHex).join(":");
  }
  /**
   * Return the decimal form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  decimal() {
    return this.parsedAddress.map((n2) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n2, 16))).join(":");
  }
  /**
   * Return the address as a BigInteger
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  bigInteger() {
    return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
  }
  /**
   * Return the last two groups of this address as an IPv4 address string
   * @memberof Address6
   * @instance
   * @returns {Address4}
   * @example
   * var address = new Address6('2001:4860:4001::1825:bf11');
   * address.to4().correctForm(); // '24.37.191.17'
   */
  to4() {
    const binary = this.binaryZeroPad().split("");
    return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
  }
  /**
   * Return the v4-in-v6 form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  to4in6() {
    const address4 = this.to4();
    const address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
    const correct = address6.correctForm();
    let infix = "";
    if (!/:$/.test(correct)) {
      infix = ":";
    }
    return correct + infix + address4.address;
  }
  /**
   * Return an object containing the Teredo properties of the address
   * @memberof Address6
   * @instance
   * @returns {Object}
   */
  inspectTeredo() {
    const prefix = this.getBitsBase16(0, 32);
    const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
    const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
    const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
    const flags = this.getBits(64, 80);
    const flagsBase2 = this.getBitsBase2(64, 80);
    const coneNat = flags.testBit(15);
    const reserved = flags.testBit(14);
    const groupIndividual = flags.testBit(8);
    const universalLocal = flags.testBit(9);
    const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
    return {
      prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
      server4: server4.address,
      client4: client4.address,
      flags: flagsBase2,
      coneNat,
      microsoft: {
        reserved,
        universalLocal,
        groupIndividual,
        nonce
      },
      udpPort
    };
  }
  /**
   * Return an object containing the 6to4 properties of the address
   * @memberof Address6
   * @instance
   * @returns {Object}
   */
  inspect6to4() {
    const prefix = this.getBitsBase16(0, 16);
    const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
    return {
      prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
      gateway: gateway.address
    };
  }
  /**
   * Return a v6 6to4 address from a v6 v4inv6 address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  to6to4() {
    if (!this.is4()) {
      return null;
    }
    const addr6to4 = [
      "2002",
      this.getBitsBase16(96, 112),
      this.getBitsBase16(112, 128),
      "",
      "/16"
    ].join(":");
    return new Address6(addr6to4);
  }
  /**
   * Return a byte array
   * @memberof Address6
   * @instance
   * @returns {Array}
   */
  toByteArray() {
    const byteArray = this.bigInteger().toByteArray();
    if (byteArray.length === 17 && byteArray[0] === 0) {
      return byteArray.slice(1);
    }
    return byteArray;
  }
  /**
   * Return an unsigned byte array
   * @memberof Address6
   * @instance
   * @returns {Array}
   */
  toUnsignedByteArray() {
    return this.toByteArray().map(unsignByte);
  }
  /**
   * Convert a byte array to an Address6 object
   * @memberof Address6
   * @static
   * @returns {Address6}
   */
  static fromByteArray(bytes) {
    return this.fromUnsignedByteArray(bytes.map(unsignByte));
  }
  /**
   * Convert an unsigned byte array to an Address6 object
   * @memberof Address6
   * @static
   * @returns {Address6}
   */
  static fromUnsignedByteArray(bytes) {
    const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
    let result = new jsbn_1.BigInteger("0", 10);
    let multiplier = new jsbn_1.BigInteger("1", 10);
    for (let i2 = bytes.length - 1; i2 >= 0; i2--) {
      result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i2].toString(10), 10)));
      multiplier = multiplier.multiply(BYTE_MAX);
    }
    return Address6.fromBigInteger(result);
  }
  /**
   * Returns true if the address is in the canonical form, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isCanonical() {
    return this.addressMinusSuffix === this.canonicalForm();
  }
  /**
   * Returns true if the address is a link local address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isLinkLocal() {
    if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
      return true;
    }
    return false;
  }
  /**
   * Returns true if the address is a multicast address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isMulticast() {
    return this.getType() === "Multicast";
  }
  /**
   * Returns true if the address is a v4-in-v6 address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  is4() {
    return this.v4;
  }
  /**
   * Returns true if the address is a Teredo address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isTeredo() {
    return this.isInSubnet(new Address6("2001::/32"));
  }
  /**
   * Returns true if the address is a 6to4 address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  is6to4() {
    return this.isInSubnet(new Address6("2002::/16"));
  }
  /**
   * Returns true if the address is a loopback address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isLoopback() {
    return this.getType() === "Loopback";
  }
  // #endregion
  // #region HTML
  /**
   * @returns {String} the address in link form with a default port of 80
   */
  href(optionalPort) {
    if (optionalPort === void 0) {
      optionalPort = "";
    } else {
      optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
    }
    return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
  }
  /**
   * @returns {String} a link suitable for conveying the address via a URL hash
   */
  link(options) {
    if (!options) {
      options = {};
    }
    if (options.className === void 0) {
      options.className = "";
    }
    if (options.prefix === void 0) {
      options.prefix = "/#address=";
    }
    if (options.v4 === void 0) {
      options.v4 = false;
    }
    let formFunction = this.correctForm;
    if (options.v4) {
      formFunction = this.to4in6;
    }
    if (options.className) {
      return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
    }
    return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
  }
  /**
   * Groups an address
   * @returns {String}
   */
  group() {
    if (this.elidedGroups === 0) {
      return helpers$1.simpleGroup(this.address).join(":");
    }
    assert(typeof this.elidedGroups === "number");
    assert(typeof this.elisionBegin === "number");
    const output = [];
    const [left2, right2] = this.address.split("::");
    if (left2.length) {
      output.push(...helpers$1.simpleGroup(left2));
    } else {
      output.push("");
    }
    const classes = ["hover-group"];
    for (let i2 = this.elisionBegin; i2 < this.elisionBegin + this.elidedGroups; i2++) {
      classes.push((0, sprintf_js_1.sprintf)("group-%d", i2));
    }
    output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
    if (right2.length) {
      output.push(...helpers$1.simpleGroup(right2, this.elisionEnd));
    } else {
      output.push("");
    }
    if (this.is4()) {
      assert(this.address4 instanceof ipv4_1.Address4);
      output.pop();
      output.push(this.address4.groupForV6());
    }
    return output.join(":");
  }
  // #endregion
  // #region Regular expressions
  /**
   * Generate a regular expression string that can be used to find or validate
   * all variations of this address
   * @memberof Address6
   * @instance
   * @param {boolean} substringSearch
   * @returns {string}
   */
  regularExpressionString(substringSearch = false) {
    let output = [];
    const address6 = new Address6(this.correctForm());
    if (address6.elidedGroups === 0) {
      output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
    } else if (address6.elidedGroups === constants6.GROUPS) {
      output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
    } else {
      const halves = address6.address.split("::");
      if (halves[0].length) {
        output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
      }
      assert(typeof address6.elidedGroups === "number");
      output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
      if (halves[1].length) {
        output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
      }
      output = [output.join(":")];
    }
    if (!substringSearch) {
      output = [
        "(?=^|",
        regular_expressions_1.ADDRESS_BOUNDARY,
        "|[^\\w\\:])(",
        ...output,
        ")(?=[^\\w\\:]|",
        regular_expressions_1.ADDRESS_BOUNDARY,
        "|$)"
      ];
    }
    return output.join("");
  }
  /**
   * Generate a regular expression that can be used to find or validate all
   * variations of this address.
   * @memberof Address6
   * @instance
   * @param {boolean} substringSearch
   * @returns {RegExp}
   */
  regularExpression(substringSearch = false) {
    return new RegExp(this.regularExpressionString(substringSearch), "i");
  }
}
ipv6.Address6 = Address6;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
  const ipv4_12 = ipv4;
  Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
    return ipv4_12.Address4;
  } });
  const ipv6_1 = ipv6;
  Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
    return ipv6_1.Address6;
  } });
  const address_error_12 = addressError;
  Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
    return address_error_12.AddressError;
  } });
  const helpers2 = __importStar2(helpers$2);
  exports2.v6 = { helpers: helpers2 };
})(ipAddress);
Object.defineProperty(helpers$3, "__esModule", { value: true });
helpers$3.ipToBuffer = helpers$3.int32ToIpv4 = helpers$3.ipv4ToInt32 = helpers$3.validateSocksClientChainOptions = helpers$3.validateSocksClientOptions = void 0;
const util_1$7 = util$6;
const constants_1 = constants$6;
const stream$2 = require$$0$5;
const ip_address_1 = ipAddress;
const net$4 = require$$0$1;
function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
  if (!constants_1.SocksCommand[options.command]) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
  }
  if (acceptedCommands.indexOf(options.command) === -1) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
  }
  if (!isValidSocksRemoteHost(options.destination)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
  }
  if (!isValidSocksProxy(options.proxy)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
  }
  validateCustomProxyAuth(options.proxy, options);
  if (options.timeout && !isValidTimeoutValue(options.timeout)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
  }
  if (options.existing_socket && !(options.existing_socket instanceof stream$2.Duplex)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
  }
}
helpers$3.validateSocksClientOptions = validateSocksClientOptions;
function validateSocksClientChainOptions(options) {
  if (options.command !== "connect") {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
  }
  if (!isValidSocksRemoteHost(options.destination)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
  }
  if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
  }
  options.proxies.forEach((proxy) => {
    if (!isValidSocksProxy(proxy)) {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
    }
    validateCustomProxyAuth(proxy, options);
  });
  if (options.timeout && !isValidTimeoutValue(options.timeout)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
  }
}
helpers$3.validateSocksClientChainOptions = validateSocksClientChainOptions;
function validateCustomProxyAuth(proxy, options) {
  if (proxy.custom_auth_method !== void 0) {
    if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
    }
    if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
    }
    if (proxy.custom_auth_response_size === void 0) {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
    }
    if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
    }
  }
}
function isValidSocksRemoteHost(remoteHost) {
  return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
}
function isValidSocksProxy(proxy) {
  return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
}
function isValidTimeoutValue(value) {
  return typeof value === "number" && value > 0;
}
function ipv4ToInt32(ip2) {
  const address = new ip_address_1.Address4(ip2);
  return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
}
helpers$3.ipv4ToInt32 = ipv4ToInt32;
function int32ToIpv4(int32) {
  const octet1 = int32 >>> 24 & 255;
  const octet2 = int32 >>> 16 & 255;
  const octet3 = int32 >>> 8 & 255;
  const octet4 = int32 & 255;
  return [octet1, octet2, octet3, octet4].join(".");
}
helpers$3.int32ToIpv4 = int32ToIpv4;
function ipToBuffer(ip2) {
  if (net$4.isIPv4(ip2)) {
    const address = new ip_address_1.Address4(ip2);
    return Buffer.from(address.toArray());
  } else if (net$4.isIPv6(ip2)) {
    const address = new ip_address_1.Address6(ip2);
    return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
  } else {
    throw new Error("Invalid IP address format");
  }
}
helpers$3.ipToBuffer = ipToBuffer;
var receivebuffer = {};
Object.defineProperty(receivebuffer, "__esModule", { value: true });
receivebuffer.ReceiveBuffer = void 0;
class ReceiveBuffer {
  constructor(size = 4096) {
    this.buffer = Buffer.allocUnsafe(size);
    this.offset = 0;
    this.originalSize = size;
  }
  get length() {
    return this.offset;
  }
  append(data2) {
    if (!Buffer.isBuffer(data2)) {
      throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
    }
    if (this.offset + data2.length >= this.buffer.length) {
      const tmp = this.buffer;
      this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data2.length));
      tmp.copy(this.buffer);
    }
    data2.copy(this.buffer, this.offset);
    return this.offset += data2.length;
  }
  peek(length) {
    if (length > this.offset) {
      throw new Error("Attempted to read beyond the bounds of the managed internal data.");
    }
    return this.buffer.slice(0, length);
  }
  get(length) {
    if (length > this.offset) {
      throw new Error("Attempted to read beyond the bounds of the managed internal data.");
    }
    const value = Buffer.allocUnsafe(length);
    this.buffer.slice(0, length).copy(value);
    this.buffer.copyWithin(0, length, length + this.offset - length);
    this.offset -= length;
    return value;
  }
}
receivebuffer.ReceiveBuffer = ReceiveBuffer;
(function(exports2) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SocksClientError = exports2.SocksClient = void 0;
  const events_12 = require$$3$2;
  const net2 = require$$0$1;
  const smart_buffer_1 = smartbuffer;
  const constants_12 = constants$6;
  const helpers_1 = helpers$3;
  const receivebuffer_1 = receivebuffer;
  const util_12 = util$6;
  Object.defineProperty(exports2, "SocksClientError", { enumerable: true, get: function() {
    return util_12.SocksClientError;
  } });
  const ip_address_12 = ipAddress;
  class SocksClient extends events_12.EventEmitter {
    constructor(options) {
      super();
      this.options = Object.assign({}, options);
      (0, helpers_1.validateSocksClientOptions)(options);
      this.setState(constants_12.SocksClientState.Created);
    }
    /**
     * Creates a new SOCKS connection.
     *
     * Note: Supports callbacks and promises. Only supports the connect command.
     * @param options { SocksClientOptions } Options.
     * @param callback { Function } An optional callback function.
     * @returns { Promise }
     */
    static createConnection(options, callback) {
      return new Promise((resolve2, reject) => {
        try {
          (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            return resolve2(err);
          } else {
            return reject(err);
          }
        }
        const client = new SocksClient(options);
        client.connect(options.existing_socket);
        client.once("established", (info) => {
          client.removeAllListeners();
          if (typeof callback === "function") {
            callback(null, info);
            resolve2(info);
          } else {
            resolve2(info);
          }
        });
        client.once("error", (err) => {
          client.removeAllListeners();
          if (typeof callback === "function") {
            callback(err);
            resolve2(err);
          } else {
            reject(err);
          }
        });
      });
    }
    /**
     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
     *
     * Note: Supports callbacks and promises. Only supports the connect method.
     * Note: Implemented via createConnection() factory function.
     * @param options { SocksClientChainOptions } Options
     * @param callback { Function } An optional callback function.
     * @returns { Promise }
     */
    static createConnectionChain(options, callback) {
      return new Promise((resolve2, reject) => __awaiter2(this, void 0, void 0, function* () {
        try {
          (0, helpers_1.validateSocksClientChainOptions)(options);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            return resolve2(err);
          } else {
            return reject(err);
          }
        }
        if (options.randomizeChain) {
          (0, util_12.shuffleArray)(options.proxies);
        }
        try {
          let sock;
          for (let i2 = 0; i2 < options.proxies.length; i2++) {
            const nextProxy = options.proxies[i2];
            const nextDestination = i2 === options.proxies.length - 1 ? options.destination : {
              host: options.proxies[i2 + 1].host || options.proxies[i2 + 1].ipaddress,
              port: options.proxies[i2 + 1].port
            };
            const result = yield SocksClient.createConnection({
              command: "connect",
              proxy: nextProxy,
              destination: nextDestination,
              existing_socket: sock
            });
            sock = sock || result.socket;
          }
          if (typeof callback === "function") {
            callback(null, { socket: sock });
            resolve2({ socket: sock });
          } else {
            resolve2({ socket: sock });
          }
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            resolve2(err);
          } else {
            reject(err);
          }
        }
      }));
    }
    /**
     * Creates a SOCKS UDP Frame.
     * @param options
     */
    static createUDPFrame(options) {
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt16BE(0);
      buff.writeUInt8(options.frameNumber || 0);
      if (net2.isIPv4(options.remoteHost.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv4);
        buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
      } else if (net2.isIPv6(options.remoteHost.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
      } else {
        buff.writeUInt8(constants_12.Socks5HostType.Hostname);
        buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
        buff.writeString(options.remoteHost.host);
      }
      buff.writeUInt16BE(options.remoteHost.port);
      buff.writeBuffer(options.data);
      return buff.toBuffer();
    }
    /**
     * Parses a SOCKS UDP frame.
     * @param data
     */
    static parseUDPFrame(data2) {
      const buff = smart_buffer_1.SmartBuffer.fromBuffer(data2);
      buff.readOffset = 2;
      const frameNumber = buff.readUInt8();
      const hostType = buff.readUInt8();
      let remoteHost;
      if (hostType === constants_12.Socks5HostType.IPv4) {
        remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
      } else if (hostType === constants_12.Socks5HostType.IPv6) {
        remoteHost = ip_address_12.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
      } else {
        remoteHost = buff.readString(buff.readUInt8());
      }
      const remotePort = buff.readUInt16BE();
      return {
        frameNumber,
        remoteHost: {
          host: remoteHost,
          port: remotePort
        },
        data: buff.readBuffer()
      };
    }
    /**
     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
     */
    setState(newState) {
      if (this.state !== constants_12.SocksClientState.Error) {
        this.state = newState;
      }
    }
    /**
     * Starts the connection establishment to the proxy and destination.
     * @param existingSocket Connected socket to use instead of creating a new one (internal use).
     */
    connect(existingSocket) {
      this.onDataReceived = (data2) => this.onDataReceivedHandler(data2);
      this.onClose = () => this.onCloseHandler();
      this.onError = (err) => this.onErrorHandler(err);
      this.onConnect = () => this.onConnectHandler();
      const timer2 = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_12.DEFAULT_TIMEOUT);
      if (timer2.unref && typeof timer2.unref === "function") {
        timer2.unref();
      }
      if (existingSocket) {
        this.socket = existingSocket;
      } else {
        this.socket = new net2.Socket();
      }
      this.socket.once("close", this.onClose);
      this.socket.once("error", this.onError);
      this.socket.once("connect", this.onConnect);
      this.socket.on("data", this.onDataReceived);
      this.setState(constants_12.SocksClientState.Connecting);
      this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
      if (existingSocket) {
        this.socket.emit("connect");
      } else {
        this.socket.connect(this.getSocketOptions());
        if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
          this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
        }
      }
      this.prependOnceListener("established", (info) => {
        setImmediate(() => {
          if (this.receiveBuffer.length > 0) {
            const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
            info.socket.emit("data", excessData);
          }
          info.socket.resume();
        });
      });
    }
    // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
    getSocketOptions() {
      return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
    }
    /**
     * Handles internal Socks timeout callback.
     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
     */
    onEstablishedTimeout() {
      if (this.state !== constants_12.SocksClientState.Established && this.state !== constants_12.SocksClientState.BoundWaitingForConnection) {
        this.closeSocket(constants_12.ERRORS.ProxyConnectionTimedOut);
      }
    }
    /**
     * Handles Socket connect event.
     */
    onConnectHandler() {
      this.setState(constants_12.SocksClientState.Connected);
      if (this.options.proxy.type === 4) {
        this.sendSocks4InitialHandshake();
      } else {
        this.sendSocks5InitialHandshake();
      }
      this.setState(constants_12.SocksClientState.SentInitialHandshake);
    }
    /**
     * Handles Socket data event.
     * @param data
     */
    onDataReceivedHandler(data2) {
      this.receiveBuffer.append(data2);
      this.processData();
    }
    /**
     * Handles processing of the data we have received.
     */
    processData() {
      while (this.state !== constants_12.SocksClientState.Established && this.state !== constants_12.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
        if (this.state === constants_12.SocksClientState.SentInitialHandshake) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4FinalHandshakeResponse();
          } else {
            this.handleInitialSocks5HandshakeResponse();
          }
        } else if (this.state === constants_12.SocksClientState.SentAuthentication) {
          this.handleInitialSocks5AuthenticationHandshakeResponse();
        } else if (this.state === constants_12.SocksClientState.SentFinalHandshake) {
          this.handleSocks5FinalHandshakeResponse();
        } else if (this.state === constants_12.SocksClientState.BoundWaitingForConnection) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4IncomingConnectionResponse();
          } else {
            this.handleSocks5IncomingConnectionResponse();
          }
        } else {
          this.closeSocket(constants_12.ERRORS.InternalError);
          break;
        }
      }
    }
    /**
     * Handles Socket close event.
     * @param had_error
     */
    onCloseHandler() {
      this.closeSocket(constants_12.ERRORS.SocketClosed);
    }
    /**
     * Handles Socket error event.
     * @param err
     */
    onErrorHandler(err) {
      this.closeSocket(err.message);
    }
    /**
     * Removes internal event listeners on the underlying Socket.
     */
    removeInternalSocketHandlers() {
      this.socket.pause();
      this.socket.removeListener("data", this.onDataReceived);
      this.socket.removeListener("close", this.onClose);
      this.socket.removeListener("error", this.onError);
      this.socket.removeListener("connect", this.onConnect);
    }
    /**
     * Closes and destroys the underlying Socket. Emits an error event.
     * @param err { String } An error string to include in error event.
     */
    closeSocket(err) {
      if (this.state !== constants_12.SocksClientState.Error) {
        this.setState(constants_12.SocksClientState.Error);
        this.socket.destroy();
        this.removeInternalSocketHandlers();
        this.emit("error", new util_12.SocksClientError(err, this.options));
      }
    }
    /**
     * Sends initial Socks v4 handshake request.
     */
    sendSocks4InitialHandshake() {
      const userId = this.options.proxy.userId || "";
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(4);
      buff.writeUInt8(constants_12.SocksCommand[this.options.command]);
      buff.writeUInt16BE(this.options.destination.port);
      if (net2.isIPv4(this.options.destination.host)) {
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        buff.writeStringNT(userId);
      } else {
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(1);
        buff.writeStringNT(userId);
        buff.writeStringNT(this.options.destination.host);
      }
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
      this.socket.write(buff.toBuffer());
    }
    /**
     * Handles Socks v4 handshake response.
     * @param data
     */
    handleSocks4FinalHandshakeResponse() {
      const data2 = this.receiveBuffer.get(8);
      if (data2[1] !== constants_12.Socks4Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.Socks4ProxyRejectedConnection} - (${constants_12.Socks4Response[data2[1]]})`);
      } else {
        if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.bind) {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data2);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
          this.setState(constants_12.SocksClientState.BoundWaitingForConnection);
          this.emit("bound", { remoteHost, socket: this.socket });
        } else {
          this.setState(constants_12.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { socket: this.socket });
        }
      }
    }
    /**
     * Handles Socks v4 incoming connection request (BIND)
     * @param data
     */
    handleSocks4IncomingConnectionResponse() {
      const data2 = this.receiveBuffer.get(8);
      if (data2[1] !== constants_12.Socks4Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_12.Socks4Response[data2[1]]})`);
      } else {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data2);
        buff.readOffset = 2;
        const remoteHost = {
          port: buff.readUInt16BE(),
          host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
        };
        this.setState(constants_12.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    /**
     * Sends initial Socks v5 handshake request.
     */
    sendSocks5InitialHandshake() {
      const buff = new smart_buffer_1.SmartBuffer();
      const supportedAuthMethods = [constants_12.Socks5Auth.NoAuth];
      if (this.options.proxy.userId || this.options.proxy.password) {
        supportedAuthMethods.push(constants_12.Socks5Auth.UserPass);
      }
      if (this.options.proxy.custom_auth_method !== void 0) {
        supportedAuthMethods.push(this.options.proxy.custom_auth_method);
      }
      buff.writeUInt8(5);
      buff.writeUInt8(supportedAuthMethods.length);
      for (const authMethod of supportedAuthMethods) {
        buff.writeUInt8(authMethod);
      }
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_12.SocksClientState.SentInitialHandshake);
    }
    /**
     * Handles initial Socks v5 handshake response.
     * @param data
     */
    handleInitialSocks5HandshakeResponse() {
      const data2 = this.receiveBuffer.get(2);
      if (data2[0] !== 5) {
        this.closeSocket(constants_12.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
      } else if (data2[1] === constants_12.SOCKS5_NO_ACCEPTABLE_AUTH) {
        this.closeSocket(constants_12.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
      } else {
        if (data2[1] === constants_12.Socks5Auth.NoAuth) {
          this.socks5ChosenAuthType = constants_12.Socks5Auth.NoAuth;
          this.sendSocks5CommandRequest();
        } else if (data2[1] === constants_12.Socks5Auth.UserPass) {
          this.socks5ChosenAuthType = constants_12.Socks5Auth.UserPass;
          this.sendSocks5UserPassAuthentication();
        } else if (data2[1] === this.options.proxy.custom_auth_method) {
          this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
          this.sendSocks5CustomAuthentication();
        } else {
          this.closeSocket(constants_12.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
        }
      }
    }
    /**
     * Sends Socks v5 user & password auth handshake.
     *
     * Note: No auth and user/pass are currently supported.
     */
    sendSocks5UserPassAuthentication() {
      const userId = this.options.proxy.userId || "";
      const password = this.options.proxy.password || "";
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(1);
      buff.writeUInt8(Buffer.byteLength(userId));
      buff.writeString(userId);
      buff.writeUInt8(Buffer.byteLength(password));
      buff.writeString(password);
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_12.SocksClientState.SentAuthentication);
    }
    sendSocks5CustomAuthentication() {
      return __awaiter2(this, void 0, void 0, function* () {
        this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
        this.socket.write(yield this.options.proxy.custom_auth_request_handler());
        this.setState(constants_12.SocksClientState.SentAuthentication);
      });
    }
    handleSocks5CustomAuthHandshakeResponse(data2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return yield this.options.proxy.custom_auth_response_handler(data2);
      });
    }
    handleSocks5AuthenticationNoAuthHandshakeResponse(data2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return data2[1] === 0;
      });
    }
    handleSocks5AuthenticationUserPassHandshakeResponse(data2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return data2[1] === 0;
      });
    }
    /**
     * Handles Socks v5 auth handshake response.
     * @param data
     */
    handleInitialSocks5AuthenticationHandshakeResponse() {
      return __awaiter2(this, void 0, void 0, function* () {
        this.setState(constants_12.SocksClientState.ReceivedAuthenticationResponse);
        let authResult = false;
        if (this.socks5ChosenAuthType === constants_12.Socks5Auth.NoAuth) {
          authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === constants_12.Socks5Auth.UserPass) {
          authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
          authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
        }
        if (!authResult) {
          this.closeSocket(constants_12.ERRORS.Socks5AuthenticationFailed);
        } else {
          this.sendSocks5CommandRequest();
        }
      });
    }
    /**
     * Sends Socks v5 final handshake request.
     */
    sendSocks5CommandRequest() {
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(5);
      buff.writeUInt8(constants_12.SocksCommand[this.options.command]);
      buff.writeUInt8(0);
      if (net2.isIPv4(this.options.destination.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv4);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else if (net2.isIPv6(this.options.destination.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else {
        buff.writeUInt8(constants_12.Socks5HostType.Hostname);
        buff.writeUInt8(this.options.destination.host.length);
        buff.writeString(this.options.destination.host);
      }
      buff.writeUInt16BE(this.options.destination.port);
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
      this.socket.write(buff.toBuffer());
      this.setState(constants_12.SocksClientState.SentFinalHandshake);
    }
    /**
     * Handles Socks v5 final handshake response.
     * @param data
     */
    handleSocks5FinalHandshakeResponse() {
      const header = this.receiveBuffer.peek(5);
      if (header[0] !== 5 || header[1] !== constants_12.Socks5Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_12.Socks5Response[header[1]]}`);
      } else {
        const addressType = header[3];
        let remoteHost;
        let buff;
        if (addressType === constants_12.Socks5HostType.IPv4) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_12.Socks5HostType.Hostname) {
          const hostLength = header[4];
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_12.Socks5HostType.IPv6) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip_address_12.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_12.SocksClientState.ReceivedFinalResponse);
        if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.connect) {
          this.setState(constants_12.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        } else if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.bind) {
          this.setState(constants_12.SocksClientState.BoundWaitingForConnection);
          this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
          this.emit("bound", { remoteHost, socket: this.socket });
        } else if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.associate) {
          this.setState(constants_12.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", {
            remoteHost,
            socket: this.socket
          });
        }
      }
    }
    /**
     * Handles Socks v5 incoming connection request (BIND).
     */
    handleSocks5IncomingConnectionResponse() {
      const header = this.receiveBuffer.peek(5);
      if (header[0] !== 5 || header[1] !== constants_12.Socks5Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_12.Socks5Response[header[1]]}`);
      } else {
        const addressType = header[3];
        let remoteHost;
        let buff;
        if (addressType === constants_12.Socks5HostType.IPv4) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_12.Socks5HostType.Hostname) {
          const hostLength = header[4];
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_12.Socks5HostType.IPv6) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip_address_12.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_12.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    get socksClientOptions() {
      return Object.assign({}, this.options);
    }
  }
  exports2.SocksClient = SocksClient;
})(socksclient);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar2(socksclient, exports2);
})(build$3);
var dist$8 = {};
var helpers = {};
var __createBinding$6 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$6 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$6(result, mod, k2);
  }
  __setModuleDefault$6(result, mod);
  return result;
};
Object.defineProperty(helpers, "__esModule", { value: true });
helpers.req = helpers.json = helpers.toBuffer = void 0;
const http$1 = __importStar$6(require$$0$2);
const https$2 = __importStar$6(require$$1);
async function toBuffer$1(stream2) {
  let length = 0;
  const chunks = [];
  for await (const chunk of stream2) {
    length += chunk.length;
    chunks.push(chunk);
  }
  return Buffer.concat(chunks, length);
}
helpers.toBuffer = toBuffer$1;
async function json$1(stream2) {
  const buf = await toBuffer$1(stream2);
  const str = buf.toString("utf8");
  try {
    return JSON.parse(str);
  } catch (_err) {
    const err = _err;
    err.message += ` (input: ${str})`;
    throw err;
  }
}
helpers.json = json$1;
function req(url, opts = {}) {
  const href = typeof url === "string" ? url : url.href;
  const req2 = (href.startsWith("https:") ? https$2 : http$1).request(url, opts);
  const promise = new Promise((resolve2, reject) => {
    req2.once("response", resolve2).once("error", reject).end();
  });
  req2.then = promise.then.bind(promise);
  return req2;
}
helpers.req = req;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Agent = void 0;
  const net2 = __importStar2(require$$0$1);
  const http2 = __importStar2(require$$0$2);
  const https_12 = require$$1;
  __exportStar2(helpers, exports2);
  const INTERNAL = Symbol("AgentBaseInternalState");
  class Agent extends http2.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name2) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name2]) {
        this.sockets[name2] = [];
      }
      const fakeSocket = new net2.Socket({ writable: false });
      this.sockets[name2].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name2, socket) {
      if (!this.sockets[name2] || socket === null) {
        return;
      }
      const sockets = this.sockets[name2];
      const index2 = sockets.indexOf(socket);
      if (index2 !== -1) {
        sockets.splice(index2, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name2];
        }
      }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_12.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req2, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name2 = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name2);
      Promise.resolve().then(() => this.connect(req2, connectOpts)).then((socket) => {
        this.decrementSockets(name2, fakeSocket);
        if (socket instanceof http2.Agent) {
          return socket.addRequest(req2, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req2, options, cb);
      }, (err) => {
        this.decrementSockets(name2, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = void 0;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v2;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v2;
      }
    }
  }
  exports2.Agent = Agent;
})(dist$8);
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$5(result, mod, k2);
  }
  __setModuleDefault$5(result, mod);
  return result;
};
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$9, "__esModule", { value: true });
dist$9.SocksProxyAgent = void 0;
const socks_1 = build$3;
const agent_base_1$3 = dist$8;
const debug_1$8 = __importDefault$a(srcExports);
const dns = __importStar$5(require$$3$3);
const net$3 = __importStar$5(require$$0$1);
const tls$3 = __importStar$5(require$$1$1);
const url_1$4 = require$$5$1;
const debug$9 = (0, debug_1$8.default)("socks-proxy-agent");
function parseSocksURL(url) {
  let lookup = false;
  let type = 5;
  const host = url.hostname;
  const port = parseInt(url.port, 10) || 1080;
  switch (url.protocol.replace(":", "")) {
    case "socks4":
      lookup = true;
      type = 4;
      break;
    case "socks4a":
      type = 4;
      break;
    case "socks5":
      lookup = true;
      type = 5;
      break;
    case "socks":
      type = 5;
      break;
    case "socks5h":
      type = 5;
      break;
    default:
      throw new TypeError(`A "socks" protocol must be specified! Got: ${String(url.protocol)}`);
  }
  const proxy = {
    host,
    port,
    type
  };
  if (url.username) {
    Object.defineProperty(proxy, "userId", {
      value: decodeURIComponent(url.username),
      enumerable: false
    });
  }
  if (url.password != null) {
    Object.defineProperty(proxy, "password", {
      value: decodeURIComponent(url.password),
      enumerable: false
    });
  }
  return { lookup, proxy };
}
class SocksProxyAgent extends agent_base_1$3.Agent {
  constructor(uri, opts) {
    super(opts);
    const url = typeof uri === "string" ? new url_1$4.URL(uri) : uri;
    const { proxy, lookup } = parseSocksURL(url);
    this.shouldLookup = lookup;
    this.proxy = proxy;
    this.timeout = (opts == null ? void 0 : opts.timeout) ?? null;
    this.socketOptions = (opts == null ? void 0 : opts.socketOptions) ?? null;
  }
  /**
   * Initiates a SOCKS connection to the specified SOCKS proxy server,
   * which in turn connects to the specified remote host and port.
   */
  async connect(req2, opts) {
    const { shouldLookup, proxy, timeout: timeout2 } = this;
    if (!opts.host) {
      throw new Error("No `host` defined!");
    }
    let { host } = opts;
    const { port, lookup: lookupFn = dns.lookup } = opts;
    if (shouldLookup) {
      host = await new Promise((resolve2, reject) => {
        lookupFn(host, {}, (err, res) => {
          if (err) {
            reject(err);
          } else {
            resolve2(res);
          }
        });
      });
    }
    const socksOpts = {
      proxy,
      destination: {
        host,
        port: typeof port === "number" ? port : parseInt(port, 10)
      },
      command: "connect",
      timeout: timeout2 ?? void 0,
      // @ts-expect-error the type supplied by socks for socket_options is wider
      // than necessary since socks will always override the host and port
      socket_options: this.socketOptions ?? void 0
    };
    const cleanup = (tlsSocket) => {
      req2.destroy();
      socket.destroy();
      if (tlsSocket)
        tlsSocket.destroy();
    };
    debug$9("Creating socks proxy connection: %o", socksOpts);
    const { socket } = await socks_1.SocksClient.createConnection(socksOpts);
    debug$9("Successfully created socks proxy connection");
    if (timeout2 !== null) {
      socket.setTimeout(timeout2);
      socket.on("timeout", () => cleanup());
    }
    if (opts.secureEndpoint) {
      debug$9("Upgrading socket connection to TLS");
      const servername = opts.servername || opts.host;
      const tlsSocket = tls$3.connect({
        ...omit$2(opts, "host", "path", "port"),
        socket,
        servername: net$3.isIP(servername) ? void 0 : servername
      });
      tlsSocket.once("error", (error) => {
        debug$9("Socket TLS error", error.message);
        cleanup(tlsSocket);
      });
      return tlsSocket;
    }
    return socket;
  }
}
SocksProxyAgent.protocols = [
  "socks",
  "socks4",
  "socks4a",
  "socks5",
  "socks5h"
];
dist$9.SocksProxyAgent = SocksProxyAgent;
function omit$2(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var dist$7 = {};
var data$1 = {};
var dist$6 = {};
var common = {};
Object.defineProperty(common, "__esModule", { value: true });
common.makeDataUriToBuffer = void 0;
const makeDataUriToBuffer = (convert) => (uri) => {
  uri = String(uri);
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base642 = true;
    } else if (meta[i2]) {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const data2 = unescape(uri.substring(firstComma + 1));
  const buffer = base642 ? convert.base64ToArrayBuffer(data2) : convert.stringToBuffer(data2);
  return {
    type,
    typeFull,
    charset,
    buffer
  };
};
common.makeDataUriToBuffer = makeDataUriToBuffer;
Object.defineProperty(dist$6, "__esModule", { value: true });
dist$6.dataUriToBuffer = void 0;
const common_1 = common;
function base64ToArrayBuffer(base642) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const bytes = [];
  for (let i2 = 0; i2 < base642.length; i2 += 4) {
    const idx0 = chars.indexOf(base642.charAt(i2));
    const idx1 = chars.indexOf(base642.charAt(i2 + 1));
    const idx2 = base642.charAt(i2 + 2) === "=" ? 0 : chars.indexOf(base642.charAt(i2 + 2));
    const idx3 = base642.charAt(i2 + 3) === "=" ? 0 : chars.indexOf(base642.charAt(i2 + 3));
    const bin0 = idx0 << 2 | idx1 >> 4;
    const bin1 = (idx1 & 15) << 4 | idx2 >> 2;
    const bin2 = (idx2 & 3) << 6 | idx3;
    bytes.push(bin0);
    if (base642.charAt(i2 + 2) !== "=")
      bytes.push(bin1);
    if (base642.charAt(i2 + 3) !== "=")
      bytes.push(bin2);
  }
  const buffer = new ArrayBuffer(bytes.length);
  const view = new Uint8Array(buffer);
  view.set(bytes);
  return buffer;
}
function stringToBuffer(str) {
  const buffer = new ArrayBuffer(str.length);
  const view = new Uint8Array(buffer);
  for (let i2 = 0; i2 < str.length; i2++) {
    view[i2] = str.charCodeAt(i2);
  }
  return buffer;
}
dist$6.dataUriToBuffer = (0, common_1.makeDataUriToBuffer)({ stringToBuffer, base64ToArrayBuffer });
var notmodified = {};
Object.defineProperty(notmodified, "__esModule", { value: true });
class NotModifiedError extends Error {
  constructor(message2) {
    super(message2 || 'Source has not been modified since the provied "cache", re-use previous results');
    this.code = "ENOTMODIFIED";
  }
}
notmodified.default = NotModifiedError;
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(data$1, "__esModule", { value: true });
data$1.data = void 0;
const debug_1$7 = __importDefault$9(srcExports);
const stream_1$3 = require$$0$5;
const crypto_1 = require$$2$1;
const data_uri_to_buffer_1 = dist$6;
const notmodified_1$2 = __importDefault$9(notmodified);
const debug$8 = (0, debug_1$7.default)("get-uri:data");
class DataReadable extends stream_1$3.Readable {
  constructor(hash, buf) {
    super();
    this.push(buf);
    this.push(null);
    this.hash = hash;
  }
}
const data = async ({ href: uri }, { cache } = {}) => {
  const shasum = (0, crypto_1.createHash)("sha1");
  shasum.update(uri);
  const hash = shasum.digest("hex");
  debug$8('generated SHA1 hash for "data:" URI: %o', hash);
  if ((cache == null ? void 0 : cache.hash) === hash) {
    debug$8("got matching cache SHA1 hash: %o", hash);
    throw new notmodified_1$2.default();
  } else {
    debug$8('creating Readable stream from "data:" URI buffer');
    const { buffer } = (0, data_uri_to_buffer_1.dataUriToBuffer)(uri);
    return new DataReadable(hash, Buffer.from(buffer));
  }
};
data$1.data = data;
var file$2 = {};
var fs$m = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        args.push((err, res) => err != null ? reject(err) : resolve2(res));
        fn.apply(this, args);
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else {
      args.pop();
      fn.apply(this, args).then((r2) => cb(null, r2), cb);
    }
  }, "name", { value: fn.name });
};
var constants$2 = require$$0$6;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d2) {
    cwd = null;
    chdir.call(process, d2);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$1;
function patch$1(fs2) {
  if (constants$2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (fs2.chown && !fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
      function rename2(from2, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from2, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st2) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from2, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(rename2, fs$rename);
      return rename2;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _2, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs22) {
    fs22.lchmod = function(path2, mode, callback) {
      fs22.open(
        path2,
        constants$2.O_WRONLY | constants$2.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs22.fchmod(fd, mode, function(err2) {
            fs22.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        }
      );
    };
    fs22.lchmodSync = function(path2, mode) {
      var fd = fs22.openSync(path2, constants$2.O_WRONLY | constants$2.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs22.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs22.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs22.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs22) {
    if (constants$2.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
      fs22.lutimes = function(path2, at2, mt2, cb) {
        fs22.open(path2, constants$2.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs22.futimes(fd, at2, mt2, function(er2) {
            fs22.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs22.lutimesSync = function(path2, at2, mt2) {
        var fd = fs22.openSync(path2, constants$2.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs22.futimesSync(fd, at2, mt2);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    } else if (fs22.futimes) {
      fs22.lutimes = function(_a3, _b3, _c3, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs22.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats) {
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
      }
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0$5.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream: ReadStream2,
    WriteStream: WriteStream2
  };
  function ReadStream2(path2, options) {
    if (!(this instanceof ReadStream2))
      return new ReadStream2(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index2 = 0, length = keys.length; index2 < length; index2++) {
      var key = keys[index2];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream2(path2, options) {
    if (!(this instanceof WriteStream2))
      return new WriteStream2(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index2 = 0, length = keys.length; index2 < length; index2++) {
      var key = keys[index2];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$l = fs$o;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$5 = require$$4;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop$3() {
}
function publishQueue(context2, queue2) {
  Object.defineProperty(context2, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$7 = noop$3;
if (util$5.debuglog)
  debug$7 = util$5.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$7 = function() {
    var m2 = util$5.format.apply(util$5, arguments);
    m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
    console.error(m2);
  };
if (!fs$l[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$l, queue);
  fs$l.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$l, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$l.close);
  fs$l.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$l, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$l.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$7(fs$l[gracefulQueue]);
      require$$2.equal(fs$l[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$l[gracefulQueue]);
}
var gracefulFs = patch(clone(fs$l));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$l.__patched) {
  gracefulFs = patch(fs$l);
  fs$l.__patched = true;
}
function patch(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path22, options2, cb2, startTime) {
      return fs$readFile(path22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data2, options, cb);
    function go$writeFile(path22, data22, options2, cb2, startTime) {
      return fs$writeFile(path22, data22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data2, options, cb);
    function go$appendFile(path22, data22, options2, cb2, startTime) {
      return fs$appendFile(path22, data22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src2, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src22, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src22, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src22, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    } : function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, options2, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options, cb);
    function fs$readdirCallback(path22, options2, cb2, startTime) {
      return function(err, files2) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([
            go$readdir,
            [path22, options2, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]);
        else {
          if (files2 && files2.sort)
            files2.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files2);
        }
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream2 = legStreams.ReadStream;
    WriteStream2 = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream2.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream2.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream2.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream2.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream2;
    },
    set: function(val) {
      ReadStream2 = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream2;
    },
    set: function(val) {
      WriteStream2 = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream2;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream2;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream2(path2, options) {
    if (this instanceof ReadStream2)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream2(path2, options) {
    if (this instanceof WriteStream2)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream2.apply(Object.create(WriteStream2.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open2;
  function open2(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path22, flags2, mode2, cb2, startTime) {
      return fs$open(path22, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path22, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$7("ENQUEUE", elem[0].name, elem[1]);
  fs$l[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i2 = 0; i2 < fs$l[gracefulQueue].length; ++i2) {
    if (fs$l[gracefulQueue][i2].length > 2) {
      fs$l[gracefulQueue][i2][3] = now;
      fs$l[gracefulQueue][i2][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$l[gracefulQueue].length === 0)
    return;
  var elem = fs$l[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$7("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$7("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$7("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$l[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports2) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports2, fs2);
  api.forEach((method) => {
    exports2[method] = u2(fs2[method]);
  });
  exports2.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports2.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports2.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports2.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.readv(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports2.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.writev(fd, buffers, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs2.realpath.native === "function") {
    exports2.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$m);
var makeDir$1 = {};
var utils$2 = {};
const path$d = path$e;
utils$2.checkPath = function checkPath(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$d.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`);
      error.code = "EINVAL";
      throw error;
    }
  }
};
const fs$k = fs$m;
const { checkPath: checkPath2 } = utils$2;
const getMode = (options) => {
  const defaults = { mode: 511 };
  if (typeof options === "number")
    return options;
  return { ...defaults, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$k.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$k.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$f = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$f(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$e = universalify$1.fromPromise;
const fs$j = fs$m;
function pathExists$6(path2) {
  return fs$j.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$e(pathExists$6),
  pathExistsSync: fs$j.existsSync
};
const fs$i = fs$m;
const u$d = universalify$1.fromPromise;
async function utimesMillis$1(path2, atime, mtime) {
  const fd = await fs$i.open(path2, "r+");
  let closeErr = null;
  try {
    await fs$i.futimes(fd, atime, mtime);
  } finally {
    try {
      await fs$i.close(fd);
    } catch (e2) {
      closeErr = e2;
    }
  }
  if (closeErr) {
    throw closeErr;
  }
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$i.openSync(path2, "r+");
  fs$i.futimesSync(fd, atime, mtime);
  return fs$i.closeSync(fd);
}
var utimes = {
  utimesMillis: u$d(utimesMillis$1),
  utimesMillisSync: utimesMillisSync$1
};
const fs$h = fs$m;
const path$c = path$e;
const u$c = universalify$1.fromPromise;
function getStats$1(src2, dest, opts) {
  const statFunc = opts.dereference ? (file2) => fs$h.stat(file2, { bigint: true }) : (file2) => fs$h.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src2),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src2, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ? (file2) => fs$h.statSync(file2, { bigint: true }) : (file2) => fs$h.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src2);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
async function checkPaths(src2, dest, funcName, opts) {
  const { srcStat, destStat } = await getStats$1(src2, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$c.basename(src2);
      const destBaseName = path$c.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkPathsSync(src2, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src2, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$c.basename(src2);
      const destBaseName = path$c.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return { srcStat, destStat };
}
async function checkParentPaths(src2, srcStat, dest, funcName) {
  const srcParent = path$c.resolve(path$c.dirname(src2));
  const destParent = path$c.resolve(path$c.dirname(dest));
  if (destParent === srcParent || destParent === path$c.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = await fs$h.stat(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return checkParentPaths(src2, srcStat, destParent, funcName);
}
function checkParentPathsSync(src2, srcStat, dest, funcName) {
  const srcParent = path$c.resolve(path$c.dirname(src2));
  const destParent = path$c.resolve(path$c.dirname(dest));
  if (destParent === srcParent || destParent === path$c.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$h.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return checkParentPathsSync(src2, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src2, dest) {
  const srcArr = path$c.resolve(src2).split(path$c.sep).filter((i2) => i2);
  const destArr = path$c.resolve(dest).split(path$c.sep).filter((i2) => i2);
  return srcArr.every((cur, i2) => destArr[i2] === cur);
}
function errMsg(src2, dest, funcName) {
  return `Cannot ${funcName} '${src2}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  // checkPaths
  checkPaths: u$c(checkPaths),
  checkPathsSync,
  // checkParent
  checkParentPaths: u$c(checkParentPaths),
  checkParentPathsSync,
  // Misc
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$g = fs$m;
const path$b = path$e;
const { mkdirs: mkdirs$1 } = mkdirs$2;
const { pathExists: pathExists$5 } = pathExists_1;
const { utimesMillis } = utimes;
const stat$3 = stat$4;
async function copy$3(src2, dest, opts = {}) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  const { srcStat, destStat } = await stat$3.checkPaths(src2, dest, "copy", opts);
  await stat$3.checkParentPaths(src2, srcStat, dest, "copy");
  const include = await runFilter(src2, dest, opts);
  if (!include)
    return;
  const destParent = path$b.dirname(dest);
  const dirExists = await pathExists$5(destParent);
  if (!dirExists) {
    await mkdirs$1(destParent);
  }
  await getStatsAndPerformCopy(destStat, src2, dest, opts);
}
async function runFilter(src2, dest, opts) {
  if (!opts.filter)
    return true;
  return opts.filter(src2, dest);
}
async function getStatsAndPerformCopy(destStat, src2, dest, opts) {
  const statFn = opts.dereference ? fs$g.stat : fs$g.lstat;
  const srcStat = await statFn(src2);
  if (srcStat.isDirectory())
    return onDir$1(srcStat, destStat, src2, dest, opts);
  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$1(srcStat, destStat, src2, dest, opts);
  if (srcStat.isSymbolicLink())
    return onLink$1(destStat, src2, dest, opts);
  if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src2}`);
  if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
  throw new Error(`Unknown file: ${src2}`);
}
async function onFile$1(srcStat, destStat, src2, dest, opts) {
  if (!destStat)
    return copyFile$1(srcStat, src2, dest, opts);
  if (opts.overwrite) {
    await fs$g.unlink(dest);
    return copyFile$1(srcStat, src2, dest, opts);
  }
  if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
async function copyFile$1(srcStat, src2, dest, opts) {
  await fs$g.copyFile(src2, dest);
  if (opts.preserveTimestamps) {
    if (fileIsNotWritable$1(srcStat.mode)) {
      await makeFileWritable$1(dest, srcStat.mode);
    }
    const updatedSrcStat = await fs$g.stat(src2);
    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  return fs$g.chmod(dest, srcStat.mode);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return fs$g.chmod(dest, srcMode | 128);
}
async function onDir$1(srcStat, destStat, src2, dest, opts) {
  if (!destStat) {
    await fs$g.mkdir(dest);
  }
  const items = await fs$g.readdir(src2);
  await Promise.all(items.map(async (item) => {
    const srcItem = path$b.join(src2, item);
    const destItem = path$b.join(dest, item);
    const include = await runFilter(srcItem, destItem, opts);
    if (!include)
      return;
    const { destStat: destStat2 } = await stat$3.checkPaths(srcItem, destItem, "copy", opts);
    return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
  }));
  if (!destStat) {
    await fs$g.chmod(dest, srcStat.mode);
  }
}
async function onLink$1(destStat, src2, dest, opts) {
  let resolvedSrc = await fs$g.readlink(src2);
  if (opts.dereference) {
    resolvedSrc = path$b.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$g.symlink(resolvedSrc, dest);
  }
  let resolvedDest = null;
  try {
    resolvedDest = await fs$g.readlink(dest);
  } catch (e2) {
    if (e2.code === "EINVAL" || e2.code === "UNKNOWN")
      return fs$g.symlink(resolvedSrc, dest);
    throw e2;
  }
  if (opts.dereference) {
    resolvedDest = path$b.resolve(process.cwd(), resolvedDest);
  }
  if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
  }
  if (stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
  }
  await fs$g.unlink(dest);
  return fs$g.symlink(resolvedSrc, dest);
}
var copy_1 = copy$3;
const fs$f = gracefulFs;
const path$a = path$e;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src2, dest, opts) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src2, dest, "copy", opts);
  stat$2.checkParentPathsSync(src2, srcStat, dest, "copy");
  if (opts.filter && !opts.filter(src2, dest))
    return;
  const destParent = path$a.dirname(dest);
  if (!fs$f.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats(destStat, src2, dest, opts);
}
function getStats(destStat, src2, dest, opts) {
  const statSync2 = opts.dereference ? fs$f.statSync : fs$f.lstatSync;
  const srcStat = statSync2(src2);
  if (srcStat.isDirectory())
    return onDir(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isSymbolicLink())
    return onLink(destStat, src2, dest, opts);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src2}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
  throw new Error(`Unknown file: ${src2}`);
}
function onFile(srcStat, destStat, src2, dest, opts) {
  if (!destStat)
    return copyFile(srcStat, src2, dest, opts);
  return mayCopyFile(srcStat, src2, dest, opts);
}
function mayCopyFile(srcStat, src2, dest, opts) {
  if (opts.overwrite) {
    fs$f.unlinkSync(dest);
    return copyFile(srcStat, src2, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src2, dest, opts) {
  fs$f.copyFileSync(src2, dest);
  if (opts.preserveTimestamps)
    handleTimestamps(srcStat.mode, src2, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src2, dest) {
  if (fileIsNotWritable(srcMode))
    makeFileWritable(dest, srcMode);
  return setDestTimestamps(src2, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$f.chmodSync(dest, srcMode);
}
function setDestTimestamps(src2, dest) {
  const updatedSrcStat = fs$f.statSync(src2);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src2, dest, opts) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src2, dest, opts);
  return copyDir(src2, dest, opts);
}
function mkDirAndCopy(srcMode, src2, dest, opts) {
  fs$f.mkdirSync(dest);
  copyDir(src2, dest, opts);
  return setDestMode(dest, srcMode);
}
function copyDir(src2, dest, opts) {
  fs$f.readdirSync(src2).forEach((item) => copyDirItem(item, src2, dest, opts));
}
function copyDirItem(item, src2, dest, opts) {
  const srcItem = path$a.join(src2, item);
  const destItem = path$a.join(dest, item);
  if (opts.filter && !opts.filter(srcItem, destItem))
    return;
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts);
  return getStats(destStat, srcItem, destItem, opts);
}
function onLink(destStat, src2, dest, opts) {
  let resolvedSrc = fs$f.readlinkSync(src2);
  if (opts.dereference) {
    resolvedSrc = path$a.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$f.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$f.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$f.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts.dereference) {
      resolvedDest = path$a.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$f.unlinkSync(dest);
  return fs$f.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$b = universalify$1.fromPromise;
var copy$2 = {
  copy: u$b(copy_1),
  copySync: copySync_1
};
const fs$e = gracefulFs;
const u$a = universalify$1.fromCallback;
function remove$2(path2, callback) {
  fs$e.rm(path2, { recursive: true, force: true }, callback);
}
function removeSync$1(path2) {
  fs$e.rmSync(path2, { recursive: true, force: true });
}
var remove_1 = {
  remove: u$a(remove$2),
  removeSync: removeSync$1
};
const u$9 = universalify$1.fromPromise;
const fs$d = fs$m;
const path$9 = path$e;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$9(async function emptyDir2(dir) {
  let items;
  try {
    items = await fs$d.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items.map((item) => remove$1.remove(path$9.join(dir, item))));
});
function emptyDirSync(dir) {
  let items;
  try {
    items = fs$d.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items.forEach((item) => {
    item = path$9.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$8 = universalify$1.fromPromise;
const path$8 = path$e;
const fs$c = fs$m;
const mkdir$2 = mkdirs$2;
async function createFile$1(file2) {
  let stats;
  try {
    stats = await fs$c.stat(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$8.dirname(file2);
  let dirStats = null;
  try {
    dirStats = await fs$c.stat(dir);
  } catch (err) {
    if (err.code === "ENOENT") {
      await mkdir$2.mkdirs(dir);
      await fs$c.writeFile(file2, "");
      return;
    } else {
      throw err;
    }
  }
  if (dirStats.isDirectory()) {
    await fs$c.writeFile(file2, "");
  } else {
    await fs$c.readdir(dir);
  }
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$c.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$8.dirname(file2);
  try {
    if (!fs$c.statSync(dir).isDirectory()) {
      fs$c.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$c.writeFileSync(file2, "");
}
var file$1 = {
  createFile: u$8(createFile$1),
  createFileSync: createFileSync$1
};
const u$7 = universalify$1.fromPromise;
const path$7 = path$e;
const fs$b = fs$m;
const mkdir$1 = mkdirs$2;
const { pathExists: pathExists$4 } = pathExists_1;
const { areIdentical: areIdentical$1 } = stat$4;
async function createLink$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = await fs$b.lstat(dstpath);
  } catch {
  }
  let srcStat;
  try {
    srcStat = await fs$b.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  if (dstStat && areIdentical$1(srcStat, dstStat))
    return;
  const dir = path$7.dirname(dstpath);
  const dirExists = await pathExists$4(dir);
  if (!dirExists) {
    await mkdir$1.mkdirs(dir);
  }
  await fs$b.link(srcpath, dstpath);
}
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$b.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$b.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$7.dirname(dstpath);
  const dirExists = fs$b.existsSync(dir);
  if (dirExists)
    return fs$b.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$b.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$7(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$6 = path$e;
const fs$a = fs$m;
const { pathExists: pathExists$3 } = pathExists_1;
const u$6 = universalify$1.fromPromise;
async function symlinkPaths$1(srcpath, dstpath) {
  if (path$6.isAbsolute(srcpath)) {
    try {
      await fs$a.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$6.dirname(dstpath);
  const relativeToDst = path$6.join(dstdir, srcpath);
  const exists = await pathExists$3(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  try {
    await fs$a.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureSymlink");
    throw err;
  }
  return {
    toCwd: srcpath,
    toDst: path$6.relative(dstdir, srcpath)
  };
}
function symlinkPathsSync$1(srcpath, dstpath) {
  if (path$6.isAbsolute(srcpath)) {
    const exists2 = fs$a.existsSync(srcpath);
    if (!exists2)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$6.dirname(dstpath);
  const relativeToDst = path$6.join(dstdir, srcpath);
  const exists = fs$a.existsSync(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  const srcExists = fs$a.existsSync(srcpath);
  if (!srcExists)
    throw new Error("relative srcpath does not exist");
  return {
    toCwd: srcpath,
    toDst: path$6.relative(dstdir, srcpath)
  };
}
var symlinkPaths_1 = {
  symlinkPaths: u$6(symlinkPaths$1),
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$9 = fs$m;
const u$5 = universalify$1.fromPromise;
async function symlinkType$1(srcpath, type) {
  if (type)
    return type;
  let stats;
  try {
    stats = await fs$9.lstat(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
function symlinkTypeSync$1(srcpath, type) {
  if (type)
    return type;
  let stats;
  try {
    stats = fs$9.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: u$5(symlinkType$1),
  symlinkTypeSync: symlinkTypeSync$1
};
const u$4 = universalify$1.fromPromise;
const path$5 = path$e;
const fs$8 = fs$m;
const { mkdirs, mkdirsSync } = mkdirs$2;
const { symlinkPaths, symlinkPathsSync } = symlinkPaths_1;
const { symlinkType, symlinkTypeSync } = symlinkType_1;
const { pathExists: pathExists$2 } = pathExists_1;
const { areIdentical } = stat$4;
async function createSymlink$1(srcpath, dstpath, type) {
  let stats;
  try {
    stats = await fs$8.lstat(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const [srcStat, dstStat] = await Promise.all([
      fs$8.stat(srcpath),
      fs$8.stat(dstpath)
    ]);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = await symlinkPaths(srcpath, dstpath);
  srcpath = relative.toDst;
  const toType = await symlinkType(relative.toCwd, type);
  const dir = path$5.dirname(dstpath);
  if (!await pathExists$2(dir)) {
    await mkdirs(dir);
  }
  return fs$8.symlink(srcpath, dstpath, toType);
}
function createSymlinkSync$1(srcpath, dstpath, type) {
  let stats;
  try {
    stats = fs$8.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$8.statSync(srcpath);
    const dstStat = fs$8.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync(relative.toCwd, type);
  const dir = path$5.dirname(dstpath);
  const exists = fs$8.existsSync(dir);
  if (exists)
    return fs$8.symlinkSync(srcpath, dstpath, type);
  mkdirsSync(dir);
  return fs$8.symlinkSync(srcpath, dstpath, type);
}
var symlink = {
  createSymlink: u$4(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file$1;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str = JSON.stringify(obj, replacer, spaces);
  return str.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils$1 = { stringify: stringify$3, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_2) {
  _fs = fs$o;
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils$1;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data2 = await universalify.fromCallback(fs2.readFile)(file2, options);
  data2 = stripBom(data2);
  let obj;
  try {
    obj = JSON.parse(data2, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile = universalify.fromPromise(_readFile);
function readFileSync(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str, options);
}
const writeFile = universalify.fromPromise(_writeFile);
function writeFileSync(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str = stringify$2(obj, options);
  return fs2.writeFileSync(file2, str, options);
}
const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$3 = universalify$1.fromPromise;
const fs$7 = fs$m;
const path$4 = path$e;
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;
async function outputFile$1(file2, data2, encoding = "utf-8") {
  const dir = path$4.dirname(file2);
  if (!await pathExists$1(dir)) {
    await mkdir.mkdirs(dir);
  }
  return fs$7.writeFile(file2, data2, encoding);
}
function outputFileSync$1(file2, ...args) {
  const dir = path$4.dirname(file2);
  if (!fs$7.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }
  fs$7.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$3(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$1 } = utils$1;
const { outputFile } = outputFile_1;
async function outputJson(file2, data2, options = {}) {
  const str = stringify$1(data2, options);
  await outputFile(file2, str, options);
}
var outputJson_1 = outputJson;
const { stringify } = utils$1;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data2, options) {
  const str = stringify(data2, options);
  outputFileSync(file2, str, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$2 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$2(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json = jsonFile;
const fs$6 = fs$m;
const path$3 = path$e;
const { copy: copy$1 } = copy$2;
const { remove } = remove_1;
const { mkdirp } = mkdirs$2;
const { pathExists } = pathExists_1;
const stat$1 = stat$4;
async function move$1(src2, dest, opts = {}) {
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = await stat$1.checkPaths(src2, dest, "move", opts);
  await stat$1.checkParentPaths(src2, srcStat, dest, "move");
  const destParent = path$3.dirname(dest);
  const parsedParentPath = path$3.parse(destParent);
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent);
  }
  return doRename$1(src2, dest, overwrite, isChangingCase);
}
async function doRename$1(src2, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest);
    } else if (await pathExists(dest)) {
      throw new Error("dest already exists.");
    }
  }
  try {
    await fs$6.rename(src2, dest);
  } catch (err) {
    if (err.code !== "EXDEV") {
      throw err;
    }
    await moveAcrossDevice$1(src2, dest, overwrite);
  }
}
async function moveAcrossDevice$1(src2, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  await copy$1(src2, dest, opts);
  return remove(src2);
}
var move_1 = move$1;
const fs$5 = gracefulFs;
const path$2 = path$e;
const copySync = copy$2.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src2, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src2, dest, "move", opts);
  stat.checkParentPathsSync(src2, srcStat, dest, "move");
  if (!isParentRoot(dest))
    mkdirpSync(path$2.dirname(dest));
  return doRename(src2, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$2.dirname(dest);
  const parsedPath = path$2.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src2, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename(src2, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src2, dest, overwrite);
  }
  if (fs$5.existsSync(dest))
    throw new Error("dest already exists.");
  return rename(src2, dest, overwrite);
}
function rename(src2, dest, overwrite) {
  try {
    fs$5.renameSync(src2, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice(src2, dest, overwrite);
  }
}
function moveAcrossDevice(src2, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  copySync(src2, dest, opts);
  return removeSync(src2);
}
var moveSync_1 = moveSync;
const u$1 = universalify$1.fromPromise;
var move = {
  move: u$1(move_1),
  moveSync: moveSync_1
};
var lib$1 = {
  // Export promiseified graceful-fs:
  ...fs$m,
  // Export extra methods:
  ...copy$2,
  ...empty,
  ...ensure,
  ...json,
  ...mkdirs$2,
  ...move,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var notfound = {};
Object.defineProperty(notfound, "__esModule", { value: true });
class NotFoundError extends Error {
  constructor(message2) {
    super(message2 || "File does not exist at the specified endpoint");
    this.code = "ENOTFOUND";
  }
}
notfound.default = NotFoundError;
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(file$2, "__esModule", { value: true });
file$2.file = void 0;
const debug_1$6 = __importDefault$8(srcExports);
const fs_1$1 = fs$o;
const fs_extra_1 = lib$1;
const notfound_1$1 = __importDefault$8(notfound);
const notmodified_1$1 = __importDefault$8(notmodified);
const url_1$3 = require$$5$1;
const debug$6 = (0, debug_1$6.default)("get-uri:file");
const file = async ({ href: uri }, opts = {}) => {
  const {
    cache,
    flags = "r",
    mode = 438
    // =0666
  } = opts;
  try {
    const filepath = (0, url_1$3.fileURLToPath)(uri);
    debug$6("Normalized pathname: %o", filepath);
    const fd = await (0, fs_extra_1.open)(filepath, flags, mode);
    const stat2 = await (0, fs_extra_1.fstat)(fd);
    if (cache && cache.stat && stat2 && isNotModified(cache.stat, stat2)) {
      throw new notmodified_1$1.default();
    }
    const rs = (0, fs_1$1.createReadStream)(null, {
      autoClose: true,
      ...opts,
      fd
    });
    rs.stat = stat2;
    return rs;
  } catch (err) {
    if (err.code === "ENOENT") {
      throw new notfound_1$1.default();
    }
    throw err;
  }
};
file$2.file = file;
function isNotModified(prev, curr) {
  return +prev.mtime === +curr.mtime;
}
var ftp$1 = {};
var dist$5 = {};
var Client$1 = {};
var FtpContext = {};
var parseControlResponse$1 = {};
Object.defineProperty(parseControlResponse$1, "__esModule", { value: true });
parseControlResponse$1.positiveIntermediate = parseControlResponse$1.positiveCompletion = parseControlResponse$1.isMultiline = parseControlResponse$1.isSingleLine = parseControlResponse$1.parseControlResponse = void 0;
const LF = "\n";
function parseControlResponse(text) {
  const lines = text.split(/\r?\n/).filter(isNotBlank$1);
  const messages = [];
  let startAt = 0;
  let tokenRegex;
  for (let i2 = 0; i2 < lines.length; i2++) {
    const line = lines[i2];
    if (!tokenRegex) {
      if (isMultiline(line)) {
        const token = line.substr(0, 3);
        tokenRegex = new RegExp(`^${token}(?:$| )`);
        startAt = i2;
      } else if (isSingleLine(line)) {
        messages.push(line);
      }
    } else if (tokenRegex.test(line)) {
      tokenRegex = void 0;
      messages.push(lines.slice(startAt, i2 + 1).join(LF));
    }
  }
  const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : "";
  return { messages, rest };
}
parseControlResponse$1.parseControlResponse = parseControlResponse;
function isSingleLine(line) {
  return /^\d\d\d(?:$| )/.test(line);
}
parseControlResponse$1.isSingleLine = isSingleLine;
function isMultiline(line) {
  return /^\d\d\d-/.test(line);
}
parseControlResponse$1.isMultiline = isMultiline;
function positiveCompletion(code2) {
  return code2 >= 200 && code2 < 300;
}
parseControlResponse$1.positiveCompletion = positiveCompletion;
function positiveIntermediate(code2) {
  return code2 >= 300 && code2 < 400;
}
parseControlResponse$1.positiveIntermediate = positiveIntermediate;
function isNotBlank$1(str) {
  return str.trim() !== "";
}
Object.defineProperty(FtpContext, "__esModule", { value: true });
FtpContext.FTPContext = FtpContext.FTPError = void 0;
const net_1$1 = require$$0$1;
const parseControlResponse_1$2 = parseControlResponse$1;
class FTPError extends Error {
  constructor(res) {
    super(res.message);
    this.name = this.constructor.name;
    this.code = res.code;
  }
}
FtpContext.FTPError = FTPError;
function doNothing() {
}
class FTPContext {
  /**
   * Instantiate an FTP context.
   *
   * @param timeout - Timeout in milliseconds to apply to control and data connections. Use 0 for no timeout.
   * @param encoding - Encoding to use for control connection. UTF-8 by default. Use "latin1" for older servers.
   */
  constructor(timeout2 = 0, encoding = "utf8") {
    this.timeout = timeout2;
    this.verbose = false;
    this.ipFamily = void 0;
    this.tlsOptions = {};
    this._partialResponse = "";
    this._encoding = encoding;
    this._socket = this.socket = this._newSocket();
    this._dataSocket = void 0;
  }
  /**
   * Close the context.
   */
  close() {
    const message2 = this._task ? "User closed client during task" : "User closed client";
    const err = new Error(message2);
    this.closeWithError(err);
  }
  /**
   * Close the context with an error.
   */
  closeWithError(err) {
    if (this._closingError) {
      return;
    }
    this._closingError = err;
    this._closeControlSocket();
    this._closeSocket(this._dataSocket);
    this._passToHandler(err);
    this._stopTrackingTask();
  }
  /**
   * Returns true if this context has been closed or hasn't been connected yet. You can reopen it with `access`.
   */
  get closed() {
    return this.socket.remoteAddress === void 0 || this._closingError !== void 0;
  }
  /**
   * Reset this contex and all of its state.
   */
  reset() {
    this.socket = this._newSocket();
  }
  /**
   * Get the FTP control socket.
   */
  get socket() {
    return this._socket;
  }
  /**
   * Set the socket for the control connection. This will only close the current control socket
   * if the new one is not an upgrade to the current one.
   */
  set socket(socket) {
    this.dataSocket = void 0;
    this.tlsOptions = {};
    this._partialResponse = "";
    if (this._socket) {
      const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;
      if (newSocketUpgradesExisting) {
        this._removeSocketListeners(this.socket);
      } else {
        this._closeControlSocket();
      }
    }
    if (socket) {
      this._closingError = void 0;
      socket.setTimeout(0);
      socket.setEncoding(this._encoding);
      socket.setKeepAlive(true);
      socket.on("data", (data2) => this._onControlSocketData(data2));
      socket.on("end", () => this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")));
      socket.on("close", (hadError) => {
        if (!hadError)
          this.closeWithError(new Error("Server closed connection unexpectedly."));
      });
      this._setupDefaultErrorHandlers(socket, "control socket");
    }
    this._socket = socket;
  }
  /**
   * Get the current FTP data connection if present.
   */
  get dataSocket() {
    return this._dataSocket;
  }
  /**
   * Set the socket for the data connection. This will automatically close the former data socket.
   */
  set dataSocket(socket) {
    this._closeSocket(this._dataSocket);
    if (socket) {
      socket.setTimeout(0);
      this._setupDefaultErrorHandlers(socket, "data socket");
    }
    this._dataSocket = socket;
  }
  /**
   * Get the currently used encoding.
   */
  get encoding() {
    return this._encoding;
  }
  /**
   * Set the encoding used for the control socket.
   *
   * See https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings for what encodings
   * are supported by Node.
   */
  set encoding(encoding) {
    this._encoding = encoding;
    if (this.socket) {
      this.socket.setEncoding(encoding);
    }
  }
  /**
   * Send an FTP command without waiting for or handling the result.
   */
  send(command) {
    const containsPassword = command.startsWith("PASS");
    const message2 = containsPassword ? "> PASS ###" : `> ${command}`;
    this.log(message2);
    this._socket.write(command + "\r\n", this.encoding);
  }
  /**
   * Send an FTP command and handle the first response. Use this if you have a simple
   * request-response situation.
   */
  request(command) {
    return this.handle(command, (res, task) => {
      if (res instanceof Error) {
        task.reject(res);
      } else {
        task.resolve(res);
      }
    });
  }
  /**
   * Send an FTP command and handle any response until you resolve/reject. Use this if you expect multiple responses
   * to a request. This returns a Promise that will hold whatever the response handler passed on when resolving/rejecting its task.
   */
  handle(command, responseHandler) {
    if (this._task) {
      const err = new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");
      err.stack += `
Running task launched at: ${this._task.stack}`;
      this.closeWithError(err);
    }
    return new Promise((resolveTask, rejectTask) => {
      this._task = {
        stack: new Error().stack || "Unknown call stack",
        responseHandler,
        resolver: {
          resolve: (arg) => {
            this._stopTrackingTask();
            resolveTask(arg);
          },
          reject: (err) => {
            this._stopTrackingTask();
            rejectTask(err);
          }
        }
      };
      if (this._closingError) {
        const err = new Error(`Client is closed because ${this._closingError.message}`);
        err.stack += `
Closing reason: ${this._closingError.stack}`;
        err.code = this._closingError.code !== void 0 ? this._closingError.code : "0";
        this._passToHandler(err);
        return;
      }
      this.socket.setTimeout(this.timeout);
      if (command) {
        this.send(command);
      }
    });
  }
  /**
   * Log message if set to be verbose.
   */
  log(message2) {
    if (this.verbose) {
      console.log(message2);
    }
  }
  /**
   * Return true if the control socket is using TLS. This does not mean that a session
   * has already been negotiated.
   */
  get hasTLS() {
    return "encrypted" in this._socket;
  }
  /**
   * Removes reference to current task and handler. This won't resolve or reject the task.
   * @protected
   */
  _stopTrackingTask() {
    this.socket.setTimeout(0);
    this._task = void 0;
  }
  /**
   * Handle incoming data on the control socket. The chunk is going to be of type `string`
   * because we let `socket` handle encoding with `setEncoding`.
   * @protected
   */
  _onControlSocketData(chunk) {
    this.log(`< ${chunk}`);
    const completeResponse = this._partialResponse + chunk;
    const parsed = (0, parseControlResponse_1$2.parseControlResponse)(completeResponse);
    this._partialResponse = parsed.rest;
    for (const message2 of parsed.messages) {
      const code2 = parseInt(message2.substr(0, 3), 10);
      const response = { code: code2, message: message2 };
      const err = code2 >= 400 ? new FTPError(response) : void 0;
      this._passToHandler(err ? err : response);
    }
  }
  /**
   * Send the current handler a response. This is usually a control socket response
   * or a socket event, like an error or timeout.
   * @protected
   */
  _passToHandler(response) {
    if (this._task) {
      this._task.responseHandler(response, this._task.resolver);
    }
  }
  /**
   * Setup all error handlers for a socket.
   * @protected
   */
  _setupDefaultErrorHandlers(socket, identifier) {
    socket.once("error", (error) => {
      error.message += ` (${identifier})`;
      this.closeWithError(error);
    });
    socket.once("close", (hadError) => {
      if (hadError) {
        this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));
      }
    });
    socket.once("timeout", () => {
      socket.destroy();
      this.closeWithError(new Error(`Timeout (${identifier})`));
    });
  }
  /**
   * Close the control socket. Sends QUIT, then FIN, and ignores any response or error.
   */
  _closeControlSocket() {
    this._removeSocketListeners(this._socket);
    this._socket.on("error", doNothing);
    this.send("QUIT");
    this._closeSocket(this._socket);
  }
  /**
   * Close a socket, ignores any error.
   * @protected
   */
  _closeSocket(socket) {
    if (socket) {
      this._removeSocketListeners(socket);
      socket.on("error", doNothing);
      socket.destroy();
    }
  }
  /**
   * Remove all default listeners for socket.
   * @protected
   */
  _removeSocketListeners(socket) {
    socket.removeAllListeners();
    socket.removeAllListeners("timeout");
    socket.removeAllListeners("data");
    socket.removeAllListeners("end");
    socket.removeAllListeners("error");
    socket.removeAllListeners("close");
    socket.removeAllListeners("connect");
  }
  /**
   * Provide a new socket instance.
   *
   * Internal use only, replaced for unit tests.
   */
  _newSocket() {
    return new net_1$1.Socket();
  }
}
FtpContext.FTPContext = FTPContext;
var parseList$1 = {};
var parseListDOS = {};
var FileInfo$1 = {};
Object.defineProperty(FileInfo$1, "__esModule", { value: true });
FileInfo$1.FileInfo = FileInfo$1.FileType = void 0;
var FileType;
(function(FileType2) {
  FileType2[FileType2["Unknown"] = 0] = "Unknown";
  FileType2[FileType2["File"] = 1] = "File";
  FileType2[FileType2["Directory"] = 2] = "Directory";
  FileType2[FileType2["SymbolicLink"] = 3] = "SymbolicLink";
})(FileType || (FileInfo$1.FileType = FileType = {}));
class FileInfo {
  constructor(name2) {
    this.name = name2;
    this.type = FileType.Unknown;
    this.size = 0;
    this.rawModifiedAt = "";
    this.modifiedAt = void 0;
    this.permissions = void 0;
    this.hardLinkCount = void 0;
    this.link = void 0;
    this.group = void 0;
    this.user = void 0;
    this.uniqueID = void 0;
    this.name = name2;
  }
  get isDirectory() {
    return this.type === FileType.Directory;
  }
  get isSymbolicLink() {
    return this.type === FileType.SymbolicLink;
  }
  get isFile() {
    return this.type === FileType.File;
  }
  /**
   * Deprecated, legacy API. Use `rawModifiedAt` instead.
   * @deprecated
   */
  get date() {
    return this.rawModifiedAt;
  }
  set date(rawModifiedAt) {
    this.rawModifiedAt = rawModifiedAt;
  }
}
FileInfo$1.FileInfo = FileInfo;
FileInfo.UnixPermission = {
  Read: 4,
  Write: 2,
  Execute: 1
};
Object.defineProperty(parseListDOS, "__esModule", { value: true });
parseListDOS.transformList = parseListDOS.parseLine = parseListDOS.testLine = void 0;
const FileInfo_1$2 = FileInfo$1;
const RE_LINE$1 = new RegExp(
  "(\\S+)\\s+(\\S+)\\s+(?:(<DIR>)|([0-9]+))\\s+(\\S.*)"
  // First non-space followed by rest of line (name)
);
function testLine$2(line) {
  return /^\d{2}/.test(line) && RE_LINE$1.test(line);
}
parseListDOS.testLine = testLine$2;
function parseLine$2(line) {
  const groups = line.match(RE_LINE$1);
  if (groups === null) {
    return void 0;
  }
  const name2 = groups[5];
  if (name2 === "." || name2 === "..") {
    return void 0;
  }
  const file2 = new FileInfo_1$2.FileInfo(name2);
  const fileType = groups[3];
  if (fileType === "<DIR>") {
    file2.type = FileInfo_1$2.FileType.Directory;
    file2.size = 0;
  } else {
    file2.type = FileInfo_1$2.FileType.File;
    file2.size = parseInt(groups[4], 10);
  }
  file2.rawModifiedAt = groups[1] + " " + groups[2];
  return file2;
}
parseListDOS.parseLine = parseLine$2;
function transformList$2(files2) {
  return files2;
}
parseListDOS.transformList = transformList$2;
var parseListUnix = {};
Object.defineProperty(parseListUnix, "__esModule", { value: true });
parseListUnix.transformList = parseListUnix.parseLine = parseListUnix.testLine = void 0;
const FileInfo_1$1 = FileInfo$1;
const JA_MONTH = "";
const JA_DAY = "";
const JA_YEAR = "";
const RE_LINE = new RegExp("([bcdelfmpSs-])(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?\\s*(\\d+)\\s+(?:(\\S+(?:\\s\\S+)*?)\\s+)?(?:(\\S+(?:\\s\\S+)*)\\s+)?(\\d+(?:,\\s*\\d+)?)\\s+((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3})|(?:\\d{1,2}" + JA_MONTH + "\\s+\\d{1,2}" + JA_DAY + "))\\s+((?:\\d+(?::\\d+)?)|(?:\\d{4}" + JA_YEAR + "))\\s(.*)");
function testLine$1(line) {
  return RE_LINE.test(line);
}
parseListUnix.testLine = testLine$1;
function parseLine$1(line) {
  const groups = line.match(RE_LINE);
  if (groups === null) {
    return void 0;
  }
  const name2 = groups[21];
  if (name2 === "." || name2 === "..") {
    return void 0;
  }
  const file2 = new FileInfo_1$1.FileInfo(name2);
  file2.size = parseInt(groups[18], 10);
  file2.user = groups[16];
  file2.group = groups[17];
  file2.hardLinkCount = parseInt(groups[15], 10);
  file2.rawModifiedAt = groups[19] + " " + groups[20];
  file2.permissions = {
    user: parseMode(groups[4], groups[5], groups[6]),
    group: parseMode(groups[8], groups[9], groups[10]),
    world: parseMode(groups[12], groups[13], groups[14])
  };
  switch (groups[1].charAt(0)) {
    case "d":
      file2.type = FileInfo_1$1.FileType.Directory;
      break;
    case "e":
      file2.type = FileInfo_1$1.FileType.SymbolicLink;
      break;
    case "l":
      file2.type = FileInfo_1$1.FileType.SymbolicLink;
      break;
    case "b":
    case "c":
      file2.type = FileInfo_1$1.FileType.File;
      break;
    case "f":
    case "-":
      file2.type = FileInfo_1$1.FileType.File;
      break;
    default:
      file2.type = FileInfo_1$1.FileType.Unknown;
  }
  if (file2.isSymbolicLink) {
    const end = name2.indexOf(" -> ");
    if (end !== -1) {
      file2.name = name2.substring(0, end);
      file2.link = name2.substring(end + 4);
    }
  }
  return file2;
}
parseListUnix.parseLine = parseLine$1;
function transformList$1(files2) {
  return files2;
}
parseListUnix.transformList = transformList$1;
function parseMode(r2, w2, x2) {
  let value = 0;
  if (r2 !== "-") {
    value += FileInfo_1$1.FileInfo.UnixPermission.Read;
  }
  if (w2 !== "-") {
    value += FileInfo_1$1.FileInfo.UnixPermission.Write;
  }
  const execToken = x2.charAt(0);
  if (execToken !== "-" && execToken.toUpperCase() !== execToken) {
    value += FileInfo_1$1.FileInfo.UnixPermission.Execute;
  }
  return value;
}
var parseListMLSD = {};
Object.defineProperty(parseListMLSD, "__esModule", { value: true });
parseListMLSD.parseMLSxDate = parseListMLSD.transformList = parseListMLSD.parseLine = parseListMLSD.testLine = void 0;
const FileInfo_1 = FileInfo$1;
function parseSize(value, info) {
  info.size = parseInt(value, 10);
}
const factHandlersByName = {
  "size": parseSize,
  // File size
  "sizd": parseSize,
  // Directory size
  "unique": (value, info) => {
    info.uniqueID = value;
  },
  "modify": (value, info) => {
    info.modifiedAt = parseMLSxDate(value);
    info.rawModifiedAt = info.modifiedAt.toISOString();
  },
  "type": (value, info) => {
    if (value.startsWith("OS.unix=slink")) {
      info.type = FileInfo_1.FileType.SymbolicLink;
      info.link = value.substr(value.indexOf(":") + 1);
      return 1;
    }
    switch (value) {
      case "file":
        info.type = FileInfo_1.FileType.File;
        break;
      case "dir":
        info.type = FileInfo_1.FileType.Directory;
        break;
      case "OS.unix=symlink":
        info.type = FileInfo_1.FileType.SymbolicLink;
        break;
      case "cdir":
      case "pdir":
        return 2;
      default:
        info.type = FileInfo_1.FileType.Unknown;
    }
    return 1;
  },
  "unix.mode": (value, info) => {
    const digits = value.substr(-3);
    info.permissions = {
      user: parseInt(digits[0], 10),
      group: parseInt(digits[1], 10),
      world: parseInt(digits[2], 10)
    };
  },
  "unix.ownername": (value, info) => {
    info.user = value;
  },
  "unix.owner": (value, info) => {
    if (info.user === void 0)
      info.user = value;
  },
  get "unix.uid"() {
    return this["unix.owner"];
  },
  "unix.groupname": (value, info) => {
    info.group = value;
  },
  "unix.group": (value, info) => {
    if (info.group === void 0)
      info.group = value;
  },
  get "unix.gid"() {
    return this["unix.group"];
  }
  // Regarding the fact "perm":
  // We don't handle permission information stored in "perm" because its information is conceptually
  // different from what users of FTP clients usually associate with "permissions". Those that have
  // some expectations (and probably want to edit them with a SITE command) often unknowingly expect
  // the Unix permission system. The information passed by "perm" describes what FTP commands can be
  // executed with a file/directory. But even this can be either incomplete or just meant as a "guide"
  // as the spec mentions. From https://tools.ietf.org/html/rfc3659#section-7.5.5: "The permissions are
  // described here as they apply to FTP commands. They may not map easily into particular permissions
  // available on the server's operating system." The parser by Apache Commons tries to translate these
  // to Unix permissions  this is misleading users and might not even be correct.
};
function splitStringOnce(str, delimiter) {
  const pos = str.indexOf(delimiter);
  const a2 = str.substr(0, pos);
  const b2 = str.substr(pos + delimiter.length);
  return [a2, b2];
}
function testLine(line) {
  return /^\S+=\S+;/.test(line) || line.startsWith(" ");
}
parseListMLSD.testLine = testLine;
function parseLine(line) {
  const [packedFacts, name2] = splitStringOnce(line, " ");
  if (name2 === "" || name2 === "." || name2 === "..") {
    return void 0;
  }
  const info = new FileInfo_1.FileInfo(name2);
  const facts = packedFacts.split(";");
  for (const fact of facts) {
    const [factName, factValue] = splitStringOnce(fact, "=");
    if (!factValue) {
      continue;
    }
    const factHandler = factHandlersByName[factName.toLowerCase()];
    if (!factHandler) {
      continue;
    }
    const result = factHandler(factValue, info);
    if (result === 2) {
      return void 0;
    }
  }
  return info;
}
parseListMLSD.parseLine = parseLine;
function transformList(files2) {
  const nonLinksByID = /* @__PURE__ */ new Map();
  for (const file2 of files2) {
    if (!file2.isSymbolicLink && file2.uniqueID !== void 0) {
      nonLinksByID.set(file2.uniqueID, file2);
    }
  }
  const resolvedFiles = [];
  for (const file2 of files2) {
    if (file2.isSymbolicLink && file2.uniqueID !== void 0 && file2.link === void 0) {
      const target = nonLinksByID.get(file2.uniqueID);
      if (target !== void 0) {
        file2.link = target.name;
      }
    }
    const isPartOfDirectory = !file2.name.includes("/");
    if (isPartOfDirectory) {
      resolvedFiles.push(file2);
    }
  }
  return resolvedFiles;
}
parseListMLSD.transformList = transformList;
function parseMLSxDate(fact) {
  return new Date(Date.UTC(
    +fact.slice(0, 4),
    // Year
    +fact.slice(4, 6) - 1,
    // Month
    +fact.slice(6, 8),
    // Date
    +fact.slice(8, 10),
    // Hours
    +fact.slice(10, 12),
    // Minutes
    +fact.slice(12, 14),
    // Seconds
    +fact.slice(15, 18)
    // Milliseconds
  ));
}
parseListMLSD.parseMLSxDate = parseMLSxDate;
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$4(result, mod, k2);
  }
  __setModuleDefault$4(result, mod);
  return result;
};
Object.defineProperty(parseList$1, "__esModule", { value: true });
parseList$1.parseList = void 0;
const dosParser = __importStar$4(parseListDOS);
const unixParser = __importStar$4(parseListUnix);
const mlsdParser = __importStar$4(parseListMLSD);
const availableParsers = [
  dosParser,
  unixParser,
  mlsdParser
  // Keep MLSD last, may accept filename only
];
function firstCompatibleParser(line, parsers) {
  return parsers.find((parser2) => parser2.testLine(line) === true);
}
function isNotBlank(str) {
  return str.trim() !== "";
}
function isNotMeta(str) {
  return !str.startsWith("total");
}
const REGEX_NEWLINE = /\r?\n/;
function parseList(rawList) {
  const lines = rawList.split(REGEX_NEWLINE).filter(isNotBlank).filter(isNotMeta);
  if (lines.length === 0) {
    return [];
  }
  const testLine2 = lines[lines.length - 1];
  const parser2 = firstCompatibleParser(testLine2, availableParsers);
  if (!parser2) {
    throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");
  }
  const files2 = lines.map(parser2.parseLine).filter((info) => info !== void 0);
  return parser2.transformList(files2);
}
parseList$1.parseList = parseList;
var ProgressTracker$1 = {};
Object.defineProperty(ProgressTracker$1, "__esModule", { value: true });
ProgressTracker$1.ProgressTracker = void 0;
class ProgressTracker {
  constructor() {
    this.bytesOverall = 0;
    this.intervalMs = 500;
    this.onStop = noop$2;
    this.onHandle = noop$2;
  }
  /**
   * Register a new handler for progress info. Use `undefined` to disable reporting.
   */
  reportTo(onHandle = noop$2) {
    this.onHandle = onHandle;
  }
  /**
   * Start tracking transfer progress of a socket.
   *
   * @param socket  The socket to observe.
   * @param name  A name associated with this progress tracking, e.g. a filename.
   * @param type  The type of the transfer, typically "upload" or "download".
   */
  start(socket, name2, type) {
    let lastBytes = 0;
    this.onStop = poll(this.intervalMs, () => {
      const bytes = socket.bytesRead + socket.bytesWritten;
      this.bytesOverall += bytes - lastBytes;
      lastBytes = bytes;
      this.onHandle({
        name: name2,
        type,
        bytes,
        bytesOverall: this.bytesOverall
      });
    });
  }
  /**
   * Stop tracking transfer progress.
   */
  stop() {
    this.onStop(false);
  }
  /**
   * Call the progress handler one more time, then stop tracking.
   */
  updateAndStop() {
    this.onStop(true);
  }
}
ProgressTracker$1.ProgressTracker = ProgressTracker;
function poll(intervalMs, updateFunc) {
  const id = setInterval(updateFunc, intervalMs);
  const stopFunc = (stopWithUpdate) => {
    clearInterval(id);
    if (stopWithUpdate) {
      updateFunc();
    }
    updateFunc = noop$2;
  };
  updateFunc();
  return stopFunc;
}
function noop$2() {
}
var StringWriter$1 = {};
Object.defineProperty(StringWriter$1, "__esModule", { value: true });
StringWriter$1.StringWriter = void 0;
const stream_1$2 = require$$0$5;
class StringWriter extends stream_1$2.Writable {
  constructor() {
    super(...arguments);
    this.buf = Buffer.alloc(0);
  }
  _write(chunk, _2, callback) {
    if (chunk instanceof Buffer) {
      this.buf = Buffer.concat([this.buf, chunk]);
      callback(null);
    } else {
      callback(new Error("StringWriter expects chunks of type 'Buffer'."));
    }
  }
  getText(encoding) {
    return this.buf.toString(encoding);
  }
}
StringWriter$1.StringWriter = StringWriter;
var netUtils = {};
Object.defineProperty(netUtils, "__esModule", { value: true });
netUtils.ipIsPrivateV4Address = netUtils.upgradeSocket = netUtils.describeAddress = netUtils.describeTLS = void 0;
const tls_1$2 = require$$1$1;
function describeTLS(socket) {
  if (socket instanceof tls_1$2.TLSSocket) {
    const protocol = socket.getProtocol();
    return protocol ? protocol : "Server socket or disconnected client socket";
  }
  return "No encryption";
}
netUtils.describeTLS = describeTLS;
function describeAddress(socket) {
  if (socket.remoteFamily === "IPv6") {
    return `[${socket.remoteAddress}]:${socket.remotePort}`;
  }
  return `${socket.remoteAddress}:${socket.remotePort}`;
}
netUtils.describeAddress = describeAddress;
function upgradeSocket(socket, options) {
  return new Promise((resolve2, reject) => {
    const tlsOptions = Object.assign({}, options, {
      socket
    });
    const tlsSocket = (0, tls_1$2.connect)(tlsOptions, () => {
      const expectCertificate = tlsOptions.rejectUnauthorized !== false;
      if (expectCertificate && !tlsSocket.authorized) {
        reject(tlsSocket.authorizationError);
      } else {
        tlsSocket.removeAllListeners("error");
        resolve2(tlsSocket);
      }
    }).once("error", (error) => {
      reject(error);
    });
  });
}
netUtils.upgradeSocket = upgradeSocket;
function ipIsPrivateV4Address(ip2 = "") {
  if (ip2.startsWith("::ffff:")) {
    ip2 = ip2.substr(7);
  }
  const octets = ip2.split(".").map((o2) => parseInt(o2, 10));
  return octets[0] === 10 || octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31 || octets[0] === 192 && octets[1] === 168 || ip2 === "127.0.0.1";
}
netUtils.ipIsPrivateV4Address = ipIsPrivateV4Address;
var transfer = {};
Object.defineProperty(transfer, "__esModule", { value: true });
transfer.downloadTo = transfer.uploadFrom = transfer.connectForPassiveTransfer = transfer.parsePasvResponse = transfer.enterPassiveModeIPv4 = transfer.parseEpsvResponse = transfer.enterPassiveModeIPv6 = void 0;
const netUtils_1$1 = netUtils;
const stream_1$1 = require$$0$5;
const tls_1$1 = require$$1$1;
const parseControlResponse_1$1 = parseControlResponse$1;
async function enterPassiveModeIPv6(ftp2) {
  const res = await ftp2.request("EPSV");
  const port = parseEpsvResponse(res.message);
  if (!port) {
    throw new Error("Can't parse EPSV response: " + res.message);
  }
  const controlHost = ftp2.socket.remoteAddress;
  if (controlHost === void 0) {
    throw new Error("Control socket is disconnected, can't get remote address.");
  }
  await connectForPassiveTransfer(controlHost, port, ftp2);
  return res;
}
transfer.enterPassiveModeIPv6 = enterPassiveModeIPv6;
function parseEpsvResponse(message2) {
  const groups = message2.match(/[|!]{3}(.+)[|!]/);
  if (groups === null || groups[1] === void 0) {
    throw new Error(`Can't parse response to 'EPSV': ${message2}`);
  }
  const port = parseInt(groups[1], 10);
  if (Number.isNaN(port)) {
    throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message2}`);
  }
  return port;
}
transfer.parseEpsvResponse = parseEpsvResponse;
async function enterPassiveModeIPv4(ftp2) {
  const res = await ftp2.request("PASV");
  const target = parsePasvResponse(res.message);
  if (!target) {
    throw new Error("Can't parse PASV response: " + res.message);
  }
  const controlHost = ftp2.socket.remoteAddress;
  if ((0, netUtils_1$1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1$1.ipIsPrivateV4Address)(controlHost)) {
    target.host = controlHost;
  }
  await connectForPassiveTransfer(target.host, target.port, ftp2);
  return res;
}
transfer.enterPassiveModeIPv4 = enterPassiveModeIPv4;
function parsePasvResponse(message2) {
  const groups = message2.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
  if (groups === null || groups.length !== 4) {
    throw new Error(`Can't parse response to 'PASV': ${message2}`);
  }
  return {
    host: groups[1].replace(/,/g, "."),
    port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)
  };
}
transfer.parsePasvResponse = parsePasvResponse;
function connectForPassiveTransfer(host, port, ftp2) {
  return new Promise((resolve2, reject) => {
    let socket = ftp2._newSocket();
    const handleConnErr = function(err) {
      err.message = "Can't open data connection in passive mode: " + err.message;
      reject(err);
    };
    const handleTimeout = function() {
      socket.destroy();
      reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));
    };
    socket.setTimeout(ftp2.timeout);
    socket.on("error", handleConnErr);
    socket.on("timeout", handleTimeout);
    socket.connect({ port, host, family: ftp2.ipFamily }, () => {
      if (ftp2.socket instanceof tls_1$1.TLSSocket) {
        socket = (0, tls_1$1.connect)(Object.assign({}, ftp2.tlsOptions, {
          socket,
          // Reuse the TLS session negotiated earlier when the control connection
          // was upgraded. Servers expect this because it provides additional
          // security: If a completely new session would be negotiated, a hacker
          // could guess the port and connect to the new data connection before we do
          // by just starting his/her own TLS session.
          session: ftp2.socket.getSession()
        }));
      }
      socket.removeListener("error", handleConnErr);
      socket.removeListener("timeout", handleTimeout);
      ftp2.dataSocket = socket;
      resolve2();
    });
  });
}
transfer.connectForPassiveTransfer = connectForPassiveTransfer;
class TransferResolver {
  /**
   * Instantiate a TransferResolver
   */
  constructor(ftp2, progress) {
    this.ftp = ftp2;
    this.progress = progress;
    this.response = void 0;
    this.dataTransferDone = false;
  }
  /**
   * Mark the beginning of a transfer.
   *
   * @param name - Name of the transfer, usually the filename.
   * @param type - Type of transfer, usually "upload" or "download".
   */
  onDataStart(name2, type) {
    if (this.ftp.dataSocket === void 0) {
      throw new Error("Data transfer should start but there is no data connection.");
    }
    this.ftp.socket.setTimeout(0);
    this.ftp.dataSocket.setTimeout(this.ftp.timeout);
    this.progress.start(this.ftp.dataSocket, name2, type);
  }
  /**
   * The data connection has finished the transfer.
   */
  onDataDone(task) {
    this.progress.updateAndStop();
    this.ftp.socket.setTimeout(this.ftp.timeout);
    if (this.ftp.dataSocket) {
      this.ftp.dataSocket.setTimeout(0);
    }
    this.dataTransferDone = true;
    this.tryResolve(task);
  }
  /**
   * The control connection reports the transfer as finished.
   */
  onControlDone(task, response) {
    this.response = response;
    this.tryResolve(task);
  }
  /**
   * An error has been reported and the task should be rejected.
   */
  onError(task, err) {
    this.progress.updateAndStop();
    this.ftp.socket.setTimeout(this.ftp.timeout);
    this.ftp.dataSocket = void 0;
    task.reject(err);
  }
  /**
   * Control connection sent an unexpected request requiring a response from our part. We
   * can't provide that (because unknown) and have to close the contrext with an error because
   * the FTP server is now caught up in a state we can't resolve.
   */
  onUnexpectedRequest(response) {
    const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);
    this.ftp.closeWithError(err);
  }
  tryResolve(task) {
    const canResolve = this.dataTransferDone && this.response !== void 0;
    if (canResolve) {
      this.ftp.dataSocket = void 0;
      task.resolve(this.response);
    }
  }
}
function uploadFrom(source2, config2) {
  const resolver = new TransferResolver(config2.ftp, config2.tracker);
  const fullCommand = `${config2.command} ${config2.remotePath}`;
  return config2.ftp.handle(fullCommand, (res, task) => {
    if (res instanceof Error) {
      resolver.onError(task, res);
    } else if (res.code === 150 || res.code === 125) {
      const dataSocket = config2.ftp.dataSocket;
      if (!dataSocket) {
        resolver.onError(task, new Error("Upload should begin but no data connection is available."));
        return;
      }
      const canUpload = "getCipher" in dataSocket ? dataSocket.getCipher() !== void 0 : true;
      onConditionOrEvent(canUpload, dataSocket, "secureConnect", () => {
        config2.ftp.log(`Uploading to ${(0, netUtils_1$1.describeAddress)(dataSocket)} (${(0, netUtils_1$1.describeTLS)(dataSocket)})`);
        resolver.onDataStart(config2.remotePath, config2.type);
        (0, stream_1$1.pipeline)(source2, dataSocket, (err) => {
          if (err) {
            resolver.onError(task, err);
          } else {
            resolver.onDataDone(task);
          }
        });
      });
    } else if ((0, parseControlResponse_1$1.positiveCompletion)(res.code)) {
      resolver.onControlDone(task, res);
    } else if ((0, parseControlResponse_1$1.positiveIntermediate)(res.code)) {
      resolver.onUnexpectedRequest(res);
    }
  });
}
transfer.uploadFrom = uploadFrom;
function downloadTo(destination, config2) {
  if (!config2.ftp.dataSocket) {
    throw new Error("Download will be initiated but no data connection is available.");
  }
  const resolver = new TransferResolver(config2.ftp, config2.tracker);
  return config2.ftp.handle(config2.command, (res, task) => {
    if (res instanceof Error) {
      resolver.onError(task, res);
    } else if (res.code === 150 || res.code === 125) {
      const dataSocket = config2.ftp.dataSocket;
      if (!dataSocket) {
        resolver.onError(task, new Error("Download should begin but no data connection is available."));
        return;
      }
      config2.ftp.log(`Downloading from ${(0, netUtils_1$1.describeAddress)(dataSocket)} (${(0, netUtils_1$1.describeTLS)(dataSocket)})`);
      resolver.onDataStart(config2.remotePath, config2.type);
      (0, stream_1$1.pipeline)(dataSocket, destination, (err) => {
        if (err) {
          resolver.onError(task, err);
        } else {
          resolver.onDataDone(task);
        }
      });
    } else if (res.code === 350) {
      config2.ftp.send("RETR " + config2.remotePath);
    } else if ((0, parseControlResponse_1$1.positiveCompletion)(res.code)) {
      resolver.onControlDone(task, res);
    } else if ((0, parseControlResponse_1$1.positiveIntermediate)(res.code)) {
      resolver.onUnexpectedRequest(res);
    }
  });
}
transfer.downloadTo = downloadTo;
function onConditionOrEvent(condition, emitter, eventName, action) {
  if (condition === true) {
    action();
  } else {
    emitter.once(eventName, () => action());
  }
}
Object.defineProperty(Client$1, "__esModule", { value: true });
Client$1.Client = void 0;
const fs_1 = fs$o;
const path_1$1 = path$e;
const tls_1 = require$$1$1;
const util_1$6 = require$$4;
const FtpContext_1 = FtpContext;
const parseList_1 = parseList$1;
const ProgressTracker_1 = ProgressTracker$1;
const StringWriter_1 = StringWriter$1;
const parseListMLSD_1 = parseListMLSD;
const netUtils_1 = netUtils;
const transfer_1 = transfer;
const parseControlResponse_1 = parseControlResponse$1;
const fsReadDir = (0, util_1$6.promisify)(fs_1.readdir);
const fsMkDir = (0, util_1$6.promisify)(fs_1.mkdir);
const fsStat = (0, util_1$6.promisify)(fs_1.stat);
const fsOpen = (0, util_1$6.promisify)(fs_1.open);
const fsClose = (0, util_1$6.promisify)(fs_1.close);
const fsUnlink = (0, util_1$6.promisify)(fs_1.unlink);
const LIST_COMMANDS_DEFAULT = () => ["LIST -a", "LIST"];
const LIST_COMMANDS_MLSD = () => ["MLSD", "LIST -a", "LIST"];
class Client {
  /**
   * Instantiate an FTP client.
   *
   * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.
   */
  constructor(timeout2 = 3e4) {
    this.availableListCommands = LIST_COMMANDS_DEFAULT();
    this.ftp = new FtpContext_1.FTPContext(timeout2);
    this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);
    this.parseList = parseList_1.parseList;
    this._progressTracker = new ProgressTracker_1.ProgressTracker();
  }
  /**
   * Close the client and all open socket connections.
   *
   * Close the client and all open socket connections. The client cant be used anymore after calling this method,
   * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.
   * A client is also closed automatically if any timeout or connection error occurs.
   */
  close() {
    this.ftp.close();
    this._progressTracker.stop();
  }
  /**
   * Returns true if the client is closed and can't be used anymore.
   */
  get closed() {
    return this.ftp.closed;
  }
  /**
   * Connect (or reconnect) to an FTP server.
   *
   * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
   * instance. Whenever you do, the client is reset with a new control connection. This also implies that
   * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
   * method. In fact, reconnecting is the only way to continue using a closed `Client`.
   *
   * @param host  Host the client should connect to. Optional, default is "localhost".
   * @param port  Port the client should connect to. Optional, default is 21.
   */
  connect(host = "localhost", port = 21) {
    this.ftp.reset();
    this.ftp.socket.connect({
      host,
      port,
      family: this.ftp.ipFamily
    }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
    return this._handleConnectResponse();
  }
  /**
   * As `connect` but using implicit TLS. Implicit TLS is not an FTP standard and has been replaced by
   * explicit TLS. There are still FTP servers that support only implicit TLS, though.
   */
  connectImplicitTLS(host = "localhost", port = 21, tlsOptions = {}) {
    this.ftp.reset();
    this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
    this.ftp.tlsOptions = tlsOptions;
    return this._handleConnectResponse();
  }
  /**
   * Handles the first reponse by an FTP server after the socket connection has been established.
   */
  _handleConnectResponse() {
    return this.ftp.handle(void 0, (res, task) => {
      if (res instanceof Error) {
        task.reject(res);
      } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
        task.resolve(res);
      } else {
        task.reject(new FtpContext_1.FTPError(res));
      }
    });
  }
  /**
   * Send an FTP command and handle the first response.
   */
  send(command, ignoreErrorCodesDEPRECATED = false) {
    if (ignoreErrorCodesDEPRECATED) {
      this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).");
      return this.sendIgnoringError(command);
    }
    return this.ftp.request(command);
  }
  /**
   * Send an FTP command and ignore an FTP error response. Any other kind of error or timeout will still reject the Promise.
   *
   * @param command
   */
  sendIgnoringError(command) {
    return this.ftp.handle(command, (res, task) => {
      if (res instanceof FtpContext_1.FTPError) {
        task.resolve({ code: res.code, message: res.message });
      } else if (res instanceof Error) {
        task.reject(res);
      } else {
        task.resolve(res);
      }
    });
  }
  /**
   * Upgrade the current socket connection to TLS.
   *
   * @param options  TLS options as in `tls.connect(options)`, optional.
   * @param command  Set the authentication command. Optional, default is "AUTH TLS".
   */
  async useTLS(options = {}, command = "AUTH TLS") {
    const ret = await this.send(command);
    this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);
    this.ftp.tlsOptions = options;
    this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
    return ret;
  }
  /**
   * Login a user with a password.
   *
   * @param user  Username to use for login. Optional, default is "anonymous".
   * @param password  Password to use for login. Optional, default is "guest".
   */
  login(user = "anonymous", password = "guest") {
    this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
    return this.ftp.handle("USER " + user, (res, task) => {
      if (res instanceof Error) {
        task.reject(res);
      } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {
        task.resolve(res);
      } else if (res.code === 331) {
        this.ftp.send("PASS " + password);
      } else {
        task.reject(new FtpContext_1.FTPError(res));
      }
    });
  }
  /**
   * Set the usual default settings.
   *
   * Settings used:
   * * Binary mode (TYPE I)
   * * File structure (STRU F)
   * * Additional settings for FTPS (PBSZ 0, PROT P)
   */
  async useDefaultSettings() {
    const features = await this.features();
    const supportsMLSD = features.has("MLST");
    this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD() : LIST_COMMANDS_DEFAULT();
    await this.send("TYPE I");
    await this.sendIgnoringError("STRU F");
    await this.sendIgnoringError("OPTS UTF8 ON");
    if (supportsMLSD) {
      await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;");
    }
    if (this.ftp.hasTLS) {
      await this.sendIgnoringError("PBSZ 0");
      await this.sendIgnoringError("PROT P");
    }
  }
  /**
   * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.
   *
   * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
   * instance. Whenever you do, the client is reset with a new control connection. This also implies that
   * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
   * method. In fact, reconnecting is the only way to continue using a closed `Client`.
   */
  async access(options = {}) {
    var _a3, _b3;
    const useExplicitTLS = options.secure === true;
    const useImplicitTLS = options.secure === "implicit";
    let welcome;
    if (useImplicitTLS) {
      welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);
    } else {
      welcome = await this.connect(options.host, options.port);
    }
    if (useExplicitTLS) {
      const secureOptions = (_a3 = options.secureOptions) !== null && _a3 !== void 0 ? _a3 : {};
      secureOptions.host = (_b3 = secureOptions.host) !== null && _b3 !== void 0 ? _b3 : options.host;
      await this.useTLS(secureOptions);
    }
    await this.sendIgnoringError("OPTS UTF8 ON");
    await this.login(options.user, options.password);
    await this.useDefaultSettings();
    return welcome;
  }
  /**
   * Get the current working directory.
   */
  async pwd() {
    const res = await this.send("PWD");
    const parsed = res.message.match(/"(.+)"/);
    if (parsed === null || parsed[1] === void 0) {
      throw new Error(`Can't parse response to command 'PWD': ${res.message}`);
    }
    return parsed[1];
  }
  /**
   * Get a description of supported features.
   *
   * This sends the FEAT command and parses the result into a Map where keys correspond to available commands
   * and values hold further information. Be aware that your FTP servers might not support this
   * command in which case this method will not throw an exception but just return an empty Map.
   */
  async features() {
    const res = await this.sendIgnoringError("FEAT");
    const features = /* @__PURE__ */ new Map();
    if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {
      res.message.split("\n").slice(1, -1).forEach((line) => {
        const entry = line.trim().split(" ");
        features.set(entry[0], entry[1] || "");
      });
    }
    return features;
  }
  /**
   * Set the working directory.
   */
  async cd(path2) {
    const validPath = await this.protectWhitespace(path2);
    return this.send("CWD " + validPath);
  }
  /**
   * Switch to the parent directory of the working directory.
   */
  async cdup() {
    return this.send("CDUP");
  }
  /**
   * Get the last modified time of a file. This is not supported by every FTP server, in which case
   * calling this method will throw an exception.
   */
  async lastMod(path2) {
    const validPath = await this.protectWhitespace(path2);
    const res = await this.send(`MDTM ${validPath}`);
    const date = res.message.slice(4);
    return (0, parseListMLSD_1.parseMLSxDate)(date);
  }
  /**
   * Get the size of a file.
   */
  async size(path2) {
    const validPath = await this.protectWhitespace(path2);
    const command = `SIZE ${validPath}`;
    const res = await this.send(command);
    const size = parseInt(res.message.slice(4), 10);
    if (Number.isNaN(size)) {
      throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);
    }
    return size;
  }
  /**
   * Rename a file.
   *
   * Depending on the FTP server this might also be used to move a file from one
   * directory to another by providing full paths.
   */
  async rename(srcPath, destPath) {
    const validSrc = await this.protectWhitespace(srcPath);
    const validDest = await this.protectWhitespace(destPath);
    await this.send("RNFR " + validSrc);
    return this.send("RNTO " + validDest);
  }
  /**
   * Remove a file from the current working directory.
   *
   * You can ignore FTP error return codes which won't throw an exception if e.g.
   * the file doesn't exist.
   */
  async remove(path2, ignoreErrorCodes = false) {
    const validPath = await this.protectWhitespace(path2);
    if (ignoreErrorCodes) {
      return this.sendIgnoringError(`DELE ${validPath}`);
    }
    return this.send(`DELE ${validPath}`);
  }
  /**
   * Report transfer progress for any upload or download to a given handler.
   *
   * This will also reset the overall transfer counter that can be used for multiple transfers. You can
   * also call the function without a handler to stop reporting to an earlier one.
   *
   * @param handler  Handler function to call on transfer progress.
   */
  trackProgress(handler) {
    this._progressTracker.bytesOverall = 0;
    this._progressTracker.reportTo(handler);
  }
  /**
   * Upload data from a readable stream or a local file to a remote file.
   *
   * @param source  Readable stream or path to a local file.
   * @param toRemotePath  Path to a remote file to write to.
   */
  async uploadFrom(source2, toRemotePath, options = {}) {
    return this._uploadWithCommand(source2, toRemotePath, "STOR", options);
  }
  /**
   * Upload data from a readable stream or a local file by appending it to an existing file. If the file doesn't
   * exist the FTP server should create it.
   *
   * @param source  Readable stream or path to a local file.
   * @param toRemotePath  Path to a remote file to write to.
   */
  async appendFrom(source2, toRemotePath, options = {}) {
    return this._uploadWithCommand(source2, toRemotePath, "APPE", options);
  }
  /**
   * @protected
   */
  async _uploadWithCommand(source2, remotePath, command, options) {
    if (typeof source2 === "string") {
      return this._uploadLocalFile(source2, remotePath, command, options);
    }
    return this._uploadFromStream(source2, remotePath, command);
  }
  /**
   * @protected
   */
  async _uploadLocalFile(localPath, remotePath, command, options) {
    const fd = await fsOpen(localPath, "r");
    const source2 = (0, fs_1.createReadStream)("", {
      fd,
      start: options.localStart,
      end: options.localEndInclusive,
      autoClose: false
    });
    try {
      return await this._uploadFromStream(source2, remotePath, command);
    } finally {
      await ignoreError(() => fsClose(fd));
    }
  }
  /**
   * @protected
   */
  async _uploadFromStream(source2, remotePath, command) {
    const onError = (err) => this.ftp.closeWithError(err);
    source2.once("error", onError);
    try {
      const validPath = await this.protectWhitespace(remotePath);
      await this.prepareTransfer(this.ftp);
      return await (0, transfer_1.uploadFrom)(source2, {
        ftp: this.ftp,
        tracker: this._progressTracker,
        command,
        remotePath: validPath,
        type: "upload"
      });
    } finally {
      source2.removeListener("error", onError);
    }
  }
  /**
   * Download a remote file and pipe its data to a writable stream or to a local file.
   *
   * You can optionally define at which position of the remote file you'd like to start
   * downloading. If the destination you provide is a file, the offset will be applied
   * to it as well. For example: To resume a failed download, you'd request the size of
   * the local, partially downloaded file and use that as the offset. Assuming the size
   * is 23, you'd download the rest using `downloadTo("local.txt", "remote.txt", 23)`.
   *
   * @param destination  Stream or path for a local file to write to.
   * @param fromRemotePath  Path of the remote file to read from.
   * @param startAt  Position within the remote file to start downloading at. If the destination is a file, this offset is also applied to it.
   */
  async downloadTo(destination, fromRemotePath, startAt = 0) {
    if (typeof destination === "string") {
      return this._downloadToFile(destination, fromRemotePath, startAt);
    }
    return this._downloadToStream(destination, fromRemotePath, startAt);
  }
  /**
   * @protected
   */
  async _downloadToFile(localPath, remotePath, startAt) {
    const appendingToLocalFile = startAt > 0;
    const fileSystemFlags = appendingToLocalFile ? "r+" : "w";
    const fd = await fsOpen(localPath, fileSystemFlags);
    const destination = (0, fs_1.createWriteStream)("", {
      fd,
      start: startAt,
      autoClose: false
    });
    try {
      return await this._downloadToStream(destination, remotePath, startAt);
    } catch (err) {
      const localFileStats = await ignoreError(() => fsStat(localPath));
      const hasDownloadedData = localFileStats && localFileStats.size > 0;
      const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;
      if (shouldRemoveLocalFile) {
        await ignoreError(() => fsUnlink(localPath));
      }
      throw err;
    } finally {
      await ignoreError(() => fsClose(fd));
    }
  }
  /**
   * @protected
   */
  async _downloadToStream(destination, remotePath, startAt) {
    const onError = (err) => this.ftp.closeWithError(err);
    destination.once("error", onError);
    try {
      const validPath = await this.protectWhitespace(remotePath);
      await this.prepareTransfer(this.ftp);
      return await (0, transfer_1.downloadTo)(destination, {
        ftp: this.ftp,
        tracker: this._progressTracker,
        command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,
        remotePath: validPath,
        type: "download"
      });
    } finally {
      destination.removeListener("error", onError);
      destination.end();
    }
  }
  /**
   * List files and directories in the current working directory, or from `path` if specified.
   *
   * @param [path]  Path to remote file or directory.
   */
  async list(path2 = "") {
    const validPath = await this.protectWhitespace(path2);
    let lastError;
    for (const candidate of this.availableListCommands) {
      const command = validPath === "" ? candidate : `${candidate} ${validPath}`;
      await this.prepareTransfer(this.ftp);
      try {
        const parsedList = await this._requestListWithCommand(command);
        this.availableListCommands = [candidate];
        return parsedList;
      } catch (err) {
        const shouldTryNext = err instanceof FtpContext_1.FTPError;
        if (!shouldTryNext) {
          throw err;
        }
        lastError = err;
      }
    }
    throw lastError;
  }
  /**
   * @protected
   */
  async _requestListWithCommand(command) {
    const buffer = new StringWriter_1.StringWriter();
    await (0, transfer_1.downloadTo)(buffer, {
      ftp: this.ftp,
      tracker: this._progressTracker,
      command,
      remotePath: "",
      type: "list"
    });
    const text = buffer.getText(this.ftp.encoding);
    this.ftp.log(text);
    return this.parseList(text);
  }
  /**
   * Remove a directory and all of its content.
   *
   * @param remoteDirPath  The path of the remote directory to delete.
   * @example client.removeDir("foo") // Remove directory 'foo' using a relative path.
   * @example client.removeDir("foo/bar") // Remove directory 'bar' using a relative path.
   * @example client.removeDir("/foo/bar") // Remove directory 'bar' using an absolute path.
   * @example client.removeDir("/") // Remove everything.
   */
  async removeDir(remoteDirPath) {
    return this._exitAtCurrentDirectory(async () => {
      await this.cd(remoteDirPath);
      const absoluteDirPath = await this.pwd();
      await this.clearWorkingDir();
      const dirIsRoot = absoluteDirPath === "/";
      if (!dirIsRoot) {
        await this.cdup();
        await this.removeEmptyDir(absoluteDirPath);
      }
    });
  }
  /**
   * Remove all files and directories in the working directory without removing
   * the working directory itself.
   */
  async clearWorkingDir() {
    for (const file2 of await this.list()) {
      if (file2.isDirectory) {
        await this.cd(file2.name);
        await this.clearWorkingDir();
        await this.cdup();
        await this.removeEmptyDir(file2.name);
      } else {
        await this.remove(file2.name);
      }
    }
  }
  /**
   * Upload the contents of a local directory to the remote working directory.
   *
   * This will overwrite existing files with the same names and reuse existing directories.
   * Unrelated files and directories will remain untouched. You can optionally provide a `remoteDirPath`
   * to put the contents inside a directory which will be created if necessary including all
   * intermediate directories. If you did provide a remoteDirPath the working directory will stay
   * the same as before calling this method.
   *
   * @param localDirPath  Local path, e.g. "foo/bar" or "../test"
   * @param [remoteDirPath]  Remote path of a directory to upload to. Working directory if undefined.
   */
  async uploadFromDir(localDirPath, remoteDirPath) {
    return this._exitAtCurrentDirectory(async () => {
      if (remoteDirPath) {
        await this.ensureDir(remoteDirPath);
      }
      return await this._uploadToWorkingDir(localDirPath);
    });
  }
  /**
   * @protected
   */
  async _uploadToWorkingDir(localDirPath) {
    const files2 = await fsReadDir(localDirPath);
    for (const file2 of files2) {
      const fullPath = (0, path_1$1.join)(localDirPath, file2);
      const stats = await fsStat(fullPath);
      if (stats.isFile()) {
        await this.uploadFrom(fullPath, file2);
      } else if (stats.isDirectory()) {
        await this._openDir(file2);
        await this._uploadToWorkingDir(fullPath);
        await this.cdup();
      }
    }
  }
  /**
   * Download all files and directories of the working directory to a local directory.
   *
   * @param localDirPath  The local directory to download to.
   * @param remoteDirPath  Remote directory to download. Current working directory if not specified.
   */
  async downloadToDir(localDirPath, remoteDirPath) {
    return this._exitAtCurrentDirectory(async () => {
      if (remoteDirPath) {
        await this.cd(remoteDirPath);
      }
      return await this._downloadFromWorkingDir(localDirPath);
    });
  }
  /**
   * @protected
   */
  async _downloadFromWorkingDir(localDirPath) {
    await ensureLocalDirectory(localDirPath);
    for (const file2 of await this.list()) {
      const localPath = (0, path_1$1.join)(localDirPath, file2.name);
      if (file2.isDirectory) {
        await this.cd(file2.name);
        await this._downloadFromWorkingDir(localPath);
        await this.cdup();
      } else if (file2.isFile) {
        await this.downloadTo(localPath, file2.name);
      }
    }
  }
  /**
   * Make sure a given remote path exists, creating all directories as necessary.
   * This function also changes the current working directory to the given path.
   */
  async ensureDir(remoteDirPath) {
    if (remoteDirPath.startsWith("/")) {
      await this.cd("/");
    }
    const names = remoteDirPath.split("/").filter((name2) => name2 !== "");
    for (const name2 of names) {
      await this._openDir(name2);
    }
  }
  /**
   * Try to create a directory and enter it. This will not raise an exception if the directory
   * couldn't be created if for example it already exists.
   * @protected
   */
  async _openDir(dirName) {
    await this.sendIgnoringError("MKD " + dirName);
    await this.cd(dirName);
  }
  /**
   * Remove an empty directory, will fail if not empty.
   */
  async removeEmptyDir(path2) {
    const validPath = await this.protectWhitespace(path2);
    return this.send(`RMD ${validPath}`);
  }
  /**
   * FTP servers can't handle filenames that have leading whitespace. This method transforms
   * a given path to fix that issue for most cases.
   */
  async protectWhitespace(path2) {
    if (!path2.startsWith(" ")) {
      return path2;
    }
    const pwd = await this.pwd();
    const absolutePathPrefix = pwd.endsWith("/") ? pwd : pwd + "/";
    return absolutePathPrefix + path2;
  }
  async _exitAtCurrentDirectory(func) {
    const userDir = await this.pwd();
    try {
      return await func();
    } finally {
      if (!this.closed) {
        await ignoreError(() => this.cd(userDir));
      }
    }
  }
  /**
   * Try all available transfer strategies and pick the first one that works. Update `client` to
   * use the working strategy for all successive transfer requests.
   *
   * @returns a function that will try the provided strategies.
   */
  _enterFirstCompatibleMode(strategies) {
    return async (ftp2) => {
      ftp2.log("Trying to find optimal transfer strategy...");
      let lastError = void 0;
      for (const strategy of strategies) {
        try {
          const res = await strategy(ftp2);
          ftp2.log("Optimal transfer strategy found.");
          this.prepareTransfer = strategy;
          return res;
        } catch (err) {
          lastError = err;
        }
      }
      throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);
    };
  }
  /**
   * DEPRECATED, use `uploadFrom`.
   * @deprecated
   */
  async upload(source2, toRemotePath, options = {}) {
    this.ftp.log("Warning: upload() has been deprecated, use uploadFrom().");
    return this.uploadFrom(source2, toRemotePath, options);
  }
  /**
   * DEPRECATED, use `appendFrom`.
   * @deprecated
   */
  async append(source2, toRemotePath, options = {}) {
    this.ftp.log("Warning: append() has been deprecated, use appendFrom().");
    return this.appendFrom(source2, toRemotePath, options);
  }
  /**
   * DEPRECATED, use `downloadTo`.
   * @deprecated
   */
  async download(destination, fromRemotePath, startAt = 0) {
    this.ftp.log("Warning: download() has been deprecated, use downloadTo().");
    return this.downloadTo(destination, fromRemotePath, startAt);
  }
  /**
   * DEPRECATED, use `uploadFromDir`.
   * @deprecated
   */
  async uploadDir(localDirPath, remoteDirPath) {
    this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir().");
    return this.uploadFromDir(localDirPath, remoteDirPath);
  }
  /**
   * DEPRECATED, use `downloadToDir`.
   * @deprecated
   */
  async downloadDir(localDirPath) {
    this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir().");
    return this.downloadToDir(localDirPath);
  }
}
Client$1.Client = Client;
async function ensureLocalDirectory(path2) {
  try {
    await fsStat(path2);
  } catch (err) {
    await fsMkDir(path2, { recursive: true });
  }
}
async function ignoreError(func) {
  try {
    return await func();
  } catch (err) {
    return void 0;
  }
}
var StringEncoding = {};
Object.defineProperty(StringEncoding, "__esModule", { value: true });
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.enterPassiveModeIPv6 = exports2.enterPassiveModeIPv4 = void 0;
  __exportStar2(Client$1, exports2);
  __exportStar2(FtpContext, exports2);
  __exportStar2(FileInfo$1, exports2);
  __exportStar2(parseList$1, exports2);
  __exportStar2(StringEncoding, exports2);
  var transfer_12 = transfer;
  Object.defineProperty(exports2, "enterPassiveModeIPv4", { enumerable: true, get: function() {
    return transfer_12.enterPassiveModeIPv4;
  } });
  Object.defineProperty(exports2, "enterPassiveModeIPv6", { enumerable: true, get: function() {
    return transfer_12.enterPassiveModeIPv6;
  } });
})(dist$5);
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ftp$1, "__esModule", { value: true });
ftp$1.ftp = void 0;
const basic_ftp_1 = dist$5;
const stream_1 = require$$0$5;
const path_1 = path$e;
const debug_1$5 = __importDefault$7(srcExports);
const notfound_1 = __importDefault$7(notfound);
const notmodified_1 = __importDefault$7(notmodified);
const debug$5 = (0, debug_1$5.default)("get-uri:ftp");
const ftp = async (url, opts = {}) => {
  const { cache } = opts;
  const filepath = decodeURIComponent(url.pathname);
  let lastModified;
  if (!filepath) {
    throw new TypeError('No "pathname"!');
  }
  const client = new basic_ftp_1.Client();
  try {
    const host = url.hostname || url.host || "localhost";
    const port = parseInt(url.port || "0", 10) || 21;
    const user = url.username ? decodeURIComponent(url.username) : void 0;
    const password = url.password ? decodeURIComponent(url.password) : void 0;
    await client.access({
      host,
      port,
      user,
      password,
      ...opts
    });
    try {
      lastModified = await client.lastMod(filepath);
    } catch (err) {
      if (err.code === 550) {
        throw new notfound_1.default();
      }
    }
    if (!lastModified) {
      const list = await client.list((0, path_1.dirname)(filepath));
      const name2 = (0, path_1.basename)(filepath);
      const entry = list.find((e2) => e2.name === name2);
      if (entry) {
        lastModified = entry.modifiedAt;
      }
    }
    if (lastModified) {
      if (isNotModified2()) {
        throw new notmodified_1.default();
      }
    } else {
      throw new notfound_1.default();
    }
    const stream2 = new stream_1.PassThrough();
    const rs = stream2;
    client.downloadTo(stream2, filepath).then((result) => {
      debug$5(result.message);
      client.close();
    });
    rs.lastModified = lastModified;
    return rs;
  } catch (err) {
    client.close();
    throw err;
  }
  function isNotModified2() {
    if ((cache == null ? void 0 : cache.lastModified) && lastModified) {
      return +cache.lastModified === +lastModified;
    }
    return false;
  }
};
ftp$1.ftp = ftp;
var http = {};
var httpError = {};
Object.defineProperty(httpError, "__esModule", { value: true });
const http_1$1 = require$$0$2;
class HTTPError extends Error {
  constructor(statusCode, message2 = http_1$1.STATUS_CODES[statusCode]) {
    super(message2);
    this.statusCode = statusCode;
    this.code = `E${String(message2).toUpperCase().replace(/\s+/g, "")}`;
  }
}
httpError.default = HTTPError;
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.http = void 0;
  const http_12 = __importDefault2(require$$0$2);
  const https_12 = __importDefault2(require$$1);
  const events_12 = require$$3$2;
  const debug_12 = __importDefault2(srcExports);
  const http_error_1 = __importDefault2(httpError);
  const notfound_12 = __importDefault2(notfound);
  const notmodified_12 = __importDefault2(notmodified);
  const debug2 = (0, debug_12.default)("get-uri:http");
  const http2 = async (url, opts = {}) => {
    debug2("GET %o", url.href);
    const cache = getCache(url, opts.cache);
    if (cache && isFresh(cache) && typeof cache.statusCode === "number") {
      const type2 = cache.statusCode / 100 | 0;
      if (type2 === 3 && cache.headers.location) {
        debug2("cached redirect");
        throw new Error("TODO: implement cached redirects!");
      }
      throw new notmodified_12.default();
    }
    const maxRedirects = typeof opts.maxRedirects === "number" ? opts.maxRedirects : 5;
    debug2("allowing %o max redirects", maxRedirects);
    let mod;
    if (opts.http) {
      mod = opts.http;
      debug2("using secure `https` core module");
    } else {
      mod = http_12.default;
      debug2("using `http` core module");
    }
    const options = { ...opts };
    if (cache) {
      if (!options.headers) {
        options.headers = {};
      }
      const lastModified = cache.headers["last-modified"];
      if (lastModified) {
        options.headers["If-Modified-Since"] = lastModified;
        debug2('added "If-Modified-Since" request header: %o', lastModified);
      }
      const etag = cache.headers.etag;
      if (etag) {
        options.headers["If-None-Match"] = etag;
        debug2('added "If-None-Match" request header: %o', etag);
      }
    }
    const req2 = mod.get(url, options);
    const [res] = await (0, events_12.once)(req2, "response");
    const code2 = res.statusCode || 0;
    res.date = Date.now();
    res.parsed = url;
    debug2("got %o response status code", code2);
    const type = code2 / 100 | 0;
    const location = res.headers.location;
    if (type === 3 && location) {
      if (!opts.redirects)
        opts.redirects = [];
      const redirects = opts.redirects;
      if (redirects.length < maxRedirects) {
        debug2('got a "redirect" status code with Location: %o', location);
        res.resume();
        redirects.push(res);
        const newUri = new URL(location, url.href);
        debug2("resolved redirect URL: %o", newUri.href);
        const left2 = maxRedirects - redirects.length;
        debug2("%o more redirects allowed after this one", left2);
        if (newUri.protocol !== url.protocol) {
          opts.http = newUri.protocol === "https:" ? https_12.default : void 0;
        }
        return (0, exports2.http)(newUri, opts);
      }
    }
    if (type !== 2) {
      res.resume();
      if (code2 === 304) {
        throw new notmodified_12.default();
      } else if (code2 === 404) {
        throw new notfound_12.default();
      }
      throw new http_error_1.default(code2);
    }
    if (opts.redirects) {
      res.redirects = opts.redirects;
    }
    return res;
  };
  exports2.http = http2;
  function isFresh(cache) {
    let fresh = false;
    let expires = parseInt(cache.headers.expires || "", 10);
    const cacheControl = cache.headers["cache-control"];
    if (cacheControl) {
      debug2("Cache-Control: %o", cacheControl);
      const parts = cacheControl.split(/,\s*?\b/);
      for (let i2 = 0; i2 < parts.length; i2++) {
        const part = parts[i2];
        const subparts = part.split("=");
        const name2 = subparts[0];
        switch (name2) {
          case "max-age":
            expires = (cache.date || 0) + parseInt(subparts[1], 10) * 1e3;
            fresh = Date.now() < expires;
            if (fresh) {
              debug2('cache is "fresh" due to previous %o Cache-Control param', part);
            }
            return fresh;
          case "must-revalidate":
            break;
          case "no-cache":
          case "no-store":
            debug2('cache is "stale" due to explicit %o Cache-Control param', name2);
            return false;
        }
      }
    } else if (expires) {
      debug2("Expires: %o", expires);
      fresh = Date.now() < expires;
      if (fresh) {
        debug2('cache is "fresh" due to previous Expires response header');
      }
      return fresh;
    }
    return false;
  }
  function getCache(url, cache) {
    if (cache) {
      if (cache.parsed && cache.parsed.href === url.href) {
        return cache;
      }
      if (cache.redirects) {
        for (let i2 = 0; i2 < cache.redirects.length; i2++) {
          const c2 = getCache(url, cache.redirects[i2]);
          if (c2) {
            return c2;
          }
        }
      }
    }
    return null;
  }
})(http);
var https$1 = {};
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(https$1, "__esModule", { value: true });
https$1.https = void 0;
const https_1 = __importDefault$6(require$$1);
const http_1 = http;
const https = (url, opts) => {
  return (0, http_1.http)(url, { ...opts, http: https_1.default });
};
https$1.https = https;
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getUri = exports2.isValidProtocol = exports2.protocols = void 0;
  const debug_12 = __importDefault2(srcExports);
  const data_1 = data$1;
  const file_1 = file$2;
  const ftp_1 = ftp$1;
  const http_12 = http;
  const https_12 = https$1;
  const debug2 = (0, debug_12.default)("get-uri");
  exports2.protocols = {
    data: data_1.data,
    file: file_1.file,
    ftp: ftp_1.ftp,
    http: http_12.http,
    https: https_12.https
  };
  const VALID_PROTOCOLS = new Set(Object.keys(exports2.protocols));
  function isValidProtocol(p2) {
    return VALID_PROTOCOLS.has(p2);
  }
  exports2.isValidProtocol = isValidProtocol;
  async function getUri(uri, opts) {
    debug2("getUri(%o)", uri);
    if (!uri) {
      throw new TypeError('Must pass in a URI to "getUri()"');
    }
    const url = typeof uri === "string" ? new URL(uri) : uri;
    const protocol = url.protocol.replace(/:$/, "");
    if (!isValidProtocol(protocol)) {
      throw new TypeError(`Unsupported protocol "${protocol}" specified in URI: "${uri}"`);
    }
    const getter = exports2.protocols[protocol];
    return getter(url, opts);
  }
  exports2.getUri = getUri;
})(dist$7);
var dist$4 = {};
var dist$3 = {};
var degenerator$1 = {};
var escodegen = {};
var estraverse = {};
(function(exports2) {
  (function clone2(exports3) {
    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
    function deepCopy(obj) {
      var ret = {}, key, val;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === "object" && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }
      return ret;
    }
    function upperBound(array, func) {
      var diff2, len, i2, current;
      len = array.length;
      i2 = 0;
      while (len) {
        diff2 = len >>> 1;
        current = i2 + diff2;
        if (func(array[current])) {
          len = diff2;
        } else {
          i2 = current + 1;
          len -= diff2 + 1;
        }
      }
      return i2;
    }
    Syntax = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      // CAUTION: It's deferred to ES7.
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: "ComprehensionExpression",
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      // CAUTION: It's deferred to ES7.
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      PrivateIdentifier: "PrivateIdentifier",
      Program: "Program",
      Property: "Property",
      PropertyDefinition: "PropertyDefinition",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    };
    VisitorKeys = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      // CAUTION: It's deferred to ES7.
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      PrivateIdentifier: [],
      Program: ["body"],
      Property: ["key", "value"],
      PropertyDefinition: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    };
    BREAK = {};
    SKIP = {};
    REMOVE = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE
    };
    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }
    Reference.prototype.replace = function replace2(node2) {
      this.parent[this.key] = node2;
    };
    Reference.prototype.remove = function remove2() {
      if (Array.isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };
    function Element2(node2, path2, wrap2, ref) {
      this.node = node2;
      this.path = path2;
      this.wrap = wrap2;
      this.ref = ref;
    }
    function Controller() {
    }
    Controller.prototype.path = function path2() {
      var i2, iz, j2, jz, result, element;
      function addToPath(result2, path3) {
        if (Array.isArray(path3)) {
          for (j2 = 0, jz = path3.length; j2 < jz; ++j2) {
            result2.push(path3[j2]);
          }
        } else {
          result2.push(path3);
        }
      }
      if (!this.__current.path) {
        return null;
      }
      result = [];
      for (i2 = 2, iz = this.__leavelist.length; i2 < iz; ++i2) {
        element = this.__leavelist[i2];
        addToPath(result, element.path);
      }
      addToPath(result, this.__current.path);
      return result;
    };
    Controller.prototype.type = function() {
      var node2 = this.current();
      return node2.type || this.__current.wrap;
    };
    Controller.prototype.parents = function parents() {
      var i2, iz, result;
      result = [];
      for (i2 = 1, iz = this.__leavelist.length; i2 < iz; ++i2) {
        result.push(this.__leavelist[i2].node);
      }
      return result;
    };
    Controller.prototype.current = function current() {
      return this.__current.node;
    };
    Controller.prototype.__execute = function __execute(callback, element) {
      var previous, result;
      result = void 0;
      previous = this.__current;
      this.__current = element;
      this.__state = null;
      if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
      }
      this.__current = previous;
      return result;
    };
    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    };
    Controller.prototype.skip = function() {
      this.notify(SKIP);
    };
    Controller.prototype["break"] = function() {
      this.notify(BREAK);
    };
    Controller.prototype.remove = function() {
      this.notify(REMOVE);
    };
    Controller.prototype.__initialize = function(root, visitor) {
      this.visitor = visitor;
      this.root = root;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = null;
      if (visitor.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof visitor.fallback === "function") {
        this.__fallback = visitor.fallback;
      }
      this.__keys = VisitorKeys;
      if (visitor.keys) {
        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
      }
    };
    function isNode2(node2) {
      if (node2 == null) {
        return false;
      }
      return typeof node2 === "object" && typeof node2.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
    }
    function candidateExistsInLeaveList(leavelist, candidate) {
      for (var i2 = leavelist.length - 1; i2 >= 0; --i2) {
        if (leavelist[i2].node === candidate) {
          return true;
        }
      }
      return false;
    }
    Controller.prototype.traverse = function traverse2(root, visitor) {
      var worklist, leavelist, element, node2, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      worklist.push(new Element2(root, null, null, null));
      leavelist.push(new Element2(null, null, null, null));
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          ret = this.__execute(visitor.leave, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          continue;
        }
        if (element.node) {
          ret = this.__execute(visitor.enter, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }
          node2 = element.node;
          nodeType = node2.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node2);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node2[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element2(candidate[current2], [key, current2], "Property", null);
                } else if (isNode2(candidate[current2])) {
                  element = new Element2(candidate[current2], [key, current2], null, null);
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode2(candidate)) {
              if (candidateExistsInLeaveList(leavelist, candidate)) {
                continue;
              }
              worklist.push(new Element2(candidate, key, null, null));
            }
          }
        }
      }
    };
    Controller.prototype.replace = function replace2(root, visitor) {
      var worklist, leavelist, node2, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
      function removeElem(element2) {
        var i2, key2, nextElem, parent;
        if (element2.ref.remove()) {
          key2 = element2.ref.key;
          parent = element2.ref.parent;
          i2 = worklist.length;
          while (i2--) {
            nextElem = worklist[i2];
            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key2) {
                break;
              }
              --nextElem.ref.key;
            }
          }
        }
      }
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      outer = {
        root
      };
      element = new Element2(root, null, null, new Reference(outer, "root"));
      worklist.push(element);
      leavelist.push(element);
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          target = this.__execute(visitor.leave, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          continue;
        }
        target = this.__execute(visitor.enter, element);
        if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
          element.ref.replace(target);
          element.node = target;
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
          element.node = null;
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        node2 = element.node;
        if (!node2) {
          continue;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || target === SKIP) {
          continue;
        }
        nodeType = node2.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node2);
          } else {
            throw new Error("Unknown node type " + nodeType + ".");
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node2[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element2(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
              } else if (isNode2(candidate[current2])) {
                element = new Element2(candidate[current2], [key, current2], null, new Reference(candidate, current2));
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode2(candidate)) {
            worklist.push(new Element2(candidate, key, null, new Reference(node2, key)));
          }
        }
      }
      return outer.root;
    };
    function traverse(root, visitor) {
      var controller = new Controller();
      return controller.traverse(root, visitor);
    }
    function replace(root, visitor) {
      var controller = new Controller();
      return controller.replace(root, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [comment.range[0], comment.range[1]];
      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }
      target -= 1;
      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }
      return comment;
    }
    function attachComments(tree, providedComments, tokens) {
      var comments = [], comment, len, i2, cursor;
      if (!tree.range) {
        throw new Error("attachComments needs range information");
      }
      if (!tokens.length) {
        if (providedComments.length) {
          for (i2 = 0, len = providedComments.length; i2 < len; i2 += 1) {
            comment = deepCopy(providedComments[i2]);
            comment.extendedRange = [0, tree.range[0]];
            comments.push(comment);
          }
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i2 = 0, len = providedComments.length; i2 < len; i2 += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i2]), tokens));
      }
      cursor = 0;
      traverse(tree, {
        enter: function(node2) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (comment2.extendedRange[1] > node2.range[0]) {
              break;
            }
            if (comment2.extendedRange[1] === node2.range[0]) {
              if (!node2.leadingComments) {
                node2.leadingComments = [];
              }
              node2.leadingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node2.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      cursor = 0;
      traverse(tree, {
        leave: function(node2) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (node2.range[1] < comment2.extendedRange[0]) {
              break;
            }
            if (node2.range[1] === comment2.extendedRange[0]) {
              if (!node2.trailingComments) {
                node2.trailingComments = [];
              }
              node2.trailingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node2.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      return tree;
    }
    exports3.Syntax = Syntax;
    exports3.traverse = traverse;
    exports3.replace = replace;
    exports3.attachComments = attachComments;
    exports3.VisitorKeys = VisitorKeys;
    exports3.VisitorOption = VisitorOption;
    exports3.Controller = Controller;
    exports3.cloneEnvironment = function() {
      return clone2({});
    };
    return exports3;
  })(exports2);
})(estraverse);
var utils = {};
var ast = { exports: {} };
(function() {
  function isExpression(node2) {
    if (node2 == null) {
      return false;
    }
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "Literal":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
        return true;
    }
    return false;
  }
  function isIterationStatement(node2) {
    if (node2 == null) {
      return false;
    }
    switch (node2.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
        return true;
    }
    return false;
  }
  function isStatement(node2) {
    if (node2 == null) {
      return false;
    }
    switch (node2.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
        return true;
    }
    return false;
  }
  function isSourceElement(node2) {
    return isStatement(node2) || node2 != null && node2.type === "FunctionDeclaration";
  }
  function trailingStatement(node2) {
    switch (node2.type) {
      case "IfStatement":
        if (node2.alternate != null) {
          return node2.alternate;
        }
        return node2.consequent;
      case "LabeledStatement":
      case "ForStatement":
      case "ForInStatement":
      case "WhileStatement":
      case "WithStatement":
        return node2.body;
    }
    return null;
  }
  function isProblematicIfStatement(node2) {
    var current;
    if (node2.type !== "IfStatement") {
      return false;
    }
    if (node2.alternate == null) {
      return false;
    }
    current = node2.consequent;
    do {
      if (current.type === "IfStatement") {
        if (current.alternate == null) {
          return true;
        }
      }
      current = trailingStatement(current);
    } while (current);
    return false;
  }
  ast.exports = {
    isExpression,
    isStatement,
    isIterationStatement,
    isSourceElement,
    isProblematicIfStatement,
    trailingStatement
  };
})();
var astExports = ast.exports;
var code = { exports: {} };
(function() {
  var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
  ES5Regex = {
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  };
  ES6Regex = {
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };
  function isDecimalDigit(ch2) {
    return 48 <= ch2 && ch2 <= 57;
  }
  function isHexDigit(ch2) {
    return 48 <= ch2 && ch2 <= 57 || // 0..9
    97 <= ch2 && ch2 <= 102 || // a..f
    65 <= ch2 && ch2 <= 70;
  }
  function isOctalDigit(ch2) {
    return ch2 >= 48 && ch2 <= 55;
  }
  NON_ASCII_WHITESPACES = [
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  function isWhiteSpace(ch2) {
    return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
  }
  function isLineTerminator(ch2) {
    return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
  }
  function fromCodePoint(cp) {
    if (cp <= 65535) {
      return String.fromCharCode(cp);
    }
    var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
    var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
    return cu1 + cu2;
  }
  IDENTIFIER_START = new Array(128);
  for (ch = 0; ch < 128; ++ch) {
    IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
    ch >= 65 && ch <= 90 || // A..Z
    ch === 36 || ch === 95;
  }
  IDENTIFIER_PART = new Array(128);
  for (ch = 0; ch < 128; ++ch) {
    IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
    ch >= 65 && ch <= 90 || // A..Z
    ch >= 48 && ch <= 57 || // 0..9
    ch === 36 || ch === 95;
  }
  function isIdentifierStartES5(ch2) {
    return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
  }
  function isIdentifierPartES5(ch2) {
    return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
  }
  function isIdentifierStartES6(ch2) {
    return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
  }
  function isIdentifierPartES6(ch2) {
    return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
  }
  code.exports = {
    isDecimalDigit,
    isHexDigit,
    isOctalDigit,
    isWhiteSpace,
    isLineTerminator,
    isIdentifierStartES5,
    isIdentifierPartES5,
    isIdentifierStartES6,
    isIdentifierPartES6
  };
})();
var codeExports = code.exports;
var keyword = { exports: {} };
(function() {
  var code2 = codeExports;
  function isStrictModeReservedWordES6(id) {
    switch (id) {
      case "implements":
      case "interface":
      case "package":
      case "private":
      case "protected":
      case "public":
      case "static":
      case "let":
        return true;
      default:
        return false;
    }
  }
  function isKeywordES5(id, strict) {
    if (!strict && id === "yield") {
      return false;
    }
    return isKeywordES6(id, strict);
  }
  function isKeywordES6(id, strict) {
    if (strict && isStrictModeReservedWordES6(id)) {
      return true;
    }
    switch (id.length) {
      case 2:
        return id === "if" || id === "in" || id === "do";
      case 3:
        return id === "var" || id === "for" || id === "new" || id === "try";
      case 4:
        return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
      case 5:
        return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
      case 6:
        return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
      case 7:
        return id === "default" || id === "finally" || id === "extends";
      case 8:
        return id === "function" || id === "continue" || id === "debugger";
      case 10:
        return id === "instanceof";
      default:
        return false;
    }
  }
  function isReservedWordES5(id, strict) {
    return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
  }
  function isReservedWordES6(id, strict) {
    return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
  }
  function isRestrictedWord(id) {
    return id === "eval" || id === "arguments";
  }
  function isIdentifierNameES5(id) {
    var i2, iz, ch;
    if (id.length === 0) {
      return false;
    }
    ch = id.charCodeAt(0);
    if (!code2.isIdentifierStartES5(ch)) {
      return false;
    }
    for (i2 = 1, iz = id.length; i2 < iz; ++i2) {
      ch = id.charCodeAt(i2);
      if (!code2.isIdentifierPartES5(ch)) {
        return false;
      }
    }
    return true;
  }
  function decodeUtf16(lead, trail) {
    return (lead - 55296) * 1024 + (trail - 56320) + 65536;
  }
  function isIdentifierNameES6(id) {
    var i2, iz, ch, lowCh, check;
    if (id.length === 0) {
      return false;
    }
    check = code2.isIdentifierStartES6;
    for (i2 = 0, iz = id.length; i2 < iz; ++i2) {
      ch = id.charCodeAt(i2);
      if (55296 <= ch && ch <= 56319) {
        ++i2;
        if (i2 >= iz) {
          return false;
        }
        lowCh = id.charCodeAt(i2);
        if (!(56320 <= lowCh && lowCh <= 57343)) {
          return false;
        }
        ch = decodeUtf16(ch, lowCh);
      }
      if (!check(ch)) {
        return false;
      }
      check = code2.isIdentifierPartES6;
    }
    return true;
  }
  function isIdentifierES5(id, strict) {
    return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
  }
  function isIdentifierES6(id, strict) {
    return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
  }
  keyword.exports = {
    isKeywordES5,
    isKeywordES6,
    isReservedWordES5,
    isReservedWordES6,
    isRestrictedWord,
    isIdentifierNameES5,
    isIdentifierNameES6,
    isIdentifierES5,
    isIdentifierES6
  };
})();
var keywordExports = keyword.exports;
(function() {
  utils.ast = astExports;
  utils.code = codeExports;
  utils.keyword = keywordExports;
})();
var sourceMap = {};
var sourceMapGenerator = {};
var base64Vlq = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64)
    return base64;
  hasRequiredBase64 = 1;
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  base64.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  base64.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  return base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq)
    return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base642 = requireBase64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base642.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base642.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}
var util$4 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$4;
  hasRequiredUtil = 1;
  (function(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path2 = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path2 = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path2);
      var parts = path2.split(/\/+/);
      for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
        part = parts[i2];
        if (part === ".") {
          parts.splice(i2, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i2 + 1, up);
            up = 0;
          } else {
            parts.splice(i2, 2);
            up--;
          }
        }
      }
      path2 = parts.join("/");
      if (path2 === "") {
        path2 = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path2;
        return urlGenerate(url);
      }
      return path2;
    }
    exports2.normalize = normalize;
    function join2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join2;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity2(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity2 : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity2 : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i2 = length - 10; i2 >= 0; i2--) {
        if (s2.charCodeAt(i2) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp2 = strcmp(mappingA.source, mappingB.source);
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalLine - mappingB.originalLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp2 !== 0 || onlyCompareOriginal) {
        return cmp2;
      }
      cmp2 = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp2 !== 0 || onlyCompareGenerated) {
        return cmp2;
      }
      cmp2 = strcmp(mappingA.source, mappingB.source);
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalLine - mappingB.originalLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp2 = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = strcmp(mappingA.source, mappingB.source);
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalLine - mappingB.originalLine;
      if (cmp2 !== 0) {
        return cmp2;
      }
      cmp2 = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp2 !== 0) {
        return cmp2;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join2(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  })(util$4);
  return util$4;
}
var arraySet = {};
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet)
    return arraySet;
  hasRequiredArraySet = 1;
  var util2 = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
      set.add(aArray[i2], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util2.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util2.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}
var mappingList = {};
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList)
    return mappingList;
  hasRequiredMappingList = 1;
  var util2 = requireUtil();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util2.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator)
    return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq();
  var util2 = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util2.getArg(aArgs, "file", null);
    this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util2.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util2.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util2.getArg(aArgs, "generated");
    var original = util2.getArg(aArgs, "original", null);
    var source2 = util2.getArg(aArgs, "source", null);
    var name2 = util2.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source2, name2);
    }
    if (source2 != null) {
      source2 = String(source2);
      if (!this._sources.has(source2)) {
        this._sources.add(source2);
      }
    }
    if (name2 != null) {
      name2 = String(name2);
      if (!this._names.has(name2)) {
        this._names.add(name2);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source2,
      name: name2
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source2 = aSourceFile;
    if (this._sourceRoot != null) {
      source2 = util2.relative(this._sourceRoot, source2);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = /* @__PURE__ */ Object.create(null);
      }
      this._sourcesContents[util2.toSetString(source2)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util2.toSetString(source2)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util2.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util2.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util2.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source2 = mapping.source;
      if (source2 != null && !newSources.has(source2)) {
        newSources.add(source2);
      }
      var name2 = mapping.name;
      if (name2 != null && !newNames.has(name2)) {
        newNames.add(name2);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util2.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
      mapping = mappings[i2];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i2 > 0) {
          if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source2) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source2 = util2.relative(aSourceRoot, source2);
      }
      var key = util2.toSetString(source2);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map2 = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map2.file = this._file;
    }
    if (this._sourceRoot != null) {
      map2.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
    }
    return map2;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}
var sourceMapConsumer = {};
var binarySearch = {};
var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch)
    return binarySearch;
  hasRequiredBinarySearch = 1;
  (function(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp2 = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp2 === 0) {
        return mid;
      } else if (cmp2 > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index2 = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index2 < 0) {
        return -1;
      }
      while (index2 - 1 >= 0) {
        if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
          break;
        }
        --index2;
      }
      return index2;
    };
  })(binarySearch);
  return binarySearch;
}
var quickSort = {};
var hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort)
    return quickSort;
  hasRequiredQuickSort = 1;
  function swap(ary, x2, y2) {
    var temp = ary[x2];
    ary[x2] = ary[y2];
    ary[y2] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator2, p2, r2) {
    if (p2 < r2) {
      var pivotIndex = randomIntInRange(p2, r2);
      var i2 = p2 - 1;
      swap(ary, pivotIndex, r2);
      var pivot = ary[r2];
      for (var j2 = p2; j2 < r2; j2++) {
        if (comparator2(ary[j2], pivot) <= 0) {
          i2 += 1;
          swap(ary, i2, j2);
        }
      }
      swap(ary, i2 + 1, j2);
      var q2 = i2 + 1;
      doQuickSort(ary, comparator2, p2, q2 - 1);
      doQuickSort(ary, comparator2, q2 + 1, r2);
    }
  }
  quickSort.quickSort = function(ary, comparator2) {
    doQuickSort(ary, comparator2, 0, ary.length - 1);
  };
  return quickSort;
}
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer)
    return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  var util2 = requireUtil();
  var binarySearch2 = requireBinarySearch();
  var ArraySet = requireArraySet().ArraySet;
  var base64VLQ = requireBase64Vlq();
  var quickSort2 = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
    var c2 = aStr.charAt(index2);
    return c2 === ";" || c2 === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context2 = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source2 = mapping.source === null ? null : this._sources.at(mapping.source);
      source2 = util2.computeSourceURL(sourceRoot, source2, this._sourceMapURL);
      return {
        source: source2,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context2);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util2.getArg(aArgs, "line");
    var needle = {
      source: util2.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util2.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index2 = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      binarySearch2.LEAST_UPPER_BOUND
    );
    if (index2 >= 0) {
      var mapping = this._originalMappings[index2];
      if (aArgs.column === void 0) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index2];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index2];
        }
      }
    }
    return mappings;
  };
  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap2, "version");
    var sources = util2.getArg(sourceMap2, "sources");
    var names = util2.getArg(sourceMap2, "names", []);
    var sourceRoot = util2.getArg(sourceMap2, "sourceRoot", null);
    var sourcesContent = util2.getArg(sourceMap2, "sourcesContent", null);
    var mappings = util2.getArg(sourceMap2, "mappings");
    var file2 = util2.getArg(sourceMap2, "file", null);
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    if (sourceRoot) {
      sourceRoot = util2.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util2.normalize).map(function(source2) {
      return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source2) ? util2.relative(sourceRoot, source2) : source2;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s2) {
      return util2.computeSourceURL(sourceRoot, s2, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file2;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i2;
    for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
      if (this._absoluteSources[i2] == aSource) {
        return i2;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(
      smc._sources.toArray(),
      smc.sourceRoot
    );
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s2) {
      return util2.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i2 = 0, length = generatedMappings.length; i2 < length; i2++) {
      var srcMapping = generatedMappings[i2];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort2(smc.__originalMappings, util2.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index2 = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index2 < length) {
      if (aStr.charAt(index2) === ";") {
        generatedLine++;
        index2++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index2) === ",") {
        index2++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index2; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index2, end);
        segment = cachedSegments[str];
        if (segment) {
          index2 += str.length;
        } else {
          segment = [];
          while (index2 < end) {
            base64VLQ.decode(aStr, index2, temp);
            value = temp.value;
            index2 = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort2(generatedMappings, util2.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort2(originalMappings, util2.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
      var mapping = this._generatedMappings[index2];
      if (index2 + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index2 + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var index2 = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util2.compareByGeneratedPositionsDeflated,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index2 >= 0) {
      var mapping = this._generatedMappings[index2];
      if (mapping.generatedLine === needle.generatedLine) {
        var source2 = util2.getArg(mapping, "source", null);
        if (source2 !== null) {
          source2 = this._sources.at(source2);
          source2 = util2.computeSourceURL(this.sourceRoot, source2, this._sourceMapURL);
        }
        var name2 = util2.getArg(mapping, "name", null);
        if (name2 !== null) {
          name2 = this._names.at(name2);
        }
        return {
          source: source2,
          line: util2.getArg(mapping, "originalLine", null),
          column: util2.getArg(mapping, "originalColumn", null),
          name: name2
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index2 = this._findSourceIndex(aSource);
    if (index2 >= 0) {
      return this.sourcesContent[index2];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util2.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source2 = util2.getArg(aArgs, "source");
    source2 = this._findSourceIndex(source2);
    if (source2 < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source: source2,
      originalLine: util2.getArg(aArgs, "line"),
      originalColumn: util2.getArg(aArgs, "column")
    };
    var index2 = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index2 >= 0) {
      var mapping = this._originalMappings[index2];
      if (mapping.source === needle.source) {
        return {
          line: util2.getArg(mapping, "generatedLine", null),
          column: util2.getArg(mapping, "generatedColumn", null),
          lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap2, "version");
    var sections = util2.getArg(sourceMap2, "sections");
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s2) {
      if (s2.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util2.getArg(s2, "offset");
      var offsetLine = util2.getArg(offset, "line");
      var offsetColumn = util2.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util2.getArg(s2, "map"), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i2 = 0; i2 < this._sections.length; i2++) {
        for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++) {
          sources.push(this._sections[i2].consumer.sources[j2]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch2.search(
      needle,
      this._sections,
      function(needle2, section2) {
        var cmp2 = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp2) {
          return cmp2;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      }
    );
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s2) {
      return s2.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i2 = 0; i2 < this._sections.length; i2++) {
      var section = this._sections[i2];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i2 = 0; i2 < this._sections.length; i2++) {
      var section = this._sections[i2];
      if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i2 = 0; i2 < this._sections.length; i2++) {
      var section = this._sections[i2];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j2 = 0; j2 < sectionMappings.length; j2++) {
        var mapping = sectionMappings[j2];
        var source2 = section.consumer._sources.at(mapping.source);
        source2 = util2.computeSourceURL(section.consumer.sourceRoot, source2, this._sourceMapURL);
        this._sources.add(source2);
        source2 = this._sources.indexOf(source2);
        var name2 = null;
        if (mapping.name) {
          name2 = section.consumer._names.at(mapping.name);
          this._names.add(name2);
          name2 = this._names.indexOf(name2);
        }
        var adjustedMapping = {
          source: source2,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name2
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
    quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
  };
  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return sourceMapConsumer;
}
var sourceNode = {};
var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode)
    return sourceNode;
  hasRequiredSourceNode = 1;
  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  var util2 = requireUtil();
  var REGEX_NEWLINE2 = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node2 = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE2);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code2 = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code2);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node2.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node2.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node2.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util2.join(aRelativePath, sourceFile);
        }
        node2.setSourceContent(sourceFile, content);
      }
    });
    return node2;
    function addMappingWithCode(mapping, code2) {
      if (mapping === null || mapping.source === void 0) {
        node2.add(code2);
      } else {
        var source2 = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
        node2.add(new SourceNode(
          mapping.originalLine,
          mapping.originalColumn,
          source2,
          code2,
          mapping.name
        ));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
        this.prepend(aChunk[i2]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
      chunk = this.children[i2];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i2;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i2 = 0; i2 < len - 1; i2++) {
        newChildren.push(this.children[i2]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i2]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i2 = 0, len = this.children.length; i2 < len; i2++) {
      if (this.children[i2][isSourceNode]) {
        this.children[i2].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i2 = 0, len = sources.length; i2 < len; i2++) {
      aFn(util2.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map2 = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map2.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map2.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map2.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map2.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map: map2 };
  };
  sourceNode.SourceNode = SourceNode;
  return sourceNode;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap)
    return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}
const name = "escodegen";
const description = "ECMAScript code generator";
const homepage = "http://github.com/estools/escodegen";
const main$2 = "escodegen.js";
const bin = {
  esgenerate: "./bin/esgenerate.js",
  escodegen: "./bin/escodegen.js"
};
const files = [
  "LICENSE.BSD",
  "README.md",
  "bin",
  "escodegen.js",
  "package.json"
];
const version = "2.1.0";
const engines = {
  node: ">=6.0"
};
const maintainers = [
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "http://github.com/Constellation"
  }
];
const repository = {
  type: "git",
  url: "http://github.com/estools/escodegen.git"
};
const dependencies = {
  estraverse: "^5.2.0",
  esutils: "^2.0.2",
  esprima: "^4.0.1"
};
const optionalDependencies = {
  "source-map": "~0.6.1"
};
const devDependencies = {
  acorn: "^8.0.4",
  bluebird: "^3.4.7",
  "bower-registry-client": "^1.0.0",
  chai: "^4.2.0",
  "chai-exclude": "^2.0.2",
  "commonjs-everywhere": "^0.9.7",
  gulp: "^4.0.2",
  "gulp-eslint": "^6.0.0",
  "gulp-mocha": "^7.0.2",
  minimist: "^1.2.5",
  optionator: "^0.9.1",
  semver: "^7.3.4"
};
const license = "BSD-2-Clause";
const scripts = {
  test: "gulp travis",
  "unit-test": "gulp test",
  lint: "gulp lint",
  release: "node tools/release.js",
  "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
  build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
};
const require$$3 = {
  name,
  description,
  homepage,
  main: main$2,
  bin,
  files,
  version,
  engines,
  maintainers,
  repository,
  dependencies,
  optionalDependencies,
  devDependencies,
  license,
  scripts
};
(function(exports2) {
  (function() {
    var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse$1, esutils, base, indent, json2, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse2, sourceMap2, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
    estraverse$1 = estraverse;
    esutils = utils;
    Syntax = estraverse$1.Syntax;
    function isExpression(node2) {
      return CodeGenerator.Expression.hasOwnProperty(node2.type);
    }
    function isStatement(node2) {
      return CodeGenerator.Statement.hasOwnProperty(node2.type);
    }
    Precedence = {
      Sequence: 0,
      Yield: 1,
      Assignment: 1,
      Conditional: 2,
      ArrowFunction: 2,
      Coalesce: 3,
      LogicalOR: 4,
      LogicalAND: 5,
      BitwiseOR: 6,
      BitwiseXOR: 7,
      BitwiseAND: 8,
      Equality: 9,
      Relational: 10,
      BitwiseSHIFT: 11,
      Additive: 12,
      Multiplicative: 13,
      Exponentiation: 14,
      Await: 15,
      Unary: 15,
      Postfix: 16,
      OptionalChaining: 17,
      Call: 18,
      New: 19,
      TaggedTemplate: 20,
      Member: 21,
      Primary: 22
    };
    BinaryPrecedence = {
      "??": Precedence.Coalesce,
      "||": Precedence.LogicalOR,
      "&&": Precedence.LogicalAND,
      "|": Precedence.BitwiseOR,
      "^": Precedence.BitwiseXOR,
      "&": Precedence.BitwiseAND,
      "==": Precedence.Equality,
      "!=": Precedence.Equality,
      "===": Precedence.Equality,
      "!==": Precedence.Equality,
      "is": Precedence.Equality,
      "isnt": Precedence.Equality,
      "<": Precedence.Relational,
      ">": Precedence.Relational,
      "<=": Precedence.Relational,
      ">=": Precedence.Relational,
      "in": Precedence.Relational,
      "instanceof": Precedence.Relational,
      "<<": Precedence.BitwiseSHIFT,
      ">>": Precedence.BitwiseSHIFT,
      ">>>": Precedence.BitwiseSHIFT,
      "+": Precedence.Additive,
      "-": Precedence.Additive,
      "*": Precedence.Multiplicative,
      "%": Precedence.Multiplicative,
      "/": Precedence.Multiplicative,
      "**": Precedence.Exponentiation
    };
    var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5, F_FOUND_COALESCE = 1 << 6;
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
    var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
    function getDefaultOptions() {
      return {
        indent: null,
        base: null,
        parse: null,
        comment: false,
        format: {
          indent: {
            style: "    ",
            base: 0,
            adjustMultilineComment: false
          },
          newline: "\n",
          space: " ",
          json: false,
          renumber: false,
          hexadecimal: false,
          quotes: "single",
          escapeless: false,
          compact: false,
          parentheses: true,
          semicolons: true,
          safeConcatenation: false,
          preserveBlankLines: false
        },
        moz: {
          comprehensionExpressionStartsWithAssignment: false,
          starlessGenerator: false
        },
        sourceMap: null,
        sourceMapRoot: null,
        sourceMapWithCode: false,
        directive: false,
        raw: true,
        verbatim: null,
        sourceCode: null
      };
    }
    function stringRepeat(str, num) {
      var result = "";
      for (num |= 0; num > 0; num >>>= 1, str += str) {
        if (num & 1) {
          result += str;
        }
      }
      return result;
    }
    function hasLineTerminator(str) {
      return /[\r\n]/g.test(str);
    }
    function endsWithLineTerminator(str) {
      var len = str.length;
      return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }
    function merge2(target, override) {
      var key;
      for (key in override) {
        if (override.hasOwnProperty(key)) {
          target[key] = override[key];
        }
      }
      return target;
    }
    function updateDeeply(target, override) {
      var key, val;
      function isHashObject(target2) {
        return typeof target2 === "object" && target2 instanceof Object && !(target2 instanceof RegExp);
      }
      for (key in override) {
        if (override.hasOwnProperty(key)) {
          val = override[key];
          if (isHashObject(val)) {
            if (isHashObject(target[key])) {
              updateDeeply(target[key], val);
            } else {
              target[key] = updateDeeply({}, val);
            }
          } else {
            target[key] = val;
          }
        }
      }
      return target;
    }
    function generateNumber(value) {
      var result, point, temp, exponent, pos;
      if (value !== value) {
        throw new Error("Numeric literal whose value is NaN");
      }
      if (value < 0 || value === 0 && 1 / value < 0) {
        throw new Error("Numeric literal whose value is negative");
      }
      if (value === 1 / 0) {
        return json2 ? "null" : renumber ? "1e400" : "1e+400";
      }
      result = "" + value;
      if (!renumber || result.length < 3) {
        return result;
      }
      point = result.indexOf(".");
      if (!json2 && result.charCodeAt(0) === 48 && point === 1) {
        point = 0;
        result = result.slice(1);
      }
      temp = result;
      result = result.replace("e+", "e");
      exponent = 0;
      if ((pos = temp.indexOf("e")) > 0) {
        exponent = +temp.slice(pos + 1);
        temp = temp.slice(0, pos);
      }
      if (point >= 0) {
        exponent -= temp.length - point - 1;
        temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
      }
      pos = 0;
      while (temp.charCodeAt(temp.length + pos - 1) === 48) {
        --pos;
      }
      if (pos !== 0) {
        exponent -= pos;
        temp = temp.slice(0, pos);
      }
      if (exponent !== 0) {
        temp += "e" + exponent;
      }
      if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
        result = temp;
      }
      return result;
    }
    function escapeRegExpCharacter(ch, previousIsBackslash) {
      if ((ch & ~1) === 8232) {
        return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
      } else if (ch === 10 || ch === 13) {
        return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
      }
      return String.fromCharCode(ch);
    }
    function generateRegExp(reg) {
      var match, result, flags, i2, iz, ch, characterInBrack, previousIsBackslash;
      result = reg.toString();
      if (reg.source) {
        match = result.match(/\/([^/]*)$/);
        if (!match) {
          return result;
        }
        flags = match[1];
        result = "";
        characterInBrack = false;
        previousIsBackslash = false;
        for (i2 = 0, iz = reg.source.length; i2 < iz; ++i2) {
          ch = reg.source.charCodeAt(i2);
          if (!previousIsBackslash) {
            if (characterInBrack) {
              if (ch === 93) {
                characterInBrack = false;
              }
            } else {
              if (ch === 47) {
                result += "\\";
              } else if (ch === 91) {
                characterInBrack = true;
              }
            }
            result += escapeRegExpCharacter(ch, previousIsBackslash);
            previousIsBackslash = ch === 92;
          } else {
            result += escapeRegExpCharacter(ch, previousIsBackslash);
            previousIsBackslash = false;
          }
        }
        return "/" + result + "/" + flags;
      }
      return result;
    }
    function escapeAllowedCharacter(code2, next) {
      var hex;
      if (code2 === 8) {
        return "\\b";
      }
      if (code2 === 12) {
        return "\\f";
      }
      if (code2 === 9) {
        return "\\t";
      }
      hex = code2.toString(16).toUpperCase();
      if (json2 || code2 > 255) {
        return "\\u" + "0000".slice(hex.length) + hex;
      } else if (code2 === 0 && !esutils.code.isDecimalDigit(next)) {
        return "\\0";
      } else if (code2 === 11) {
        return "\\x0B";
      } else {
        return "\\x" + "00".slice(hex.length) + hex;
      }
    }
    function escapeDisallowedCharacter(code2) {
      if (code2 === 92) {
        return "\\\\";
      }
      if (code2 === 10) {
        return "\\n";
      }
      if (code2 === 13) {
        return "\\r";
      }
      if (code2 === 8232) {
        return "\\u2028";
      }
      if (code2 === 8233) {
        return "\\u2029";
      }
      throw new Error("Incorrectly classified character");
    }
    function escapeDirective(str) {
      var i2, iz, code2, quote;
      quote = quotes === "double" ? '"' : "'";
      for (i2 = 0, iz = str.length; i2 < iz; ++i2) {
        code2 = str.charCodeAt(i2);
        if (code2 === 39) {
          quote = '"';
          break;
        } else if (code2 === 34) {
          quote = "'";
          break;
        } else if (code2 === 92) {
          ++i2;
        }
      }
      return quote + str + quote;
    }
    function escapeString(str) {
      var result = "", i2, len, code2, singleQuotes = 0, doubleQuotes = 0, single, quote;
      for (i2 = 0, len = str.length; i2 < len; ++i2) {
        code2 = str.charCodeAt(i2);
        if (code2 === 39) {
          ++singleQuotes;
        } else if (code2 === 34) {
          ++doubleQuotes;
        } else if (code2 === 47 && json2) {
          result += "\\";
        } else if (esutils.code.isLineTerminator(code2) || code2 === 92) {
          result += escapeDisallowedCharacter(code2);
          continue;
        } else if (!esutils.code.isIdentifierPartES5(code2) && (json2 && code2 < 32 || !json2 && !escapeless && (code2 < 32 || code2 > 126))) {
          result += escapeAllowedCharacter(code2, str.charCodeAt(i2 + 1));
          continue;
        }
        result += String.fromCharCode(code2);
      }
      single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
      quote = single ? "'" : '"';
      if (!(single ? singleQuotes : doubleQuotes)) {
        return quote + result + quote;
      }
      str = result;
      result = quote;
      for (i2 = 0, len = str.length; i2 < len; ++i2) {
        code2 = str.charCodeAt(i2);
        if (code2 === 39 && single || code2 === 34 && !single) {
          result += "\\";
        }
        result += String.fromCharCode(code2);
      }
      return result + quote;
    }
    function flattenToString(arr) {
      var i2, iz, elem, result = "";
      for (i2 = 0, iz = arr.length; i2 < iz; ++i2) {
        elem = arr[i2];
        result += Array.isArray(elem) ? flattenToString(elem) : elem;
      }
      return result;
    }
    function toSourceNodeWhenNeeded(generated, node2) {
      if (!sourceMap2) {
        if (Array.isArray(generated)) {
          return flattenToString(generated);
        } else {
          return generated;
        }
      }
      if (node2 == null) {
        if (generated instanceof SourceNode) {
          return generated;
        } else {
          node2 = {};
        }
      }
      if (node2.loc == null) {
        return new SourceNode(null, null, sourceMap2, generated, node2.name || null);
      }
      return new SourceNode(node2.loc.start.line, node2.loc.start.column, sourceMap2 === true ? node2.loc.source || null : sourceMap2, generated, node2.name || null);
    }
    function noEmptySpace() {
      return space ? space : " ";
    }
    function join2(left2, right2) {
      var leftSource, rightSource, leftCharCode, rightCharCode;
      leftSource = toSourceNodeWhenNeeded(left2).toString();
      if (leftSource.length === 0) {
        return [right2];
      }
      rightSource = toSourceNodeWhenNeeded(right2).toString();
      if (rightSource.length === 0) {
        return [left2];
      }
      leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
      rightCharCode = rightSource.charCodeAt(0);
      if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
        return [left2, noEmptySpace(), right2];
      } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
        return [left2, right2];
      }
      return [left2, space, right2];
    }
    function addIndent(stmt) {
      return [base, stmt];
    }
    function withIndent(fn) {
      var previousBase;
      previousBase = base;
      base += indent;
      fn(base);
      base = previousBase;
    }
    function calculateSpaces(str) {
      var i2;
      for (i2 = str.length - 1; i2 >= 0; --i2) {
        if (esutils.code.isLineTerminator(str.charCodeAt(i2))) {
          break;
        }
      }
      return str.length - 1 - i2;
    }
    function adjustMultilineComment(value, specialBase) {
      var array, i2, len, line, j2, spaces, previousBase, sn;
      array = value.split(/\r\n|[\r\n]/);
      spaces = Number.MAX_VALUE;
      for (i2 = 1, len = array.length; i2 < len; ++i2) {
        line = array[i2];
        j2 = 0;
        while (j2 < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j2))) {
          ++j2;
        }
        if (spaces > j2) {
          spaces = j2;
        }
      }
      if (typeof specialBase !== "undefined") {
        previousBase = base;
        if (array[1][spaces] === "*") {
          specialBase += " ";
        }
        base = specialBase;
      } else {
        if (spaces & 1) {
          --spaces;
        }
        previousBase = base;
      }
      for (i2 = 1, len = array.length; i2 < len; ++i2) {
        sn = toSourceNodeWhenNeeded(addIndent(array[i2].slice(spaces)));
        array[i2] = sourceMap2 ? sn.join("") : sn;
      }
      base = previousBase;
      return array.join("\n");
    }
    function generateComment(comment, specialBase) {
      if (comment.type === "Line") {
        if (endsWithLineTerminator(comment.value)) {
          return "//" + comment.value;
        } else {
          var result = "//" + comment.value;
          if (!preserveBlankLines) {
            result += "\n";
          }
          return result;
        }
      }
      if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
        return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
      }
      return "/*" + comment.value + "*/";
    }
    function addComments(stmt, result) {
      var i2, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range2, prevRange, prefix, infix, suffix, count;
      if (stmt.leadingComments && stmt.leadingComments.length > 0) {
        save = result;
        if (preserveBlankLines) {
          comment = stmt.leadingComments[0];
          result = [];
          extRange = comment.extendedRange;
          range2 = comment.range;
          prefix = sourceCode.substring(extRange[0], range2[0]);
          count = (prefix.match(/\n/g) || []).length;
          if (count > 0) {
            result.push(stringRepeat("\n", count));
            result.push(addIndent(generateComment(comment)));
          } else {
            result.push(prefix);
            result.push(generateComment(comment));
          }
          prevRange = range2;
          for (i2 = 1, len = stmt.leadingComments.length; i2 < len; i2++) {
            comment = stmt.leadingComments[i2];
            range2 = comment.range;
            infix = sourceCode.substring(prevRange[1], range2[0]);
            count = (infix.match(/\n/g) || []).length;
            result.push(stringRepeat("\n", count));
            result.push(addIndent(generateComment(comment)));
            prevRange = range2;
          }
          suffix = sourceCode.substring(range2[1], extRange[1]);
          count = (suffix.match(/\n/g) || []).length;
          result.push(stringRepeat("\n", count));
        } else {
          comment = stmt.leadingComments[0];
          result = [];
          if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
            result.push("\n");
          }
          result.push(generateComment(comment));
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push("\n");
          }
          for (i2 = 1, len = stmt.leadingComments.length; i2 < len; ++i2) {
            comment = stmt.leadingComments[i2];
            fragment = [generateComment(comment)];
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              fragment.push("\n");
            }
            result.push(addIndent(fragment));
          }
        }
        result.push(addIndent(save));
      }
      if (stmt.trailingComments) {
        if (preserveBlankLines) {
          comment = stmt.trailingComments[0];
          extRange = comment.extendedRange;
          range2 = comment.range;
          prefix = sourceCode.substring(extRange[0], range2[0]);
          count = (prefix.match(/\n/g) || []).length;
          if (count > 0) {
            result.push(stringRepeat("\n", count));
            result.push(addIndent(generateComment(comment)));
          } else {
            result.push(prefix);
            result.push(generateComment(comment));
          }
        } else {
          tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
          specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
          for (i2 = 0, len = stmt.trailingComments.length; i2 < len; ++i2) {
            comment = stmt.trailingComments[i2];
            if (tailingToStatement) {
              if (i2 === 0) {
                result = [result, indent];
              } else {
                result = [result, specialBase];
              }
              result.push(generateComment(comment, specialBase));
            } else {
              result = [result, addIndent(generateComment(comment))];
            }
            if (i2 !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result = [result, "\n"];
            }
          }
        }
      }
      return result;
    }
    function generateBlankLines(start, end, result) {
      var j2, newlineCount = 0;
      for (j2 = start; j2 < end; j2++) {
        if (sourceCode[j2] === "\n") {
          newlineCount++;
        }
      }
      for (j2 = 1; j2 < newlineCount; j2++) {
        result.push(newline);
      }
    }
    function parenthesize(text, current, should) {
      if (current < should) {
        return ["(", text, ")"];
      }
      return text;
    }
    function generateVerbatimString(string) {
      var i2, iz, result;
      result = string.split(/\r\n|\n/);
      for (i2 = 1, iz = result.length; i2 < iz; i2++) {
        result[i2] = newline + base + result[i2];
      }
      return result;
    }
    function generateVerbatim(expr, precedence) {
      var verbatim, result, prec;
      verbatim = expr[extra.verbatim];
      if (typeof verbatim === "string") {
        result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
      } else {
        result = generateVerbatimString(verbatim.content);
        prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
        result = parenthesize(result, prec, precedence);
      }
      return toSourceNodeWhenNeeded(result, expr);
    }
    function CodeGenerator() {
    }
    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
      var result, noLeadingComment, that = this;
      noLeadingComment = !extra.comment || !stmt.leadingComments;
      if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
        return [space, this.generateStatement(stmt, flags)];
      }
      if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
        return ";";
      }
      withIndent(function() {
        result = [
          newline,
          addIndent(that.generateStatement(stmt, flags))
        ];
      });
      return result;
    };
    CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
      var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
      if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
        return [result, space];
      }
      if (ends) {
        return [result, base];
      }
      return [result, newline, base];
    };
    function generateIdentifier(node2) {
      return toSourceNodeWhenNeeded(node2.name, node2);
    }
    function generateAsyncPrefix(node2, spaceRequired) {
      return node2.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
    }
    function generateStarSuffix(node2) {
      var isGenerator = node2.generator && !extra.moz.starlessGenerator;
      return isGenerator ? "*" + space : "";
    }
    function generateMethodPrefix(prop) {
      var func = prop.value, prefix = "";
      if (func.async) {
        prefix += generateAsyncPrefix(func, !prop.computed);
      }
      if (func.generator) {
        prefix += generateStarSuffix(func) ? "*" : "";
      }
      return prefix;
    }
    CodeGenerator.prototype.generatePattern = function(node2, precedence, flags) {
      if (node2.type === Syntax.Identifier) {
        return generateIdentifier(node2);
      }
      return this.generateExpression(node2, precedence, flags);
    };
    CodeGenerator.prototype.generateFunctionParams = function(node2) {
      var i2, iz, result, hasDefault;
      hasDefault = false;
      if (node2.type === Syntax.ArrowFunctionExpression && !node2.rest && (!node2.defaults || node2.defaults.length === 0) && node2.params.length === 1 && node2.params[0].type === Syntax.Identifier) {
        result = [generateAsyncPrefix(node2, true), generateIdentifier(node2.params[0])];
      } else {
        result = node2.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node2, false)] : [];
        result.push("(");
        if (node2.defaults) {
          hasDefault = true;
        }
        for (i2 = 0, iz = node2.params.length; i2 < iz; ++i2) {
          if (hasDefault && node2.defaults[i2]) {
            result.push(this.generateAssignment(node2.params[i2], node2.defaults[i2], "=", Precedence.Assignment, E_TTT));
          } else {
            result.push(this.generatePattern(node2.params[i2], Precedence.Assignment, E_TTT));
          }
          if (i2 + 1 < iz) {
            result.push("," + space);
          }
        }
        if (node2.rest) {
          if (node2.params.length) {
            result.push("," + space);
          }
          result.push("...");
          result.push(generateIdentifier(node2.rest));
        }
        result.push(")");
      }
      return result;
    };
    CodeGenerator.prototype.generateFunctionBody = function(node2) {
      var result, expr;
      result = this.generateFunctionParams(node2);
      if (node2.type === Syntax.ArrowFunctionExpression) {
        result.push(space);
        result.push("=>");
      }
      if (node2.expression) {
        result.push(space);
        expr = this.generateExpression(node2.body, Precedence.Assignment, E_TTT);
        if (expr.toString().charAt(0) === "{") {
          expr = ["(", expr, ")"];
        }
        result.push(expr);
      } else {
        result.push(this.maybeBlock(node2.body, S_TTFF));
      }
      return result;
    };
    CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
      var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
      withIndent(function() {
        if (stmt.left.type === Syntax.VariableDeclaration) {
          withIndent(function() {
            result.push(stmt.left.kind + noEmptySpace());
            result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
          });
        } else {
          result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
        }
        result = join2(result, operator);
        result = [join2(
          result,
          that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
        ), ")"];
      });
      result.push(this.maybeBlock(stmt.body, flags));
      return result;
    };
    CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
      var result = [];
      if (computed) {
        result.push("[");
      }
      result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
      if (computed) {
        result.push("]");
      }
      return result;
    };
    CodeGenerator.prototype.generateAssignment = function(left2, right2, operator, precedence, flags) {
      if (Precedence.Assignment < precedence) {
        flags |= F_ALLOW_IN;
      }
      return parenthesize(
        [
          this.generateExpression(left2, Precedence.Call, flags),
          space + operator + space,
          this.generateExpression(right2, Precedence.Assignment, flags)
        ],
        Precedence.Assignment,
        precedence
      );
    };
    CodeGenerator.prototype.semicolon = function(flags) {
      if (!semicolons && flags & F_SEMICOLON_OPT) {
        return "";
      }
      return ";";
    };
    CodeGenerator.Statement = {
      BlockStatement: function(stmt, flags) {
        var range2, content, result = ["{", newline], that = this;
        withIndent(function() {
          if (stmt.body.length === 0 && preserveBlankLines) {
            range2 = stmt.range;
            if (range2[1] - range2[0] > 2) {
              content = sourceCode.substring(range2[0] + 1, range2[1] - 1);
              if (content[0] === "\n") {
                result = ["{"];
              }
              result.push(content);
            }
          }
          var i2, iz, fragment, bodyFlags;
          bodyFlags = S_TFFF;
          if (flags & F_FUNC_BODY) {
            bodyFlags |= F_DIRECTIVE_CTX;
          }
          for (i2 = 0, iz = stmt.body.length; i2 < iz; ++i2) {
            if (preserveBlankLines) {
              if (i2 === 0) {
                if (stmt.body[0].leadingComments) {
                  range2 = stmt.body[0].leadingComments[0].extendedRange;
                  content = sourceCode.substring(range2[0], range2[1]);
                  if (content[0] === "\n") {
                    result = ["{"];
                  }
                }
                if (!stmt.body[0].leadingComments) {
                  generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                }
              }
              if (i2 > 0) {
                if (!stmt.body[i2 - 1].trailingComments && !stmt.body[i2].leadingComments) {
                  generateBlankLines(stmt.body[i2 - 1].range[1], stmt.body[i2].range[0], result);
                }
              }
            }
            if (i2 === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.body[i2].leadingComments && preserveBlankLines) {
              fragment = that.generateStatement(stmt.body[i2], bodyFlags);
            } else {
              fragment = addIndent(that.generateStatement(stmt.body[i2], bodyFlags));
            }
            result.push(fragment);
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              if (preserveBlankLines && i2 < iz - 1) {
                if (!stmt.body[i2 + 1].leadingComments) {
                  result.push(newline);
                }
              } else {
                result.push(newline);
              }
            }
            if (preserveBlankLines) {
              if (i2 === iz - 1) {
                if (!stmt.body[i2].trailingComments) {
                  generateBlankLines(stmt.body[i2].range[1], stmt.range[1], result);
                }
              }
            }
          }
        });
        result.push(addIndent("}"));
        return result;
      },
      BreakStatement: function(stmt, flags) {
        if (stmt.label) {
          return "break " + stmt.label.name + this.semicolon(flags);
        }
        return "break" + this.semicolon(flags);
      },
      ContinueStatement: function(stmt, flags) {
        if (stmt.label) {
          return "continue " + stmt.label.name + this.semicolon(flags);
        }
        return "continue" + this.semicolon(flags);
      },
      ClassBody: function(stmt, flags) {
        var result = ["{", newline], that = this;
        withIndent(function(indent2) {
          var i2, iz;
          for (i2 = 0, iz = stmt.body.length; i2 < iz; ++i2) {
            result.push(indent2);
            result.push(that.generateExpression(stmt.body[i2], Precedence.Sequence, E_TTT));
            if (i2 + 1 < iz) {
              result.push(newline);
            }
          }
        });
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(base);
        result.push("}");
        return result;
      },
      ClassDeclaration: function(stmt, flags) {
        var result, fragment;
        result = ["class"];
        if (stmt.id) {
          result = join2(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
        }
        if (stmt.superClass) {
          fragment = join2("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
          result = join2(result, fragment);
        }
        result.push(space);
        result.push(this.generateStatement(stmt.body, S_TFFT));
        return result;
      },
      DirectiveStatement: function(stmt, flags) {
        if (extra.raw && stmt.raw) {
          return stmt.raw + this.semicolon(flags);
        }
        return escapeDirective(stmt.directive) + this.semicolon(flags);
      },
      DoWhileStatement: function(stmt, flags) {
        var result = join2("do", this.maybeBlock(stmt.body, S_TFFF));
        result = this.maybeBlockSuffix(stmt.body, result);
        return join2(result, [
          "while" + space + "(",
          this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
          ")" + this.semicolon(flags)
        ]);
      },
      CatchClause: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          var guard;
          if (stmt.param) {
            result = [
              "catch" + space + "(",
              that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
              ")"
            ];
            if (stmt.guard) {
              guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
              result.splice(2, 0, " if ", guard);
            }
          } else {
            result = ["catch"];
          }
        });
        result.push(this.maybeBlock(stmt.body, S_TFFF));
        return result;
      },
      DebuggerStatement: function(stmt, flags) {
        return "debugger" + this.semicolon(flags);
      },
      EmptyStatement: function(stmt, flags) {
        return ";";
      },
      ExportDefaultDeclaration: function(stmt, flags) {
        var result = ["export"], bodyFlags;
        bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
        result = join2(result, "default");
        if (isStatement(stmt.declaration)) {
          result = join2(result, this.generateStatement(stmt.declaration, bodyFlags));
        } else {
          result = join2(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
        }
        return result;
      },
      ExportNamedDeclaration: function(stmt, flags) {
        var result = ["export"], bodyFlags, that = this;
        bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
        if (stmt.declaration) {
          return join2(result, this.generateStatement(stmt.declaration, bodyFlags));
        }
        if (stmt.specifiers) {
          if (stmt.specifiers.length === 0) {
            result = join2(result, "{" + space + "}");
          } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
            result = join2(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
          } else {
            result = join2(result, "{");
            withIndent(function(indent2) {
              var i2, iz;
              result.push(newline);
              for (i2 = 0, iz = stmt.specifiers.length; i2 < iz; ++i2) {
                result.push(indent2);
                result.push(that.generateExpression(stmt.specifiers[i2], Precedence.Sequence, E_TTT));
                if (i2 + 1 < iz) {
                  result.push("," + newline);
                }
              }
            });
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            result.push(base + "}");
          }
          if (stmt.source) {
            result = join2(result, [
              "from" + space,
              // ModuleSpecifier
              this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
              this.semicolon(flags)
            ]);
          } else {
            result.push(this.semicolon(flags));
          }
        }
        return result;
      },
      ExportAllDeclaration: function(stmt, flags) {
        return [
          "export" + space,
          "*" + space,
          "from" + space,
          // ModuleSpecifier
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
          this.semicolon(flags)
        ];
      },
      ExpressionStatement: function(stmt, flags) {
        var result, fragment;
        function isClassPrefixed(fragment2) {
          var code2;
          if (fragment2.slice(0, 5) !== "class") {
            return false;
          }
          code2 = fragment2.charCodeAt(5);
          return code2 === 123 || esutils.code.isWhiteSpace(code2) || esutils.code.isLineTerminator(code2);
        }
        function isFunctionPrefixed(fragment2) {
          var code2;
          if (fragment2.slice(0, 8) !== "function") {
            return false;
          }
          code2 = fragment2.charCodeAt(8);
          return code2 === 40 || esutils.code.isWhiteSpace(code2) || code2 === 42 || esutils.code.isLineTerminator(code2);
        }
        function isAsyncPrefixed(fragment2) {
          var code2, i2, iz;
          if (fragment2.slice(0, 5) !== "async") {
            return false;
          }
          if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(5))) {
            return false;
          }
          for (i2 = 6, iz = fragment2.length; i2 < iz; ++i2) {
            if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(i2))) {
              break;
            }
          }
          if (i2 === iz) {
            return false;
          }
          if (fragment2.slice(i2, i2 + 8) !== "function") {
            return false;
          }
          code2 = fragment2.charCodeAt(i2 + 8);
          return code2 === 40 || esutils.code.isWhiteSpace(code2) || code2 === 42 || esutils.code.isLineTerminator(code2);
        }
        result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (fragment.charCodeAt(0) === 123 || // ObjectExpression
        isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") {
          result = ["(", result, ")" + this.semicolon(flags)];
        } else {
          result.push(this.semicolon(flags));
        }
        return result;
      },
      ImportDeclaration: function(stmt, flags) {
        var result, cursor, that = this;
        if (stmt.specifiers.length === 0) {
          return [
            "import",
            space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ];
        }
        result = [
          "import"
        ];
        cursor = 0;
        if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
          result = join2(result, [
            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
          ]);
          ++cursor;
        }
        if (stmt.specifiers[cursor]) {
          if (cursor !== 0) {
            result.push(",");
          }
          if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
            result = join2(result, [
              space,
              this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
            ]);
          } else {
            result.push(space + "{");
            if (stmt.specifiers.length - cursor === 1) {
              result.push(space);
              result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
              result.push(space + "}" + space);
            } else {
              withIndent(function(indent2) {
                var i2, iz;
                result.push(newline);
                for (i2 = cursor, iz = stmt.specifiers.length; i2 < iz; ++i2) {
                  result.push(indent2);
                  result.push(that.generateExpression(stmt.specifiers[i2], Precedence.Sequence, E_TTT));
                  if (i2 + 1 < iz) {
                    result.push("," + newline);
                  }
                }
              });
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
              }
              result.push(base + "}" + space);
            }
          }
        }
        result = join2(result, [
          "from" + space,
          // ModuleSpecifier
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
          this.semicolon(flags)
        ]);
        return result;
      },
      VariableDeclarator: function(stmt, flags) {
        var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
        if (stmt.init) {
          return [
            this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
            space,
            "=",
            space,
            this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
          ];
        }
        return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
      },
      VariableDeclaration: function(stmt, flags) {
        var result, i2, iz, node2, bodyFlags, that = this;
        result = [stmt.kind];
        bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
        function block() {
          node2 = stmt.declarations[0];
          if (extra.comment && node2.leadingComments) {
            result.push("\n");
            result.push(addIndent(that.generateStatement(node2, bodyFlags)));
          } else {
            result.push(noEmptySpace());
            result.push(that.generateStatement(node2, bodyFlags));
          }
          for (i2 = 1, iz = stmt.declarations.length; i2 < iz; ++i2) {
            node2 = stmt.declarations[i2];
            if (extra.comment && node2.leadingComments) {
              result.push("," + newline);
              result.push(addIndent(that.generateStatement(node2, bodyFlags)));
            } else {
              result.push("," + space);
              result.push(that.generateStatement(node2, bodyFlags));
            }
          }
        }
        if (stmt.declarations.length > 1) {
          withIndent(block);
        } else {
          block();
        }
        result.push(this.semicolon(flags));
        return result;
      },
      ThrowStatement: function(stmt, flags) {
        return [join2(
          "throw",
          this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
        ), this.semicolon(flags)];
      },
      TryStatement: function(stmt, flags) {
        var result, i2, iz, guardedHandlers;
        result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
        result = this.maybeBlockSuffix(stmt.block, result);
        if (stmt.handlers) {
          for (i2 = 0, iz = stmt.handlers.length; i2 < iz; ++i2) {
            result = join2(result, this.generateStatement(stmt.handlers[i2], S_TFFF));
            if (stmt.finalizer || i2 + 1 !== iz) {
              result = this.maybeBlockSuffix(stmt.handlers[i2].body, result);
            }
          }
        } else {
          guardedHandlers = stmt.guardedHandlers || [];
          for (i2 = 0, iz = guardedHandlers.length; i2 < iz; ++i2) {
            result = join2(result, this.generateStatement(guardedHandlers[i2], S_TFFF));
            if (stmt.finalizer || i2 + 1 !== iz) {
              result = this.maybeBlockSuffix(guardedHandlers[i2].body, result);
            }
          }
          if (stmt.handler) {
            if (Array.isArray(stmt.handler)) {
              for (i2 = 0, iz = stmt.handler.length; i2 < iz; ++i2) {
                result = join2(result, this.generateStatement(stmt.handler[i2], S_TFFF));
                if (stmt.finalizer || i2 + 1 !== iz) {
                  result = this.maybeBlockSuffix(stmt.handler[i2].body, result);
                }
              }
            } else {
              result = join2(result, this.generateStatement(stmt.handler, S_TFFF));
              if (stmt.finalizer) {
                result = this.maybeBlockSuffix(stmt.handler.body, result);
              }
            }
          }
        }
        if (stmt.finalizer) {
          result = join2(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
        }
        return result;
      },
      SwitchStatement: function(stmt, flags) {
        var result, fragment, i2, iz, bodyFlags, that = this;
        withIndent(function() {
          result = [
            "switch" + space + "(",
            that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
            ")" + space + "{" + newline
          ];
        });
        if (stmt.cases) {
          bodyFlags = S_TFFF;
          for (i2 = 0, iz = stmt.cases.length; i2 < iz; ++i2) {
            if (i2 === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            fragment = addIndent(this.generateStatement(stmt.cases[i2], bodyFlags));
            result.push(fragment);
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
        }
        result.push(addIndent("}"));
        return result;
      },
      SwitchCase: function(stmt, flags) {
        var result, fragment, i2, iz, bodyFlags, that = this;
        withIndent(function() {
          if (stmt.test) {
            result = [
              join2("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
              ":"
            ];
          } else {
            result = ["default:"];
          }
          i2 = 0;
          iz = stmt.consequent.length;
          if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
            fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
            result.push(fragment);
            i2 = 1;
          }
          if (i2 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          bodyFlags = S_TFFF;
          for (; i2 < iz; ++i2) {
            if (i2 === iz - 1 && flags & F_SEMICOLON_OPT) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            fragment = addIndent(that.generateStatement(stmt.consequent[i2], bodyFlags));
            result.push(fragment);
            if (i2 + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
        });
        return result;
      },
      IfStatement: function(stmt, flags) {
        var result, bodyFlags, semicolonOptional, that = this;
        withIndent(function() {
          result = [
            "if" + space + "(",
            that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        semicolonOptional = flags & F_SEMICOLON_OPT;
        bodyFlags = S_TFFF;
        if (semicolonOptional) {
          bodyFlags |= F_SEMICOLON_OPT;
        }
        if (stmt.alternate) {
          result.push(this.maybeBlock(stmt.consequent, S_TFFF));
          result = this.maybeBlockSuffix(stmt.consequent, result);
          if (stmt.alternate.type === Syntax.IfStatement) {
            result = join2(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
          } else {
            result = join2(result, join2("else", this.maybeBlock(stmt.alternate, bodyFlags)));
          }
        } else {
          result.push(this.maybeBlock(stmt.consequent, bodyFlags));
        }
        return result;
      },
      ForStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = ["for" + space + "("];
          if (stmt.init) {
            if (stmt.init.type === Syntax.VariableDeclaration) {
              result.push(that.generateStatement(stmt.init, S_FFFF));
            } else {
              result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
              result.push(";");
            }
          } else {
            result.push(";");
          }
          if (stmt.test) {
            result.push(space);
            result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
            result.push(";");
          } else {
            result.push(";");
          }
          if (stmt.update) {
            result.push(space);
            result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
            result.push(")");
          } else {
            result.push(")");
          }
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      },
      ForInStatement: function(stmt, flags) {
        return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
      },
      ForOfStatement: function(stmt, flags) {
        return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
      },
      LabeledStatement: function(stmt, flags) {
        return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
      },
      Program: function(stmt, flags) {
        var result, fragment, i2, iz, bodyFlags;
        iz = stmt.body.length;
        result = [safeConcatenation && iz > 0 ? "\n" : ""];
        bodyFlags = S_TFTF;
        for (i2 = 0; i2 < iz; ++i2) {
          if (!safeConcatenation && i2 === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (preserveBlankLines) {
            if (i2 === 0) {
              if (!stmt.body[0].leadingComments) {
                generateBlankLines(stmt.range[0], stmt.body[i2].range[0], result);
              }
            }
            if (i2 > 0) {
              if (!stmt.body[i2 - 1].trailingComments && !stmt.body[i2].leadingComments) {
                generateBlankLines(stmt.body[i2 - 1].range[1], stmt.body[i2].range[0], result);
              }
            }
          }
          fragment = addIndent(this.generateStatement(stmt.body[i2], bodyFlags));
          result.push(fragment);
          if (i2 + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            if (preserveBlankLines) {
              if (!stmt.body[i2 + 1].leadingComments) {
                result.push(newline);
              }
            } else {
              result.push(newline);
            }
          }
          if (preserveBlankLines) {
            if (i2 === iz - 1) {
              if (!stmt.body[i2].trailingComments) {
                generateBlankLines(stmt.body[i2].range[1], stmt.range[1], result);
              }
            }
          }
        }
        return result;
      },
      FunctionDeclaration: function(stmt, flags) {
        return [
          generateAsyncPrefix(stmt, true),
          "function",
          generateStarSuffix(stmt) || noEmptySpace(),
          stmt.id ? generateIdentifier(stmt.id) : "",
          this.generateFunctionBody(stmt)
        ];
      },
      ReturnStatement: function(stmt, flags) {
        if (stmt.argument) {
          return [join2(
            "return",
            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
          ), this.semicolon(flags)];
        }
        return ["return" + this.semicolon(flags)];
      },
      WhileStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = [
            "while" + space + "(",
            that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      },
      WithStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = [
            "with" + space + "(",
            that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      }
    };
    merge2(CodeGenerator.prototype, CodeGenerator.Statement);
    CodeGenerator.Expression = {
      SequenceExpression: function(expr, precedence, flags) {
        var result, i2, iz;
        if (Precedence.Sequence < precedence) {
          flags |= F_ALLOW_IN;
        }
        result = [];
        for (i2 = 0, iz = expr.expressions.length; i2 < iz; ++i2) {
          result.push(this.generateExpression(expr.expressions[i2], Precedence.Assignment, flags));
          if (i2 + 1 < iz) {
            result.push("," + space);
          }
        }
        return parenthesize(result, Precedence.Sequence, precedence);
      },
      AssignmentExpression: function(expr, precedence, flags) {
        return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
      },
      ArrowFunctionExpression: function(expr, precedence, flags) {
        return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
      },
      ConditionalExpression: function(expr, precedence, flags) {
        if (Precedence.Conditional < precedence) {
          flags |= F_ALLOW_IN;
        }
        return parenthesize(
          [
            this.generateExpression(expr.test, Precedence.Coalesce, flags),
            space + "?" + space,
            this.generateExpression(expr.consequent, Precedence.Assignment, flags),
            space + ":" + space,
            this.generateExpression(expr.alternate, Precedence.Assignment, flags)
          ],
          Precedence.Conditional,
          precedence
        );
      },
      LogicalExpression: function(expr, precedence, flags) {
        if (expr.operator === "??") {
          flags |= F_FOUND_COALESCE;
        }
        return this.BinaryExpression(expr, precedence, flags);
      },
      BinaryExpression: function(expr, precedence, flags) {
        var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
        currentPrecedence = BinaryPrecedence[expr.operator];
        leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence;
        rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1;
        if (currentPrecedence < precedence) {
          flags |= F_ALLOW_IN;
        }
        fragment = this.generateExpression(expr.left, leftPrecedence, flags);
        leftSource = fragment.toString();
        if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
          result = [fragment, noEmptySpace(), expr.operator];
        } else {
          result = join2(fragment, expr.operator);
        }
        fragment = this.generateExpression(expr.right, rightPrecedence, flags);
        if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
          result.push(noEmptySpace());
          result.push(fragment);
        } else {
          result = join2(result, fragment);
        }
        if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
          return ["(", result, ")"];
        }
        if ((expr.operator === "||" || expr.operator === "&&") && flags & F_FOUND_COALESCE) {
          return ["(", result, ")"];
        }
        return parenthesize(result, currentPrecedence, precedence);
      },
      CallExpression: function(expr, precedence, flags) {
        var result, i2, iz;
        result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
        if (expr.optional) {
          result.push("?.");
        }
        result.push("(");
        for (i2 = 0, iz = expr["arguments"].length; i2 < iz; ++i2) {
          result.push(this.generateExpression(expr["arguments"][i2], Precedence.Assignment, E_TTT));
          if (i2 + 1 < iz) {
            result.push("," + space);
          }
        }
        result.push(")");
        if (!(flags & F_ALLOW_CALL)) {
          return ["(", result, ")"];
        }
        return parenthesize(result, Precedence.Call, precedence);
      },
      ChainExpression: function(expr, precedence, flags) {
        if (Precedence.OptionalChaining < precedence) {
          flags |= F_ALLOW_CALL;
        }
        var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
        return parenthesize(result, Precedence.OptionalChaining, precedence);
      },
      NewExpression: function(expr, precedence, flags) {
        var result, length, i2, iz, itemFlags;
        length = expr["arguments"].length;
        itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
        result = join2(
          "new",
          this.generateExpression(expr.callee, Precedence.New, itemFlags)
        );
        if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
          result.push("(");
          for (i2 = 0, iz = length; i2 < iz; ++i2) {
            result.push(this.generateExpression(expr["arguments"][i2], Precedence.Assignment, E_TTT));
            if (i2 + 1 < iz) {
              result.push("," + space);
            }
          }
          result.push(")");
        }
        return parenthesize(result, Precedence.New, precedence);
      },
      MemberExpression: function(expr, precedence, flags) {
        var result, fragment;
        result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];
        if (expr.computed) {
          if (expr.optional) {
            result.push("?.");
          }
          result.push("[");
          result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
          result.push("]");
        } else {
          if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
              result.push(" ");
            }
          }
          result.push(expr.optional ? "?." : ".");
          result.push(generateIdentifier(expr.property));
        }
        return parenthesize(result, Precedence.Member, precedence);
      },
      MetaProperty: function(expr, precedence, flags) {
        var result;
        result = [];
        result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
        result.push(".");
        result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
        return parenthesize(result, Precedence.Member, precedence);
      },
      UnaryExpression: function(expr, precedence, flags) {
        var result, fragment, rightCharCode, leftSource, leftCharCode;
        fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
        if (space === "") {
          result = join2(expr.operator, fragment);
        } else {
          result = [expr.operator];
          if (expr.operator.length > 2) {
            result = join2(result, fragment);
          } else {
            leftSource = toSourceNodeWhenNeeded(result).toString();
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
            rightCharCode = fragment.toString().charCodeAt(0);
            if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
              result.push(noEmptySpace());
              result.push(fragment);
            } else {
              result.push(fragment);
            }
          }
        }
        return parenthesize(result, Precedence.Unary, precedence);
      },
      YieldExpression: function(expr, precedence, flags) {
        var result;
        if (expr.delegate) {
          result = "yield*";
        } else {
          result = "yield";
        }
        if (expr.argument) {
          result = join2(
            result,
            this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
          );
        }
        return parenthesize(result, Precedence.Yield, precedence);
      },
      AwaitExpression: function(expr, precedence, flags) {
        var result = join2(
          expr.all ? "await*" : "await",
          this.generateExpression(expr.argument, Precedence.Await, E_TTT)
        );
        return parenthesize(result, Precedence.Await, precedence);
      },
      UpdateExpression: function(expr, precedence, flags) {
        if (expr.prefix) {
          return parenthesize(
            [
              expr.operator,
              this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
            ],
            Precedence.Unary,
            precedence
          );
        }
        return parenthesize(
          [
            this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
            expr.operator
          ],
          Precedence.Postfix,
          precedence
        );
      },
      FunctionExpression: function(expr, precedence, flags) {
        var result = [
          generateAsyncPrefix(expr, true),
          "function"
        ];
        if (expr.id) {
          result.push(generateStarSuffix(expr) || noEmptySpace());
          result.push(generateIdentifier(expr.id));
        } else {
          result.push(generateStarSuffix(expr) || space);
        }
        result.push(this.generateFunctionBody(expr));
        return result;
      },
      ArrayPattern: function(expr, precedence, flags) {
        return this.ArrayExpression(expr, precedence, flags, true);
      },
      ArrayExpression: function(expr, precedence, flags, isPattern) {
        var result, multiline, that = this;
        if (!expr.elements.length) {
          return "[]";
        }
        multiline = isPattern ? false : expr.elements.length > 1;
        result = ["[", multiline ? newline : ""];
        withIndent(function(indent2) {
          var i2, iz;
          for (i2 = 0, iz = expr.elements.length; i2 < iz; ++i2) {
            if (!expr.elements[i2]) {
              if (multiline) {
                result.push(indent2);
              }
              if (i2 + 1 === iz) {
                result.push(",");
              }
            } else {
              result.push(multiline ? indent2 : "");
              result.push(that.generateExpression(expr.elements[i2], Precedence.Assignment, E_TTT));
            }
            if (i2 + 1 < iz) {
              result.push("," + (multiline ? newline : space));
            }
          }
        });
        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(multiline ? base : "");
        result.push("]");
        return result;
      },
      RestElement: function(expr, precedence, flags) {
        return "..." + this.generatePattern(expr.argument);
      },
      ClassExpression: function(expr, precedence, flags) {
        var result, fragment;
        result = ["class"];
        if (expr.id) {
          result = join2(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
        }
        if (expr.superClass) {
          fragment = join2("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
          result = join2(result, fragment);
        }
        result.push(space);
        result.push(this.generateStatement(expr.body, S_TFFT));
        return result;
      },
      MethodDefinition: function(expr, precedence, flags) {
        var result, fragment;
        if (expr["static"]) {
          result = ["static" + space];
        } else {
          result = [];
        }
        if (expr.kind === "get" || expr.kind === "set") {
          fragment = [
            join2(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
            this.generateFunctionBody(expr.value)
          ];
        } else {
          fragment = [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        return join2(result, fragment);
      },
      Property: function(expr, precedence, flags) {
        if (expr.kind === "get" || expr.kind === "set") {
          return [
            expr.kind,
            noEmptySpace(),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        if (expr.shorthand) {
          if (expr.value.type === "AssignmentPattern") {
            return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
          }
          return this.generatePropertyKey(expr.key, expr.computed);
        }
        if (expr.method) {
          return [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        return [
          this.generatePropertyKey(expr.key, expr.computed),
          ":" + space,
          this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
        ];
      },
      ObjectExpression: function(expr, precedence, flags) {
        var multiline, result, fragment, that = this;
        if (!expr.properties.length) {
          return "{}";
        }
        multiline = expr.properties.length > 1;
        withIndent(function() {
          fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
        });
        if (!multiline) {
          if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            return ["{", space, fragment, space, "}"];
          }
        }
        withIndent(function(indent2) {
          var i2, iz;
          result = ["{", newline, indent2, fragment];
          if (multiline) {
            result.push("," + newline);
            for (i2 = 1, iz = expr.properties.length; i2 < iz; ++i2) {
              result.push(indent2);
              result.push(that.generateExpression(expr.properties[i2], Precedence.Sequence, E_TTT));
              if (i2 + 1 < iz) {
                result.push("," + newline);
              }
            }
          }
        });
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(base);
        result.push("}");
        return result;
      },
      AssignmentPattern: function(expr, precedence, flags) {
        return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
      },
      ObjectPattern: function(expr, precedence, flags) {
        var result, i2, iz, multiline, property, that = this;
        if (!expr.properties.length) {
          return "{}";
        }
        multiline = false;
        if (expr.properties.length === 1) {
          property = expr.properties[0];
          if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
            multiline = true;
          }
        } else {
          for (i2 = 0, iz = expr.properties.length; i2 < iz; ++i2) {
            property = expr.properties[i2];
            if (property.type === Syntax.Property && !property.shorthand) {
              multiline = true;
              break;
            }
          }
        }
        result = ["{", multiline ? newline : ""];
        withIndent(function(indent2) {
          var i3, iz2;
          for (i3 = 0, iz2 = expr.properties.length; i3 < iz2; ++i3) {
            result.push(multiline ? indent2 : "");
            result.push(that.generateExpression(expr.properties[i3], Precedence.Sequence, E_TTT));
            if (i3 + 1 < iz2) {
              result.push("," + (multiline ? newline : space));
            }
          }
        });
        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(multiline ? base : "");
        result.push("}");
        return result;
      },
      ThisExpression: function(expr, precedence, flags) {
        return "this";
      },
      Super: function(expr, precedence, flags) {
        return "super";
      },
      Identifier: function(expr, precedence, flags) {
        return generateIdentifier(expr);
      },
      ImportDefaultSpecifier: function(expr, precedence, flags) {
        return generateIdentifier(expr.id || expr.local);
      },
      ImportNamespaceSpecifier: function(expr, precedence, flags) {
        var result = ["*"];
        var id = expr.id || expr.local;
        if (id) {
          result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
        }
        return result;
      },
      ImportSpecifier: function(expr, precedence, flags) {
        var imported = expr.imported;
        var result = [imported.name];
        var local = expr.local;
        if (local && local.name !== imported.name) {
          result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
        }
        return result;
      },
      ExportSpecifier: function(expr, precedence, flags) {
        var local = expr.local;
        var result = [local.name];
        var exported = expr.exported;
        if (exported && exported.name !== local.name) {
          result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
        }
        return result;
      },
      Literal: function(expr, precedence, flags) {
        var raw;
        if (expr.hasOwnProperty("raw") && parse2 && extra.raw) {
          try {
            raw = parse2(expr.raw).body[0].expression;
            if (raw.type === Syntax.Literal) {
              if (raw.value === expr.value) {
                return expr.raw;
              }
            }
          } catch (e2) {
          }
        }
        if (expr.regex) {
          return "/" + expr.regex.pattern + "/" + expr.regex.flags;
        }
        if (typeof expr.value === "bigint") {
          return expr.value.toString() + "n";
        }
        if (expr.bigint) {
          return expr.bigint + "n";
        }
        if (expr.value === null) {
          return "null";
        }
        if (typeof expr.value === "string") {
          return escapeString(expr.value);
        }
        if (typeof expr.value === "number") {
          return generateNumber(expr.value);
        }
        if (typeof expr.value === "boolean") {
          return expr.value ? "true" : "false";
        }
        return generateRegExp(expr.value);
      },
      GeneratorExpression: function(expr, precedence, flags) {
        return this.ComprehensionExpression(expr, precedence, flags);
      },
      ComprehensionExpression: function(expr, precedence, flags) {
        var result, i2, iz, fragment, that = this;
        result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];
        if (extra.moz.comprehensionExpressionStartsWithAssignment) {
          fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
          result.push(fragment);
        }
        if (expr.blocks) {
          withIndent(function() {
            for (i2 = 0, iz = expr.blocks.length; i2 < iz; ++i2) {
              fragment = that.generateExpression(expr.blocks[i2], Precedence.Sequence, E_TTT);
              if (i2 > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                result = join2(result, fragment);
              } else {
                result.push(fragment);
              }
            }
          });
        }
        if (expr.filter) {
          result = join2(result, "if" + space);
          fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
          result = join2(result, ["(", fragment, ")"]);
        }
        if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
          fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
          result = join2(result, fragment);
        }
        result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
        return result;
      },
      ComprehensionBlock: function(expr, precedence, flags) {
        var fragment;
        if (expr.left.type === Syntax.VariableDeclaration) {
          fragment = [
            expr.left.kind,
            noEmptySpace(),
            this.generateStatement(expr.left.declarations[0], S_FFFF)
          ];
        } else {
          fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
        }
        fragment = join2(fragment, expr.of ? "of" : "in");
        fragment = join2(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
        return ["for" + space + "(", fragment, ")"];
      },
      SpreadElement: function(expr, precedence, flags) {
        return [
          "...",
          this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
        ];
      },
      TaggedTemplateExpression: function(expr, precedence, flags) {
        var itemFlags = E_TTF;
        if (!(flags & F_ALLOW_CALL)) {
          itemFlags = E_TFF;
        }
        var result = [
          this.generateExpression(expr.tag, Precedence.Call, itemFlags),
          this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
        ];
        return parenthesize(result, Precedence.TaggedTemplate, precedence);
      },
      TemplateElement: function(expr, precedence, flags) {
        return expr.value.raw;
      },
      TemplateLiteral: function(expr, precedence, flags) {
        var result, i2, iz;
        result = ["`"];
        for (i2 = 0, iz = expr.quasis.length; i2 < iz; ++i2) {
          result.push(this.generateExpression(expr.quasis[i2], Precedence.Primary, E_TTT));
          if (i2 + 1 < iz) {
            result.push("${" + space);
            result.push(this.generateExpression(expr.expressions[i2], Precedence.Sequence, E_TTT));
            result.push(space + "}");
          }
        }
        result.push("`");
        return result;
      },
      ModuleSpecifier: function(expr, precedence, flags) {
        return this.Literal(expr, precedence, flags);
      },
      ImportExpression: function(expr, precedence, flag) {
        return parenthesize([
          "import(",
          this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
          ")"
        ], Precedence.Call, precedence);
      }
    };
    merge2(CodeGenerator.prototype, CodeGenerator.Expression);
    CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
      var result, type;
      type = expr.type || Syntax.Property;
      if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
        return generateVerbatim(expr, precedence);
      }
      result = this[type](expr, precedence, flags);
      if (extra.comment) {
        result = addComments(expr, result);
      }
      return toSourceNodeWhenNeeded(result, expr);
    };
    CodeGenerator.prototype.generateStatement = function(stmt, flags) {
      var result, fragment;
      result = this[stmt.type](stmt, flags);
      if (extra.comment) {
        result = addComments(stmt, result);
      }
      fragment = toSourceNodeWhenNeeded(result).toString();
      if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
        result = sourceMap2 ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
      }
      return toSourceNodeWhenNeeded(result, stmt);
    };
    function generateInternal(node2) {
      var codegen;
      codegen = new CodeGenerator();
      if (isStatement(node2)) {
        return codegen.generateStatement(node2, S_TFFF);
      }
      if (isExpression(node2)) {
        return codegen.generateExpression(node2, Precedence.Sequence, E_TTT);
      }
      throw new Error("Unknown node type: " + node2.type);
    }
    function generate(node2, options) {
      var defaultOptions2 = getDefaultOptions(), result, pair;
      if (options != null) {
        if (typeof options.indent === "string") {
          defaultOptions2.format.indent.style = options.indent;
        }
        if (typeof options.base === "number") {
          defaultOptions2.format.indent.base = options.base;
        }
        options = updateDeeply(defaultOptions2, options);
        indent = options.format.indent.style;
        if (typeof options.base === "string") {
          base = options.base;
        } else {
          base = stringRepeat(indent, options.format.indent.base);
        }
      } else {
        options = defaultOptions2;
        indent = options.format.indent.style;
        base = stringRepeat(indent, options.format.indent.base);
      }
      json2 = options.format.json;
      renumber = options.format.renumber;
      hexadecimal = json2 ? false : options.format.hexadecimal;
      quotes = json2 ? "double" : options.format.quotes;
      escapeless = options.format.escapeless;
      newline = options.format.newline;
      space = options.format.space;
      if (options.format.compact) {
        newline = space = indent = base = "";
      }
      parentheses = options.format.parentheses;
      semicolons = options.format.semicolons;
      safeConcatenation = options.format.safeConcatenation;
      directive = options.directive;
      parse2 = json2 ? null : options.parse;
      sourceMap2 = options.sourceMap;
      sourceCode = options.sourceCode;
      preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
      extra = options;
      if (sourceMap2) {
        if (!exports2.browser) {
          SourceNode = requireSourceMap().SourceNode;
        } else {
          SourceNode = commonjsGlobal.sourceMap.SourceNode;
        }
      }
      result = generateInternal(node2);
      if (!sourceMap2) {
        pair = { code: result.toString(), map: null };
        return options.sourceMapWithCode ? pair : pair.code;
      }
      pair = result.toStringWithSourceMap({
        file: options.file,
        sourceRoot: options.sourceMapRoot
      });
      if (options.sourceContent) {
        pair.map.setSourceContent(
          options.sourceMap,
          options.sourceContent
        );
      }
      if (options.sourceMapWithCode) {
        return pair;
      }
      return pair.map.toString();
    }
    FORMAT_MINIFY = {
      indent: {
        style: "",
        base: 0
      },
      renumber: true,
      hexadecimal: true,
      quotes: "auto",
      escapeless: true,
      compact: true,
      parentheses: false,
      semicolons: false
    };
    FORMAT_DEFAULTS = getDefaultOptions().format;
    exports2.version = require$$3.version;
    exports2.generate = generate;
    exports2.attachComments = estraverse$1.attachComments;
    exports2.Precedence = updateDeeply({}, Precedence);
    exports2.browser = false;
    exports2.FORMAT_MINIFY = FORMAT_MINIFY;
    exports2.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
  })();
})(escodegen);
var esprima$1 = { exports: {} };
(function(module2, exports2) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module3 = installedModules[moduleId] = {
            /******/
            exports: {},
            /******/
            id: moduleId,
            /******/
            loaded: false
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.loaded = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        /* 0 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var comment_handler_1 = __webpack_require__(1);
          var jsx_parser_1 = __webpack_require__(3);
          var parser_1 = __webpack_require__(8);
          var tokenizer_1 = __webpack_require__(15);
          function parse2(code2, options, delegate) {
            var commentHandler = null;
            var proxyDelegate = function(node2, metadata) {
              if (delegate) {
                delegate(node2, metadata);
              }
              if (commentHandler) {
                commentHandler.visit(node2, metadata);
              }
            };
            var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
            var collectComment = false;
            if (options) {
              collectComment = typeof options.comment === "boolean" && options.comment;
              var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
              if (collectComment || attachComment) {
                commentHandler = new comment_handler_1.CommentHandler();
                commentHandler.attach = attachComment;
                options.comment = true;
                parserDelegate = proxyDelegate;
              }
            }
            var isModule = false;
            if (options && typeof options.sourceType === "string") {
              isModule = options.sourceType === "module";
            }
            var parser2;
            if (options && typeof options.jsx === "boolean" && options.jsx) {
              parser2 = new jsx_parser_1.JSXParser(code2, options, parserDelegate);
            } else {
              parser2 = new parser_1.Parser(code2, options, parserDelegate);
            }
            var program = isModule ? parser2.parseModule() : parser2.parseScript();
            var ast2 = program;
            if (collectComment && commentHandler) {
              ast2.comments = commentHandler.comments;
            }
            if (parser2.config.tokens) {
              ast2.tokens = parser2.tokens;
            }
            if (parser2.config.tolerant) {
              ast2.errors = parser2.errorHandler.errors;
            }
            return ast2;
          }
          exports3.parse = parse2;
          function parseModule(code2, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "module";
            return parse2(code2, parsingOptions, delegate);
          }
          exports3.parseModule = parseModule;
          function parseScript(code2, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "script";
            return parse2(code2, parsingOptions, delegate);
          }
          exports3.parseScript = parseScript;
          function tokenize(code2, options, delegate) {
            var tokenizer = new tokenizer_1.Tokenizer(code2, options);
            var tokens;
            tokens = [];
            try {
              while (true) {
                var token = tokenizer.getNextToken();
                if (!token) {
                  break;
                }
                if (delegate) {
                  token = delegate(token);
                }
                tokens.push(token);
              }
            } catch (e2) {
              tokenizer.errorHandler.tolerate(e2);
            }
            if (tokenizer.errorHandler.tolerant) {
              tokens.errors = tokenizer.errors();
            }
            return tokens;
          }
          exports3.tokenize = tokenize;
          var syntax_1 = __webpack_require__(2);
          exports3.Syntax = syntax_1.Syntax;
          exports3.version = "4.0.1";
        },
        /* 1 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var CommentHandler = function() {
            function CommentHandler2() {
              this.attach = false;
              this.comments = [];
              this.stack = [];
              this.leading = [];
              this.trailing = [];
            }
            CommentHandler2.prototype.insertInnerComments = function(node2, metadata) {
              if (node2.type === syntax_1.Syntax.BlockStatement && node2.body.length === 0) {
                var innerComments = [];
                for (var i2 = this.leading.length - 1; i2 >= 0; --i2) {
                  var entry = this.leading[i2];
                  if (metadata.end.offset >= entry.start) {
                    innerComments.unshift(entry.comment);
                    this.leading.splice(i2, 1);
                    this.trailing.splice(i2, 1);
                  }
                }
                if (innerComments.length) {
                  node2.innerComments = innerComments;
                }
              }
            };
            CommentHandler2.prototype.findTrailingComments = function(metadata) {
              var trailingComments = [];
              if (this.trailing.length > 0) {
                for (var i2 = this.trailing.length - 1; i2 >= 0; --i2) {
                  var entry_1 = this.trailing[i2];
                  if (entry_1.start >= metadata.end.offset) {
                    trailingComments.unshift(entry_1.comment);
                  }
                }
                this.trailing.length = 0;
                return trailingComments;
              }
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.node.trailingComments) {
                var firstComment = entry.node.trailingComments[0];
                if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                  trailingComments = entry.node.trailingComments;
                  delete entry.node.trailingComments;
                }
              }
              return trailingComments;
            };
            CommentHandler2.prototype.findLeadingComments = function(metadata) {
              var leadingComments = [];
              var target;
              while (this.stack.length > 0) {
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.start >= metadata.start.offset) {
                  target = entry.node;
                  this.stack.pop();
                } else {
                  break;
                }
              }
              if (target) {
                var count = target.leadingComments ? target.leadingComments.length : 0;
                for (var i2 = count - 1; i2 >= 0; --i2) {
                  var comment = target.leadingComments[i2];
                  if (comment.range[1] <= metadata.start.offset) {
                    leadingComments.unshift(comment);
                    target.leadingComments.splice(i2, 1);
                  }
                }
                if (target.leadingComments && target.leadingComments.length === 0) {
                  delete target.leadingComments;
                }
                return leadingComments;
              }
              for (var i2 = this.leading.length - 1; i2 >= 0; --i2) {
                var entry = this.leading[i2];
                if (entry.start <= metadata.start.offset) {
                  leadingComments.unshift(entry.comment);
                  this.leading.splice(i2, 1);
                }
              }
              return leadingComments;
            };
            CommentHandler2.prototype.visitNode = function(node2, metadata) {
              if (node2.type === syntax_1.Syntax.Program && node2.body.length > 0) {
                return;
              }
              this.insertInnerComments(node2, metadata);
              var trailingComments = this.findTrailingComments(metadata);
              var leadingComments = this.findLeadingComments(metadata);
              if (leadingComments.length > 0) {
                node2.leadingComments = leadingComments;
              }
              if (trailingComments.length > 0) {
                node2.trailingComments = trailingComments;
              }
              this.stack.push({
                node: node2,
                start: metadata.start.offset
              });
            };
            CommentHandler2.prototype.visitComment = function(node2, metadata) {
              var type = node2.type[0] === "L" ? "Line" : "Block";
              var comment = {
                type,
                value: node2.value
              };
              if (node2.range) {
                comment.range = node2.range;
              }
              if (node2.loc) {
                comment.loc = node2.loc;
              }
              this.comments.push(comment);
              if (this.attach) {
                var entry = {
                  comment: {
                    type,
                    value: node2.value,
                    range: [metadata.start.offset, metadata.end.offset]
                  },
                  start: metadata.start.offset
                };
                if (node2.loc) {
                  entry.comment.loc = node2.loc;
                }
                node2.type = type;
                this.leading.push(entry);
                this.trailing.push(entry);
              }
            };
            CommentHandler2.prototype.visit = function(node2, metadata) {
              if (node2.type === "LineComment") {
                this.visitComment(node2, metadata);
              } else if (node2.type === "BlockComment") {
                this.visitComment(node2, metadata);
              } else if (this.attach) {
                this.visitNode(node2, metadata);
              }
            };
            return CommentHandler2;
          }();
          exports3.CommentHandler = CommentHandler;
        },
        /* 2 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.Syntax = {
            AssignmentExpression: "AssignmentExpression",
            AssignmentPattern: "AssignmentPattern",
            ArrayExpression: "ArrayExpression",
            ArrayPattern: "ArrayPattern",
            ArrowFunctionExpression: "ArrowFunctionExpression",
            AwaitExpression: "AwaitExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ClassBody: "ClassBody",
            ClassDeclaration: "ClassDeclaration",
            ClassExpression: "ClassExpression",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExportAllDeclaration: "ExportAllDeclaration",
            ExportDefaultDeclaration: "ExportDefaultDeclaration",
            ExportNamedDeclaration: "ExportNamedDeclaration",
            ExportSpecifier: "ExportSpecifier",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForOfStatement: "ForOfStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            ImportDeclaration: "ImportDeclaration",
            ImportDefaultSpecifier: "ImportDefaultSpecifier",
            ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
            ImportSpecifier: "ImportSpecifier",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            MetaProperty: "MetaProperty",
            MethodDefinition: "MethodDefinition",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            ObjectPattern: "ObjectPattern",
            Program: "Program",
            Property: "Property",
            RestElement: "RestElement",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SpreadElement: "SpreadElement",
            Super: "Super",
            SwitchCase: "SwitchCase",
            SwitchStatement: "SwitchStatement",
            TaggedTemplateExpression: "TaggedTemplateExpression",
            TemplateElement: "TemplateElement",
            TemplateLiteral: "TemplateLiteral",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement",
            YieldExpression: "YieldExpression"
          };
        },
        /* 3 */
        /***/
        function(module3, exports3, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
              d2.__proto__ = b2;
            } || function(d2, b2) {
              for (var p2 in b2)
                if (b2.hasOwnProperty(p2))
                  d2[p2] = b2[p2];
            };
            return function(d2, b2) {
              extendStatics2(d2, b2);
              function __() {
                this.constructor = d2;
              }
              d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var character_1 = __webpack_require__(4);
          var JSXNode = __webpack_require__(5);
          var jsx_syntax_1 = __webpack_require__(6);
          var Node2 = __webpack_require__(7);
          var parser_1 = __webpack_require__(8);
          var token_1 = __webpack_require__(13);
          var xhtml_entities_1 = __webpack_require__(14);
          token_1.TokenName[
            100
            /* Identifier */
          ] = "JSXIdentifier";
          token_1.TokenName[
            101
            /* Text */
          ] = "JSXText";
          function getQualifiedElementName(elementName) {
            var qualifiedName;
            switch (elementName.type) {
              case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                var id = elementName;
                qualifiedName = id.name;
                break;
              case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                var ns = elementName;
                qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                break;
              case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                var expr = elementName;
                qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                break;
            }
            return qualifiedName;
          }
          var JSXParser = function(_super) {
            __extends2(JSXParser2, _super);
            function JSXParser2(code2, options, delegate) {
              return _super.call(this, code2, options, delegate) || this;
            }
            JSXParser2.prototype.parsePrimaryExpression = function() {
              return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
            };
            JSXParser2.prototype.startJSX = function() {
              this.scanner.index = this.startMarker.index;
              this.scanner.lineNumber = this.startMarker.line;
              this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
            };
            JSXParser2.prototype.finishJSX = function() {
              this.nextToken();
            };
            JSXParser2.prototype.reenterJSX = function() {
              this.startJSX();
              this.expectJSX("}");
              if (this.config.tokens) {
                this.tokens.pop();
              }
            };
            JSXParser2.prototype.createJSXNode = function() {
              this.collectComments();
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.createJSXChildNode = function() {
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.scanXHTMLEntity = function(quote) {
              var result = "&";
              var valid2 = true;
              var terminated = false;
              var numeric2 = false;
              var hex = false;
              while (!this.scanner.eof() && valid2 && !terminated) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === quote) {
                  break;
                }
                terminated = ch === ";";
                result += ch;
                ++this.scanner.index;
                if (!terminated) {
                  switch (result.length) {
                    case 2:
                      numeric2 = ch === "#";
                      break;
                    case 3:
                      if (numeric2) {
                        hex = ch === "x";
                        valid2 = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                        numeric2 = numeric2 && !hex;
                      }
                      break;
                    default:
                      valid2 = valid2 && !(numeric2 && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                      valid2 = valid2 && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                      break;
                  }
                }
              }
              if (valid2 && terminated && result.length > 2) {
                var str = result.substr(1, result.length - 2);
                if (numeric2 && str.length > 1) {
                  result = String.fromCharCode(parseInt(str.substr(1), 10));
                } else if (hex && str.length > 2) {
                  result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                } else if (!numeric2 && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                  result = xhtml_entities_1.XHTMLEntities[str];
                }
              }
              return result;
            };
            JSXParser2.prototype.lexJSX = function() {
              var cp = this.scanner.source.charCodeAt(this.scanner.index);
              if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                var value = this.scanner.source[this.scanner.index++];
                return {
                  type: 7,
                  value,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index - 1,
                  end: this.scanner.index
                };
              }
              if (cp === 34 || cp === 39) {
                var start = this.scanner.index;
                var quote = this.scanner.source[this.scanner.index++];
                var str = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index++];
                  if (ch === quote) {
                    break;
                  } else if (ch === "&") {
                    str += this.scanXHTMLEntity(quote);
                  } else {
                    str += ch;
                  }
                }
                return {
                  type: 8,
                  value: str,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 46) {
                var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                var value = n1 === 46 && n2 === 46 ? "..." : ".";
                var start = this.scanner.index;
                this.scanner.index += value.length;
                return {
                  type: 7,
                  value,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 96) {
                return {
                  type: 10,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index,
                  end: this.scanner.index
                };
              }
              if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                var start = this.scanner.index;
                ++this.scanner.index;
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source.charCodeAt(this.scanner.index);
                  if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                    ++this.scanner.index;
                  } else if (ch === 45) {
                    ++this.scanner.index;
                  } else {
                    break;
                  }
                }
                var id = this.scanner.source.slice(start, this.scanner.index);
                return {
                  type: 100,
                  value: id,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              return this.scanner.lex();
            };
            JSXParser2.prototype.nextJSXToken = function() {
              this.collectComments();
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = this.lexJSX();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              if (this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.nextJSXText = function() {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var start = this.scanner.index;
              var text = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === "{" || ch === "<") {
                  break;
                }
                ++this.scanner.index;
                text += ch;
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.scanner.lineNumber;
                  if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                    ++this.scanner.index;
                  }
                  this.scanner.lineStart = this.scanner.index;
                }
              }
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = {
                type: 101,
                value: text,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
              if (text.length > 0 && this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.peekJSXToken = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.lexJSX();
              this.scanner.restoreState(state);
              return next;
            };
            JSXParser2.prototype.expectJSX = function(value) {
              var token = this.nextJSXToken();
              if (token.type !== 7 || token.value !== value) {
                this.throwUnexpectedToken(token);
              }
            };
            JSXParser2.prototype.matchJSX = function(value) {
              var next = this.peekJSXToken();
              return next.type === 7 && next.value === value;
            };
            JSXParser2.prototype.parseJSXIdentifier = function() {
              var node2 = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 100) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node2, new JSXNode.JSXIdentifier(token.value));
            };
            JSXParser2.prototype.parseJSXElementName = function() {
              var node2 = this.createJSXNode();
              var elementName = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = elementName;
                this.expectJSX(":");
                var name_1 = this.parseJSXIdentifier();
                elementName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_1));
              } else if (this.matchJSX(".")) {
                while (this.matchJSX(".")) {
                  var object = elementName;
                  this.expectJSX(".");
                  var property = this.parseJSXIdentifier();
                  elementName = this.finalize(node2, new JSXNode.JSXMemberExpression(object, property));
                }
              }
              return elementName;
            };
            JSXParser2.prototype.parseJSXAttributeName = function() {
              var node2 = this.createJSXNode();
              var attributeName;
              var identifier = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = identifier;
                this.expectJSX(":");
                var name_2 = this.parseJSXIdentifier();
                attributeName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_2));
              } else {
                attributeName = identifier;
              }
              return attributeName;
            };
            JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
              var node2 = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 8) {
                this.throwUnexpectedToken(token);
              }
              var raw = this.getTokenRaw(token);
              return this.finalize(node2, new Node2.Literal(token.value, raw));
            };
            JSXParser2.prototype.parseJSXExpressionAttribute = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("{");
              this.finishJSX();
              if (this.match("}")) {
                this.tolerateError("JSX attributes must only be assigned a non-empty expression");
              }
              var expression = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXAttributeValue = function() {
              return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
            };
            JSXParser2.prototype.parseJSXNameValueAttribute = function() {
              var node2 = this.createJSXNode();
              var name2 = this.parseJSXAttributeName();
              var value = null;
              if (this.matchJSX("=")) {
                this.expectJSX("=");
                value = this.parseJSXAttributeValue();
              }
              return this.finalize(node2, new JSXNode.JSXAttribute(name2, value));
            };
            JSXParser2.prototype.parseJSXSpreadAttribute = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("{");
              this.expectJSX("...");
              this.finishJSX();
              var argument = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node2, new JSXNode.JSXSpreadAttribute(argument));
            };
            JSXParser2.prototype.parseJSXAttributes = function() {
              var attributes = [];
              while (!this.matchJSX("/") && !this.matchJSX(">")) {
                var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                attributes.push(attribute);
              }
              return attributes;
            };
            JSXParser2.prototype.parseJSXOpeningElement = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("<");
              var name2 = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXBoundaryElement = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("<");
              if (this.matchJSX("/")) {
                this.expectJSX("/");
                var name_3 = this.parseJSXElementName();
                this.expectJSX(">");
                return this.finalize(node2, new JSXNode.JSXClosingElement(name_3));
              }
              var name2 = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXEmptyExpression = function() {
              var node2 = this.createJSXChildNode();
              this.collectComments();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              return this.finalize(node2, new JSXNode.JSXEmptyExpression());
            };
            JSXParser2.prototype.parseJSXExpressionContainer = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("{");
              var expression;
              if (this.matchJSX("}")) {
                expression = this.parseJSXEmptyExpression();
                this.expectJSX("}");
              } else {
                this.finishJSX();
                expression = this.parseAssignmentExpression();
                this.reenterJSX();
              }
              return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXChildren = function() {
              var children = [];
              while (!this.scanner.eof()) {
                var node2 = this.createJSXChildNode();
                var token = this.nextJSXText();
                if (token.start < token.end) {
                  var raw = this.getTokenRaw(token);
                  var child = this.finalize(node2, new JSXNode.JSXText(token.value, raw));
                  children.push(child);
                }
                if (this.scanner.source[this.scanner.index] === "{") {
                  var container = this.parseJSXExpressionContainer();
                  children.push(container);
                } else {
                  break;
                }
              }
              return children;
            };
            JSXParser2.prototype.parseComplexJSXElement = function(el) {
              var stack = [];
              while (!this.scanner.eof()) {
                el.children = el.children.concat(this.parseJSXChildren());
                var node2 = this.createJSXChildNode();
                var element = this.parseJSXBoundaryElement();
                if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                  var opening = element;
                  if (opening.selfClosing) {
                    var child = this.finalize(node2, new JSXNode.JSXElement(opening, [], null));
                    el.children.push(child);
                  } else {
                    stack.push(el);
                    el = { node: node2, opening, closing: null, children: [] };
                  }
                }
                if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                  el.closing = element;
                  var open_1 = getQualifiedElementName(el.opening.name);
                  var close_1 = getQualifiedElementName(el.closing.name);
                  if (open_1 !== close_1) {
                    this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                  }
                  if (stack.length > 0) {
                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                    el = stack[stack.length - 1];
                    el.children.push(child);
                    stack.pop();
                  } else {
                    break;
                  }
                }
              }
              return el;
            };
            JSXParser2.prototype.parseJSXElement = function() {
              var node2 = this.createJSXNode();
              var opening = this.parseJSXOpeningElement();
              var children = [];
              var closing = null;
              if (!opening.selfClosing) {
                var el = this.parseComplexJSXElement({ node: node2, opening, closing, children });
                children = el.children;
                closing = el.closing;
              }
              return this.finalize(node2, new JSXNode.JSXElement(opening, children, closing));
            };
            JSXParser2.prototype.parseJSXRoot = function() {
              if (this.config.tokens) {
                this.tokens.pop();
              }
              this.startJSX();
              var element = this.parseJSXElement();
              this.finishJSX();
              return element;
            };
            JSXParser2.prototype.isStartOfExpression = function() {
              return _super.prototype.isStartOfExpression.call(this) || this.match("<");
            };
            return JSXParser2;
          }(parser_1.Parser);
          exports3.JSXParser = JSXParser;
        },
        /* 4 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var Regex = {
            // Unicode v8.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            // Unicode v8.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
          };
          exports3.Character = {
            /* tslint:disable:no-bitwise */
            fromCodePoint: function(cp) {
              return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
            },
            // https://tc39.github.io/ecma262/#sec-white-space
            isWhiteSpace: function(cp) {
              return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
            },
            // https://tc39.github.io/ecma262/#sec-line-terminators
            isLineTerminator: function(cp) {
              return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
            },
            // https://tc39.github.io/ecma262/#sec-names-and-keywords
            isIdentifierStart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports3.Character.fromCodePoint(cp));
            },
            isIdentifierPart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports3.Character.fromCodePoint(cp));
            },
            // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
            isDecimalDigit: function(cp) {
              return cp >= 48 && cp <= 57;
            },
            isHexDigit: function(cp) {
              return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
            },
            isOctalDigit: function(cp) {
              return cp >= 48 && cp <= 55;
            }
          };
        },
        /* 5 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var jsx_syntax_1 = __webpack_require__(6);
          var JSXClosingElement = /* @__PURE__ */ function() {
            function JSXClosingElement2(name2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
              this.name = name2;
            }
            return JSXClosingElement2;
          }();
          exports3.JSXClosingElement = JSXClosingElement;
          var JSXElement = /* @__PURE__ */ function() {
            function JSXElement2(openingElement, children, closingElement) {
              this.type = jsx_syntax_1.JSXSyntax.JSXElement;
              this.openingElement = openingElement;
              this.children = children;
              this.closingElement = closingElement;
            }
            return JSXElement2;
          }();
          exports3.JSXElement = JSXElement;
          var JSXEmptyExpression = /* @__PURE__ */ function() {
            function JSXEmptyExpression2() {
              this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
            }
            return JSXEmptyExpression2;
          }();
          exports3.JSXEmptyExpression = JSXEmptyExpression;
          var JSXExpressionContainer = /* @__PURE__ */ function() {
            function JSXExpressionContainer2(expression) {
              this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
              this.expression = expression;
            }
            return JSXExpressionContainer2;
          }();
          exports3.JSXExpressionContainer = JSXExpressionContainer;
          var JSXIdentifier = /* @__PURE__ */ function() {
            function JSXIdentifier2(name2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
              this.name = name2;
            }
            return JSXIdentifier2;
          }();
          exports3.JSXIdentifier = JSXIdentifier;
          var JSXMemberExpression = /* @__PURE__ */ function() {
            function JSXMemberExpression2(object, property) {
              this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
              this.object = object;
              this.property = property;
            }
            return JSXMemberExpression2;
          }();
          exports3.JSXMemberExpression = JSXMemberExpression;
          var JSXAttribute = /* @__PURE__ */ function() {
            function JSXAttribute2(name2, value) {
              this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
              this.name = name2;
              this.value = value;
            }
            return JSXAttribute2;
          }();
          exports3.JSXAttribute = JSXAttribute;
          var JSXNamespacedName = /* @__PURE__ */ function() {
            function JSXNamespacedName2(namespace, name2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
              this.namespace = namespace;
              this.name = name2;
            }
            return JSXNamespacedName2;
          }();
          exports3.JSXNamespacedName = JSXNamespacedName;
          var JSXOpeningElement = /* @__PURE__ */ function() {
            function JSXOpeningElement2(name2, selfClosing, attributes) {
              this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
              this.name = name2;
              this.selfClosing = selfClosing;
              this.attributes = attributes;
            }
            return JSXOpeningElement2;
          }();
          exports3.JSXOpeningElement = JSXOpeningElement;
          var JSXSpreadAttribute = /* @__PURE__ */ function() {
            function JSXSpreadAttribute2(argument) {
              this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
              this.argument = argument;
            }
            return JSXSpreadAttribute2;
          }();
          exports3.JSXSpreadAttribute = JSXSpreadAttribute;
          var JSXText = /* @__PURE__ */ function() {
            function JSXText2(value, raw) {
              this.type = jsx_syntax_1.JSXSyntax.JSXText;
              this.value = value;
              this.raw = raw;
            }
            return JSXText2;
          }();
          exports3.JSXText = JSXText;
        },
        /* 6 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.JSXSyntax = {
            JSXAttribute: "JSXAttribute",
            JSXClosingElement: "JSXClosingElement",
            JSXElement: "JSXElement",
            JSXEmptyExpression: "JSXEmptyExpression",
            JSXExpressionContainer: "JSXExpressionContainer",
            JSXIdentifier: "JSXIdentifier",
            JSXMemberExpression: "JSXMemberExpression",
            JSXNamespacedName: "JSXNamespacedName",
            JSXOpeningElement: "JSXOpeningElement",
            JSXSpreadAttribute: "JSXSpreadAttribute",
            JSXText: "JSXText"
          };
        },
        /* 7 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var ArrayExpression = /* @__PURE__ */ function() {
            function ArrayExpression2(elements) {
              this.type = syntax_1.Syntax.ArrayExpression;
              this.elements = elements;
            }
            return ArrayExpression2;
          }();
          exports3.ArrayExpression = ArrayExpression;
          var ArrayPattern = /* @__PURE__ */ function() {
            function ArrayPattern2(elements) {
              this.type = syntax_1.Syntax.ArrayPattern;
              this.elements = elements;
            }
            return ArrayPattern2;
          }();
          exports3.ArrayPattern = ArrayPattern;
          var ArrowFunctionExpression = /* @__PURE__ */ function() {
            function ArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = false;
            }
            return ArrowFunctionExpression2;
          }();
          exports3.ArrowFunctionExpression = ArrowFunctionExpression;
          var AssignmentExpression = /* @__PURE__ */ function() {
            function AssignmentExpression2(operator, left2, right2) {
              this.type = syntax_1.Syntax.AssignmentExpression;
              this.operator = operator;
              this.left = left2;
              this.right = right2;
            }
            return AssignmentExpression2;
          }();
          exports3.AssignmentExpression = AssignmentExpression;
          var AssignmentPattern = /* @__PURE__ */ function() {
            function AssignmentPattern2(left2, right2) {
              this.type = syntax_1.Syntax.AssignmentPattern;
              this.left = left2;
              this.right = right2;
            }
            return AssignmentPattern2;
          }();
          exports3.AssignmentPattern = AssignmentPattern;
          var AsyncArrowFunctionExpression = /* @__PURE__ */ function() {
            function AsyncArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = true;
            }
            return AsyncArrowFunctionExpression2;
          }();
          exports3.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
          var AsyncFunctionDeclaration = /* @__PURE__ */ function() {
            function AsyncFunctionDeclaration2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionDeclaration2;
          }();
          exports3.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
          var AsyncFunctionExpression = /* @__PURE__ */ function() {
            function AsyncFunctionExpression2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionExpression2;
          }();
          exports3.AsyncFunctionExpression = AsyncFunctionExpression;
          var AwaitExpression = /* @__PURE__ */ function() {
            function AwaitExpression2(argument) {
              this.type = syntax_1.Syntax.AwaitExpression;
              this.argument = argument;
            }
            return AwaitExpression2;
          }();
          exports3.AwaitExpression = AwaitExpression;
          var BinaryExpression = /* @__PURE__ */ function() {
            function BinaryExpression2(operator, left2, right2) {
              var logical = operator === "||" || operator === "&&";
              this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
              this.operator = operator;
              this.left = left2;
              this.right = right2;
            }
            return BinaryExpression2;
          }();
          exports3.BinaryExpression = BinaryExpression;
          var BlockStatement = /* @__PURE__ */ function() {
            function BlockStatement2(body) {
              this.type = syntax_1.Syntax.BlockStatement;
              this.body = body;
            }
            return BlockStatement2;
          }();
          exports3.BlockStatement = BlockStatement;
          var BreakStatement = /* @__PURE__ */ function() {
            function BreakStatement2(label) {
              this.type = syntax_1.Syntax.BreakStatement;
              this.label = label;
            }
            return BreakStatement2;
          }();
          exports3.BreakStatement = BreakStatement;
          var CallExpression = /* @__PURE__ */ function() {
            function CallExpression2(callee, args) {
              this.type = syntax_1.Syntax.CallExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return CallExpression2;
          }();
          exports3.CallExpression = CallExpression;
          var CatchClause = /* @__PURE__ */ function() {
            function CatchClause2(param, body) {
              this.type = syntax_1.Syntax.CatchClause;
              this.param = param;
              this.body = body;
            }
            return CatchClause2;
          }();
          exports3.CatchClause = CatchClause;
          var ClassBody = /* @__PURE__ */ function() {
            function ClassBody2(body) {
              this.type = syntax_1.Syntax.ClassBody;
              this.body = body;
            }
            return ClassBody2;
          }();
          exports3.ClassBody = ClassBody;
          var ClassDeclaration = /* @__PURE__ */ function() {
            function ClassDeclaration2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassDeclaration;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassDeclaration2;
          }();
          exports3.ClassDeclaration = ClassDeclaration;
          var ClassExpression = /* @__PURE__ */ function() {
            function ClassExpression2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassExpression;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassExpression2;
          }();
          exports3.ClassExpression = ClassExpression;
          var ComputedMemberExpression = /* @__PURE__ */ function() {
            function ComputedMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = true;
              this.object = object;
              this.property = property;
            }
            return ComputedMemberExpression2;
          }();
          exports3.ComputedMemberExpression = ComputedMemberExpression;
          var ConditionalExpression = /* @__PURE__ */ function() {
            function ConditionalExpression2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.ConditionalExpression;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return ConditionalExpression2;
          }();
          exports3.ConditionalExpression = ConditionalExpression;
          var ContinueStatement = /* @__PURE__ */ function() {
            function ContinueStatement2(label) {
              this.type = syntax_1.Syntax.ContinueStatement;
              this.label = label;
            }
            return ContinueStatement2;
          }();
          exports3.ContinueStatement = ContinueStatement;
          var DebuggerStatement = /* @__PURE__ */ function() {
            function DebuggerStatement2() {
              this.type = syntax_1.Syntax.DebuggerStatement;
            }
            return DebuggerStatement2;
          }();
          exports3.DebuggerStatement = DebuggerStatement;
          var Directive = /* @__PURE__ */ function() {
            function Directive2(expression, directive) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
              this.directive = directive;
            }
            return Directive2;
          }();
          exports3.Directive = Directive;
          var DoWhileStatement = /* @__PURE__ */ function() {
            function DoWhileStatement2(body, test) {
              this.type = syntax_1.Syntax.DoWhileStatement;
              this.body = body;
              this.test = test;
            }
            return DoWhileStatement2;
          }();
          exports3.DoWhileStatement = DoWhileStatement;
          var EmptyStatement = /* @__PURE__ */ function() {
            function EmptyStatement2() {
              this.type = syntax_1.Syntax.EmptyStatement;
            }
            return EmptyStatement2;
          }();
          exports3.EmptyStatement = EmptyStatement;
          var ExportAllDeclaration = /* @__PURE__ */ function() {
            function ExportAllDeclaration2(source2) {
              this.type = syntax_1.Syntax.ExportAllDeclaration;
              this.source = source2;
            }
            return ExportAllDeclaration2;
          }();
          exports3.ExportAllDeclaration = ExportAllDeclaration;
          var ExportDefaultDeclaration = /* @__PURE__ */ function() {
            function ExportDefaultDeclaration2(declaration) {
              this.type = syntax_1.Syntax.ExportDefaultDeclaration;
              this.declaration = declaration;
            }
            return ExportDefaultDeclaration2;
          }();
          exports3.ExportDefaultDeclaration = ExportDefaultDeclaration;
          var ExportNamedDeclaration = /* @__PURE__ */ function() {
            function ExportNamedDeclaration2(declaration, specifiers, source2) {
              this.type = syntax_1.Syntax.ExportNamedDeclaration;
              this.declaration = declaration;
              this.specifiers = specifiers;
              this.source = source2;
            }
            return ExportNamedDeclaration2;
          }();
          exports3.ExportNamedDeclaration = ExportNamedDeclaration;
          var ExportSpecifier = /* @__PURE__ */ function() {
            function ExportSpecifier2(local, exported) {
              this.type = syntax_1.Syntax.ExportSpecifier;
              this.exported = exported;
              this.local = local;
            }
            return ExportSpecifier2;
          }();
          exports3.ExportSpecifier = ExportSpecifier;
          var ExpressionStatement = /* @__PURE__ */ function() {
            function ExpressionStatement2(expression) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
            }
            return ExpressionStatement2;
          }();
          exports3.ExpressionStatement = ExpressionStatement;
          var ForInStatement = /* @__PURE__ */ function() {
            function ForInStatement2(left2, right2, body) {
              this.type = syntax_1.Syntax.ForInStatement;
              this.left = left2;
              this.right = right2;
              this.body = body;
              this.each = false;
            }
            return ForInStatement2;
          }();
          exports3.ForInStatement = ForInStatement;
          var ForOfStatement = /* @__PURE__ */ function() {
            function ForOfStatement2(left2, right2, body) {
              this.type = syntax_1.Syntax.ForOfStatement;
              this.left = left2;
              this.right = right2;
              this.body = body;
            }
            return ForOfStatement2;
          }();
          exports3.ForOfStatement = ForOfStatement;
          var ForStatement = /* @__PURE__ */ function() {
            function ForStatement2(init, test, update, body) {
              this.type = syntax_1.Syntax.ForStatement;
              this.init = init;
              this.test = test;
              this.update = update;
              this.body = body;
            }
            return ForStatement2;
          }();
          exports3.ForStatement = ForStatement;
          var FunctionDeclaration = /* @__PURE__ */ function() {
            function FunctionDeclaration2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionDeclaration2;
          }();
          exports3.FunctionDeclaration = FunctionDeclaration;
          var FunctionExpression = /* @__PURE__ */ function() {
            function FunctionExpression2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionExpression2;
          }();
          exports3.FunctionExpression = FunctionExpression;
          var Identifier = /* @__PURE__ */ function() {
            function Identifier2(name2) {
              this.type = syntax_1.Syntax.Identifier;
              this.name = name2;
            }
            return Identifier2;
          }();
          exports3.Identifier = Identifier;
          var IfStatement = /* @__PURE__ */ function() {
            function IfStatement2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.IfStatement;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return IfStatement2;
          }();
          exports3.IfStatement = IfStatement;
          var ImportDeclaration = /* @__PURE__ */ function() {
            function ImportDeclaration2(specifiers, source2) {
              this.type = syntax_1.Syntax.ImportDeclaration;
              this.specifiers = specifiers;
              this.source = source2;
            }
            return ImportDeclaration2;
          }();
          exports3.ImportDeclaration = ImportDeclaration;
          var ImportDefaultSpecifier = /* @__PURE__ */ function() {
            function ImportDefaultSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportDefaultSpecifier;
              this.local = local;
            }
            return ImportDefaultSpecifier2;
          }();
          exports3.ImportDefaultSpecifier = ImportDefaultSpecifier;
          var ImportNamespaceSpecifier = /* @__PURE__ */ function() {
            function ImportNamespaceSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
              this.local = local;
            }
            return ImportNamespaceSpecifier2;
          }();
          exports3.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
          var ImportSpecifier = /* @__PURE__ */ function() {
            function ImportSpecifier2(local, imported) {
              this.type = syntax_1.Syntax.ImportSpecifier;
              this.local = local;
              this.imported = imported;
            }
            return ImportSpecifier2;
          }();
          exports3.ImportSpecifier = ImportSpecifier;
          var LabeledStatement = /* @__PURE__ */ function() {
            function LabeledStatement2(label, body) {
              this.type = syntax_1.Syntax.LabeledStatement;
              this.label = label;
              this.body = body;
            }
            return LabeledStatement2;
          }();
          exports3.LabeledStatement = LabeledStatement;
          var Literal = /* @__PURE__ */ function() {
            function Literal2(value, raw) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value;
              this.raw = raw;
            }
            return Literal2;
          }();
          exports3.Literal = Literal;
          var MetaProperty = /* @__PURE__ */ function() {
            function MetaProperty2(meta, property) {
              this.type = syntax_1.Syntax.MetaProperty;
              this.meta = meta;
              this.property = property;
            }
            return MetaProperty2;
          }();
          exports3.MetaProperty = MetaProperty;
          var MethodDefinition = /* @__PURE__ */ function() {
            function MethodDefinition2(key, computed, value, kind, isStatic) {
              this.type = syntax_1.Syntax.MethodDefinition;
              this.key = key;
              this.computed = computed;
              this.value = value;
              this.kind = kind;
              this.static = isStatic;
            }
            return MethodDefinition2;
          }();
          exports3.MethodDefinition = MethodDefinition;
          var Module = /* @__PURE__ */ function() {
            function Module2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "module";
            }
            return Module2;
          }();
          exports3.Module = Module;
          var NewExpression = /* @__PURE__ */ function() {
            function NewExpression2(callee, args) {
              this.type = syntax_1.Syntax.NewExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return NewExpression2;
          }();
          exports3.NewExpression = NewExpression;
          var ObjectExpression = /* @__PURE__ */ function() {
            function ObjectExpression2(properties) {
              this.type = syntax_1.Syntax.ObjectExpression;
              this.properties = properties;
            }
            return ObjectExpression2;
          }();
          exports3.ObjectExpression = ObjectExpression;
          var ObjectPattern = /* @__PURE__ */ function() {
            function ObjectPattern2(properties) {
              this.type = syntax_1.Syntax.ObjectPattern;
              this.properties = properties;
            }
            return ObjectPattern2;
          }();
          exports3.ObjectPattern = ObjectPattern;
          var Property = /* @__PURE__ */ function() {
            function Property2(kind, key, computed, value, method, shorthand) {
              this.type = syntax_1.Syntax.Property;
              this.key = key;
              this.computed = computed;
              this.value = value;
              this.kind = kind;
              this.method = method;
              this.shorthand = shorthand;
            }
            return Property2;
          }();
          exports3.Property = Property;
          var RegexLiteral = /* @__PURE__ */ function() {
            function RegexLiteral2(value, raw, pattern, flags) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value;
              this.raw = raw;
              this.regex = { pattern, flags };
            }
            return RegexLiteral2;
          }();
          exports3.RegexLiteral = RegexLiteral;
          var RestElement = /* @__PURE__ */ function() {
            function RestElement2(argument) {
              this.type = syntax_1.Syntax.RestElement;
              this.argument = argument;
            }
            return RestElement2;
          }();
          exports3.RestElement = RestElement;
          var ReturnStatement = /* @__PURE__ */ function() {
            function ReturnStatement2(argument) {
              this.type = syntax_1.Syntax.ReturnStatement;
              this.argument = argument;
            }
            return ReturnStatement2;
          }();
          exports3.ReturnStatement = ReturnStatement;
          var Script = /* @__PURE__ */ function() {
            function Script2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "script";
            }
            return Script2;
          }();
          exports3.Script = Script;
          var SequenceExpression = /* @__PURE__ */ function() {
            function SequenceExpression2(expressions) {
              this.type = syntax_1.Syntax.SequenceExpression;
              this.expressions = expressions;
            }
            return SequenceExpression2;
          }();
          exports3.SequenceExpression = SequenceExpression;
          var SpreadElement = /* @__PURE__ */ function() {
            function SpreadElement2(argument) {
              this.type = syntax_1.Syntax.SpreadElement;
              this.argument = argument;
            }
            return SpreadElement2;
          }();
          exports3.SpreadElement = SpreadElement;
          var StaticMemberExpression = /* @__PURE__ */ function() {
            function StaticMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = false;
              this.object = object;
              this.property = property;
            }
            return StaticMemberExpression2;
          }();
          exports3.StaticMemberExpression = StaticMemberExpression;
          var Super = /* @__PURE__ */ function() {
            function Super2() {
              this.type = syntax_1.Syntax.Super;
            }
            return Super2;
          }();
          exports3.Super = Super;
          var SwitchCase = /* @__PURE__ */ function() {
            function SwitchCase2(test, consequent) {
              this.type = syntax_1.Syntax.SwitchCase;
              this.test = test;
              this.consequent = consequent;
            }
            return SwitchCase2;
          }();
          exports3.SwitchCase = SwitchCase;
          var SwitchStatement = /* @__PURE__ */ function() {
            function SwitchStatement2(discriminant, cases) {
              this.type = syntax_1.Syntax.SwitchStatement;
              this.discriminant = discriminant;
              this.cases = cases;
            }
            return SwitchStatement2;
          }();
          exports3.SwitchStatement = SwitchStatement;
          var TaggedTemplateExpression = /* @__PURE__ */ function() {
            function TaggedTemplateExpression2(tag, quasi) {
              this.type = syntax_1.Syntax.TaggedTemplateExpression;
              this.tag = tag;
              this.quasi = quasi;
            }
            return TaggedTemplateExpression2;
          }();
          exports3.TaggedTemplateExpression = TaggedTemplateExpression;
          var TemplateElement = /* @__PURE__ */ function() {
            function TemplateElement2(value, tail) {
              this.type = syntax_1.Syntax.TemplateElement;
              this.value = value;
              this.tail = tail;
            }
            return TemplateElement2;
          }();
          exports3.TemplateElement = TemplateElement;
          var TemplateLiteral = /* @__PURE__ */ function() {
            function TemplateLiteral2(quasis, expressions) {
              this.type = syntax_1.Syntax.TemplateLiteral;
              this.quasis = quasis;
              this.expressions = expressions;
            }
            return TemplateLiteral2;
          }();
          exports3.TemplateLiteral = TemplateLiteral;
          var ThisExpression = /* @__PURE__ */ function() {
            function ThisExpression2() {
              this.type = syntax_1.Syntax.ThisExpression;
            }
            return ThisExpression2;
          }();
          exports3.ThisExpression = ThisExpression;
          var ThrowStatement = /* @__PURE__ */ function() {
            function ThrowStatement2(argument) {
              this.type = syntax_1.Syntax.ThrowStatement;
              this.argument = argument;
            }
            return ThrowStatement2;
          }();
          exports3.ThrowStatement = ThrowStatement;
          var TryStatement = /* @__PURE__ */ function() {
            function TryStatement2(block, handler, finalizer) {
              this.type = syntax_1.Syntax.TryStatement;
              this.block = block;
              this.handler = handler;
              this.finalizer = finalizer;
            }
            return TryStatement2;
          }();
          exports3.TryStatement = TryStatement;
          var UnaryExpression = /* @__PURE__ */ function() {
            function UnaryExpression2(operator, argument) {
              this.type = syntax_1.Syntax.UnaryExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = true;
            }
            return UnaryExpression2;
          }();
          exports3.UnaryExpression = UnaryExpression;
          var UpdateExpression = /* @__PURE__ */ function() {
            function UpdateExpression2(operator, argument, prefix) {
              this.type = syntax_1.Syntax.UpdateExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = prefix;
            }
            return UpdateExpression2;
          }();
          exports3.UpdateExpression = UpdateExpression;
          var VariableDeclaration = /* @__PURE__ */ function() {
            function VariableDeclaration2(declarations, kind) {
              this.type = syntax_1.Syntax.VariableDeclaration;
              this.declarations = declarations;
              this.kind = kind;
            }
            return VariableDeclaration2;
          }();
          exports3.VariableDeclaration = VariableDeclaration;
          var VariableDeclarator = /* @__PURE__ */ function() {
            function VariableDeclarator2(id, init) {
              this.type = syntax_1.Syntax.VariableDeclarator;
              this.id = id;
              this.init = init;
            }
            return VariableDeclarator2;
          }();
          exports3.VariableDeclarator = VariableDeclarator;
          var WhileStatement = /* @__PURE__ */ function() {
            function WhileStatement2(test, body) {
              this.type = syntax_1.Syntax.WhileStatement;
              this.test = test;
              this.body = body;
            }
            return WhileStatement2;
          }();
          exports3.WhileStatement = WhileStatement;
          var WithStatement = /* @__PURE__ */ function() {
            function WithStatement2(object, body) {
              this.type = syntax_1.Syntax.WithStatement;
              this.object = object;
              this.body = body;
            }
            return WithStatement2;
          }();
          exports3.WithStatement = WithStatement;
          var YieldExpression = /* @__PURE__ */ function() {
            function YieldExpression2(argument, delegate) {
              this.type = syntax_1.Syntax.YieldExpression;
              this.argument = argument;
              this.delegate = delegate;
            }
            return YieldExpression2;
          }();
          exports3.YieldExpression = YieldExpression;
        },
        /* 8 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var assert_12 = __webpack_require__(9);
          var error_handler_1 = __webpack_require__(10);
          var messages_1 = __webpack_require__(11);
          var Node2 = __webpack_require__(7);
          var scanner_1 = __webpack_require__(12);
          var syntax_1 = __webpack_require__(2);
          var token_1 = __webpack_require__(13);
          var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
          var Parser3 = function() {
            function Parser4(code2, options, delegate) {
              if (options === void 0) {
                options = {};
              }
              this.config = {
                range: typeof options.range === "boolean" && options.range,
                loc: typeof options.loc === "boolean" && options.loc,
                source: null,
                tokens: typeof options.tokens === "boolean" && options.tokens,
                comment: typeof options.comment === "boolean" && options.comment,
                tolerant: typeof options.tolerant === "boolean" && options.tolerant
              };
              if (this.config.loc && options.source && options.source !== null) {
                this.config.source = String(options.source);
              }
              this.delegate = delegate;
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = this.config.tolerant;
              this.scanner = new scanner_1.Scanner(code2, this.errorHandler);
              this.scanner.trackComment = this.config.comment;
              this.operatorPrecedence = {
                ")": 0,
                ";": 0,
                ",": 0,
                "=": 0,
                "]": 0,
                "||": 1,
                "&&": 2,
                "|": 3,
                "^": 4,
                "&": 5,
                "==": 6,
                "!=": 6,
                "===": 6,
                "!==": 6,
                "<": 7,
                ">": 7,
                "<=": 7,
                ">=": 7,
                "<<": 8,
                ">>": 8,
                ">>>": 8,
                "+": 9,
                "-": 9,
                "*": 11,
                "/": 11,
                "%": 11
              };
              this.lookahead = {
                type: 2,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: 0,
                start: 0,
                end: 0
              };
              this.hasLineTerminator = false;
              this.context = {
                isModule: false,
                await: false,
                allowIn: true,
                allowStrictDirective: true,
                allowYield: true,
                firstCoverInitializedNameError: null,
                isAssignmentTarget: false,
                isBindingElement: false,
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                labelSet: {},
                strict: false
              };
              this.tokens = [];
              this.startMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.lastMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.nextToken();
              this.lastMarker = {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }
            Parser4.prototype.throwError = function(messageFormat) {
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_12.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index2 = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              throw this.errorHandler.createError(index2, line, column, msg);
            };
            Parser4.prototype.tolerateError = function(messageFormat) {
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_12.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index2 = this.lastMarker.index;
              var line = this.scanner.lineNumber;
              var column = this.lastMarker.column + 1;
              this.errorHandler.tolerateError(index2, line, column, msg);
            };
            Parser4.prototype.unexpectedTokenError = function(token, message2) {
              var msg = message2 || messages_1.Messages.UnexpectedToken;
              var value;
              if (token) {
                if (!message2) {
                  msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                  if (token.type === 4) {
                    if (this.scanner.isFutureReservedWord(token.value)) {
                      msg = messages_1.Messages.UnexpectedReserved;
                    } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                      msg = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                value = token.value;
              } else {
                value = "ILLEGAL";
              }
              msg = msg.replace("%0", value);
              if (token && typeof token.lineNumber === "number") {
                var index2 = token.start;
                var line = token.lineNumber;
                var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                var column = token.start - lastMarkerLineStart + 1;
                return this.errorHandler.createError(index2, line, column, msg);
              } else {
                var index2 = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                return this.errorHandler.createError(index2, line, column, msg);
              }
            };
            Parser4.prototype.throwUnexpectedToken = function(token, message2) {
              throw this.unexpectedTokenError(token, message2);
            };
            Parser4.prototype.tolerateUnexpectedToken = function(token, message2) {
              this.errorHandler.tolerate(this.unexpectedTokenError(token, message2));
            };
            Parser4.prototype.collectComments = function() {
              if (!this.config.comment) {
                this.scanner.scanComments();
              } else {
                var comments = this.scanner.scanComments();
                if (comments.length > 0 && this.delegate) {
                  for (var i2 = 0; i2 < comments.length; ++i2) {
                    var e2 = comments[i2];
                    var node2 = void 0;
                    node2 = {
                      type: e2.multiLine ? "BlockComment" : "LineComment",
                      value: this.scanner.source.slice(e2.slice[0], e2.slice[1])
                    };
                    if (this.config.range) {
                      node2.range = e2.range;
                    }
                    if (this.config.loc) {
                      node2.loc = e2.loc;
                    }
                    var metadata = {
                      start: {
                        line: e2.loc.start.line,
                        column: e2.loc.start.column,
                        offset: e2.range[0]
                      },
                      end: {
                        line: e2.loc.end.line,
                        column: e2.loc.end.column,
                        offset: e2.range[1]
                      }
                    };
                    this.delegate(node2, metadata);
                  }
                }
              }
            };
            Parser4.prototype.getTokenRaw = function(token) {
              return this.scanner.source.slice(token.start, token.end);
            };
            Parser4.prototype.convertToken = function(token) {
              var t2 = {
                type: token_1.TokenName[token.type],
                value: this.getTokenRaw(token)
              };
              if (this.config.range) {
                t2.range = [token.start, token.end];
              }
              if (this.config.loc) {
                t2.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                };
              }
              if (token.type === 9) {
                var pattern = token.pattern;
                var flags = token.flags;
                t2.regex = { pattern, flags };
              }
              return t2;
            };
            Parser4.prototype.nextToken = function() {
              var token = this.lookahead;
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              this.collectComments();
              if (this.scanner.index !== this.startMarker.index) {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              }
              var next = this.scanner.lex();
              this.hasLineTerminator = token.lineNumber !== next.lineNumber;
              if (next && this.context.strict && next.type === 3) {
                if (this.scanner.isStrictModeReservedWord(next.value)) {
                  next.type = 4;
                }
              }
              this.lookahead = next;
              if (this.config.tokens && next.type !== 2) {
                this.tokens.push(this.convertToken(next));
              }
              return token;
            };
            Parser4.prototype.nextRegexToken = function() {
              this.collectComments();
              var token = this.scanner.scanRegExp();
              if (this.config.tokens) {
                this.tokens.pop();
                this.tokens.push(this.convertToken(token));
              }
              this.lookahead = token;
              this.nextToken();
              return token;
            };
            Parser4.prototype.createNode = function() {
              return {
                index: this.startMarker.index,
                line: this.startMarker.line,
                column: this.startMarker.column
              };
            };
            Parser4.prototype.startNode = function(token, lastLineStart) {
              if (lastLineStart === void 0) {
                lastLineStart = 0;
              }
              var column = token.start - token.lineStart;
              var line = token.lineNumber;
              if (column < 0) {
                column += lastLineStart;
                line--;
              }
              return {
                index: token.start,
                line,
                column
              };
            };
            Parser4.prototype.finalize = function(marker, node2) {
              if (this.config.range) {
                node2.range = [marker.index, this.lastMarker.index];
              }
              if (this.config.loc) {
                node2.loc = {
                  start: {
                    line: marker.line,
                    column: marker.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                };
                if (this.config.source) {
                  node2.loc.source = this.config.source;
                }
              }
              if (this.delegate) {
                var metadata = {
                  start: {
                    line: marker.line,
                    column: marker.column,
                    offset: marker.index
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column,
                    offset: this.lastMarker.index
                  }
                };
                this.delegate(node2, metadata);
              }
              return node2;
            };
            Parser4.prototype.expect = function(value) {
              var token = this.nextToken();
              if (token.type !== 7 || token.value !== value) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser4.prototype.expectCommaSeparator = function() {
              if (this.config.tolerant) {
                var token = this.lookahead;
                if (token.type === 7 && token.value === ",") {
                  this.nextToken();
                } else if (token.type === 7 && token.value === ";") {
                  this.nextToken();
                  this.tolerateUnexpectedToken(token);
                } else {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                }
              } else {
                this.expect(",");
              }
            };
            Parser4.prototype.expectKeyword = function(keyword2) {
              var token = this.nextToken();
              if (token.type !== 4 || token.value !== keyword2) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser4.prototype.match = function(value) {
              return this.lookahead.type === 7 && this.lookahead.value === value;
            };
            Parser4.prototype.matchKeyword = function(keyword2) {
              return this.lookahead.type === 4 && this.lookahead.value === keyword2;
            };
            Parser4.prototype.matchContextualKeyword = function(keyword2) {
              return this.lookahead.type === 3 && this.lookahead.value === keyword2;
            };
            Parser4.prototype.matchAssign = function() {
              if (this.lookahead.type !== 7) {
                return false;
              }
              var op = this.lookahead.value;
              return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
            };
            Parser4.prototype.isolateCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              if (this.context.firstCoverInitializedNameError !== null) {
                this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
              }
              this.context.isBindingElement = previousIsBindingElement;
              this.context.isAssignmentTarget = previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
              return result;
            };
            Parser4.prototype.inheritCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
              this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
              return result;
            };
            Parser4.prototype.consumeSemicolon = function() {
              if (this.match(";")) {
                this.nextToken();
              } else if (!this.hasLineTerminator) {
                if (this.lookahead.type !== 2 && !this.match("}")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.lastMarker.index = this.startMarker.index;
                this.lastMarker.line = this.startMarker.line;
                this.lastMarker.column = this.startMarker.column;
              }
            };
            Parser4.prototype.parsePrimaryExpression = function() {
              var node2 = this.createNode();
              var expr;
              var token, raw;
              switch (this.lookahead.type) {
                case 3:
                  if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node2, new Node2.Identifier(this.nextToken().value));
                  break;
                case 6:
                case 8:
                  if (this.context.strict && this.lookahead.octal) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node2, new Node2.Literal(token.value, raw));
                  break;
                case 1:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node2, new Node2.Literal(token.value === "true", raw));
                  break;
                case 5:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node2, new Node2.Literal(null, raw));
                  break;
                case 10:
                  expr = this.parseTemplateLiteral();
                  break;
                case 7:
                  switch (this.lookahead.value) {
                    case "(":
                      this.context.isBindingElement = false;
                      expr = this.inheritCoverGrammar(this.parseGroupExpression);
                      break;
                    case "[":
                      expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                      break;
                    case "{":
                      expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                      break;
                    case "/":
                    case "/=":
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.scanner.index = this.startMarker.index;
                      token = this.nextRegexToken();
                      raw = this.getTokenRaw(token);
                      expr = this.finalize(node2, new Node2.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                      break;
                    default:
                      expr = this.throwUnexpectedToken(this.nextToken());
                  }
                  break;
                case 4:
                  if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                    expr = this.parseIdentifierName();
                  } else if (!this.context.strict && this.matchKeyword("let")) {
                    expr = this.finalize(node2, new Node2.Identifier(this.nextToken().value));
                  } else {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    if (this.matchKeyword("function")) {
                      expr = this.parseFunctionExpression();
                    } else if (this.matchKeyword("this")) {
                      this.nextToken();
                      expr = this.finalize(node2, new Node2.ThisExpression());
                    } else if (this.matchKeyword("class")) {
                      expr = this.parseClassExpression();
                    } else {
                      expr = this.throwUnexpectedToken(this.nextToken());
                    }
                  }
                  break;
                default:
                  expr = this.throwUnexpectedToken(this.nextToken());
              }
              return expr;
            };
            Parser4.prototype.parseSpreadElement = function() {
              var node2 = this.createNode();
              this.expect("...");
              var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
              return this.finalize(node2, new Node2.SpreadElement(arg));
            };
            Parser4.prototype.parseArrayInitializer = function() {
              var node2 = this.createNode();
              var elements = [];
              this.expect("[");
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else if (this.match("...")) {
                  var element = this.parseSpreadElement();
                  if (!this.match("]")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.expect(",");
                  }
                  elements.push(element);
                } else {
                  elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node2, new Node2.ArrayExpression(elements));
            };
            Parser4.prototype.parsePropertyMethod = function(params) {
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = params.simple;
              var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
              if (this.context.strict && params.firstRestricted) {
                this.tolerateUnexpectedToken(params.firstRestricted, params.message);
              }
              if (this.context.strict && params.stricted) {
                this.tolerateUnexpectedToken(params.stricted, params.message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              return body;
            };
            Parser4.prototype.parsePropertyMethodFunction = function() {
              var isGenerator = false;
              var node2 = this.createNode();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node2.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser4.prototype.parsePropertyMethodAsyncFunction = function() {
              var node2 = this.createNode();
              var previousAllowYield = this.context.allowYield;
              var previousAwait = this.context.await;
              this.context.allowYield = false;
              this.context.await = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              this.context.await = previousAwait;
              return this.finalize(node2, new Node2.AsyncFunctionExpression(null, params.params, method));
            };
            Parser4.prototype.parseObjectPropertyKey = function() {
              var node2 = this.createNode();
              var token = this.nextToken();
              var key;
              switch (token.type) {
                case 8:
                case 6:
                  if (this.context.strict && token.octal) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                  }
                  var raw = this.getTokenRaw(token);
                  key = this.finalize(node2, new Node2.Literal(token.value, raw));
                  break;
                case 3:
                case 1:
                case 5:
                case 4:
                  key = this.finalize(node2, new Node2.Identifier(token.value));
                  break;
                case 7:
                  if (token.value === "[") {
                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.expect("]");
                  } else {
                    key = this.throwUnexpectedToken(token);
                  }
                  break;
                default:
                  key = this.throwUnexpectedToken(token);
              }
              return key;
            };
            Parser4.prototype.isPropertyKey = function(key, value) {
              return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
            };
            Parser4.prototype.parseObjectProperty = function(hasProto) {
              var node2 = this.createNode();
              var token = this.lookahead;
              var kind;
              var key = null;
              var value = null;
              var computed = false;
              var method = false;
              var shorthand = false;
              var isAsync = false;
              if (token.type === 3) {
                var id = token.value;
                this.nextToken();
                computed = this.match("[");
                isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node2, new Node2.Identifier(id));
              } else if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value = this.parseGetterMethod();
              } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseSetterMethod();
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseGeneratorMethod();
                method = true;
              } else {
                if (!key) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                kind = "init";
                if (this.match(":") && !isAsync) {
                  if (!computed && this.isPropertyKey(key, "__proto__")) {
                    if (hasProto.value) {
                      this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                    }
                    hasProto.value = true;
                  }
                  this.nextToken();
                  value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                } else if (this.match("(")) {
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                } else if (token.type === 3) {
                  var id = this.finalize(node2, new Node2.Identifier(token.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead;
                    this.nextToken();
                    shorthand = true;
                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value = this.finalize(node2, new Node2.AssignmentPattern(id, init));
                  } else {
                    shorthand = true;
                    value = id;
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node2, new Node2.Property(kind, key, computed, value, method, shorthand));
            };
            Parser4.prototype.parseObjectInitializer = function() {
              var node2 = this.createNode();
              this.expect("{");
              var properties = [];
              var hasProto = { value: false };
              while (!this.match("}")) {
                properties.push(this.parseObjectProperty(hasProto));
                if (!this.match("}")) {
                  this.expectCommaSeparator();
                }
              }
              this.expect("}");
              return this.finalize(node2, new Node2.ObjectExpression(properties));
            };
            Parser4.prototype.parseTemplateHead = function() {
              assert_12.assert(this.lookahead.head, "Template literal must start with a template head");
              var node2 = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node2, new Node2.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser4.prototype.parseTemplateElement = function() {
              if (this.lookahead.type !== 10) {
                this.throwUnexpectedToken();
              }
              var node2 = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node2, new Node2.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser4.prototype.parseTemplateLiteral = function() {
              var node2 = this.createNode();
              var expressions = [];
              var quasis = [];
              var quasi = this.parseTemplateHead();
              quasis.push(quasi);
              while (!quasi.tail) {
                expressions.push(this.parseExpression());
                quasi = this.parseTemplateElement();
                quasis.push(quasi);
              }
              return this.finalize(node2, new Node2.TemplateLiteral(quasis, expressions));
            };
            Parser4.prototype.reinterpretExpressionAsPattern = function(expr) {
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                case syntax_1.Syntax.MemberExpression:
                case syntax_1.Syntax.RestElement:
                case syntax_1.Syntax.AssignmentPattern:
                  break;
                case syntax_1.Syntax.SpreadElement:
                  expr.type = syntax_1.Syntax.RestElement;
                  this.reinterpretExpressionAsPattern(expr.argument);
                  break;
                case syntax_1.Syntax.ArrayExpression:
                  expr.type = syntax_1.Syntax.ArrayPattern;
                  for (var i2 = 0; i2 < expr.elements.length; i2++) {
                    if (expr.elements[i2] !== null) {
                      this.reinterpretExpressionAsPattern(expr.elements[i2]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectExpression:
                  expr.type = syntax_1.Syntax.ObjectPattern;
                  for (var i2 = 0; i2 < expr.properties.length; i2++) {
                    this.reinterpretExpressionAsPattern(expr.properties[i2].value);
                  }
                  break;
                case syntax_1.Syntax.AssignmentExpression:
                  expr.type = syntax_1.Syntax.AssignmentPattern;
                  delete expr.operator;
                  this.reinterpretExpressionAsPattern(expr.left);
                  break;
              }
            };
            Parser4.prototype.parseGroupExpression = function() {
              var expr;
              this.expect("(");
              if (this.match(")")) {
                this.nextToken();
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [],
                  async: false
                };
              } else {
                var startToken = this.lookahead;
                var params = [];
                if (this.match("...")) {
                  expr = this.parseRestElement(params);
                  this.expect(")");
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [expr],
                    async: false
                  };
                } else {
                  var arrow = false;
                  this.context.isBindingElement = true;
                  expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  if (this.match(",")) {
                    var expressions = [];
                    this.context.isAssignmentTarget = false;
                    expressions.push(expr);
                    while (this.lookahead.type !== 2) {
                      if (!this.match(",")) {
                        break;
                      }
                      this.nextToken();
                      if (this.match(")")) {
                        this.nextToken();
                        for (var i2 = 0; i2 < expressions.length; i2++) {
                          this.reinterpretExpressionAsPattern(expressions[i2]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else if (this.match("...")) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        expressions.push(this.parseRestElement(params));
                        this.expect(")");
                        if (!this.match("=>")) {
                          this.expect("=>");
                        }
                        this.context.isBindingElement = false;
                        for (var i2 = 0; i2 < expressions.length; i2++) {
                          this.reinterpretExpressionAsPattern(expressions[i2]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else {
                        expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                      }
                      if (arrow) {
                        break;
                      }
                    }
                    if (!arrow) {
                      expr = this.finalize(this.startNode(startToken), new Node2.SequenceExpression(expressions));
                    }
                  }
                  if (!arrow) {
                    this.expect(")");
                    if (this.match("=>")) {
                      if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: [expr],
                          async: false
                        };
                      }
                      if (!arrow) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        if (expr.type === syntax_1.Syntax.SequenceExpression) {
                          for (var i2 = 0; i2 < expr.expressions.length; i2++) {
                            this.reinterpretExpressionAsPattern(expr.expressions[i2]);
                          }
                        } else {
                          this.reinterpretExpressionAsPattern(expr);
                        }
                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: parameters,
                          async: false
                        };
                      }
                    }
                    this.context.isBindingElement = false;
                  }
                }
              }
              return expr;
            };
            Parser4.prototype.parseArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser4.prototype.isIdentifierName = function(token) {
              return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
            };
            Parser4.prototype.parseIdentifierName = function() {
              var node2 = this.createNode();
              var token = this.nextToken();
              if (!this.isIdentifierName(token)) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node2, new Node2.Identifier(token.value));
            };
            Parser4.prototype.parseNewExpression = function() {
              var node2 = this.createNode();
              var id = this.parseIdentifierName();
              assert_12.assert(id.name === "new", "New expression must start with `new`");
              var expr;
              if (this.match(".")) {
                this.nextToken();
                if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                  var property = this.parseIdentifierName();
                  expr = new Node2.MetaProperty(id, property);
                } else {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                var args = this.match("(") ? this.parseArguments() : [];
                expr = new Node2.NewExpression(callee, args);
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return this.finalize(node2, expr);
            };
            Parser4.prototype.parseAsyncArgument = function() {
              var arg = this.parseAssignmentExpression();
              this.context.firstCoverInitializedNameError = null;
              return arg;
            };
            Parser4.prototype.parseAsyncArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser4.prototype.parseLeftHandSideExpressionAllowCall = function() {
              var startToken = this.lookahead;
              var maybeAsync2 = this.matchContextualKeyword("async");
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var expr;
              if (this.matchKeyword("super") && this.context.inFunctionBody) {
                expr = this.createNode();
                this.nextToken();
                expr = this.finalize(expr, new Node2.Super());
                if (!this.match("(") && !this.match(".") && !this.match("[")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              }
              while (true) {
                if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(this.startNode(startToken), new Node2.StaticMemberExpression(expr, property));
                } else if (this.match("(")) {
                  var asyncArrow = maybeAsync2 && startToken.lineNumber === this.lookahead.lineNumber;
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = false;
                  var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                  expr = this.finalize(this.startNode(startToken), new Node2.CallExpression(expr, args));
                  if (asyncArrow && this.match("=>")) {
                    for (var i2 = 0; i2 < args.length; ++i2) {
                      this.reinterpretExpressionAsPattern(args[i2]);
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: args,
                      async: true
                    };
                  }
                } else if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(this.startNode(startToken), new Node2.ComputedMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(this.startNode(startToken), new Node2.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              this.context.allowIn = previousAllowIn;
              return expr;
            };
            Parser4.prototype.parseSuper = function() {
              var node2 = this.createNode();
              this.expectKeyword("super");
              if (!this.match("[") && !this.match(".")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              return this.finalize(node2, new Node2.Super());
            };
            Parser4.prototype.parseLeftHandSideExpression = function() {
              assert_12.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
              var node2 = this.startNode(this.lookahead);
              var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              while (true) {
                if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(node2, new Node2.ComputedMemberExpression(expr, property));
                } else if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(node2, new Node2.StaticMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(node2, new Node2.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              return expr;
            };
            Parser4.prototype.parseUpdateExpression = function() {
              var expr;
              var startToken = this.lookahead;
              if (this.match("++") || this.match("--")) {
                var node2 = this.startNode(startToken);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                  this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                }
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                }
                var prefix = true;
                expr = this.finalize(node2, new Node2.UpdateExpression(token.value, expr, prefix));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else {
                expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                if (!this.hasLineTerminator && this.lookahead.type === 7) {
                  if (this.match("++") || this.match("--")) {
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                      this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                    }
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var operator = this.nextToken().value;
                    var prefix = false;
                    expr = this.finalize(this.startNode(startToken), new Node2.UpdateExpression(operator, expr, prefix));
                  }
                }
              }
              return expr;
            };
            Parser4.prototype.parseAwaitExpression = function() {
              var node2 = this.createNode();
              this.nextToken();
              var argument = this.parseUnaryExpression();
              return this.finalize(node2, new Node2.AwaitExpression(argument));
            };
            Parser4.prototype.parseUnaryExpression = function() {
              var expr;
              if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                var node2 = this.startNode(this.lookahead);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                expr = this.finalize(node2, new Node2.UnaryExpression(token.value, expr));
                if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                  this.tolerateError(messages_1.Messages.StrictDelete);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else if (this.context.await && this.matchContextualKeyword("await")) {
                expr = this.parseAwaitExpression();
              } else {
                expr = this.parseUpdateExpression();
              }
              return expr;
            };
            Parser4.prototype.parseExponentiationExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var left2 = expr;
                var right2 = this.isolateCoverGrammar(this.parseExponentiationExpression);
                expr = this.finalize(this.startNode(startToken), new Node2.BinaryExpression("**", left2, right2));
              }
              return expr;
            };
            Parser4.prototype.binaryPrecedence = function(token) {
              var op = token.value;
              var precedence;
              if (token.type === 7) {
                precedence = this.operatorPrecedence[op] || 0;
              } else if (token.type === 4) {
                precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
              } else {
                precedence = 0;
              }
              return precedence;
            };
            Parser4.prototype.parseBinaryExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
              var token = this.lookahead;
              var prec = this.binaryPrecedence(token);
              if (prec > 0) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var markers = [startToken, this.lookahead];
                var left2 = expr;
                var right2 = this.isolateCoverGrammar(this.parseExponentiationExpression);
                var stack = [left2, token.value, right2];
                var precedences = [prec];
                while (true) {
                  prec = this.binaryPrecedence(this.lookahead);
                  if (prec <= 0) {
                    break;
                  }
                  while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                    right2 = stack.pop();
                    var operator = stack.pop();
                    precedences.pop();
                    left2 = stack.pop();
                    markers.pop();
                    var node2 = this.startNode(markers[markers.length - 1]);
                    stack.push(this.finalize(node2, new Node2.BinaryExpression(operator, left2, right2)));
                  }
                  stack.push(this.nextToken().value);
                  precedences.push(prec);
                  markers.push(this.lookahead);
                  stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                }
                var i2 = stack.length - 1;
                expr = stack[i2];
                var lastMarker = markers.pop();
                while (i2 > 1) {
                  var marker = markers.pop();
                  var lastLineStart = lastMarker && lastMarker.lineStart;
                  var node2 = this.startNode(marker, lastLineStart);
                  var operator = stack[i2 - 1];
                  expr = this.finalize(node2, new Node2.BinaryExpression(operator, stack[i2 - 2], expr));
                  i2 -= 2;
                  lastMarker = marker;
                }
              }
              return expr;
            };
            Parser4.prototype.parseConditionalExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
              if (this.match("?")) {
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                this.expect(":");
                var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                expr = this.finalize(this.startNode(startToken), new Node2.ConditionalExpression(expr, consequent, alternate));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return expr;
            };
            Parser4.prototype.checkPatternParam = function(options, param) {
              switch (param.type) {
                case syntax_1.Syntax.Identifier:
                  this.validateParam(options, param, param.name);
                  break;
                case syntax_1.Syntax.RestElement:
                  this.checkPatternParam(options, param.argument);
                  break;
                case syntax_1.Syntax.AssignmentPattern:
                  this.checkPatternParam(options, param.left);
                  break;
                case syntax_1.Syntax.ArrayPattern:
                  for (var i2 = 0; i2 < param.elements.length; i2++) {
                    if (param.elements[i2] !== null) {
                      this.checkPatternParam(options, param.elements[i2]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectPattern:
                  for (var i2 = 0; i2 < param.properties.length; i2++) {
                    this.checkPatternParam(options, param.properties[i2].value);
                  }
                  break;
              }
              options.simple = options.simple && param instanceof Node2.Identifier;
            };
            Parser4.prototype.reinterpretAsCoverFormalsList = function(expr) {
              var params = [expr];
              var options;
              var asyncArrow = false;
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                  break;
                case ArrowParameterPlaceHolder:
                  params = expr.params;
                  asyncArrow = expr.async;
                  break;
                default:
                  return null;
              }
              options = {
                simple: true,
                paramSet: {}
              };
              for (var i2 = 0; i2 < params.length; ++i2) {
                var param = params[i2];
                if (param.type === syntax_1.Syntax.AssignmentPattern) {
                  if (param.right.type === syntax_1.Syntax.YieldExpression) {
                    if (param.right.argument) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    param.right.type = syntax_1.Syntax.Identifier;
                    param.right.name = "yield";
                    delete param.right.argument;
                    delete param.right.delegate;
                  }
                } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.checkPatternParam(options, param);
                params[i2] = param;
              }
              if (this.context.strict || !this.context.allowYield) {
                for (var i2 = 0; i2 < params.length; ++i2) {
                  var param = params[i2];
                  if (param.type === syntax_1.Syntax.YieldExpression) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              }
              if (options.message === messages_1.Messages.StrictParamDupe) {
                var token = this.context.strict ? options.stricted : options.firstRestricted;
                this.throwUnexpectedToken(token, options.message);
              }
              return {
                simple: options.simple,
                params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser4.prototype.parseAssignmentExpression = function() {
              var expr;
              if (!this.context.allowYield && this.matchKeyword("yield")) {
                expr = this.parseYieldExpression();
              } else {
                var startToken = this.lookahead;
                var token = startToken;
                expr = this.parseConditionalExpression();
                if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                  if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg);
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [arg],
                      async: true
                    };
                  }
                }
                if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var isAsync = expr.async;
                  var list = this.reinterpretAsCoverFormalsList(expr);
                  if (list) {
                    if (this.hasLineTerminator) {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    this.context.firstCoverInitializedNameError = null;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = list.simple;
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = true;
                    this.context.await = isAsync;
                    var node2 = this.startNode(startToken);
                    this.expect("=>");
                    var body = void 0;
                    if (this.match("{")) {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = true;
                      body = this.parseFunctionSourceElements();
                      this.context.allowIn = previousAllowIn;
                    } else {
                      body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
                    if (this.context.strict && list.firstRestricted) {
                      this.throwUnexpectedToken(list.firstRestricted, list.message);
                    }
                    if (this.context.strict && list.stricted) {
                      this.tolerateUnexpectedToken(list.stricted, list.message);
                    }
                    expr = isAsync ? this.finalize(node2, new Node2.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node2, new Node2.ArrowFunctionExpression(list.params, body, expression));
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                  }
                } else {
                  if (this.matchAssign()) {
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                      var id = expr;
                      if (this.scanner.isRestrictedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                      }
                      if (this.scanner.isStrictModeReservedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      }
                    }
                    if (!this.match("=")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else {
                      this.reinterpretExpressionAsPattern(expr);
                    }
                    token = this.nextToken();
                    var operator = token.value;
                    var right2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node2.AssignmentExpression(operator, expr, right2));
                    this.context.firstCoverInitializedNameError = null;
                  }
                }
              }
              return expr;
            };
            Parser4.prototype.parseExpression = function() {
              var startToken = this.lookahead;
              var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
              if (this.match(",")) {
                var expressions = [];
                expressions.push(expr);
                while (this.lookahead.type !== 2) {
                  if (!this.match(",")) {
                    break;
                  }
                  this.nextToken();
                  expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                }
                expr = this.finalize(this.startNode(startToken), new Node2.SequenceExpression(expressions));
              }
              return expr;
            };
            Parser4.prototype.parseStatementListItem = function() {
              var statement;
              this.context.isAssignmentTarget = true;
              this.context.isBindingElement = true;
              if (this.lookahead.type === 4) {
                switch (this.lookahead.value) {
                  case "export":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                    }
                    statement = this.parseExportDeclaration();
                    break;
                  case "import":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                    }
                    statement = this.parseImportDeclaration();
                    break;
                  case "const":
                    statement = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "class":
                    statement = this.parseClassDeclaration();
                    break;
                  case "let":
                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                    break;
                  default:
                    statement = this.parseStatement();
                    break;
                }
              } else {
                statement = this.parseStatement();
              }
              return statement;
            };
            Parser4.prototype.parseBlock = function() {
              var node2 = this.createNode();
              this.expect("{");
              var block = [];
              while (true) {
                if (this.match("}")) {
                  break;
                }
                block.push(this.parseStatementListItem());
              }
              this.expect("}");
              return this.finalize(node2, new Node2.BlockStatement(block));
            };
            Parser4.prototype.parseLexicalBinding = function(kind, options) {
              var node2 = this.createNode();
              var params = [];
              var id = this.parsePattern(params, kind);
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init = null;
              if (kind === "const") {
                if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                  if (this.match("=")) {
                    this.nextToken();
                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  } else {
                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                  }
                }
              } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                this.expect("=");
                init = this.isolateCoverGrammar(this.parseAssignmentExpression);
              }
              return this.finalize(node2, new Node2.VariableDeclarator(id, init));
            };
            Parser4.prototype.parseBindingList = function(kind, options) {
              var list = [this.parseLexicalBinding(kind, options)];
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseLexicalBinding(kind, options));
              }
              return list;
            };
            Parser4.prototype.isLexicalDeclaration = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state);
              return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
            };
            Parser4.prototype.parseLexicalDeclaration = function(options) {
              var node2 = this.createNode();
              var kind = this.nextToken().value;
              assert_12.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
              var declarations = this.parseBindingList(kind, options);
              this.consumeSemicolon();
              return this.finalize(node2, new Node2.VariableDeclaration(declarations, kind));
            };
            Parser4.prototype.parseBindingRestElement = function(params, kind) {
              var node2 = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params, kind);
              return this.finalize(node2, new Node2.RestElement(arg));
            };
            Parser4.prototype.parseArrayPattern = function(params, kind) {
              var node2 = this.createNode();
              this.expect("[");
              var elements = [];
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else {
                  if (this.match("...")) {
                    elements.push(this.parseBindingRestElement(params, kind));
                    break;
                  } else {
                    elements.push(this.parsePatternWithDefault(params, kind));
                  }
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node2, new Node2.ArrayPattern(elements));
            };
            Parser4.prototype.parsePropertyPattern = function(params, kind) {
              var node2 = this.createNode();
              var computed = false;
              var shorthand = false;
              var method = false;
              var key;
              var value;
              if (this.lookahead.type === 3) {
                var keyToken = this.lookahead;
                key = this.parseVariableIdentifier();
                var init = this.finalize(node2, new Node2.Identifier(keyToken.value));
                if (this.match("=")) {
                  params.push(keyToken);
                  shorthand = true;
                  this.nextToken();
                  var expr = this.parseAssignmentExpression();
                  value = this.finalize(this.startNode(keyToken), new Node2.AssignmentPattern(init, expr));
                } else if (!this.match(":")) {
                  params.push(keyToken);
                  shorthand = true;
                  value = init;
                } else {
                  this.expect(":");
                  value = this.parsePatternWithDefault(params, kind);
                }
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.expect(":");
                value = this.parsePatternWithDefault(params, kind);
              }
              return this.finalize(node2, new Node2.Property("init", key, computed, value, method, shorthand));
            };
            Parser4.prototype.parseObjectPattern = function(params, kind) {
              var node2 = this.createNode();
              var properties = [];
              this.expect("{");
              while (!this.match("}")) {
                properties.push(this.parsePropertyPattern(params, kind));
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return this.finalize(node2, new Node2.ObjectPattern(properties));
            };
            Parser4.prototype.parsePattern = function(params, kind) {
              var pattern;
              if (this.match("[")) {
                pattern = this.parseArrayPattern(params, kind);
              } else if (this.match("{")) {
                pattern = this.parseObjectPattern(params, kind);
              } else {
                if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                }
                params.push(this.lookahead);
                pattern = this.parseVariableIdentifier(kind);
              }
              return pattern;
            };
            Parser4.prototype.parsePatternWithDefault = function(params, kind) {
              var startToken = this.lookahead;
              var pattern = this.parsePattern(params, kind);
              if (this.match("=")) {
                this.nextToken();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var right2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowYield = previousAllowYield;
                pattern = this.finalize(this.startNode(startToken), new Node2.AssignmentPattern(pattern, right2));
              }
              return pattern;
            };
            Parser4.prototype.parseVariableIdentifier = function(kind) {
              var node2 = this.createNode();
              var token = this.nextToken();
              if (token.type === 4 && token.value === "yield") {
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else if (!this.context.allowYield) {
                  this.throwUnexpectedToken(token);
                }
              } else if (token.type !== 3) {
                if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else {
                  if (this.context.strict || token.value !== "let" || kind !== "var") {
                    this.throwUnexpectedToken(token);
                  }
                }
              } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                this.tolerateUnexpectedToken(token);
              }
              return this.finalize(node2, new Node2.Identifier(token.value));
            };
            Parser4.prototype.parseVariableDeclaration = function(options) {
              var node2 = this.createNode();
              var params = [];
              var id = this.parsePattern(params, "var");
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init = null;
              if (this.match("=")) {
                this.nextToken();
                init = this.isolateCoverGrammar(this.parseAssignmentExpression);
              } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                this.expect("=");
              }
              return this.finalize(node2, new Node2.VariableDeclarator(id, init));
            };
            Parser4.prototype.parseVariableDeclarationList = function(options) {
              var opt = { inFor: options.inFor };
              var list = [];
              list.push(this.parseVariableDeclaration(opt));
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseVariableDeclaration(opt));
              }
              return list;
            };
            Parser4.prototype.parseVariableStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("var");
              var declarations = this.parseVariableDeclarationList({ inFor: false });
              this.consumeSemicolon();
              return this.finalize(node2, new Node2.VariableDeclaration(declarations, "var"));
            };
            Parser4.prototype.parseEmptyStatement = function() {
              var node2 = this.createNode();
              this.expect(";");
              return this.finalize(node2, new Node2.EmptyStatement());
            };
            Parser4.prototype.parseExpressionStatement = function() {
              var node2 = this.createNode();
              var expr = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node2, new Node2.ExpressionStatement(expr));
            };
            Parser4.prototype.parseIfClause = function() {
              if (this.context.strict && this.matchKeyword("function")) {
                this.tolerateError(messages_1.Messages.StrictFunction);
              }
              return this.parseStatement();
            };
            Parser4.prototype.parseIfStatement = function() {
              var node2 = this.createNode();
              var consequent;
              var alternate = null;
              this.expectKeyword("if");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                consequent = this.finalize(this.createNode(), new Node2.EmptyStatement());
              } else {
                this.expect(")");
                consequent = this.parseIfClause();
                if (this.matchKeyword("else")) {
                  this.nextToken();
                  alternate = this.parseIfClause();
                }
              }
              return this.finalize(node2, new Node2.IfStatement(test, consequent, alternate));
            };
            Parser4.prototype.parseDoWhileStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("do");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              var body = this.parseStatement();
              this.context.inIteration = previousInIteration;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
              } else {
                this.expect(")");
                if (this.match(";")) {
                  this.nextToken();
                }
              }
              return this.finalize(node2, new Node2.DoWhileStatement(body, test));
            };
            Parser4.prototype.parseWhileStatement = function() {
              var node2 = this.createNode();
              var body;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node2.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.parseStatement();
                this.context.inIteration = previousInIteration;
              }
              return this.finalize(node2, new Node2.WhileStatement(test, body));
            };
            Parser4.prototype.parseForStatement = function() {
              var init = null;
              var test = null;
              var update = null;
              var forIn = true;
              var left2, right2;
              var node2 = this.createNode();
              this.expectKeyword("for");
              this.expect("(");
              if (this.match(";")) {
                this.nextToken();
              } else {
                if (this.matchKeyword("var")) {
                  init = this.createNode();
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseVariableDeclarationList({ inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && this.matchKeyword("in")) {
                    var decl = declarations[0];
                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                      this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                    }
                    init = this.finalize(init, new Node2.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left2 = init;
                    right2 = this.parseExpression();
                    init = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init = this.finalize(init, new Node2.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left2 = init;
                    right2 = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    init = this.finalize(init, new Node2.VariableDeclaration(declarations, "var"));
                    this.expect(";");
                  }
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  init = this.createNode();
                  var kind = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in") {
                    init = this.finalize(init, new Node2.Identifier(kind));
                    this.nextToken();
                    left2 = init;
                    right2 = this.parseExpression();
                    init = null;
                  } else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseBindingList(kind, { inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                      init = this.finalize(init, new Node2.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left2 = init;
                      right2 = this.parseExpression();
                      init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init = this.finalize(init, new Node2.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left2 = init;
                      right2 = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      this.consumeSemicolon();
                      init = this.finalize(init, new Node2.VariableDeclaration(declarations, kind));
                    }
                  }
                } else {
                  var initStartToken = this.lookahead;
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  if (this.matchKeyword("in")) {
                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init);
                    left2 = init;
                    right2 = this.parseExpression();
                    init = null;
                  } else if (this.matchContextualKeyword("of")) {
                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init);
                    left2 = init;
                    right2 = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    if (this.match(",")) {
                      var initSeq = [init];
                      while (this.match(",")) {
                        this.nextToken();
                        initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      }
                      init = this.finalize(this.startNode(initStartToken), new Node2.SequenceExpression(initSeq));
                    }
                    this.expect(";");
                  }
                }
              }
              if (typeof left2 === "undefined") {
                if (!this.match(";")) {
                  test = this.parseExpression();
                }
                this.expect(";");
                if (!this.match(")")) {
                  update = this.parseExpression();
                }
              }
              var body;
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node2.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.isolateCoverGrammar(this.parseStatement);
                this.context.inIteration = previousInIteration;
              }
              return typeof left2 === "undefined" ? this.finalize(node2, new Node2.ForStatement(init, test, update, body)) : forIn ? this.finalize(node2, new Node2.ForInStatement(left2, right2, body)) : this.finalize(node2, new Node2.ForOfStatement(left2, right2, body));
            };
            Parser4.prototype.parseContinueStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("continue");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                label = id;
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration) {
                this.throwError(messages_1.Messages.IllegalContinue);
              }
              return this.finalize(node2, new Node2.ContinueStatement(label));
            };
            Parser4.prototype.parseBreakStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("break");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
                label = id;
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                this.throwError(messages_1.Messages.IllegalBreak);
              }
              return this.finalize(node2, new Node2.BreakStatement(label));
            };
            Parser4.prototype.parseReturnStatement = function() {
              if (!this.context.inFunctionBody) {
                this.tolerateError(messages_1.Messages.IllegalReturn);
              }
              var node2 = this.createNode();
              this.expectKeyword("return");
              var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
              var argument = hasArgument ? this.parseExpression() : null;
              this.consumeSemicolon();
              return this.finalize(node2, new Node2.ReturnStatement(argument));
            };
            Parser4.prototype.parseWithStatement = function() {
              if (this.context.strict) {
                this.tolerateError(messages_1.Messages.StrictModeWith);
              }
              var node2 = this.createNode();
              var body;
              this.expectKeyword("with");
              this.expect("(");
              var object = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node2.EmptyStatement());
              } else {
                this.expect(")");
                body = this.parseStatement();
              }
              return this.finalize(node2, new Node2.WithStatement(object, body));
            };
            Parser4.prototype.parseSwitchCase = function() {
              var node2 = this.createNode();
              var test;
              if (this.matchKeyword("default")) {
                this.nextToken();
                test = null;
              } else {
                this.expectKeyword("case");
                test = this.parseExpression();
              }
              this.expect(":");
              var consequent = [];
              while (true) {
                if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                  break;
                }
                consequent.push(this.parseStatementListItem());
              }
              return this.finalize(node2, new Node2.SwitchCase(test, consequent));
            };
            Parser4.prototype.parseSwitchStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("switch");
              this.expect("(");
              var discriminant = this.parseExpression();
              this.expect(")");
              var previousInSwitch = this.context.inSwitch;
              this.context.inSwitch = true;
              var cases = [];
              var defaultFound = false;
              this.expect("{");
              while (true) {
                if (this.match("}")) {
                  break;
                }
                var clause = this.parseSwitchCase();
                if (clause.test === null) {
                  if (defaultFound) {
                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                  }
                  defaultFound = true;
                }
                cases.push(clause);
              }
              this.expect("}");
              this.context.inSwitch = previousInSwitch;
              return this.finalize(node2, new Node2.SwitchStatement(discriminant, cases));
            };
            Parser4.prototype.parseLabelledStatement = function() {
              var node2 = this.createNode();
              var expr = this.parseExpression();
              var statement;
              if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                this.nextToken();
                var id = expr;
                var key = "$" + id.name;
                if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                }
                this.context.labelSet[key] = true;
                var body = void 0;
                if (this.matchKeyword("class")) {
                  this.tolerateUnexpectedToken(this.lookahead);
                  body = this.parseClassDeclaration();
                } else if (this.matchKeyword("function")) {
                  var token = this.lookahead;
                  var declaration = this.parseFunctionDeclaration();
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                  } else if (declaration.generator) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                  }
                  body = declaration;
                } else {
                  body = this.parseStatement();
                }
                delete this.context.labelSet[key];
                statement = new Node2.LabeledStatement(id, body);
              } else {
                this.consumeSemicolon();
                statement = new Node2.ExpressionStatement(expr);
              }
              return this.finalize(node2, statement);
            };
            Parser4.prototype.parseThrowStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("throw");
              if (this.hasLineTerminator) {
                this.throwError(messages_1.Messages.NewlineAfterThrow);
              }
              var argument = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node2, new Node2.ThrowStatement(argument));
            };
            Parser4.prototype.parseCatchClause = function() {
              var node2 = this.createNode();
              this.expectKeyword("catch");
              this.expect("(");
              if (this.match(")")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              var params = [];
              var param = this.parsePattern(params);
              var paramMap = {};
              for (var i2 = 0; i2 < params.length; i2++) {
                var key = "$" + params[i2].value;
                if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                  this.tolerateError(messages_1.Messages.DuplicateBinding, params[i2].value);
                }
                paramMap[key] = true;
              }
              if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(param.name)) {
                  this.tolerateError(messages_1.Messages.StrictCatchVariable);
                }
              }
              this.expect(")");
              var body = this.parseBlock();
              return this.finalize(node2, new Node2.CatchClause(param, body));
            };
            Parser4.prototype.parseFinallyClause = function() {
              this.expectKeyword("finally");
              return this.parseBlock();
            };
            Parser4.prototype.parseTryStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("try");
              var block = this.parseBlock();
              var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
              var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
              if (!handler && !finalizer) {
                this.throwError(messages_1.Messages.NoCatchOrFinally);
              }
              return this.finalize(node2, new Node2.TryStatement(block, handler, finalizer));
            };
            Parser4.prototype.parseDebuggerStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("debugger");
              this.consumeSemicolon();
              return this.finalize(node2, new Node2.DebuggerStatement());
            };
            Parser4.prototype.parseStatement = function() {
              var statement;
              switch (this.lookahead.type) {
                case 1:
                case 5:
                case 6:
                case 8:
                case 10:
                case 9:
                  statement = this.parseExpressionStatement();
                  break;
                case 7:
                  var value = this.lookahead.value;
                  if (value === "{") {
                    statement = this.parseBlock();
                  } else if (value === "(") {
                    statement = this.parseExpressionStatement();
                  } else if (value === ";") {
                    statement = this.parseEmptyStatement();
                  } else {
                    statement = this.parseExpressionStatement();
                  }
                  break;
                case 3:
                  statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                  break;
                case 4:
                  switch (this.lookahead.value) {
                    case "break":
                      statement = this.parseBreakStatement();
                      break;
                    case "continue":
                      statement = this.parseContinueStatement();
                      break;
                    case "debugger":
                      statement = this.parseDebuggerStatement();
                      break;
                    case "do":
                      statement = this.parseDoWhileStatement();
                      break;
                    case "for":
                      statement = this.parseForStatement();
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "if":
                      statement = this.parseIfStatement();
                      break;
                    case "return":
                      statement = this.parseReturnStatement();
                      break;
                    case "switch":
                      statement = this.parseSwitchStatement();
                      break;
                    case "throw":
                      statement = this.parseThrowStatement();
                      break;
                    case "try":
                      statement = this.parseTryStatement();
                      break;
                    case "var":
                      statement = this.parseVariableStatement();
                      break;
                    case "while":
                      statement = this.parseWhileStatement();
                      break;
                    case "with":
                      statement = this.parseWithStatement();
                      break;
                    default:
                      statement = this.parseExpressionStatement();
                      break;
                  }
                  break;
                default:
                  statement = this.throwUnexpectedToken(this.lookahead);
              }
              return statement;
            };
            Parser4.prototype.parseFunctionSourceElements = function() {
              var node2 = this.createNode();
              this.expect("{");
              var body = this.parseDirectivePrologues();
              var previousLabelSet = this.context.labelSet;
              var previousInIteration = this.context.inIteration;
              var previousInSwitch = this.context.inSwitch;
              var previousInFunctionBody = this.context.inFunctionBody;
              this.context.labelSet = {};
              this.context.inIteration = false;
              this.context.inSwitch = false;
              this.context.inFunctionBody = true;
              while (this.lookahead.type !== 2) {
                if (this.match("}")) {
                  break;
                }
                body.push(this.parseStatementListItem());
              }
              this.expect("}");
              this.context.labelSet = previousLabelSet;
              this.context.inIteration = previousInIteration;
              this.context.inSwitch = previousInSwitch;
              this.context.inFunctionBody = previousInFunctionBody;
              return this.finalize(node2, new Node2.BlockStatement(body));
            };
            Parser4.prototype.validateParam = function(options, param, name2) {
              var key = "$" + name2;
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(name2)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamName;
                }
                if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              } else if (!options.firstRestricted) {
                if (this.scanner.isRestrictedWord(name2)) {
                  options.firstRestricted = param;
                  options.message = messages_1.Messages.StrictParamName;
                } else if (this.scanner.isStrictModeReservedWord(name2)) {
                  options.firstRestricted = param;
                  options.message = messages_1.Messages.StrictReservedWord;
                } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              }
              if (typeof Object.defineProperty === "function") {
                Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
              } else {
                options.paramSet[key] = true;
              }
            };
            Parser4.prototype.parseRestElement = function(params) {
              var node2 = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params);
              if (this.match("=")) {
                this.throwError(messages_1.Messages.DefaultRestParameter);
              }
              if (!this.match(")")) {
                this.throwError(messages_1.Messages.ParameterAfterRestParameter);
              }
              return this.finalize(node2, new Node2.RestElement(arg));
            };
            Parser4.prototype.parseFormalParameter = function(options) {
              var params = [];
              var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
              for (var i2 = 0; i2 < params.length; i2++) {
                this.validateParam(options, params[i2], params[i2].value);
              }
              options.simple = options.simple && param instanceof Node2.Identifier;
              options.params.push(param);
            };
            Parser4.prototype.parseFormalParameters = function(firstRestricted) {
              var options;
              options = {
                simple: true,
                params: [],
                firstRestricted
              };
              this.expect("(");
              if (!this.match(")")) {
                options.paramSet = {};
                while (this.lookahead.type !== 2) {
                  this.parseFormalParameter(options);
                  if (this.match(")")) {
                    break;
                  }
                  this.expect(",");
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return {
                simple: options.simple,
                params: options.params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser4.prototype.matchAsyncFunction = function() {
              var match = this.matchContextualKeyword("async");
              if (match) {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                this.scanner.restoreState(state);
                match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
              }
              return match;
            };
            Parser4.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
              var node2 = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message2;
              var id = null;
              var firstRestricted = null;
              if (!identifierIsOptional || !this.match("(")) {
                var token = this.lookahead;
                id = this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message2 = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message2 = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message2 = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message2);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message2);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node2, new Node2.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node2, new Node2.FunctionDeclaration(id, params, body, isGenerator));
            };
            Parser4.prototype.parseFunctionExpression = function() {
              var node2 = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message2;
              var id = null;
              var firstRestricted;
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              if (!this.match("(")) {
                var token = this.lookahead;
                id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message2 = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message2 = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message2 = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message2);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message2);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node2, new Node2.AsyncFunctionExpression(id, params, body)) : this.finalize(node2, new Node2.FunctionExpression(id, params, body, isGenerator));
            };
            Parser4.prototype.parseDirective = function() {
              var token = this.lookahead;
              var node2 = this.createNode();
              var expr = this.parseExpression();
              var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
              this.consumeSemicolon();
              return this.finalize(node2, directive ? new Node2.Directive(expr, directive) : new Node2.ExpressionStatement(expr));
            };
            Parser4.prototype.parseDirectivePrologues = function() {
              var firstRestricted = null;
              var body = [];
              while (true) {
                var token = this.lookahead;
                if (token.type !== 8) {
                  break;
                }
                var statement = this.parseDirective();
                body.push(statement);
                var directive = statement.directive;
                if (typeof directive !== "string") {
                  break;
                }
                if (directive === "use strict") {
                  this.context.strict = true;
                  if (firstRestricted) {
                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                  }
                  if (!this.context.allowStrictDirective) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                  }
                } else {
                  if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                  }
                }
              }
              return body;
            };
            Parser4.prototype.qualifiedPropertyName = function(token) {
              switch (token.type) {
                case 3:
                case 8:
                case 1:
                case 5:
                case 6:
                case 4:
                  return true;
                case 7:
                  return token.value === "[";
              }
              return false;
            };
            Parser4.prototype.parseGetterMethod = function() {
              var node2 = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length > 0) {
                this.tolerateError(messages_1.Messages.BadGetterArity);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node2.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser4.prototype.parseSetterMethod = function() {
              var node2 = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length !== 1) {
                this.tolerateError(messages_1.Messages.BadSetterArity);
              } else if (formalParameters.params[0] instanceof Node2.RestElement) {
                this.tolerateError(messages_1.Messages.BadSetterRestParameter);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node2.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser4.prototype.parseGeneratorMethod = function() {
              var node2 = this.createNode();
              var isGenerator = true;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              this.context.allowYield = false;
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node2.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser4.prototype.isStartOfExpression = function() {
              var start = true;
              var value = this.lookahead.value;
              switch (this.lookahead.type) {
                case 7:
                  start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                  break;
                case 4:
                  start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                  break;
              }
              return start;
            };
            Parser4.prototype.parseYieldExpression = function() {
              var node2 = this.createNode();
              this.expectKeyword("yield");
              var argument = null;
              var delegate = false;
              if (!this.hasLineTerminator) {
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = false;
                delegate = this.match("*");
                if (delegate) {
                  this.nextToken();
                  argument = this.parseAssignmentExpression();
                } else if (this.isStartOfExpression()) {
                  argument = this.parseAssignmentExpression();
                }
                this.context.allowYield = previousAllowYield;
              }
              return this.finalize(node2, new Node2.YieldExpression(argument, delegate));
            };
            Parser4.prototype.parseClassElement = function(hasConstructor) {
              var token = this.lookahead;
              var node2 = this.createNode();
              var kind = "";
              var key = null;
              var value = null;
              var computed = false;
              var method = false;
              var isStatic = false;
              var isAsync = false;
              if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                var id = key;
                if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                  token = this.lookahead;
                  isStatic = true;
                  computed = this.match("[");
                  if (this.match("*")) {
                    this.nextToken();
                  } else {
                    key = this.parseObjectPropertyKey();
                  }
                }
                if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                  var punctuator = this.lookahead.value;
                  if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                    isAsync = true;
                    token = this.lookahead;
                    key = this.parseObjectPropertyKey();
                    if (token.type === 3 && token.value === "constructor") {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                    }
                  }
                }
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3) {
                if (token.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value = this.parseGetterMethod();
                } else if (token.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseSetterMethod();
                }
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseGeneratorMethod();
                method = true;
              }
              if (!kind && key && this.match("(")) {
                kind = "init";
                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              }
              if (!kind) {
                this.throwUnexpectedToken(this.lookahead);
              }
              if (kind === "init") {
                kind = "method";
              }
              if (!computed) {
                if (isStatic && this.isPropertyKey(key, "prototype")) {
                  this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                }
                if (!isStatic && this.isPropertyKey(key, "constructor")) {
                  if (kind !== "method" || !method || value && value.generator) {
                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                  }
                  if (hasConstructor.value) {
                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                  } else {
                    hasConstructor.value = true;
                  }
                  kind = "constructor";
                }
              }
              return this.finalize(node2, new Node2.MethodDefinition(key, computed, value, kind, isStatic));
            };
            Parser4.prototype.parseClassElementList = function() {
              var body = [];
              var hasConstructor = { value: false };
              this.expect("{");
              while (!this.match("}")) {
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  body.push(this.parseClassElement(hasConstructor));
                }
              }
              this.expect("}");
              return body;
            };
            Parser4.prototype.parseClassBody = function() {
              var node2 = this.createNode();
              var elementList = this.parseClassElementList();
              return this.finalize(node2, new Node2.ClassBody(elementList));
            };
            Parser4.prototype.parseClassDeclaration = function(identifierIsOptional) {
              var node2 = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node2, new Node2.ClassDeclaration(id, superClass, classBody));
            };
            Parser4.prototype.parseClassExpression = function() {
              var node2 = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node2, new Node2.ClassExpression(id, superClass, classBody));
            };
            Parser4.prototype.parseModule = function() {
              this.context.strict = true;
              this.context.isModule = true;
              this.scanner.isModule = true;
              var node2 = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node2, new Node2.Module(body));
            };
            Parser4.prototype.parseScript = function() {
              var node2 = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node2, new Node2.Script(body));
            };
            Parser4.prototype.parseModuleSpecifier = function() {
              var node2 = this.createNode();
              if (this.lookahead.type !== 8) {
                this.throwError(messages_1.Messages.InvalidModuleSpecifier);
              }
              var token = this.nextToken();
              var raw = this.getTokenRaw(token);
              return this.finalize(node2, new Node2.Literal(token.value, raw));
            };
            Parser4.prototype.parseImportSpecifier = function() {
              var node2 = this.createNode();
              var imported;
              var local;
              if (this.lookahead.type === 3) {
                imported = this.parseVariableIdentifier();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                }
              } else {
                imported = this.parseIdentifierName();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node2, new Node2.ImportSpecifier(local, imported));
            };
            Parser4.prototype.parseNamedImports = function() {
              this.expect("{");
              var specifiers = [];
              while (!this.match("}")) {
                specifiers.push(this.parseImportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return specifiers;
            };
            Parser4.prototype.parseImportDefaultSpecifier = function() {
              var node2 = this.createNode();
              var local = this.parseIdentifierName();
              return this.finalize(node2, new Node2.ImportDefaultSpecifier(local));
            };
            Parser4.prototype.parseImportNamespaceSpecifier = function() {
              var node2 = this.createNode();
              this.expect("*");
              if (!this.matchContextualKeyword("as")) {
                this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
              }
              this.nextToken();
              var local = this.parseIdentifierName();
              return this.finalize(node2, new Node2.ImportNamespaceSpecifier(local));
            };
            Parser4.prototype.parseImportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalImportDeclaration);
              }
              var node2 = this.createNode();
              this.expectKeyword("import");
              var src2;
              var specifiers = [];
              if (this.lookahead.type === 8) {
                src2 = this.parseModuleSpecifier();
              } else {
                if (this.match("{")) {
                  specifiers = specifiers.concat(this.parseNamedImports());
                } else if (this.match("*")) {
                  specifiers.push(this.parseImportNamespaceSpecifier());
                } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                  specifiers.push(this.parseImportDefaultSpecifier());
                  if (this.match(",")) {
                    this.nextToken();
                    if (this.match("*")) {
                      specifiers.push(this.parseImportNamespaceSpecifier());
                    } else if (this.match("{")) {
                      specifiers = specifiers.concat(this.parseNamedImports());
                    } else {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
                if (!this.matchContextualKeyword("from")) {
                  var message2 = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message2, this.lookahead.value);
                }
                this.nextToken();
                src2 = this.parseModuleSpecifier();
              }
              this.consumeSemicolon();
              return this.finalize(node2, new Node2.ImportDeclaration(specifiers, src2));
            };
            Parser4.prototype.parseExportSpecifier = function() {
              var node2 = this.createNode();
              var local = this.parseIdentifierName();
              var exported = local;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                exported = this.parseIdentifierName();
              }
              return this.finalize(node2, new Node2.ExportSpecifier(local, exported));
            };
            Parser4.prototype.parseExportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalExportDeclaration);
              }
              var node2 = this.createNode();
              this.expectKeyword("export");
              var exportDeclaration;
              if (this.matchKeyword("default")) {
                this.nextToken();
                if (this.matchKeyword("function")) {
                  var declaration = this.parseFunctionDeclaration(true);
                  exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                } else if (this.matchKeyword("class")) {
                  var declaration = this.parseClassDeclaration(true);
                  exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                } else if (this.matchContextualKeyword("async")) {
                  var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                  exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                } else {
                  if (this.matchContextualKeyword("from")) {
                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                  }
                  var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node2, new Node2.ExportDefaultDeclaration(declaration));
                }
              } else if (this.match("*")) {
                this.nextToken();
                if (!this.matchContextualKeyword("from")) {
                  var message2 = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message2, this.lookahead.value);
                }
                this.nextToken();
                var src2 = this.parseModuleSpecifier();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node2, new Node2.ExportAllDeclaration(src2));
              } else if (this.lookahead.type === 4) {
                var declaration = void 0;
                switch (this.lookahead.value) {
                  case "let":
                  case "const":
                    declaration = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "var":
                  case "class":
                  case "function":
                    declaration = this.parseStatementListItem();
                    break;
                  default:
                    this.throwUnexpectedToken(this.lookahead);
                }
                exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(declaration, [], null));
              } else if (this.matchAsyncFunction()) {
                var declaration = this.parseFunctionDeclaration();
                exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(declaration, [], null));
              } else {
                var specifiers = [];
                var source2 = null;
                var isExportFromIdentifier = false;
                this.expect("{");
                while (!this.match("}")) {
                  isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                  specifiers.push(this.parseExportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                if (this.matchContextualKeyword("from")) {
                  this.nextToken();
                  source2 = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                } else if (isExportFromIdentifier) {
                  var message2 = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message2, this.lookahead.value);
                } else {
                  this.consumeSemicolon();
                }
                exportDeclaration = this.finalize(node2, new Node2.ExportNamedDeclaration(null, specifiers, source2));
              }
              return exportDeclaration;
            };
            return Parser4;
          }();
          exports3.Parser = Parser3;
        },
        /* 9 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          function assert2(condition, message2) {
            if (!condition) {
              throw new Error("ASSERT: " + message2);
            }
          }
          exports3.assert = assert2;
        },
        /* 10 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var ErrorHandler = function() {
            function ErrorHandler2() {
              this.errors = [];
              this.tolerant = false;
            }
            ErrorHandler2.prototype.recordError = function(error) {
              this.errors.push(error);
            };
            ErrorHandler2.prototype.tolerate = function(error) {
              if (this.tolerant) {
                this.recordError(error);
              } else {
                throw error;
              }
            };
            ErrorHandler2.prototype.constructError = function(msg, column) {
              var error = new Error(msg);
              try {
                throw error;
              } catch (base) {
                if (Object.create && Object.defineProperty) {
                  error = Object.create(base);
                  Object.defineProperty(error, "column", { value: column });
                }
              }
              return error;
            };
            ErrorHandler2.prototype.createError = function(index2, line, col, description2) {
              var msg = "Line " + line + ": " + description2;
              var error = this.constructError(msg, col);
              error.index = index2;
              error.lineNumber = line;
              error.description = description2;
              return error;
            };
            ErrorHandler2.prototype.throwError = function(index2, line, col, description2) {
              throw this.createError(index2, line, col, description2);
            };
            ErrorHandler2.prototype.tolerateError = function(index2, line, col, description2) {
              var error = this.createError(index2, line, col, description2);
              if (this.tolerant) {
                this.recordError(error);
              } else {
                throw error;
              }
            };
            return ErrorHandler2;
          }();
          exports3.ErrorHandler = ErrorHandler;
        },
        /* 11 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.Messages = {
            BadGetterArity: "Getter must not have any formal parameters",
            BadSetterArity: "Setter must have exactly one formal parameter",
            BadSetterRestParameter: "Setter function argument must not be a rest parameter",
            ConstructorIsAsync: "Class constructor may not be an async method",
            ConstructorSpecialMethod: "Class constructor may not be an accessor",
            DeclarationMissingInitializer: "Missing initializer in %0 declaration",
            DefaultRestParameter: "Unexpected token =",
            DuplicateBinding: "Duplicate binding %0",
            DuplicateConstructor: "A class may only have one constructor",
            DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
            ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
            GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
            IllegalBreak: "Illegal break statement",
            IllegalContinue: "Illegal continue statement",
            IllegalExportDeclaration: "Unexpected token",
            IllegalImportDeclaration: "Unexpected token",
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
            IllegalReturn: "Illegal return statement",
            InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
            InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
            InvalidModuleSpecifier: "Unexpected token",
            InvalidRegExp: "Invalid regular expression",
            LetInLexicalBinding: "let is disallowed as a lexically bound name",
            MissingFromClause: "Unexpected token",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NewlineAfterThrow: "Illegal newline after throw",
            NoAsAfterImportNamespace: "Unexpected token",
            NoCatchOrFinally: "Missing catch or finally after try",
            ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
            Redeclaration: "%0 '%1' has already been declared",
            StaticPrototype: "Classes may not have static property named prototype",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
            UnexpectedEOS: "Unexpected end of input",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedNumber: "Unexpected number",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedString: "Unexpected string",
            UnexpectedTemplate: "Unexpected quasi %0",
            UnexpectedToken: "Unexpected token %0",
            UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
            UnknownLabel: "Undefined label '%0'",
            UnterminatedRegExp: "Invalid regular expression: missing /"
          };
        },
        /* 12 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var assert_12 = __webpack_require__(9);
          var character_1 = __webpack_require__(4);
          var messages_1 = __webpack_require__(11);
          function hexValue(ch) {
            return "0123456789abcdef".indexOf(ch.toLowerCase());
          }
          function octalValue(ch) {
            return "01234567".indexOf(ch);
          }
          var Scanner = function() {
            function Scanner2(code2, handler) {
              this.source = code2;
              this.errorHandler = handler;
              this.trackComment = false;
              this.isModule = false;
              this.length = code2.length;
              this.index = 0;
              this.lineNumber = code2.length > 0 ? 1 : 0;
              this.lineStart = 0;
              this.curlyStack = [];
            }
            Scanner2.prototype.saveState = function() {
              return {
                index: this.index,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart
              };
            };
            Scanner2.prototype.restoreState = function(state) {
              this.index = state.index;
              this.lineNumber = state.lineNumber;
              this.lineStart = state.lineStart;
            };
            Scanner2.prototype.eof = function() {
              return this.index >= this.length;
            };
            Scanner2.prototype.throwUnexpectedToken = function(message2) {
              if (message2 === void 0) {
                message2 = messages_1.Messages.UnexpectedTokenIllegal;
              }
              return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message2);
            };
            Scanner2.prototype.tolerateUnexpectedToken = function(message2) {
              if (message2 === void 0) {
                message2 = messages_1.Messages.UnexpectedTokenIllegal;
              }
              this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message2);
            };
            Scanner2.prototype.skipSingleLineComment = function(offset) {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - offset;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                ++this.index;
                if (character_1.Character.isLineTerminator(ch)) {
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 1
                    };
                    var entry = {
                      multiLine: false,
                      slice: [start + offset, this.index - 1],
                      range: [start, this.index - 1],
                      loc
                    };
                    comments.push(entry);
                  }
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  return comments;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: false,
                  slice: [start + offset, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              return comments;
            };
            Scanner2.prototype.skipMultiLineComment = function() {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - 2;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isLineTerminator(ch)) {
                  if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  ++this.index;
                  this.lineStart = this.index;
                } else if (ch === 42) {
                  if (this.source.charCodeAt(this.index + 1) === 47) {
                    this.index += 2;
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var entry = {
                        multiLine: true,
                        slice: [start + 2, this.index - 2],
                        range: [start, this.index],
                        loc
                      };
                      comments.push(entry);
                    }
                    return comments;
                  }
                  ++this.index;
                } else {
                  ++this.index;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: true,
                  slice: [start + 2, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              this.tolerateUnexpectedToken();
              return comments;
            };
            Scanner2.prototype.scanComments = function() {
              var comments;
              if (this.trackComment) {
                comments = [];
              }
              var start = this.index === 0;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isWhiteSpace(ch)) {
                  ++this.index;
                } else if (character_1.Character.isLineTerminator(ch)) {
                  ++this.index;
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  start = true;
                } else if (ch === 47) {
                  ch = this.source.charCodeAt(this.index + 1);
                  if (ch === 47) {
                    this.index += 2;
                    var comment = this.skipSingleLineComment(2);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                    start = true;
                  } else if (ch === 42) {
                    this.index += 2;
                    var comment = this.skipMultiLineComment();
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (start && ch === 45) {
                  if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                    this.index += 3;
                    var comment = this.skipSingleLineComment(3);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (ch === 60 && !this.isModule) {
                  if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                    this.index += 4;
                    var comment = this.skipSingleLineComment(4);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              }
              return comments;
            };
            Scanner2.prototype.isFutureReservedWord = function(id) {
              switch (id) {
                case "enum":
                case "export":
                case "import":
                case "super":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isStrictModeReservedWord = function(id) {
              switch (id) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "yield":
                case "let":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isRestrictedWord = function(id) {
              return id === "eval" || id === "arguments";
            };
            Scanner2.prototype.isKeyword = function(id) {
              switch (id.length) {
                case 2:
                  return id === "if" || id === "in" || id === "do";
                case 3:
                  return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                case 4:
                  return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                case 5:
                  return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                case 6:
                  return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                case 7:
                  return id === "default" || id === "finally" || id === "extends";
                case 8:
                  return id === "function" || id === "continue" || id === "debugger";
                case 10:
                  return id === "instanceof";
                default:
                  return false;
              }
            };
            Scanner2.prototype.codePointAt = function(i2) {
              var cp = this.source.charCodeAt(i2);
              if (cp >= 55296 && cp <= 56319) {
                var second = this.source.charCodeAt(i2 + 1);
                if (second >= 56320 && second <= 57343) {
                  var first2 = cp;
                  cp = (first2 - 55296) * 1024 + second - 56320 + 65536;
                }
              }
              return cp;
            };
            Scanner2.prototype.scanHexEscape = function(prefix) {
              var len = prefix === "u" ? 4 : 2;
              var code2 = 0;
              for (var i2 = 0; i2 < len; ++i2) {
                if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  code2 = code2 * 16 + hexValue(this.source[this.index++]);
                } else {
                  return null;
                }
              }
              return String.fromCharCode(code2);
            };
            Scanner2.prototype.scanUnicodeCodePointEscape = function() {
              var ch = this.source[this.index];
              var code2 = 0;
              if (ch === "}") {
                this.throwUnexpectedToken();
              }
              while (!this.eof()) {
                ch = this.source[this.index++];
                if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                  break;
                }
                code2 = code2 * 16 + hexValue(ch);
              }
              if (code2 > 1114111 || ch !== "}") {
                this.throwUnexpectedToken();
              }
              return character_1.Character.fromCodePoint(code2);
            };
            Scanner2.prototype.getIdentifier = function() {
              var start = this.index++;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (ch === 92) {
                  this.index = start;
                  return this.getComplexIdentifier();
                } else if (ch >= 55296 && ch < 57343) {
                  this.index = start;
                  return this.getComplexIdentifier();
                }
                if (character_1.Character.isIdentifierPart(ch)) {
                  ++this.index;
                } else {
                  break;
                }
              }
              return this.source.slice(start, this.index);
            };
            Scanner2.prototype.getComplexIdentifier = function() {
              var cp = this.codePointAt(this.index);
              var id = character_1.Character.fromCodePoint(cp);
              this.index += id.length;
              var ch;
              if (cp === 92) {
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id = ch;
              }
              while (!this.eof()) {
                cp = this.codePointAt(this.index);
                if (!character_1.Character.isIdentifierPart(cp)) {
                  break;
                }
                ch = character_1.Character.fromCodePoint(cp);
                id += ch;
                this.index += ch.length;
                if (cp === 92) {
                  id = id.substr(0, id.length - 1);
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id += ch;
                }
              }
              return id;
            };
            Scanner2.prototype.octalToDecimal = function(ch) {
              var octal = ch !== "0";
              var code2 = octalValue(ch);
              if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                octal = true;
                code2 = code2 * 8 + octalValue(this.source[this.index++]);
                if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  code2 = code2 * 8 + octalValue(this.source[this.index++]);
                }
              }
              return {
                code: code2,
                octal
              };
            };
            Scanner2.prototype.scanIdentifier = function() {
              var type;
              var start = this.index;
              var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
              if (id.length === 1) {
                type = 3;
              } else if (this.isKeyword(id)) {
                type = 4;
              } else if (id === "null") {
                type = 5;
              } else if (id === "true" || id === "false") {
                type = 1;
              } else {
                type = 3;
              }
              if (type !== 3 && start + id.length !== this.index) {
                var restore = this.index;
                this.index = start;
                this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                this.index = restore;
              }
              return {
                type,
                value: id,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanPunctuator = function() {
              var start = this.index;
              var str = this.source[this.index];
              switch (str) {
                case "(":
                case "{":
                  if (str === "{") {
                    this.curlyStack.push("{");
                  }
                  ++this.index;
                  break;
                case ".":
                  ++this.index;
                  if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                    this.index += 2;
                    str = "...";
                  }
                  break;
                case "}":
                  ++this.index;
                  this.curlyStack.pop();
                  break;
                case ")":
                case ";":
                case ",":
                case "[":
                case "]":
                case ":":
                case "?":
                case "~":
                  ++this.index;
                  break;
                default:
                  str = this.source.substr(this.index, 4);
                  if (str === ">>>=") {
                    this.index += 4;
                  } else {
                    str = str.substr(0, 3);
                    if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                      this.index += 3;
                    } else {
                      str = str.substr(0, 2);
                      if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                        this.index += 2;
                      } else {
                        str = this.source[this.index];
                        if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                          ++this.index;
                        }
                      }
                    }
                  }
              }
              if (this.index === start) {
                this.throwUnexpectedToken();
              }
              return {
                type: 7,
                value: str,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanHexLiteral = function(start) {
              var num = "";
              while (!this.eof()) {
                if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt("0x" + num, 16),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanBinaryLiteral = function(start) {
              var num = "";
              var ch;
              while (!this.eof()) {
                ch = this.source[this.index];
                if (ch !== "0" && ch !== "1") {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (!this.eof()) {
                ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                  this.throwUnexpectedToken();
                }
              }
              return {
                type: 6,
                value: parseInt(num, 2),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
              var num = "";
              var octal = false;
              if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                octal = true;
                num = "0" + this.source[this.index++];
              } else {
                ++this.index;
              }
              while (!this.eof()) {
                if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (!octal && num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt(num, 8),
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.isImplicitOctalLiteral = function() {
              for (var i2 = this.index + 1; i2 < this.length; ++i2) {
                var ch = this.source[i2];
                if (ch === "8" || ch === "9") {
                  return false;
                }
                if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  return true;
                }
              }
              return true;
            };
            Scanner2.prototype.scanNumericLiteral = function() {
              var start = this.index;
              var ch = this.source[start];
              assert_12.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
              var num = "";
              if (ch !== ".") {
                num = this.source[this.index++];
                ch = this.source[this.index];
                if (num === "0") {
                  if (ch === "x" || ch === "X") {
                    ++this.index;
                    return this.scanHexLiteral(start);
                  }
                  if (ch === "b" || ch === "B") {
                    ++this.index;
                    return this.scanBinaryLiteral(start);
                  }
                  if (ch === "o" || ch === "O") {
                    return this.scanOctalLiteral(ch, start);
                  }
                  if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    if (this.isImplicitOctalLiteral()) {
                      return this.scanOctalLiteral(ch, start);
                    }
                  }
                }
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === ".") {
                num += this.source[this.index++];
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === "e" || ch === "E") {
                num += this.source[this.index++];
                ch = this.source[this.index];
                if (ch === "+" || ch === "-") {
                  num += this.source[this.index++];
                }
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                } else {
                  this.throwUnexpectedToken();
                }
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseFloat(num),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanStringLiteral = function() {
              var start = this.index;
              var quote = this.source[start];
              assert_12.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
              ++this.index;
              var octal = false;
              var str = "";
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === quote) {
                  quote = "";
                  break;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          str += this.scanUnicodeCodePointEscape();
                        } else {
                          var unescaped_1 = this.scanHexEscape(ch);
                          if (unescaped_1 === null) {
                            this.throwUnexpectedToken();
                          }
                          str += unescaped_1;
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        str += unescaped;
                        break;
                      case "n":
                        str += "\n";
                        break;
                      case "r":
                        str += "\r";
                        break;
                      case "t":
                        str += "	";
                        break;
                      case "b":
                        str += "\b";
                        break;
                      case "f":
                        str += "\f";
                        break;
                      case "v":
                        str += "\v";
                        break;
                      case "8":
                      case "9":
                        str += ch;
                        this.tolerateUnexpectedToken();
                        break;
                      default:
                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          var octToDec = this.octalToDecimal(ch);
                          octal = octToDec.octal || octal;
                          str += String.fromCharCode(octToDec.code);
                        } else {
                          str += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  break;
                } else {
                  str += ch;
                }
              }
              if (quote !== "") {
                this.index = start;
                this.throwUnexpectedToken();
              }
              return {
                type: 8,
                value: str,
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanTemplate = function() {
              var cooked = "";
              var terminated = false;
              var start = this.index;
              var head = this.source[start] === "`";
              var tail = false;
              var rawOffset = 2;
              ++this.index;
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === "`") {
                  rawOffset = 1;
                  tail = true;
                  terminated = true;
                  break;
                } else if (ch === "$") {
                  if (this.source[this.index] === "{") {
                    this.curlyStack.push("${");
                    ++this.index;
                    terminated = true;
                    break;
                  }
                  cooked += ch;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "n":
                        cooked += "\n";
                        break;
                      case "r":
                        cooked += "\r";
                        break;
                      case "t":
                        cooked += "	";
                        break;
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          cooked += this.scanUnicodeCodePointEscape();
                        } else {
                          var restore = this.index;
                          var unescaped_2 = this.scanHexEscape(ch);
                          if (unescaped_2 !== null) {
                            cooked += unescaped_2;
                          } else {
                            this.index = restore;
                            cooked += ch;
                          }
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        cooked += unescaped;
                        break;
                      case "b":
                        cooked += "\b";
                        break;
                      case "f":
                        cooked += "\f";
                        break;
                      case "v":
                        cooked += "\v";
                        break;
                      default:
                        if (ch === "0") {
                          if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          }
                          cooked += "\0";
                        } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        } else {
                          cooked += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                  cooked += "\n";
                } else {
                  cooked += ch;
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken();
              }
              if (!head) {
                this.curlyStack.pop();
              }
              return {
                type: 10,
                value: this.source.slice(start + 1, this.index - rawOffset),
                cooked,
                head,
                tail,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.testRegExp = function(pattern, flags) {
              var astralSubstitute = "";
              var tmp = pattern;
              var self2 = this;
              if (flags.indexOf("u") >= 0) {
                tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                  var codePoint = parseInt($1 || $2, 16);
                  if (codePoint > 1114111) {
                    self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                  }
                  if (codePoint <= 65535) {
                    return String.fromCharCode(codePoint);
                  }
                  return astralSubstitute;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
              }
              try {
                RegExp(tmp);
              } catch (e2) {
                this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
              }
              try {
                return new RegExp(pattern, flags);
              } catch (exception) {
                return null;
              }
            };
            Scanner2.prototype.scanRegExpBody = function() {
              var ch = this.source[this.index];
              assert_12.assert(ch === "/", "Regular expression literal must start with a slash");
              var str = this.source[this.index++];
              var classMarker = false;
              var terminated = false;
              while (!this.eof()) {
                ch = this.source[this.index++];
                str += ch;
                if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  }
                  str += ch;
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                } else if (classMarker) {
                  if (ch === "]") {
                    classMarker = false;
                  }
                } else {
                  if (ch === "/") {
                    terminated = true;
                    break;
                  } else if (ch === "[") {
                    classMarker = true;
                  }
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              }
              return str.substr(1, str.length - 2);
            };
            Scanner2.prototype.scanRegExpFlags = function() {
              var str = "";
              var flags = "";
              while (!this.eof()) {
                var ch = this.source[this.index];
                if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                  break;
                }
                ++this.index;
                if (ch === "\\" && !this.eof()) {
                  ch = this.source[this.index];
                  if (ch === "u") {
                    ++this.index;
                    var restore = this.index;
                    var char = this.scanHexEscape("u");
                    if (char !== null) {
                      flags += char;
                      for (str += "\\u"; restore < this.index; ++restore) {
                        str += this.source[restore];
                      }
                    } else {
                      this.index = restore;
                      flags += "u";
                      str += "\\u";
                    }
                    this.tolerateUnexpectedToken();
                  } else {
                    str += "\\";
                    this.tolerateUnexpectedToken();
                  }
                } else {
                  flags += ch;
                  str += ch;
                }
              }
              return flags;
            };
            Scanner2.prototype.scanRegExp = function() {
              var start = this.index;
              var pattern = this.scanRegExpBody();
              var flags = this.scanRegExpFlags();
              var value = this.testRegExp(pattern, flags);
              return {
                type: 9,
                value: "",
                pattern,
                flags,
                regex: value,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.lex = function() {
              if (this.eof()) {
                return {
                  type: 2,
                  value: "",
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: this.index,
                  end: this.index
                };
              }
              var cp = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(cp)) {
                return this.scanIdentifier();
              }
              if (cp === 40 || cp === 41 || cp === 59) {
                return this.scanPunctuator();
              }
              if (cp === 39 || cp === 34) {
                return this.scanStringLiteral();
              }
              if (cp === 46) {
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                  return this.scanNumericLiteral();
                }
                return this.scanPunctuator();
              }
              if (character_1.Character.isDecimalDigit(cp)) {
                return this.scanNumericLiteral();
              }
              if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                return this.scanTemplate();
              }
              if (cp >= 55296 && cp < 57343) {
                if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                  return this.scanIdentifier();
                }
              }
              return this.scanPunctuator();
            };
            return Scanner2;
          }();
          exports3.Scanner = Scanner;
        },
        /* 13 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.TokenName = {};
          exports3.TokenName[
            1
            /* BooleanLiteral */
          ] = "Boolean";
          exports3.TokenName[
            2
            /* EOF */
          ] = "<end>";
          exports3.TokenName[
            3
            /* Identifier */
          ] = "Identifier";
          exports3.TokenName[
            4
            /* Keyword */
          ] = "Keyword";
          exports3.TokenName[
            5
            /* NullLiteral */
          ] = "Null";
          exports3.TokenName[
            6
            /* NumericLiteral */
          ] = "Numeric";
          exports3.TokenName[
            7
            /* Punctuator */
          ] = "Punctuator";
          exports3.TokenName[
            8
            /* StringLiteral */
          ] = "String";
          exports3.TokenName[
            9
            /* RegularExpression */
          ] = "RegularExpression";
          exports3.TokenName[
            10
            /* Template */
          ] = "Template";
        },
        /* 14 */
        /***/
        function(module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.XHTMLEntities = {
            quot: '"',
            amp: "&",
            apos: "'",
            gt: ">",
            nbsp: "",
            iexcl: "",
            cent: "",
            pound: "",
            curren: "",
            yen: "",
            brvbar: "",
            sect: "",
            uml: "",
            copy: "",
            ordf: "",
            laquo: "",
            not: "",
            shy: "",
            reg: "",
            macr: "",
            deg: "",
            plusmn: "",
            sup2: "",
            sup3: "",
            acute: "",
            micro: "",
            para: "",
            middot: "",
            cedil: "",
            sup1: "",
            ordm: "",
            raquo: "",
            frac14: "",
            frac12: "",
            frac34: "",
            iquest: "",
            Agrave: "",
            Aacute: "",
            Acirc: "",
            Atilde: "",
            Auml: "",
            Aring: "",
            AElig: "",
            Ccedil: "",
            Egrave: "",
            Eacute: "",
            Ecirc: "",
            Euml: "",
            Igrave: "",
            Iacute: "",
            Icirc: "",
            Iuml: "",
            ETH: "",
            Ntilde: "",
            Ograve: "",
            Oacute: "",
            Ocirc: "",
            Otilde: "",
            Ouml: "",
            times: "",
            Oslash: "",
            Ugrave: "",
            Uacute: "",
            Ucirc: "",
            Uuml: "",
            Yacute: "",
            THORN: "",
            szlig: "",
            agrave: "",
            aacute: "",
            acirc: "",
            atilde: "",
            auml: "",
            aring: "",
            aelig: "",
            ccedil: "",
            egrave: "",
            eacute: "",
            ecirc: "",
            euml: "",
            igrave: "",
            iacute: "",
            icirc: "",
            iuml: "",
            eth: "",
            ntilde: "",
            ograve: "",
            oacute: "",
            ocirc: "",
            otilde: "",
            ouml: "",
            divide: "",
            oslash: "",
            ugrave: "",
            uacute: "",
            ucirc: "",
            uuml: "",
            yacute: "",
            thorn: "",
            yuml: "",
            OElig: "",
            oelig: "",
            Scaron: "",
            scaron: "",
            Yuml: "",
            fnof: "",
            circ: "",
            tilde: "",
            Alpha: "",
            Beta: "",
            Gamma: "",
            Delta: "",
            Epsilon: "",
            Zeta: "",
            Eta: "",
            Theta: "",
            Iota: "",
            Kappa: "",
            Lambda: "",
            Mu: "",
            Nu: "",
            Xi: "",
            Omicron: "",
            Pi: "",
            Rho: "",
            Sigma: "",
            Tau: "",
            Upsilon: "",
            Phi: "",
            Chi: "",
            Psi: "",
            Omega: "",
            alpha: "",
            beta: "",
            gamma: "",
            delta: "",
            epsilon: "",
            zeta: "",
            eta: "",
            theta: "",
            iota: "",
            kappa: "",
            lambda: "",
            mu: "",
            nu: "",
            xi: "",
            omicron: "",
            pi: "",
            rho: "",
            sigmaf: "",
            sigma: "",
            tau: "",
            upsilon: "",
            phi: "",
            chi: "",
            psi: "",
            omega: "",
            thetasym: "",
            upsih: "",
            piv: "",
            ensp: "",
            emsp: "",
            thinsp: "",
            zwnj: "",
            zwj: "",
            lrm: "",
            rlm: "",
            ndash: "",
            mdash: "",
            lsquo: "",
            rsquo: "",
            sbquo: "",
            ldquo: "",
            rdquo: "",
            bdquo: "",
            dagger: "",
            Dagger: "",
            bull: "",
            hellip: "",
            permil: "",
            prime: "",
            Prime: "",
            lsaquo: "",
            rsaquo: "",
            oline: "",
            frasl: "",
            euro: "",
            image: "",
            weierp: "",
            real: "",
            trade: "",
            alefsym: "",
            larr: "",
            uarr: "",
            rarr: "",
            darr: "",
            harr: "",
            crarr: "",
            lArr: "",
            uArr: "",
            rArr: "",
            dArr: "",
            hArr: "",
            forall: "",
            part: "",
            exist: "",
            empty: "",
            nabla: "",
            isin: "",
            notin: "",
            ni: "",
            prod: "",
            sum: "",
            minus: "",
            lowast: "",
            radic: "",
            prop: "",
            infin: "",
            ang: "",
            and: "",
            or: "",
            cap: "",
            cup: "",
            int: "",
            there4: "",
            sim: "",
            cong: "",
            asymp: "",
            ne: "",
            equiv: "",
            le: "",
            ge: "",
            sub: "",
            sup: "",
            nsub: "",
            sube: "",
            supe: "",
            oplus: "",
            otimes: "",
            perp: "",
            sdot: "",
            lceil: "",
            rceil: "",
            lfloor: "",
            rfloor: "",
            loz: "",
            spades: "",
            clubs: "",
            hearts: "",
            diams: "",
            lang: "",
            rang: ""
          };
        },
        /* 15 */
        /***/
        function(module3, exports3, __webpack_require__) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          var error_handler_1 = __webpack_require__(10);
          var scanner_1 = __webpack_require__(12);
          var token_1 = __webpack_require__(13);
          var Reader = function() {
            function Reader2() {
              this.values = [];
              this.curly = this.paren = -1;
            }
            Reader2.prototype.beforeFunctionExpression = function(t2) {
              return [
                "(",
                "{",
                "[",
                "in",
                "typeof",
                "instanceof",
                "new",
                "return",
                "case",
                "delete",
                "throw",
                "void",
                // assignment operators
                "=",
                "+=",
                "-=",
                "*=",
                "**=",
                "/=",
                "%=",
                "<<=",
                ">>=",
                ">>>=",
                "&=",
                "|=",
                "^=",
                ",",
                // binary/unary operators
                "+",
                "-",
                "*",
                "**",
                "/",
                "%",
                "++",
                "--",
                "<<",
                ">>",
                ">>>",
                "&",
                "|",
                "^",
                "!",
                "~",
                "&&",
                "||",
                "?",
                ":",
                "===",
                "==",
                ">=",
                "<=",
                "<",
                ">",
                "!=",
                "!=="
              ].indexOf(t2) >= 0;
            };
            Reader2.prototype.isRegexStart = function() {
              var previous = this.values[this.values.length - 1];
              var regex = previous !== null;
              switch (previous) {
                case "this":
                case "]":
                  regex = false;
                  break;
                case ")":
                  var keyword2 = this.values[this.paren - 1];
                  regex = keyword2 === "if" || keyword2 === "while" || keyword2 === "for" || keyword2 === "with";
                  break;
                case "}":
                  regex = false;
                  if (this.values[this.curly - 3] === "function") {
                    var check = this.values[this.curly - 4];
                    regex = check ? !this.beforeFunctionExpression(check) : false;
                  } else if (this.values[this.curly - 4] === "function") {
                    var check = this.values[this.curly - 5];
                    regex = check ? !this.beforeFunctionExpression(check) : true;
                  }
                  break;
              }
              return regex;
            };
            Reader2.prototype.push = function(token) {
              if (token.type === 7 || token.type === 4) {
                if (token.value === "{") {
                  this.curly = this.values.length;
                } else if (token.value === "(") {
                  this.paren = this.values.length;
                }
                this.values.push(token.value);
              } else {
                this.values.push(null);
              }
            };
            return Reader2;
          }();
          var Tokenizer = function() {
            function Tokenizer2(code2, config2) {
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = config2 ? typeof config2.tolerant === "boolean" && config2.tolerant : false;
              this.scanner = new scanner_1.Scanner(code2, this.errorHandler);
              this.scanner.trackComment = config2 ? typeof config2.comment === "boolean" && config2.comment : false;
              this.trackRange = config2 ? typeof config2.range === "boolean" && config2.range : false;
              this.trackLoc = config2 ? typeof config2.loc === "boolean" && config2.loc : false;
              this.buffer = [];
              this.reader = new Reader();
            }
            Tokenizer2.prototype.errors = function() {
              return this.errorHandler.errors;
            };
            Tokenizer2.prototype.getNextToken = function() {
              if (this.buffer.length === 0) {
                var comments = this.scanner.scanComments();
                if (this.scanner.trackComment) {
                  for (var i2 = 0; i2 < comments.length; ++i2) {
                    var e2 = comments[i2];
                    var value = this.scanner.source.slice(e2.slice[0], e2.slice[1]);
                    var comment = {
                      type: e2.multiLine ? "BlockComment" : "LineComment",
                      value
                    };
                    if (this.trackRange) {
                      comment.range = e2.range;
                    }
                    if (this.trackLoc) {
                      comment.loc = e2.loc;
                    }
                    this.buffer.push(comment);
                  }
                }
                if (!this.scanner.eof()) {
                  var loc = void 0;
                  if (this.trackLoc) {
                    loc = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    };
                  }
                  var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                  var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                  this.reader.push(token);
                  var entry = {
                    type: token_1.TokenName[token.type],
                    value: this.scanner.source.slice(token.start, token.end)
                  };
                  if (this.trackRange) {
                    entry.range = [token.start, token.end];
                  }
                  if (this.trackLoc) {
                    loc.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                    entry.loc = loc;
                  }
                  if (token.type === 9) {
                    var pattern = token.pattern;
                    var flags = token.flags;
                    entry.regex = { pattern, flags };
                  }
                  this.buffer.push(entry);
                }
              }
              return this.buffer.shift();
            };
            return Tokenizer2;
          }();
          exports3.Tokenizer = Tokenizer;
        }
        /******/
      ])
    );
  });
})(esprima$1);
var esprimaExports = esprima$1.exports;
var main$1 = {};
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate$1(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers$1(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName$1(f2, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding$3 = Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
};
function __exportStar(m2, o2) {
  for (var p2 in m2)
    if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
      __createBinding$3(o2, m2, p2);
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume2(n2, v2);
        });
      };
  }
  function resume2(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume2("next", value);
  }
  function reject(value) {
    resume2("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume2(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: false } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v7) {
      resolve2({ value: v7, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault$3 = Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
};
function __importStar$3(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$3(result, mod, k2);
  }
  __setModuleDefault$3(result, mod);
  return result;
}
function __importDefault$5(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env2, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function")
      throw new TypeError("Object not disposable.");
    env2.stack.push({ value, dispose, async: async2 });
  } else if (async2) {
    env2.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function __disposeResources(env2) {
  function fail(e2) {
    env2.error = env2.hasError ? new _SuppressedError(e2, env2.error, "An error was suppressed during disposal.") : e2;
    env2.hasError = true;
  }
  function next() {
    while (env2.stack.length) {
      var rec = env2.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
      } catch (e2) {
        fail(e2);
      }
    }
    if (env2.hasError)
      throw env2.error;
  }
  return next();
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding: __createBinding$3,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar: __importStar$3,
  __importDefault: __importDefault$5,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding: __createBinding$3,
  __decorate,
  __disposeResources,
  __esDecorate: __esDecorate$1,
  __exportStar,
  __extends,
  __generator,
  __importDefault: __importDefault$5,
  __importStar: __importStar$3,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __runInitializers: __runInitializers$1,
  __setFunctionName: __setFunctionName$1,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var fork = { exports: {} };
var types$1 = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1)
    return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  types$1.Def = void 0;
  var tslib_1 = require$$0;
  var Op = Object.prototype;
  var objToStr = Op.toString;
  var hasOwn = Op.hasOwnProperty;
  var BaseType = (
    /** @class */
    function() {
      function BaseType2() {
      }
      BaseType2.prototype.assert = function(value, deep) {
        if (!this.check(value, deep)) {
          var str = shallowStringify(value);
          throw new Error(str + " does not match type " + this);
        }
        return true;
      };
      BaseType2.prototype.arrayOf = function() {
        var elemType = this;
        return new ArrayType(elemType);
      };
      return BaseType2;
    }()
  );
  var ArrayType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(ArrayType2, _super);
      function ArrayType2(elemType) {
        var _this = _super.call(this) || this;
        _this.elemType = elemType;
        _this.kind = "ArrayType";
        return _this;
      }
      ArrayType2.prototype.toString = function() {
        return "[" + this.elemType + "]";
      };
      ArrayType2.prototype.check = function(value, deep) {
        var _this = this;
        return Array.isArray(value) && value.every(function(elem) {
          return _this.elemType.check(elem, deep);
        });
      };
      return ArrayType2;
    }(BaseType)
  );
  var IdentityType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(IdentityType2, _super);
      function IdentityType2(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.kind = "IdentityType";
        return _this;
      }
      IdentityType2.prototype.toString = function() {
        return String(this.value);
      };
      IdentityType2.prototype.check = function(value, deep) {
        var result = value === this.value;
        if (!result && typeof deep === "function") {
          deep(this, value);
        }
        return result;
      };
      return IdentityType2;
    }(BaseType)
  );
  var ObjectType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(ObjectType2, _super);
      function ObjectType2(fields) {
        var _this = _super.call(this) || this;
        _this.fields = fields;
        _this.kind = "ObjectType";
        return _this;
      }
      ObjectType2.prototype.toString = function() {
        return "{ " + this.fields.join(", ") + " }";
      };
      ObjectType2.prototype.check = function(value, deep) {
        return objToStr.call(value) === objToStr.call({}) && this.fields.every(function(field) {
          return field.type.check(value[field.name], deep);
        });
      };
      return ObjectType2;
    }(BaseType)
  );
  var OrType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(OrType2, _super);
      function OrType2(types2) {
        var _this = _super.call(this) || this;
        _this.types = types2;
        _this.kind = "OrType";
        return _this;
      }
      OrType2.prototype.toString = function() {
        return this.types.join(" | ");
      };
      OrType2.prototype.check = function(value, deep) {
        return this.types.some(function(type) {
          return type.check(value, deep);
        });
      };
      return OrType2;
    }(BaseType)
  );
  var PredicateType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(PredicateType2, _super);
      function PredicateType2(name2, predicate) {
        var _this = _super.call(this) || this;
        _this.name = name2;
        _this.predicate = predicate;
        _this.kind = "PredicateType";
        return _this;
      }
      PredicateType2.prototype.toString = function() {
        return this.name;
      };
      PredicateType2.prototype.check = function(value, deep) {
        var result = this.predicate(value, deep);
        if (!result && typeof deep === "function") {
          deep(this, value);
        }
        return result;
      };
      return PredicateType2;
    }(BaseType)
  );
  var Def = (
    /** @class */
    function() {
      function Def2(type, typeName) {
        this.type = type;
        this.typeName = typeName;
        this.baseNames = [];
        this.ownFields = /* @__PURE__ */ Object.create(null);
        this.allSupertypes = /* @__PURE__ */ Object.create(null);
        this.supertypeList = [];
        this.allFields = /* @__PURE__ */ Object.create(null);
        this.fieldNames = [];
        this.finalized = false;
        this.buildable = false;
        this.buildParams = [];
      }
      Def2.prototype.isSupertypeOf = function(that) {
        if (that instanceof Def2) {
          if (this.finalized !== true || that.finalized !== true) {
            throw new Error("");
          }
          return hasOwn.call(that.allSupertypes, this.typeName);
        } else {
          throw new Error(that + " is not a Def");
        }
      };
      Def2.prototype.checkAllFields = function(value, deep) {
        var allFields = this.allFields;
        if (this.finalized !== true) {
          throw new Error("" + this.typeName);
        }
        function checkFieldByName(name2) {
          var field = allFields[name2];
          var type = field.type;
          var child = field.getValue(value);
          return type.check(child, deep);
        }
        return value !== null && typeof value === "object" && Object.keys(allFields).every(checkFieldByName);
      };
      Def2.prototype.bases = function() {
        var supertypeNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          supertypeNames[_i] = arguments[_i];
        }
        var bases = this.baseNames;
        if (this.finalized) {
          if (supertypeNames.length !== bases.length) {
            throw new Error("");
          }
          for (var i2 = 0; i2 < supertypeNames.length; i2++) {
            if (supertypeNames[i2] !== bases[i2]) {
              throw new Error("");
            }
          }
          return this;
        }
        supertypeNames.forEach(function(baseName) {
          if (bases.indexOf(baseName) < 0) {
            bases.push(baseName);
          }
        });
        return this;
      };
      return Def2;
    }()
  );
  types$1.Def = Def;
  var Field = (
    /** @class */
    function() {
      function Field2(name2, type, defaultFn, hidden) {
        this.name = name2;
        this.type = type;
        this.defaultFn = defaultFn;
        this.hidden = !!hidden;
      }
      Field2.prototype.toString = function() {
        return JSON.stringify(this.name) + ": " + this.type;
      };
      Field2.prototype.getValue = function(obj) {
        var value = obj[this.name];
        if (typeof value !== "undefined") {
          return value;
        }
        if (typeof this.defaultFn === "function") {
          value = this.defaultFn.call(obj);
        }
        return value;
      };
      return Field2;
    }()
  );
  function shallowStringify(value) {
    if (Array.isArray(value)) {
      return "[" + value.map(shallowStringify).join(", ") + "]";
    }
    if (value && typeof value === "object") {
      return "{ " + Object.keys(value).map(function(key) {
        return key + ": " + value[key];
      }).join(", ") + " }";
    }
    return JSON.stringify(value);
  }
  function typesPlugin(_fork) {
    var Type = {
      or: function() {
        var types2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          types2[_i] = arguments[_i];
        }
        return new OrType(types2.map(function(type) {
          return Type.from(type);
        }));
      },
      from: function(value, name2) {
        if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {
          return value;
        }
        if (value instanceof Def) {
          return value.type;
        }
        if (isArray4.check(value)) {
          if (value.length !== 1) {
            throw new Error("only one element type is permitted for typed arrays");
          }
          return new ArrayType(Type.from(value[0]));
        }
        if (isObject.check(value)) {
          return new ObjectType(Object.keys(value).map(function(name3) {
            return new Field(name3, Type.from(value[name3], name3));
          }));
        }
        if (typeof value === "function") {
          var bicfIndex = builtInCtorFns.indexOf(value);
          if (bicfIndex >= 0) {
            return builtInCtorTypes[bicfIndex];
          }
          if (typeof name2 !== "string") {
            throw new Error("missing name");
          }
          return new PredicateType(name2, value);
        }
        return new IdentityType(value);
      },
      // Define a type whose name is registered in a namespace (the defCache) so
      // that future definitions will return the same type given the same name.
      // In particular, this system allows for circular and forward definitions.
      // The Def object d returned from Type.def may be used to configure the
      // type d.type by calling methods such as d.bases, d.build, and d.field.
      def: function(typeName) {
        return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
      },
      hasDef: function(typeName) {
        return hasOwn.call(defCache, typeName);
      }
    };
    var builtInCtorFns = [];
    var builtInCtorTypes = [];
    function defBuiltInType(name2, example) {
      var objStr = objToStr.call(example);
      var type = new PredicateType(name2, function(value) {
        return objToStr.call(value) === objStr;
      });
      if (example && typeof example.constructor === "function") {
        builtInCtorFns.push(example.constructor);
        builtInCtorTypes.push(type);
      }
      return type;
    }
    var isString2 = defBuiltInType("string", "truthy");
    var isFunction2 = defBuiltInType("function", function() {
    });
    var isArray4 = defBuiltInType("array", []);
    var isObject = defBuiltInType("object", {});
    var isRegExp2 = defBuiltInType("RegExp", /./);
    var isDate2 = defBuiltInType("Date", /* @__PURE__ */ new Date());
    var isNumber2 = defBuiltInType("number", 3);
    var isBoolean = defBuiltInType("boolean", true);
    var isNull = defBuiltInType("null", null);
    var isUndefined = defBuiltInType("undefined", void 0);
    var builtInTypes = {
      string: isString2,
      function: isFunction2,
      array: isArray4,
      object: isObject,
      RegExp: isRegExp2,
      Date: isDate2,
      number: isNumber2,
      boolean: isBoolean,
      null: isNull,
      undefined: isUndefined
    };
    var defCache = /* @__PURE__ */ Object.create(null);
    function defFromValue(value) {
      if (value && typeof value === "object") {
        var type = value.type;
        if (typeof type === "string" && hasOwn.call(defCache, type)) {
          var d2 = defCache[type];
          if (d2.finalized) {
            return d2;
          }
        }
      }
      return null;
    }
    var DefImpl = (
      /** @class */
      function(_super) {
        tslib_1.__extends(DefImpl2, _super);
        function DefImpl2(typeName) {
          var _this = _super.call(this, new PredicateType(typeName, function(value, deep) {
            return _this.check(value, deep);
          }), typeName) || this;
          return _this;
        }
        DefImpl2.prototype.check = function(value, deep) {
          if (this.finalized !== true) {
            throw new Error("prematurely checking unfinalized type " + this.typeName);
          }
          if (value === null || typeof value !== "object") {
            return false;
          }
          var vDef = defFromValue(value);
          if (!vDef) {
            if (this.typeName === "SourceLocation" || this.typeName === "Position") {
              return this.checkAllFields(value, deep);
            }
            return false;
          }
          if (deep && vDef === this) {
            return this.checkAllFields(value, deep);
          }
          if (!this.isSupertypeOf(vDef)) {
            return false;
          }
          if (!deep) {
            return true;
          }
          return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);
        };
        DefImpl2.prototype.build = function() {
          var _this = this;
          var buildParams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            buildParams[_i] = arguments[_i];
          }
          this.buildParams = buildParams;
          if (this.buildable) {
            return this;
          }
          this.field("type", String, function() {
            return _this.typeName;
          });
          this.buildable = true;
          var addParam = function(built, param, arg, isArgAvailable) {
            if (hasOwn.call(built, param))
              return;
            var all = _this.allFields;
            if (!hasOwn.call(all, param)) {
              throw new Error("" + param);
            }
            var field = all[param];
            var type = field.type;
            var value;
            if (isArgAvailable) {
              value = arg;
            } else if (field.defaultFn) {
              value = field.defaultFn.call(built);
            } else {
              var message2 = "no value or default function given for field " + JSON.stringify(param) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name2) {
                return all[name2];
              }).join(", ") + ")";
              throw new Error(message2);
            }
            if (!type.check(value)) {
              throw new Error(shallowStringify(value) + " does not match field " + field + " of type " + _this.typeName);
            }
            built[param] = value;
          };
          var builder = function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            var argc = args.length;
            if (!_this.finalized) {
              throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
            }
            var built = Object.create(nodePrototype);
            _this.buildParams.forEach(function(param, i2) {
              if (i2 < argc) {
                addParam(built, param, args[i2], true);
              } else {
                addParam(built, param, null, false);
              }
            });
            Object.keys(_this.allFields).forEach(function(param) {
              addParam(built, param, null, false);
            });
            if (built.type !== _this.typeName) {
              throw new Error("");
            }
            return built;
          };
          builder.from = function(obj) {
            if (!_this.finalized) {
              throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
            }
            var built = Object.create(nodePrototype);
            Object.keys(_this.allFields).forEach(function(param) {
              if (hasOwn.call(obj, param)) {
                addParam(built, param, obj[param], true);
              } else {
                addParam(built, param, null, false);
              }
            });
            if (built.type !== _this.typeName) {
              throw new Error("");
            }
            return built;
          };
          Object.defineProperty(builders, getBuilderName(this.typeName), {
            enumerable: true,
            value: builder
          });
          return this;
        };
        DefImpl2.prototype.field = function(name2, type, defaultFn, hidden) {
          if (this.finalized) {
            console.error("Ignoring attempt to redefine field " + JSON.stringify(name2) + " of finalized type " + JSON.stringify(this.typeName));
            return this;
          }
          this.ownFields[name2] = new Field(name2, Type.from(type), defaultFn, hidden);
          return this;
        };
        DefImpl2.prototype.finalize = function() {
          var _this = this;
          if (!this.finalized) {
            var allFields = this.allFields;
            var allSupertypes = this.allSupertypes;
            this.baseNames.forEach(function(name2) {
              var def = defCache[name2];
              if (def instanceof Def) {
                def.finalize();
                extend(allFields, def.allFields);
                extend(allSupertypes, def.allSupertypes);
              } else {
                var message2 = "unknown supertype name " + JSON.stringify(name2) + " for subtype " + JSON.stringify(_this.typeName);
                throw new Error(message2);
              }
            });
            extend(allFields, this.ownFields);
            allSupertypes[this.typeName] = this;
            this.fieldNames.length = 0;
            for (var fieldName in allFields) {
              if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                this.fieldNames.push(fieldName);
              }
            }
            Object.defineProperty(namedTypes2, this.typeName, {
              enumerable: true,
              value: this.type
            });
            this.finalized = true;
            populateSupertypeList(this.typeName, this.supertypeList);
            if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) {
              wrapExpressionBuilderWithStatement(this.typeName);
            }
          }
        };
        return DefImpl2;
      }(Def)
    );
    function getSupertypeNames(typeName) {
      if (!hasOwn.call(defCache, typeName)) {
        throw new Error("");
      }
      var d2 = defCache[typeName];
      if (d2.finalized !== true) {
        throw new Error("");
      }
      return d2.supertypeList.slice(1);
    }
    function computeSupertypeLookupTable(candidates) {
      var table = {};
      var typeNames = Object.keys(defCache);
      var typeNameCount = typeNames.length;
      for (var i2 = 0; i2 < typeNameCount; ++i2) {
        var typeName = typeNames[i2];
        var d2 = defCache[typeName];
        if (d2.finalized !== true) {
          throw new Error("" + typeName);
        }
        for (var j2 = 0; j2 < d2.supertypeList.length; ++j2) {
          var superTypeName = d2.supertypeList[j2];
          if (hasOwn.call(candidates, superTypeName)) {
            table[typeName] = superTypeName;
            break;
          }
        }
      }
      return table;
    }
    var builders = /* @__PURE__ */ Object.create(null);
    var nodePrototype = {};
    function defineMethod(name2, func) {
      var old = nodePrototype[name2];
      if (isUndefined.check(func)) {
        delete nodePrototype[name2];
      } else {
        isFunction2.assert(func);
        Object.defineProperty(nodePrototype, name2, {
          enumerable: true,
          configurable: true,
          value: func
        });
      }
      return old;
    }
    function getBuilderName(typeName) {
      return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
        var len = upperCasePrefix.length;
        switch (len) {
          case 0:
            return "";
          case 1:
            return upperCasePrefix.toLowerCase();
          default:
            return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
        }
      });
    }
    function getStatementBuilderName(typeName) {
      typeName = getBuilderName(typeName);
      return typeName.replace(/(Expression)?$/, "Statement");
    }
    var namedTypes2 = {};
    function getFieldNames(object) {
      var d2 = defFromValue(object);
      if (d2) {
        return d2.fieldNames.slice(0);
      }
      if ("type" in object) {
        throw new Error("did not recognize object of type " + JSON.stringify(object.type));
      }
      return Object.keys(object);
    }
    function getFieldValue(object, fieldName) {
      var d2 = defFromValue(object);
      if (d2) {
        var field = d2.allFields[fieldName];
        if (field) {
          return field.getValue(object);
        }
      }
      return object && object[fieldName];
    }
    function eachField(object, callback, context2) {
      getFieldNames(object).forEach(function(name2) {
        callback.call(this, name2, getFieldValue(object, name2));
      }, context2);
    }
    function someField(object, callback, context2) {
      return getFieldNames(object).some(function(name2) {
        return callback.call(this, name2, getFieldValue(object, name2));
      }, context2);
    }
    function wrapExpressionBuilderWithStatement(typeName) {
      var wrapperName = getStatementBuilderName(typeName);
      if (builders[wrapperName])
        return;
      var wrapped = builders[getBuilderName(typeName)];
      if (!wrapped)
        return;
      var builder = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return builders.expressionStatement(wrapped.apply(builders, args));
      };
      builder.from = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return builders.expressionStatement(wrapped.from.apply(builders, args));
      };
      builders[wrapperName] = builder;
    }
    function populateSupertypeList(typeName, list) {
      list.length = 0;
      list.push(typeName);
      var lastSeen = /* @__PURE__ */ Object.create(null);
      for (var pos = 0; pos < list.length; ++pos) {
        typeName = list[pos];
        var d2 = defCache[typeName];
        if (d2.finalized !== true) {
          throw new Error("");
        }
        if (hasOwn.call(lastSeen, typeName)) {
          delete list[lastSeen[typeName]];
        }
        lastSeen[typeName] = pos;
        list.push.apply(list, d2.baseNames);
      }
      for (var to = 0, from2 = to, len = list.length; from2 < len; ++from2) {
        if (hasOwn.call(list, from2)) {
          list[to++] = list[from2];
        }
      }
      list.length = to;
    }
    function extend(into, from2) {
      Object.keys(from2).forEach(function(name2) {
        into[name2] = from2[name2];
      });
      return into;
    }
    function finalize() {
      Object.keys(defCache).forEach(function(name2) {
        defCache[name2].finalize();
      });
    }
    return {
      Type,
      builtInTypes,
      getSupertypeNames,
      computeSupertypeLookupTable,
      builders,
      defineMethod,
      getBuilderName,
      getStatementBuilderName,
      namedTypes: namedTypes2,
      getFieldNames,
      getFieldValue,
      eachField,
      someField,
      finalize
    };
  }
  types$1.default = typesPlugin;
  return types$1;
}
var pathVisitor = { exports: {} };
var nodePath = { exports: {} };
var path$1 = { exports: {} };
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath)
    return path$1.exports;
  hasRequiredPath = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    function pathPlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var isArray4 = types2.builtInTypes.array;
      var isNumber2 = types2.builtInTypes.number;
      var Path = function Path2(value, parentPath, name2) {
        if (!(this instanceof Path2)) {
          throw new Error("Path constructor cannot be invoked without 'new'");
        }
        if (parentPath) {
          if (!(parentPath instanceof Path2)) {
            throw new Error("");
          }
        } else {
          parentPath = null;
          name2 = null;
        }
        this.value = value;
        this.parentPath = parentPath;
        this.name = name2;
        this.__childCache = null;
      };
      var Pp = Path.prototype;
      function getChildCache(path2) {
        return path2.__childCache || (path2.__childCache = /* @__PURE__ */ Object.create(null));
      }
      function getChildPath(path2, name2) {
        var cache = getChildCache(path2);
        var actualChildValue = path2.getValueProperty(name2);
        var childPath = cache[name2];
        if (!hasOwn.call(cache, name2) || // Ensure consistency between cache and reality.
        childPath.value !== actualChildValue) {
          childPath = cache[name2] = new path2.constructor(actualChildValue, path2, name2);
        }
        return childPath;
      }
      Pp.getValueProperty = function getValueProperty(name2) {
        return this.value[name2];
      };
      Pp.get = function get2() {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          names[_i] = arguments[_i];
        }
        var path2 = this;
        var count = names.length;
        for (var i2 = 0; i2 < count; ++i2) {
          path2 = getChildPath(path2, names[i2]);
        }
        return path2;
      };
      Pp.each = function each(callback, context2) {
        var childPaths = [];
        var len = this.value.length;
        var i2 = 0;
        for (var i2 = 0; i2 < len; ++i2) {
          if (hasOwn.call(this.value, i2)) {
            childPaths[i2] = this.get(i2);
          }
        }
        context2 = context2 || this;
        for (i2 = 0; i2 < len; ++i2) {
          if (hasOwn.call(childPaths, i2)) {
            callback.call(context2, childPaths[i2]);
          }
        }
      };
      Pp.map = function map2(callback, context2) {
        var result = [];
        this.each(function(childPath) {
          result.push(callback.call(this, childPath));
        }, context2);
        return result;
      };
      Pp.filter = function filter2(callback, context2) {
        var result = [];
        this.each(function(childPath) {
          if (callback.call(this, childPath)) {
            result.push(childPath);
          }
        }, context2);
        return result;
      };
      function emptyMoves() {
      }
      function getMoves(path2, offset, start, end) {
        isArray4.assert(path2.value);
        if (offset === 0) {
          return emptyMoves;
        }
        var length = path2.value.length;
        if (length < 1) {
          return emptyMoves;
        }
        var argc = arguments.length;
        if (argc === 2) {
          start = 0;
          end = length;
        } else if (argc === 3) {
          start = Math.max(start, 0);
          end = length;
        } else {
          start = Math.max(start, 0);
          end = Math.min(end, length);
        }
        isNumber2.assert(start);
        isNumber2.assert(end);
        var moves = /* @__PURE__ */ Object.create(null);
        var cache = getChildCache(path2);
        for (var i2 = start; i2 < end; ++i2) {
          if (hasOwn.call(path2.value, i2)) {
            var childPath = path2.get(i2);
            if (childPath.name !== i2) {
              throw new Error("");
            }
            var newIndex = i2 + offset;
            childPath.name = newIndex;
            moves[newIndex] = childPath;
            delete cache[i2];
          }
        }
        delete cache.length;
        return function() {
          for (var newIndex2 in moves) {
            var childPath2 = moves[newIndex2];
            if (childPath2.name !== +newIndex2) {
              throw new Error("");
            }
            cache[newIndex2] = childPath2;
            path2.value[newIndex2] = childPath2.value;
          }
        };
      }
      Pp.shift = function shift() {
        var move2 = getMoves(this, -1);
        var result = this.value.shift();
        move2();
        return result;
      };
      Pp.unshift = function unshift2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var move2 = getMoves(this, args.length);
        var result = this.value.unshift.apply(this.value, args);
        move2();
        return result;
      };
      Pp.push = function push2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        isArray4.assert(this.value);
        delete getChildCache(this).length;
        return this.value.push.apply(this.value, args);
      };
      Pp.pop = function pop() {
        isArray4.assert(this.value);
        var cache = getChildCache(this);
        delete cache[this.value.length - 1];
        delete cache.length;
        return this.value.pop();
      };
      Pp.insertAt = function insertAt(index2) {
        var argc = arguments.length;
        var move2 = getMoves(this, argc - 1, index2);
        if (move2 === emptyMoves && argc <= 1) {
          return this;
        }
        index2 = Math.max(index2, 0);
        for (var i2 = 1; i2 < argc; ++i2) {
          this.value[index2 + i2 - 1] = arguments[i2];
        }
        move2();
        return this;
      };
      Pp.insertBefore = function insertBefore() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var pp = this.parentPath;
        var argc = args.length;
        var insertAtArgs = [this.name];
        for (var i2 = 0; i2 < argc; ++i2) {
          insertAtArgs.push(args[i2]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      Pp.insertAfter = function insertAfter() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var pp = this.parentPath;
        var argc = args.length;
        var insertAtArgs = [this.name + 1];
        for (var i2 = 0; i2 < argc; ++i2) {
          insertAtArgs.push(args[i2]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      function repairRelationshipWithParent(path2) {
        if (!(path2 instanceof Path)) {
          throw new Error("");
        }
        var pp = path2.parentPath;
        if (!pp) {
          return path2;
        }
        var parentValue = pp.value;
        var parentCache = getChildCache(pp);
        if (parentValue[path2.name] === path2.value) {
          parentCache[path2.name] = path2;
        } else if (isArray4.check(parentValue)) {
          var i2 = parentValue.indexOf(path2.value);
          if (i2 >= 0) {
            parentCache[path2.name = i2] = path2;
          }
        } else {
          parentValue[path2.name] = path2.value;
          parentCache[path2.name] = path2;
        }
        if (parentValue[path2.name] !== path2.value) {
          throw new Error("");
        }
        if (path2.parentPath.get(path2.name) !== path2) {
          throw new Error("");
        }
        return path2;
      }
      Pp.replace = function replace(replacement) {
        var results = [];
        var parentValue = this.parentPath.value;
        var parentCache = getChildCache(this.parentPath);
        var count = arguments.length;
        repairRelationshipWithParent(this);
        if (isArray4.check(parentValue)) {
          var originalLength = parentValue.length;
          var move2 = getMoves(this.parentPath, count - 1, this.name + 1);
          var spliceArgs = [this.name, 1];
          for (var i2 = 0; i2 < count; ++i2) {
            spliceArgs.push(arguments[i2]);
          }
          var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
          if (splicedOut[0] !== this.value) {
            throw new Error("");
          }
          if (parentValue.length !== originalLength - 1 + count) {
            throw new Error("");
          }
          move2();
          if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;
          } else {
            if (parentValue[this.name] !== replacement) {
              throw new Error("");
            }
            if (this.value !== replacement) {
              this.value = replacement;
              this.__childCache = null;
            }
            for (i2 = 0; i2 < count; ++i2) {
              results.push(this.parentPath.get(this.name + i2));
            }
            if (results[0] !== this) {
              throw new Error("");
            }
          }
        } else if (count === 1) {
          if (this.value !== replacement) {
            this.__childCache = null;
          }
          this.value = parentValue[this.name] = replacement;
          results.push(this);
        } else if (count === 0) {
          delete parentValue[this.name];
          delete this.value;
          this.__childCache = null;
        } else {
          throw new Error("Could not replace path");
        }
        return results;
      };
      return Path;
    }
    exports2.default = pathPlugin;
    module2.exports = exports2["default"];
  })(path$1, path$1.exports);
  return path$1.exports;
}
var scope = { exports: {} };
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope)
    return scope.exports;
  hasRequiredScope = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var hasOwn = Object.prototype.hasOwnProperty;
    function scopePlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var namedTypes2 = types2.namedTypes;
      var Node2 = namedTypes2.Node;
      var Expression = namedTypes2.Expression;
      var isArray4 = types2.builtInTypes.array;
      var b2 = types2.builders;
      var Scope2 = function Scope3(path2, parentScope) {
        if (!(this instanceof Scope3)) {
          throw new Error("Scope constructor cannot be invoked without 'new'");
        }
        ScopeType.assert(path2.value);
        var depth;
        if (parentScope) {
          if (!(parentScope instanceof Scope3)) {
            throw new Error("");
          }
          depth = parentScope.depth + 1;
        } else {
          parentScope = null;
          depth = 0;
        }
        Object.defineProperties(this, {
          path: { value: path2 },
          node: { value: path2.value },
          isGlobal: { value: !parentScope, enumerable: true },
          depth: { value: depth },
          parent: { value: parentScope },
          bindings: { value: {} },
          types: { value: {} }
        });
      };
      var scopeTypes = [
        // Program nodes introduce global scopes.
        namedTypes2.Program,
        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes2.Function,
        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes2.CatchClause
      ];
      var ScopeType = Type.or.apply(Type, scopeTypes);
      Scope2.isEstablishedBy = function(node2) {
        return ScopeType.check(node2);
      };
      var Sp = Scope2.prototype;
      Sp.didScan = false;
      Sp.declares = function(name2) {
        this.scan();
        return hasOwn.call(this.bindings, name2);
      };
      Sp.declaresType = function(name2) {
        this.scan();
        return hasOwn.call(this.types, name2);
      };
      Sp.declareTemporary = function(prefix) {
        if (prefix) {
          if (!/^[a-z$_]/i.test(prefix)) {
            throw new Error("");
          }
        } else {
          prefix = "t$";
        }
        prefix += this.depth.toString(36) + "$";
        this.scan();
        var index2 = 0;
        while (this.declares(prefix + index2)) {
          ++index2;
        }
        var name2 = prefix + index2;
        return this.bindings[name2] = types2.builders.identifier(name2);
      };
      Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());
        var bodyPath = this.path.get("body");
        if (namedTypes2.BlockStatement.check(bodyPath.value)) {
          bodyPath = bodyPath.get("body");
        }
        bodyPath.unshift(b2.variableDeclaration("var", [b2.variableDeclarator(identifier, init || null)]));
        return identifier;
      };
      Sp.scan = function(force) {
        if (force || !this.didScan) {
          for (var name2 in this.bindings) {
            delete this.bindings[name2];
          }
          scanScope(this.path, this.bindings, this.types);
          this.didScan = true;
        }
      };
      Sp.getBindings = function() {
        this.scan();
        return this.bindings;
      };
      Sp.getTypes = function() {
        this.scan();
        return this.types;
      };
      function scanScope(path2, bindings, scopeTypes2) {
        var node2 = path2.value;
        ScopeType.assert(node2);
        if (namedTypes2.CatchClause.check(node2)) {
          var param = path2.get("param");
          if (param.value) {
            addPattern(param, bindings);
          }
        } else {
          recursiveScanScope(path2, bindings, scopeTypes2);
        }
      }
      function recursiveScanScope(path2, bindings, scopeTypes2) {
        var node2 = path2.value;
        if (path2.parent && namedTypes2.FunctionExpression.check(path2.parent.node) && path2.parent.node.id) {
          addPattern(path2.parent.get("id"), bindings);
        }
        if (!node2)
          ;
        else if (isArray4.check(node2)) {
          path2.each(function(childPath) {
            recursiveScanChild(childPath, bindings, scopeTypes2);
          });
        } else if (namedTypes2.Function.check(node2)) {
          path2.get("params").each(function(paramPath) {
            addPattern(paramPath, bindings);
          });
          recursiveScanChild(path2.get("body"), bindings, scopeTypes2);
        } else if (namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node2) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node2) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node2) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node2)) {
          addTypePattern(path2.get("id"), scopeTypes2);
        } else if (namedTypes2.VariableDeclarator.check(node2)) {
          addPattern(path2.get("id"), bindings);
          recursiveScanChild(path2.get("init"), bindings, scopeTypes2);
        } else if (node2.type === "ImportSpecifier" || node2.type === "ImportNamespaceSpecifier" || node2.type === "ImportDefaultSpecifier") {
          addPattern(
            // Esprima used to use the .name field to refer to the local
            // binding identifier for ImportSpecifier nodes, but .id for
            // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
            // ESTree/Acorn/ESpree use .local for all three node types.
            path2.get(node2.local ? "local" : node2.name ? "name" : "id"),
            bindings
          );
        } else if (Node2.check(node2) && !Expression.check(node2)) {
          types2.eachField(node2, function(name2, child) {
            var childPath = path2.get(name2);
            if (!pathHasValue(childPath, child)) {
              throw new Error("");
            }
            recursiveScanChild(childPath, bindings, scopeTypes2);
          });
        }
      }
      function pathHasValue(path2, value) {
        if (path2.value === value) {
          return true;
        }
        if (Array.isArray(path2.value) && path2.value.length === 0 && Array.isArray(value) && value.length === 0) {
          return true;
        }
        return false;
      }
      function recursiveScanChild(path2, bindings, scopeTypes2) {
        var node2 = path2.value;
        if (!node2 || Expression.check(node2))
          ;
        else if (namedTypes2.FunctionDeclaration.check(node2) && node2.id !== null) {
          addPattern(path2.get("id"), bindings);
        } else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node2)) {
          addPattern(path2.get("id"), bindings);
        } else if (ScopeType.check(node2)) {
          if (namedTypes2.CatchClause.check(node2) && // TODO Broaden this to accept any pattern.
          namedTypes2.Identifier.check(node2.param)) {
            var catchParamName = node2.param.name;
            var hadBinding = hasOwn.call(bindings, catchParamName);
            recursiveScanScope(path2.get("body"), bindings, scopeTypes2);
            if (!hadBinding) {
              delete bindings[catchParamName];
            }
          }
        } else {
          recursiveScanScope(path2, bindings, scopeTypes2);
        }
      }
      function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern);
        if (namedTypes2.Identifier.check(pattern)) {
          if (hasOwn.call(bindings, pattern.name)) {
            bindings[pattern.name].push(patternPath);
          } else {
            bindings[pattern.name] = [patternPath];
          }
        } else if (namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern)) {
          addPattern(patternPath.get("left"), bindings);
        } else if (namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern)) {
          patternPath.get("properties").each(function(propertyPath) {
            var property = propertyPath.value;
            if (namedTypes2.Pattern.check(property)) {
              addPattern(propertyPath, bindings);
            } else if (namedTypes2.Property.check(property)) {
              addPattern(propertyPath.get("value"), bindings);
            } else if (namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property)) {
              addPattern(propertyPath.get("argument"), bindings);
            }
          });
        } else if (namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern)) {
          patternPath.get("elements").each(function(elementPath) {
            var element = elementPath.value;
            if (namedTypes2.Pattern.check(element)) {
              addPattern(elementPath, bindings);
            } else if (namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element)) {
              addPattern(elementPath.get("argument"), bindings);
            }
          });
        } else if (namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern)) {
          addPattern(patternPath.get("pattern"), bindings);
        } else if (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) {
          addPattern(patternPath.get("argument"), bindings);
        }
      }
      function addTypePattern(patternPath, types3) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern);
        if (namedTypes2.Identifier.check(pattern)) {
          if (hasOwn.call(types3, pattern.name)) {
            types3[pattern.name].push(patternPath);
          } else {
            types3[pattern.name] = [patternPath];
          }
        }
      }
      Sp.lookup = function(name2) {
        for (var scope2 = this; scope2; scope2 = scope2.parent)
          if (scope2.declares(name2))
            break;
        return scope2;
      };
      Sp.lookupType = function(name2) {
        for (var scope2 = this; scope2; scope2 = scope2.parent)
          if (scope2.declaresType(name2))
            break;
        return scope2;
      };
      Sp.getGlobalScope = function() {
        var scope2 = this;
        while (!scope2.isGlobal)
          scope2 = scope2.parent;
        return scope2;
      };
      return Scope2;
    }
    exports2.default = scopePlugin;
    module2.exports = exports2["default"];
  })(scope, scope.exports);
  return scope.exports;
}
var hasRequiredNodePath;
function requireNodePath() {
  if (hasRequiredNodePath)
    return nodePath.exports;
  hasRequiredNodePath = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var path_12 = tslib_1.__importDefault(requirePath());
    var scope_1 = tslib_1.__importDefault(requireScope());
    function nodePathPlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var n2 = types2.namedTypes;
      var b2 = types2.builders;
      var isNumber2 = types2.builtInTypes.number;
      var isArray4 = types2.builtInTypes.array;
      var Path = fork2.use(path_12.default);
      var Scope2 = fork2.use(scope_1.default);
      var NodePath = function NodePath2(value, parentPath, name2) {
        if (!(this instanceof NodePath2)) {
          throw new Error("NodePath constructor cannot be invoked without 'new'");
        }
        Path.call(this, value, parentPath, name2);
      };
      var NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
          value: NodePath,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(NPp, {
        node: {
          get: function() {
            Object.defineProperty(this, "node", {
              configurable: true,
              value: this._computeNode()
            });
            return this.node;
          }
        },
        parent: {
          get: function() {
            Object.defineProperty(this, "parent", {
              configurable: true,
              value: this._computeParent()
            });
            return this.parent;
          }
        },
        scope: {
          get: function() {
            Object.defineProperty(this, "scope", {
              configurable: true,
              value: this._computeScope()
            });
            return this.scope;
          }
        }
      });
      NPp.replace = function() {
        delete this.node;
        delete this.parent;
        delete this.scope;
        return Path.prototype.replace.apply(this, arguments);
      };
      NPp.prune = function() {
        var remainingNodePath = this.parent;
        this.replace();
        return cleanUpNodesAfterPrune(remainingNodePath);
      };
      NPp._computeNode = function() {
        var value = this.value;
        if (n2.Node.check(value)) {
          return value;
        }
        var pp = this.parentPath;
        return pp && pp.node || null;
      };
      NPp._computeParent = function() {
        var value = this.value;
        var pp = this.parentPath;
        if (!n2.Node.check(value)) {
          while (pp && !n2.Node.check(pp.value)) {
            pp = pp.parentPath;
          }
          if (pp) {
            pp = pp.parentPath;
          }
        }
        while (pp && !n2.Node.check(pp.value)) {
          pp = pp.parentPath;
        }
        return pp || null;
      };
      NPp._computeScope = function() {
        var value = this.value;
        var pp = this.parentPath;
        var scope2 = pp && pp.scope;
        if (n2.Node.check(value) && Scope2.isEstablishedBy(value)) {
          scope2 = new Scope2(this, scope2);
        }
        return scope2 || null;
      };
      NPp.getValueProperty = function(name2) {
        return types2.getFieldValue(this.value, name2);
      };
      NPp.needsParens = function(assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp) {
          return false;
        }
        var node2 = this.value;
        if (!n2.Expression.check(node2)) {
          return false;
        }
        if (node2.type === "Identifier") {
          return false;
        }
        while (!n2.Node.check(pp.value)) {
          pp = pp.parentPath;
          if (!pp) {
            return false;
          }
        }
        var parent = pp.value;
        switch (node2.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return parent.type === "MemberExpression" && this.name === "object" && parent.object === node2;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (parent.type) {
              case "CallExpression":
                return this.name === "callee" && parent.callee === node2;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return true;
              case "MemberExpression":
                return this.name === "object" && parent.object === node2;
              case "BinaryExpression":
              case "LogicalExpression": {
                var n_1 = node2;
                var po = parent.operator;
                var pp_1 = PRECEDENCE[po];
                var no = n_1.operator;
                var np = PRECEDENCE[no];
                if (pp_1 > np) {
                  return true;
                }
                if (pp_1 === np && this.name === "right") {
                  if (parent.right !== n_1) {
                    throw new Error("Nodes must be equal");
                  }
                  return true;
                }
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (parent.type) {
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return this.name !== "expression";
              default:
                return true;
            }
          case "YieldExpression":
            switch (parent.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return true;
              default:
                return false;
            }
          case "Literal":
            return parent.type === "MemberExpression" && isNumber2.check(node2.value) && this.name === "object" && parent.object === node2;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (parent.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return true;
              case "CallExpression":
                return this.name === "callee" && parent.callee === node2;
              case "ConditionalExpression":
                return this.name === "test" && parent.test === node2;
              case "MemberExpression":
                return this.name === "object" && parent.object === node2;
              default:
                return false;
            }
          default:
            if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node2) {
              return containsCallExpression(node2);
            }
        }
        if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
          return true;
        return false;
      };
      function isBinary(node2) {
        return n2.BinaryExpression.check(node2) || n2.LogicalExpression.check(node2);
      }
      var PRECEDENCE = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
      ].forEach(function(tier, i2) {
        tier.forEach(function(op) {
          PRECEDENCE[op] = i2;
        });
      });
      function containsCallExpression(node2) {
        if (n2.CallExpression.check(node2)) {
          return true;
        }
        if (isArray4.check(node2)) {
          return node2.some(containsCallExpression);
        }
        if (n2.Node.check(node2)) {
          return types2.someField(node2, function(_name4, child) {
            return containsCallExpression(child);
          });
        }
        return false;
      }
      NPp.canBeFirstInStatement = function() {
        var node2 = this.node;
        return !n2.FunctionExpression.check(node2) && !n2.ObjectExpression.check(node2);
      };
      NPp.firstInStatement = function() {
        return firstInStatement(this);
      };
      function firstInStatement(path2) {
        for (var node2, parent; path2.parent; path2 = path2.parent) {
          node2 = path2.node;
          parent = path2.parent.node;
          if (n2.BlockStatement.check(parent) && path2.parent.name === "body" && path2.name === 0) {
            if (parent.body[0] !== node2) {
              throw new Error("Nodes must be equal");
            }
            return true;
          }
          if (n2.ExpressionStatement.check(parent) && path2.name === "expression") {
            if (parent.expression !== node2) {
              throw new Error("Nodes must be equal");
            }
            return true;
          }
          if (n2.SequenceExpression.check(parent) && path2.parent.name === "expressions" && path2.name === 0) {
            if (parent.expressions[0] !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n2.CallExpression.check(parent) && path2.name === "callee") {
            if (parent.callee !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n2.MemberExpression.check(parent) && path2.name === "object") {
            if (parent.object !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n2.ConditionalExpression.check(parent) && path2.name === "test") {
            if (parent.test !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (isBinary(parent) && path2.name === "left") {
            if (parent.left !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n2.UnaryExpression.check(parent) && !parent.prefix && path2.name === "argument") {
            if (parent.argument !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          return false;
        }
        return true;
      }
      function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n2.VariableDeclaration.check(remainingNodePath.node)) {
          var declarations = remainingNodePath.get("declarations").value;
          if (!declarations || declarations.length === 0) {
            return remainingNodePath.prune();
          }
        } else if (n2.ExpressionStatement.check(remainingNodePath.node)) {
          if (!remainingNodePath.get("expression").value) {
            return remainingNodePath.prune();
          }
        } else if (n2.IfStatement.check(remainingNodePath.node)) {
          cleanUpIfStatementAfterPrune(remainingNodePath);
        }
        return remainingNodePath;
      }
      function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get("test").value;
        var alternate = ifStatement.get("alternate").value;
        var consequent = ifStatement.get("consequent").value;
        if (!consequent && !alternate) {
          var testExpressionStatement = b2.expressionStatement(testExpression);
          ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
          var negatedTestExpression = b2.unaryExpression("!", testExpression, true);
          if (n2.UnaryExpression.check(testExpression) && testExpression.operator === "!") {
            negatedTestExpression = testExpression.argument;
          }
          ifStatement.get("test").replace(negatedTestExpression);
          ifStatement.get("consequent").replace(alternate);
          ifStatement.get("alternate").replace();
        }
      }
      return NodePath;
    }
    exports2.default = nodePathPlugin;
    module2.exports = exports2["default"];
  })(nodePath, nodePath.exports);
  return nodePath.exports;
}
var hasRequiredPathVisitor;
function requirePathVisitor() {
  if (hasRequiredPathVisitor)
    return pathVisitor.exports;
  hasRequiredPathVisitor = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var node_path_1 = tslib_1.__importDefault(requireNodePath());
    var hasOwn = Object.prototype.hasOwnProperty;
    function pathVisitorPlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var NodePath = fork2.use(node_path_1.default);
      var isArray4 = types2.builtInTypes.array;
      var isObject = types2.builtInTypes.object;
      var isFunction2 = types2.builtInTypes.function;
      var undefined$1;
      var PathVisitor = function PathVisitor2() {
        if (!(this instanceof PathVisitor2)) {
          throw new Error("PathVisitor constructor cannot be invoked without 'new'");
        }
        this._reusableContextStack = [];
        this._methodNameTable = computeMethodNameTable(this);
        this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line");
        this.Context = makeContextConstructor(this);
        this._visiting = false;
        this._changeReported = false;
      };
      function computeMethodNameTable(visitor) {
        var typeNames = /* @__PURE__ */ Object.create(null);
        for (var methodName in visitor) {
          if (/^visit[A-Z]/.test(methodName)) {
            typeNames[methodName.slice("visit".length)] = true;
          }
        }
        var supertypeTable = types2.computeSupertypeLookupTable(typeNames);
        var methodNameTable = /* @__PURE__ */ Object.create(null);
        var typeNameKeys = Object.keys(supertypeTable);
        var typeNameCount = typeNameKeys.length;
        for (var i2 = 0; i2 < typeNameCount; ++i2) {
          var typeName = typeNameKeys[i2];
          methodName = "visit" + supertypeTable[typeName];
          if (isFunction2.check(visitor[methodName])) {
            methodNameTable[typeName] = methodName;
          }
        }
        return methodNameTable;
      }
      PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
        if (methods instanceof PathVisitor) {
          return methods;
        }
        if (!isObject.check(methods)) {
          return new PathVisitor();
        }
        var Visitor = function Visitor2() {
          if (!(this instanceof Visitor2)) {
            throw new Error("Visitor constructor cannot be invoked without 'new'");
          }
          PathVisitor.call(this);
        };
        var Vp = Visitor.prototype = Object.create(PVp);
        Vp.constructor = Visitor;
        extend(Vp, methods);
        extend(Visitor, PathVisitor);
        isFunction2.assert(Visitor.fromMethodsObject);
        isFunction2.assert(Visitor.visit);
        return new Visitor();
      };
      function extend(target, source2) {
        for (var property in source2) {
          if (hasOwn.call(source2, property)) {
            target[property] = source2[property];
          }
        }
        return target;
      }
      PathVisitor.visit = function visit(node2, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node2);
      };
      var PVp = PathVisitor.prototype;
      PVp.visit = function() {
        if (this._visiting) {
          throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
        }
        this._visiting = true;
        this._changeReported = false;
        this._abortRequested = false;
        var argc = arguments.length;
        var args = new Array(argc);
        for (var i2 = 0; i2 < argc; ++i2) {
          args[i2] = arguments[i2];
        }
        if (!(args[0] instanceof NodePath)) {
          args[0] = new NodePath({ root: args[0] }).get("root");
        }
        this.reset.apply(this, args);
        var didNotThrow;
        try {
          var root = this.visitWithoutReset(args[0]);
          didNotThrow = true;
        } finally {
          this._visiting = false;
          if (!didNotThrow && this._abortRequested) {
            return args[0].value;
          }
        }
        return root;
      };
      PVp.AbortRequest = function AbortRequest() {
      };
      PVp.abort = function() {
        var visitor = this;
        visitor._abortRequested = true;
        var request = new visitor.AbortRequest();
        request.cancel = function() {
          visitor._abortRequested = false;
        };
        throw request;
      };
      PVp.reset = function(_path2) {
      };
      PVp.visitWithoutReset = function(path2) {
        if (this instanceof this.Context) {
          return this.visitor.visitWithoutReset(path2);
        }
        if (!(path2 instanceof NodePath)) {
          throw new Error("");
        }
        var value = path2.value;
        var methodName = value && typeof value === "object" && typeof value.type === "string" && this._methodNameTable[value.type];
        if (methodName) {
          var context2 = this.acquireContext(path2);
          try {
            return context2.invokeVisitorMethod(methodName);
          } finally {
            this.releaseContext(context2);
          }
        } else {
          return visitChildren(path2, this);
        }
      };
      function visitChildren(path2, visitor) {
        if (!(path2 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(visitor instanceof PathVisitor)) {
          throw new Error("");
        }
        var value = path2.value;
        if (isArray4.check(value)) {
          path2.each(visitor.visitWithoutReset, visitor);
        } else if (!isObject.check(value))
          ;
        else {
          var childNames = types2.getFieldNames(value);
          if (visitor._shouldVisitComments && value.comments && childNames.indexOf("comments") < 0) {
            childNames.push("comments");
          }
          var childCount = childNames.length;
          var childPaths = [];
          for (var i2 = 0; i2 < childCount; ++i2) {
            var childName = childNames[i2];
            if (!hasOwn.call(value, childName)) {
              value[childName] = types2.getFieldValue(value, childName);
            }
            childPaths.push(path2.get(childName));
          }
          for (var i2 = 0; i2 < childCount; ++i2) {
            visitor.visitWithoutReset(childPaths[i2]);
          }
        }
        return path2.value;
      }
      PVp.acquireContext = function(path2) {
        if (this._reusableContextStack.length === 0) {
          return new this.Context(path2);
        }
        return this._reusableContextStack.pop().reset(path2);
      };
      PVp.releaseContext = function(context2) {
        if (!(context2 instanceof this.Context)) {
          throw new Error("");
        }
        this._reusableContextStack.push(context2);
        context2.currentPath = null;
      };
      PVp.reportChanged = function() {
        this._changeReported = true;
      };
      PVp.wasChangeReported = function() {
        return this._changeReported;
      };
      function makeContextConstructor(visitor) {
        function Context(path2) {
          if (!(this instanceof Context)) {
            throw new Error("");
          }
          if (!(this instanceof PathVisitor)) {
            throw new Error("");
          }
          if (!(path2 instanceof NodePath)) {
            throw new Error("");
          }
          Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: false,
            enumerable: true,
            configurable: false
          });
          this.currentPath = path2;
          this.needToCallTraverse = true;
          Object.seal(this);
        }
        if (!(visitor instanceof PathVisitor)) {
          throw new Error("");
        }
        var Cp = Context.prototype = Object.create(visitor);
        Cp.constructor = Context;
        extend(Cp, sharedContextProtoMethods);
        return Context;
      }
      var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);
      sharedContextProtoMethods.reset = function reset(path2) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path2 instanceof NodePath)) {
          throw new Error("");
        }
        this.currentPath = path2;
        this.needToCallTraverse = true;
        return this;
      };
      sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        var result = this.visitor[methodName].call(this, this.currentPath);
        if (result === false) {
          this.needToCallTraverse = false;
        } else if (result !== undefined$1) {
          this.currentPath = this.currentPath.replace(result)[0];
          if (this.needToCallTraverse) {
            this.traverse(this.currentPath);
          }
        }
        if (this.needToCallTraverse !== false) {
          throw new Error("Must either call this.traverse or return false in " + methodName);
        }
        var path2 = this.currentPath;
        return path2 && path2.value;
      };
      sharedContextProtoMethods.traverse = function traverse(path2, newVisitor) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path2 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        this.needToCallTraverse = false;
        return visitChildren(path2, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
      };
      sharedContextProtoMethods.visit = function visit(path2, newVisitor) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path2 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        this.needToCallTraverse = false;
        return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path2);
      };
      sharedContextProtoMethods.reportChanged = function reportChanged() {
        this.visitor.reportChanged();
      };
      sharedContextProtoMethods.abort = function abort() {
        this.needToCallTraverse = false;
        this.visitor.abort();
      };
      return PathVisitor;
    }
    exports2.default = pathVisitorPlugin;
    module2.exports = exports2["default"];
  })(pathVisitor, pathVisitor.exports);
  return pathVisitor.exports;
}
var equiv = { exports: {} };
var hasRequiredEquiv;
function requireEquiv() {
  if (hasRequiredEquiv)
    return equiv.exports;
  hasRequiredEquiv = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var getFieldNames = types2.getFieldNames;
      var getFieldValue = types2.getFieldValue;
      var isArray4 = types2.builtInTypes.array;
      var isObject = types2.builtInTypes.object;
      var isDate2 = types2.builtInTypes.Date;
      var isRegExp2 = types2.builtInTypes.RegExp;
      var hasOwn = Object.prototype.hasOwnProperty;
      function astNodesAreEquivalent(a2, b2, problemPath) {
        if (isArray4.check(problemPath)) {
          problemPath.length = 0;
        } else {
          problemPath = null;
        }
        return areEquivalent(a2, b2, problemPath);
      }
      astNodesAreEquivalent.assert = function(a2, b2) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a2, b2, problemPath)) {
          if (problemPath.length === 0) {
            if (a2 !== b2) {
              throw new Error("Nodes must be equal");
            }
          } else {
            throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
          }
        }
      };
      function subscriptForProperty(property) {
        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
          return "." + property;
        }
        return "[" + JSON.stringify(property) + "]";
      }
      function areEquivalent(a2, b2, problemPath) {
        if (a2 === b2) {
          return true;
        }
        if (isArray4.check(a2)) {
          return arraysAreEquivalent(a2, b2, problemPath);
        }
        if (isObject.check(a2)) {
          return objectsAreEquivalent(a2, b2, problemPath);
        }
        if (isDate2.check(a2)) {
          return isDate2.check(b2) && +a2 === +b2;
        }
        if (isRegExp2.check(a2)) {
          return isRegExp2.check(b2) && (a2.source === b2.source && a2.global === b2.global && a2.multiline === b2.multiline && a2.ignoreCase === b2.ignoreCase);
        }
        return a2 == b2;
      }
      function arraysAreEquivalent(a2, b2, problemPath) {
        isArray4.assert(a2);
        var aLength = a2.length;
        if (!isArray4.check(b2) || b2.length !== aLength) {
          if (problemPath) {
            problemPath.push("length");
          }
          return false;
        }
        for (var i2 = 0; i2 < aLength; ++i2) {
          if (problemPath) {
            problemPath.push(i2);
          }
          if (i2 in a2 !== i2 in b2) {
            return false;
          }
          if (!areEquivalent(a2[i2], b2[i2], problemPath)) {
            return false;
          }
          if (problemPath) {
            var problemPathTail = problemPath.pop();
            if (problemPathTail !== i2) {
              throw new Error("" + problemPathTail);
            }
          }
        }
        return true;
      }
      function objectsAreEquivalent(a2, b2, problemPath) {
        isObject.assert(a2);
        if (!isObject.check(b2)) {
          return false;
        }
        if (a2.type !== b2.type) {
          if (problemPath) {
            problemPath.push("type");
          }
          return false;
        }
        var aNames = getFieldNames(a2);
        var aNameCount = aNames.length;
        var bNames = getFieldNames(b2);
        var bNameCount = bNames.length;
        if (aNameCount === bNameCount) {
          for (var i2 = 0; i2 < aNameCount; ++i2) {
            var name2 = aNames[i2];
            var aChild = getFieldValue(a2, name2);
            var bChild = getFieldValue(b2, name2);
            if (problemPath) {
              problemPath.push(name2);
            }
            if (!areEquivalent(aChild, bChild, problemPath)) {
              return false;
            }
            if (problemPath) {
              var problemPathTail = problemPath.pop();
              if (problemPathTail !== name2) {
                throw new Error("" + problemPathTail);
              }
            }
          }
          return true;
        }
        if (!problemPath) {
          return false;
        }
        var seenNames = /* @__PURE__ */ Object.create(null);
        for (i2 = 0; i2 < aNameCount; ++i2) {
          seenNames[aNames[i2]] = true;
        }
        for (i2 = 0; i2 < bNameCount; ++i2) {
          name2 = bNames[i2];
          if (!hasOwn.call(seenNames, name2)) {
            problemPath.push(name2);
            return false;
          }
          delete seenNames[name2];
        }
        for (name2 in seenNames) {
          problemPath.push(name2);
          break;
        }
        return false;
      }
      return astNodesAreEquivalent;
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(equiv, equiv.exports);
  return equiv.exports;
}
var hasRequiredFork;
function requireFork() {
  if (hasRequiredFork)
    return fork.exports;
  hasRequiredFork = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var path_visitor_1 = tslib_1.__importDefault(requirePathVisitor());
    var equiv_1 = tslib_1.__importDefault(requireEquiv());
    var path_12 = tslib_1.__importDefault(requirePath());
    var node_path_1 = tslib_1.__importDefault(requireNodePath());
    function default_1(defs) {
      var fork2 = createFork();
      var types2 = fork2.use(types_1.default);
      defs.forEach(fork2.use);
      types2.finalize();
      var PathVisitor = fork2.use(path_visitor_1.default);
      return {
        Type: types2.Type,
        builtInTypes: types2.builtInTypes,
        namedTypes: types2.namedTypes,
        builders: types2.builders,
        defineMethod: types2.defineMethod,
        getFieldNames: types2.getFieldNames,
        getFieldValue: types2.getFieldValue,
        eachField: types2.eachField,
        someField: types2.someField,
        getSupertypeNames: types2.getSupertypeNames,
        getBuilderName: types2.getBuilderName,
        astNodesAreEquivalent: fork2.use(equiv_1.default),
        finalize: types2.finalize,
        Path: fork2.use(path_12.default),
        NodePath: fork2.use(node_path_1.default),
        PathVisitor,
        use: fork2.use,
        visit: PathVisitor.visit
      };
    }
    exports2.default = default_1;
    function createFork() {
      var used = [];
      var usedResult = [];
      function use(plugin) {
        var idx = used.indexOf(plugin);
        if (idx === -1) {
          idx = used.length;
          used.push(plugin);
          usedResult[idx] = plugin(fork2);
        }
        return usedResult[idx];
      }
      var fork2 = { use };
      return fork2;
    }
    module2.exports = exports2["default"];
  })(fork, fork.exports);
  return fork.exports;
}
var core = { exports: {} };
var shared = { exports: {} };
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared)
    return shared.exports;
  hasRequiredShared = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var builtin = types2.builtInTypes;
      var isNumber2 = builtin.number;
      function geq(than) {
        return Type.from(function(value) {
          return isNumber2.check(value) && value >= than;
        }, isNumber2 + " >= " + than);
      }
      var defaults = {
        // Functions were used because (among other reasons) that's the most
        // elegant way to allow for the emptyArray one always to give a new
        // array instance.
        "null": function() {
          return null;
        },
        "emptyArray": function() {
          return [];
        },
        "false": function() {
          return false;
        },
        "true": function() {
          return true;
        },
        "undefined": function() {
        },
        "use strict": function() {
          return "use strict";
        }
      };
      var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
      var isPrimitive = Type.from(function(value) {
        if (value === null)
          return true;
        var type = typeof value;
        if (type === "object" || type === "function") {
          return false;
        }
        return true;
      }, naiveIsPrimitive.toString());
      return {
        geq,
        defaults,
        isPrimitive
      };
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(shared, shared.exports);
  return shared.exports;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core.exports;
  hasRequiredCore = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var def = Type.def;
      var or = Type.or;
      var shared2 = fork2.use(shared_1.default);
      var defaults = shared2.defaults;
      var geq = shared2.geq;
      def("Printable").field("loc", or(def("SourceLocation"), null), defaults["null"], true);
      def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults["null"], true);
      def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults["null"]);
      def("Position").field("line", geq(1)).field("column", geq(0));
      def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults["null"]);
      def("Program").bases("Node").build("body").field("body", [def("Statement")]);
      def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]);
      def("Statement").bases("Node");
      def("EmptyStatement").bases("Statement").build();
      def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
      def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
      def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults["null"]);
      def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
      def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
      def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults["null"]);
      def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
      def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults["false"]);
      def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null));
      def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
      def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
      }).field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
      }, true).field("guardedHandlers", [def("CatchClause")], defaults.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults["null"]);
      def("CatchClause").bases("Node").build("param", "guard", "body").field("param", or(def("Pattern"), null), defaults["null"]).field("guard", or(def("Expression"), null), defaults["null"]).field("body", def("BlockStatement"));
      def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
      def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
      def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement"));
      def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
      def("DebuggerStatement").bases("Statement").build();
      def("Declaration").bases("Statement");
      def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
      def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
      def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
      def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults["null"]);
      def("Expression").bases("Node");
      def("ThisExpression").bases("Expression").build();
      def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]);
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
      def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression"));
      def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
      var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
      def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults["true"]);
      var BinaryOperator = or(
        "==",
        "!=",
        "===",
        "!==",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "**",
        "&",
        // TODO Missing from the Parser API.
        "|",
        "^",
        "in",
        "instanceof"
      );
      def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
      var AssignmentOperator = or("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&=");
      def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
      var UpdateOperator = or("++", "--");
      def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
      var LogicalOperator = or("||", "&&");
      def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
      def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
      def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
      def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
      def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
        var type = this.property.type;
        if (type === "Literal" || type === "MemberExpression" || type === "BinaryExpression") {
          return true;
        }
        return false;
      });
      def("Pattern").bases("Node");
      def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]);
      def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults["false"]);
      def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp)).field("regex", or({
        pattern: String,
        flags: String
      }, null), function() {
        if (this.value instanceof RegExp) {
          var flags = "";
          if (this.value.ignoreCase)
            flags += "i";
          if (this.value.multiline)
            flags += "m";
          if (this.value.global)
            flags += "g";
          return {
            pattern: this.value.source,
            flags
          };
        }
        return null;
      });
      def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults["true"]).field("trailing", Boolean, defaults["false"]);
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(core, core.exports);
  return core.exports;
}
var es6 = { exports: {} };
var hasRequiredEs6;
function requireEs6() {
  if (hasRequiredEs6)
    return es6.exports;
  hasRequiredEs6 = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var core_1 = tslib_1.__importDefault(requireCore());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(core_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults = fork2.use(shared_1.default).defaults;
      def("Function").field("generator", Boolean, defaults["false"]).field("expression", Boolean, defaults["false"]).field("defaults", [or(def("Expression"), null)], defaults.emptyArray).field("rest", or(def("Identifier"), null), defaults["null"]);
      def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field(
        "typeAnnotation",
        // for Babylon. Flow parser puts it on the identifier
        or(def("TypeAnnotation"), def("TSTypeAnnotation"), null),
        defaults["null"]
      );
      def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
      def("FunctionDeclaration").build("id", "params", "body", "generator", "expression");
      def("FunctionExpression").build("id", "params", "body", "generator", "expression");
      def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults["null"]).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", false, defaults["false"]);
      def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement"));
      def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults["false"]);
      def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
      def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
      def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
      def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults["false"]).field("shorthand", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]);
      def("ObjectProperty").field("shorthand", Boolean, defaults["false"]);
      def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults["false"]);
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]);
      def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]);
      def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults["false"]).field("static", Boolean, defaults["false"]);
      def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
      def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
      def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
      def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
      def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
      def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults["false"]);
      def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
      def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]);
      def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults["null"]).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults["null"]);
      def("Specifier").bases("Node");
      def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults["null"]).field("id", or(def("Identifier"), null), defaults["null"]).field("name", or(def("Identifier"), null), defaults["null"]);
      def("ImportSpecifier").bases("ModuleSpecifier").build("id", "name");
      def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("id");
      def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("id");
      def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults.emptyArray).field("source", def("Literal")).field("importKind", or("value", "type"), function() {
        return "value";
      });
      def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
      def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
      def("TemplateElement").bases("Node").build("value", "tail").field("value", { "cooked": String, "raw": String }).field("tail", Boolean);
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(es6, es6.exports);
  return es6.exports;
}
var es7 = { exports: {} };
var hasRequiredEs7;
function requireEs7() {
  if (hasRequiredEs7)
    return es7.exports;
  hasRequiredEs7 = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es6_1 = tslib_1.__importDefault(requireEs6());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es6_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults = fork2.use(shared_1.default).defaults;
      def("Function").field("async", Boolean, defaults["false"]);
      def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("ObjectExpression").field("properties", [or(def("Property"), def("SpreadProperty"), def("SpreadElement"))]);
      def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
      def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"))]);
      def("AwaitExpression").bases("Expression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults["false"]);
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(es7, es7.exports);
  return es7.exports;
}
var es2020 = { exports: {} };
var hasRequiredEs2020;
function requireEs2020() {
  if (hasRequiredEs2020)
    return es2020.exports;
  hasRequiredEs2020 = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      def("ImportExpression").bases("Expression").build("source").field("source", def("Expression"));
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(es2020, es2020.exports);
  return es2020.exports;
}
var jsx = { exports: {} };
var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx)
    return jsx.exports;
  hasRequiredJsx = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults = fork2.use(shared_1.default).defaults;
      def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(
        def("Literal"),
        // attr="value"
        def("JSXExpressionContainer"),
        // attr={value}
        null
        // attr= or just attr
      ), defaults["null"]);
      def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
      def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
      def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults.false);
      var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
      def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
      var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
      def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", def("Expression"));
      def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults["null"]).field("children", [or(
        def("JSXElement"),
        def("JSXExpressionContainer"),
        def("JSXFragment"),
        def("JSXText"),
        def("Literal")
        // TODO Esprima should return JSXText instead.
      )], defaults.emptyArray).field("name", JSXElementName, function() {
        return this.openingElement.name;
      }, true).field("selfClosing", Boolean, function() {
        return this.openingElement.selfClosing;
      }, true).field("attributes", JSXAttributes, function() {
        return this.openingElement.attributes;
      }, true);
      def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults.emptyArray).field("selfClosing", Boolean, defaults["false"]);
      def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
      def("JSXFragment").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningFragment")).field("closingElement", def("JSXClosingFragment")).field("children", [or(
        def("JSXElement"),
        def("JSXExpressionContainer"),
        def("JSXFragment"),
        def("JSXText"),
        def("Literal")
        // TODO Esprima should return JSXText instead.
      )], defaults.emptyArray);
      def("JSXOpeningFragment").bases("Node").build();
      def("JSXClosingFragment").bases("Node").build();
      def("JSXText").bases("Literal").build("value").field("value", String);
      def("JSXEmptyExpression").bases("Expression").build();
      def("JSXSpreadChild").bases("Expression").build("expression").field("expression", def("Expression"));
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(jsx, jsx.exports);
  return jsx.exports;
}
var flow = { exports: {} };
var typeAnnotations = { exports: {} };
var hasRequiredTypeAnnotations;
function requireTypeAnnotations() {
  if (hasRequiredTypeAnnotations)
    return typeAnnotations.exports;
  hasRequiredTypeAnnotations = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults = fork2.use(shared_1.default).defaults;
      var TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
      var TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
      def("Identifier").field("typeAnnotation", TypeAnnotation, defaults["null"]);
      def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults["null"]);
      def("Function").field("returnType", TypeAnnotation, defaults["null"]).field("typeParameters", TypeParamDecl, defaults["null"]);
      def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("static", Boolean, defaults["false"]).field("typeAnnotation", TypeAnnotation, defaults["null"]);
      [
        "ClassDeclaration",
        "ClassExpression"
      ].forEach(function(typeName) {
        def(typeName).field("typeParameters", TypeParamDecl, defaults["null"]).field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults["null"]).field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults.emptyArray);
      });
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(typeAnnotations, typeAnnotations.exports);
  return typeAnnotations.exports;
}
var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow)
    return flow.exports;
  hasRequiredFlow = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults = fork2.use(shared_1.default).defaults;
      def("Flow").bases("Node");
      def("FlowType").bases("Flow");
      def("AnyTypeAnnotation").bases("FlowType").build();
      def("EmptyTypeAnnotation").bases("FlowType").build();
      def("MixedTypeAnnotation").bases("FlowType").build();
      def("VoidTypeAnnotation").bases("FlowType").build();
      def("NumberTypeAnnotation").bases("FlowType").build();
      def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
      def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
      def("StringTypeAnnotation").bases("FlowType").build();
      def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
      def("BooleanTypeAnnotation").bases("FlowType").build();
      def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
      def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
      def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
      def("NullLiteralTypeAnnotation").bases("FlowType").build();
      def("NullTypeAnnotation").bases("FlowType").build();
      def("ThisTypeAnnotation").bases("FlowType").build();
      def("ExistsTypeAnnotation").bases("FlowType").build();
      def("ExistentialTypeParam").bases("FlowType").build();
      def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null));
      def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", def("Identifier")).field("typeAnnotation", def("FlowType")).field("optional", Boolean);
      def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType"));
      def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [
        or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))
      ]).field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults.emptyArray).field("inexact", or(Boolean, void 0), defaults["undefined"]).field("exact", Boolean, defaults["false"]).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults.emptyArray);
      def("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
      var LegacyVariance = or(def("Variance"), "plus", "minus", null);
      def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults["null"]);
      def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults["null"]);
      def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults["false"]);
      def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
      def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null));
      def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
      def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType"));
      def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType"));
      def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
      def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
      def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]);
      def("TypeParameter").bases("FlowType").build("name", "variance", "bound").field("name", String).field("variance", LegacyVariance, defaults["null"]).field("bound", or(def("TypeAnnotation"), null), defaults["null"]);
      def("ClassProperty").field("variance", LegacyVariance, defaults["null"]);
      def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults["null"]).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
      def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or([def("InterfaceExtends")], null), defaults["null"]);
      def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
      def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
      def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults["null"]);
      def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("FlowType"));
      def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", def("FlowType"));
      def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
      def("DeclareOpaqueType").bases("TypeAlias").build("id", "typeParameters", "supertype");
      def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
      def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
      def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier"));
      def("DeclareClass").bases("InterfaceDeclaration").build("id");
      def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
      def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation"));
      def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("FlowType"),
        // Implies default.
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
      def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def("Literal"), null), defaults["null"]);
      def("FlowPredicate").bases("Flow");
      def("InferredPredicate").bases("FlowPredicate").build();
      def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression"));
      def("CallExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults["null"]);
      def("NewExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults["null"]);
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(flow, flow.exports);
  return flow.exports;
}
var esprima = { exports: {} };
var hasRequiredEsprima;
function requireEsprima() {
  if (hasRequiredEsprima)
    return esprima.exports;
  hasRequiredEsprima = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var defaults = fork2.use(shared_1.default).defaults;
      var def = types2.Type.def;
      var or = types2.Type.or;
      def("VariableDeclaration").field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier")
        // Esprima deviation.
      )]);
      def("Property").field("value", or(
        def("Expression"),
        def("Pattern")
        // Esprima deviation.
      ));
      def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
      def("ObjectPattern").field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty")
        // Used by Esprima.
      )]);
      def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
      def("ExportBatchSpecifier").bases("Specifier").build();
      def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("Declaration"),
        def("Expression"),
        // Implies default.
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
      def("Block").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
      def("Line").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(esprima, esprima.exports);
  return esprima.exports;
}
var babel = { exports: {} };
var babelCore = { exports: {} };
var hasRequiredBabelCore;
function requireBabelCore() {
  if (hasRequiredBabelCore)
    return babelCore.exports;
  hasRequiredBabelCore = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    var es7_1 = tslib_1.__importDefault(requireEs7());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var defaults = fork2.use(shared_1.default).defaults;
      var def = types2.Type.def;
      var or = types2.Type.or;
      def("Noop").bases("Statement").build();
      def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
      def("Super").bases("Expression").build();
      def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
      def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
      def("Property").field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
      def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
      def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
      def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
      def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
      def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression")));
      def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults.emptyArray).field("source", or(def("Literal"), null), defaults["null"]);
      def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
      def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
      def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
      def("ExportAllDeclaration").bases("Declaration").build("exported", "source").field("exported", or(def("Identifier"), null)).field("source", def("Literal"));
      def("CommentBlock").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
      def("CommentLine").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
      def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
      def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults["use strict"]);
      def("InterpreterDirective").bases("Node").build("value").field("value", String);
      def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray);
      def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults.emptyArray).field("interpreter", or(def("InterpreterDirective"), null), defaults["null"]);
      def("StringLiteral").bases("Literal").build("value").field("value", String);
      def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults["null"]).field("extra", {
        rawValue: Number,
        raw: String
      }, function getDefault() {
        return {
          rawValue: this.value,
          raw: this.value + ""
        };
      });
      def("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number)).field("extra", {
        rawValue: String,
        raw: String
      }, function getDefault() {
        return {
          rawValue: String(this.value),
          raw: this.value + "n"
        };
      });
      def("NullLiteral").bases("Literal").build().field("value", null, defaults["null"]);
      def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
      def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
        return new RegExp(this.pattern, this.flags);
      });
      var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
      def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults["null"]
      ).field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults["null"]
      ).field("computed", Boolean, defaults["false"]);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"));
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
      def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("Expression")));
      def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName"));
      [
        "ClassMethod",
        "ClassPrivateMethod"
      ].forEach(function(typeName) {
        def(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
          return "method";
        }).field("body", def("BlockStatement")).field("computed", Boolean, defaults["false"]).field("static", or(Boolean, null), defaults["null"]).field("abstract", or(Boolean, null), defaults["null"]).field("access", or("public", "private", "protected", null), defaults["null"]).field("accessibility", or("public", "private", "protected", null), defaults["null"]).field("decorators", or([def("Decorator")], null), defaults["null"]).field("optional", or(Boolean, null), defaults["null"]);
      });
      def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or(def("Expression"), null), defaults["null"]);
      def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier"));
      var ObjectPatternProperty = or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty"),
        // Used by Esprima
        def("ObjectProperty"),
        // Babel 6
        def("RestProperty")
        // Babel 6
      );
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults["null"]);
      def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
      def("Import").bases("Expression").build();
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(babelCore, babelCore.exports);
  return babelCore.exports;
}
var hasRequiredBabel;
function requireBabel() {
  if (hasRequiredBabel)
    return babel.exports;
  hasRequiredBabel = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var babel_core_1 = tslib_1.__importDefault(requireBabelCore());
    var flow_1 = tslib_1.__importDefault(requireFlow());
    function default_1(fork2) {
      fork2.use(babel_core_1.default);
      fork2.use(flow_1.default);
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(babel, babel.exports);
  return babel.exports;
}
var typescript = { exports: {} };
var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript)
    return typescript.exports;
  hasRequiredTypescript = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var babel_core_1 = tslib_1.__importDefault(requireBabelCore());
    var type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(babel_core_1.default);
      fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default);
      var n2 = types2.namedTypes;
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults = fork2.use(shared_1.default).defaults;
      var StringLiteral = types2.Type.from(function(value, deep) {
        if (n2.StringLiteral && n2.StringLiteral.check(value, deep)) {
          return true;
        }
        if (n2.Literal && n2.Literal.check(value, deep) && typeof value.value === "string") {
          return true;
        }
        return false;
      }, "StringLiteral");
      def("TSType").bases("Node");
      var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
      def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
      def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults["null"]);
      def("TSHasOptionalTypeParameters").field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults["null"]);
      def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults["null"]);
      def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
      def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults["null"]);
      def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression"));
      [
        "TSAnyKeyword",
        "TSBigIntKeyword",
        "TSBooleanKeyword",
        "TSNeverKeyword",
        "TSNullKeyword",
        "TSNumberKeyword",
        "TSObjectKeyword",
        "TSStringKeyword",
        "TSSymbolKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword",
        "TSVoidKeyword",
        "TSThisType"
      ].forEach(function(keywordType) {
        def(keywordType).bases("TSType").build();
      });
      def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType"));
      def("TSLiteralType").bases("TSType").build("literal").field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression")));
      [
        "TSUnionType",
        "TSIntersectionType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
      });
      def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType"));
      def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter"));
      def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
      [
        "TSFunctionType",
        "TSConstructorType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
      });
      def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults["false"]).field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("id", or(def("Identifier"), null), defaults["null"]).field("params", [def("Pattern")]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults["null"]);
      def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults["false"]).field("generator", Boolean, defaults["false"]).field("params", [def("Pattern")]).field("abstract", Boolean, defaults["false"]).field("accessibility", or("public", "private", "protected", void 0), defaults["undefined"]).field("static", Boolean, defaults["false"]).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("key", or(
        def("Identifier"),
        def("StringLiteral"),
        def("NumericLiteral"),
        // Only allowed if .computed is true.
        def("Expression")
      )).field("kind", or("get", "set", "method", "constructor"), function getDefault() {
        return "method";
      }).field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults["undefined"]
      ).field("decorators", or([def("Decorator")], null), defaults["null"]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults["null"]);
      def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults["false"]).field("typeParameter", def("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults["false"]).field("typeAnnotation", or(def("TSType"), null), defaults["null"]);
      def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]);
      def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults["false"]).field("elementType", def("TSType"));
      def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType"));
      def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType"));
      def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation")));
      def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults["false"]);
      def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("readonly", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("initializer", or(def("Expression"), null), defaults["null"]);
      def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults["false"]).field("optional", Boolean, defaults["false"]).field("parameters", ParametersType);
      def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults["null"]).field("asserts", Boolean, defaults["false"]);
      [
        "TSCallSignatureDeclaration",
        "TSConstructSignatureDeclaration"
      ].forEach(function(typeName) {
        def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
      });
      def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def("Identifier"), StringLiteral)).field("initializer", or(def("Expression"), null), defaults["null"]);
      def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def("TSImportType")));
      var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
      def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
      def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", String).field("constraint", or(def("TSType"), void 0), defaults["undefined"]).field("default", or(def("TSType"), void 0), defaults["undefined"]);
      def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults["null"]);
      def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]);
      def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]);
      def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults["false"]).field("declare", Boolean, defaults["false"]).field("members", [def("TSEnumMember")]).field("initializer", or(def("Expression"), null), defaults["null"]);
      def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults["false"]).field("typeAnnotation", def("TSType"));
      def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]);
      def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults["false"]).field("global", Boolean, defaults["false"]).field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults["null"]);
      def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults["undefined"]);
      def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults["false"]).field("moduleReference", or(TSEntityName, def("TSExternalModuleReference")));
      def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
      def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression"));
      def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier"));
      def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
      def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
      def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults["false"]).field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults["null"]).field("body", def("TSInterfaceBody"));
      def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults["undefined"]).field("readonly", Boolean, defaults["false"]).field("parameter", or(def("Identifier"), def("AssignmentPattern")));
      def("ClassProperty").field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults["undefined"]
      );
      def("ClassBody").field("body", [or(
        def("MethodDefinition"),
        def("VariableDeclarator"),
        def("ClassPropertyDefinition"),
        def("ClassProperty"),
        def("ClassPrivateProperty"),
        def("ClassMethod"),
        def("ClassPrivateMethod"),
        // Just need to add these types:
        def("TSDeclareMethod"),
        TSTypeMember
      )]);
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(typescript, typescript.exports);
  return typescript.exports;
}
var esProposals = { exports: {} };
var hasRequiredEsProposals;
function requireEsProposals() {
  if (hasRequiredEsProposals)
    return esProposals.exports;
  hasRequiredEsProposals = 1;
  (function(module2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    var core_1 = tslib_1.__importDefault(requireCore());
    function default_1(fork2) {
      fork2.use(core_1.default);
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var def = types2.Type.def;
      var or = Type.or;
      var shared2 = fork2.use(shared_1.default);
      var defaults = shared2.defaults;
      def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults["true"]);
      def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults["true"]);
      var LogicalOperator = or("||", "&&", "??");
      def("LogicalExpression").field("operator", LogicalOperator);
    }
    exports2.default = default_1;
    module2.exports = exports2["default"];
  })(esProposals, esProposals.exports);
  return esProposals.exports;
}
var namedTypes = {};
var hasRequiredNamedTypes;
function requireNamedTypes() {
  if (hasRequiredNamedTypes)
    return namedTypes;
  hasRequiredNamedTypes = 1;
  (function(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.namedTypes = void 0;
    /* @__PURE__ */ (function(namedTypes2) {
    })(exports2.namedTypes || (exports2.namedTypes = {}));
  })(namedTypes);
  return namedTypes;
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.visit = exports2.use = exports2.Type = exports2.someField = exports2.PathVisitor = exports2.Path = exports2.NodePath = exports2.namedTypes = exports2.getSupertypeNames = exports2.getFieldValue = exports2.getFieldNames = exports2.getBuilderName = exports2.finalize = exports2.eachField = exports2.defineMethod = exports2.builtInTypes = exports2.builders = exports2.astNodesAreEquivalent = void 0;
  var tslib_1 = require$$0;
  var fork_1 = tslib_1.__importDefault(requireFork());
  var core_1 = tslib_1.__importDefault(requireCore());
  var es6_1 = tslib_1.__importDefault(requireEs6());
  var es7_1 = tslib_1.__importDefault(requireEs7());
  var es2020_1 = tslib_1.__importDefault(requireEs2020());
  var jsx_1 = tslib_1.__importDefault(requireJsx());
  var flow_1 = tslib_1.__importDefault(requireFlow());
  var esprima_12 = tslib_1.__importDefault(requireEsprima());
  var babel_1 = tslib_1.__importDefault(requireBabel());
  var typescript_1 = tslib_1.__importDefault(requireTypescript());
  var es_proposals_1 = tslib_1.__importDefault(requireEsProposals());
  var namedTypes_1 = requireNamedTypes();
  Object.defineProperty(exports2, "namedTypes", { enumerable: true, get: function() {
    return namedTypes_1.namedTypes;
  } });
  var _a3 = fork_1.default([
    // This core module of AST types captures ES5 as it is parsed today by
    // git://github.com/ariya/esprima.git#master.
    core_1.default,
    // Feel free to add to or remove from this list of extension modules to
    // configure the precise type hierarchy that you need.
    es6_1.default,
    es7_1.default,
    es2020_1.default,
    jsx_1.default,
    flow_1.default,
    esprima_12.default,
    babel_1.default,
    typescript_1.default,
    es_proposals_1.default
  ]), astNodesAreEquivalent = _a3.astNodesAreEquivalent, builders = _a3.builders, builtInTypes = _a3.builtInTypes, defineMethod = _a3.defineMethod, eachField = _a3.eachField, finalize = _a3.finalize, getBuilderName = _a3.getBuilderName, getFieldNames = _a3.getFieldNames, getFieldValue = _a3.getFieldValue, getSupertypeNames = _a3.getSupertypeNames, n2 = _a3.namedTypes, NodePath = _a3.NodePath, Path = _a3.Path, PathVisitor = _a3.PathVisitor, someField = _a3.someField, Type = _a3.Type, use = _a3.use, visit = _a3.visit;
  exports2.astNodesAreEquivalent = astNodesAreEquivalent;
  exports2.builders = builders;
  exports2.builtInTypes = builtInTypes;
  exports2.defineMethod = defineMethod;
  exports2.eachField = eachField;
  exports2.finalize = finalize;
  exports2.getBuilderName = getBuilderName;
  exports2.getFieldNames = getFieldNames;
  exports2.getFieldValue = getFieldValue;
  exports2.getSupertypeNames = getSupertypeNames;
  exports2.NodePath = NodePath;
  exports2.Path = Path;
  exports2.PathVisitor = PathVisitor;
  exports2.someField = someField;
  exports2.Type = Type;
  exports2.use = use;
  exports2.visit = visit;
  Object.assign(namedTypes_1.namedTypes, n2);
})(main$1);
Object.defineProperty(degenerator$1, "__esModule", { value: true });
degenerator$1.degenerator = void 0;
const util_1$5 = require$$4;
const escodegen_1 = escodegen;
const esprima_1 = esprimaExports;
const ast_types_1 = main$1;
function degenerator(code2, _names) {
  if (!Array.isArray(_names)) {
    throw new TypeError('an array of async function "names" is required');
  }
  const names = _names.slice(0);
  const ast2 = (0, esprima_1.parseScript)(code2);
  let lastNamesLength = 0;
  do {
    lastNamesLength = names.length;
    (0, ast_types_1.visit)(ast2, {
      visitVariableDeclaration(path2) {
        if (path2.node.declarations) {
          for (let i2 = 0; i2 < path2.node.declarations.length; i2++) {
            const declaration = path2.node.declarations[i2];
            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {
              names.push(declaration.id.name);
            }
          }
        }
        return false;
      },
      visitAssignmentExpression(path2) {
        if (ast_types_1.namedTypes.Identifier.check(path2.node.left) && ast_types_1.namedTypes.Identifier.check(path2.node.right) && checkName(path2.node.right.name, names) && !checkName(path2.node.left.name, names)) {
          names.push(path2.node.left.name);
        }
        return false;
      },
      visitFunction(path2) {
        if (path2.node.id) {
          let shouldDegenerate = false;
          (0, ast_types_1.visit)(path2.node, {
            visitCallExpression(path3) {
              if (checkNames(path3.node, names)) {
                shouldDegenerate = true;
              }
              return false;
            }
          });
          if (!shouldDegenerate) {
            return false;
          }
          path2.node.async = true;
          if (!checkName(path2.node.id.name, names)) {
            names.push(path2.node.id.name);
          }
        }
        this.traverse(path2);
      }
    });
  } while (lastNamesLength !== names.length);
  (0, ast_types_1.visit)(ast2, {
    visitCallExpression(path2) {
      if (checkNames(path2.node, names)) {
        const delegate = false;
        const { name: name2, parent: { node: pNode } } = path2;
        const expr = ast_types_1.builders.awaitExpression(path2.node, delegate);
        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {
          pNode.arguments[name2] = expr;
        } else {
          pNode[name2] = expr;
        }
      }
      this.traverse(path2);
    }
  });
  return (0, escodegen_1.generate)(ast2);
}
degenerator$1.degenerator = degenerator;
function checkNames({ callee }, names) {
  let name2;
  if (ast_types_1.namedTypes.Identifier.check(callee)) {
    name2 = callee.name;
  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {
    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {
      name2 = `${callee.object.name}.${callee.property.name}`;
    } else {
      return false;
    }
  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {
    if (callee.id) {
      name2 = callee.id.name;
    } else {
      return false;
    }
  } else {
    throw new Error(`Don't know how to get name for: ${callee.type}`);
  }
  return checkName(name2, names);
}
function checkName(name2, names) {
  for (let i2 = 0; i2 < names.length; i2++) {
    const n2 = names[i2];
    if (util_1$5.types.isRegExp(n2)) {
      if (n2.test(name2)) {
        return true;
      }
    } else if (name2 === n2) {
      return true;
    }
  }
  return false;
}
var compile$1 = {};
Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.compile = void 0;
const util_1$4 = require$$4;
const degenerator_1 = degenerator$1;
function compile(qjs, code2, returnName, options = {}) {
  const compiled = (0, degenerator_1.degenerator)(code2, options.names ?? []);
  const vm = qjs.newContext();
  if (options.sandbox) {
    for (const [name2, value] of Object.entries(options.sandbox)) {
      if (typeof value !== "function") {
        throw new Error(`Expected a "function" for sandbox property \`${name2}\`, but got "${typeof value}"`);
      }
      const fnHandle = vm.newFunction(name2, (...args) => {
        const result = value(...args.map((arg) => quickJSHandleToHost(vm, arg)));
        vm.runtime.executePendingJobs();
        return hostToQuickJSHandle(vm, result);
      });
      fnHandle.consume((handle) => vm.setProp(vm.global, name2, handle));
    }
  }
  const fnResult = vm.evalCode(`${compiled};${returnName}`, options.filename);
  const fn = vm.unwrapResult(fnResult);
  const t2 = vm.typeof(fn);
  if (t2 !== "function") {
    throw new Error(`Expected a "function" named \`${returnName}\` to be defined, but got "${t2}"`);
  }
  const r2 = async function(...args) {
    let promiseHandle;
    let resolvedHandle;
    try {
      const result = vm.callFunction(fn, vm.undefined, ...args.map((arg) => hostToQuickJSHandle(vm, arg)));
      promiseHandle = vm.unwrapResult(result);
      const resolvedResultP = vm.resolvePromise(promiseHandle);
      vm.runtime.executePendingJobs();
      const resolvedResult = await resolvedResultP;
      resolvedHandle = vm.unwrapResult(resolvedResult);
      return quickJSHandleToHost(vm, resolvedHandle);
    } catch (err) {
      if (err && typeof err === "object" && "cause" in err && err.cause) {
        if (typeof err.cause === "object" && "stack" in err.cause && "name" in err.cause && "message" in err.cause && typeof err.cause.stack === "string" && typeof err.cause.name === "string" && typeof err.cause.message === "string") {
          err.cause.stack = `${err.cause.name}: ${err.cause.message}
${err.cause.stack}`;
        }
        throw err.cause;
      }
      throw err;
    } finally {
      promiseHandle == null ? void 0 : promiseHandle.dispose();
      resolvedHandle == null ? void 0 : resolvedHandle.dispose();
    }
  };
  Object.defineProperty(r2, "toString", {
    value: () => compiled,
    enumerable: false
  });
  return r2;
}
compile$1.compile = compile;
function quickJSHandleToHost(vm, val) {
  return vm.dump(val);
}
function hostToQuickJSHandle(vm, val) {
  if (typeof val === "undefined") {
    return vm.undefined;
  } else if (val === null) {
    return vm.null;
  } else if (typeof val === "string") {
    return vm.newString(val);
  } else if (typeof val === "number") {
    return vm.newNumber(val);
  } else if (typeof val === "bigint") {
    return vm.newBigInt(val);
  } else if (typeof val === "boolean") {
    return val ? vm.true : vm.false;
  } else if (util_1$4.types.isPromise(val)) {
    const promise = vm.newPromise();
    promise.settled.then(vm.runtime.executePendingJobs);
    val.then((r2) => {
      promise.resolve(hostToQuickJSHandle(vm, r2));
    }, (err) => {
      promise.reject(hostToQuickJSHandle(vm, err));
    });
    return promise.handle;
  } else if (util_1$4.types.isNativeError(val)) {
    return vm.newError(val);
  }
  throw new Error(`Unsupported value: ${val}`);
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar2(degenerator$1, exports2);
  __exportStar2(compile$1, exports2);
})(dist$3);
var dateRange$1 = {};
Object.defineProperty(dateRange$1, "__esModule", { value: true });
function dateRange() {
  return false;
}
dateRange$1.default = dateRange;
var dnsDomainIs$1 = {};
Object.defineProperty(dnsDomainIs$1, "__esModule", { value: true });
function dnsDomainIs(host, domain) {
  host = String(host);
  domain = String(domain);
  return host.substr(domain.length * -1) === domain;
}
dnsDomainIs$1.default = dnsDomainIs;
var dnsDomainLevels$1 = {};
Object.defineProperty(dnsDomainLevels$1, "__esModule", { value: true });
function dnsDomainLevels(host) {
  const match = String(host).match(/\./g);
  let levels = 0;
  if (match) {
    levels = match.length;
  }
  return levels;
}
dnsDomainLevels$1.default = dnsDomainLevels;
var dnsResolve$1 = {};
var util$3 = {};
Object.defineProperty(util$3, "__esModule", { value: true });
util$3.isGMT = util$3.dnsLookup = void 0;
const dns_1 = require$$3$3;
function dnsLookup(host, opts) {
  return new Promise((resolve2, reject) => {
    (0, dns_1.lookup)(host, opts, (err, res) => {
      if (err) {
        reject(err);
      } else {
        resolve2(res);
      }
    });
  });
}
util$3.dnsLookup = dnsLookup;
function isGMT(v2) {
  return v2 === "GMT";
}
util$3.isGMT = isGMT;
Object.defineProperty(dnsResolve$1, "__esModule", { value: true });
const util_1$3 = util$3;
async function dnsResolve(host) {
  const family = 4;
  try {
    const r2 = await (0, util_1$3.dnsLookup)(host, { family });
    if (typeof r2 === "string") {
      return r2;
    }
  } catch (err) {
  }
  return null;
}
dnsResolve$1.default = dnsResolve;
var isInNet$1 = {};
var netmask = {};
(function() {
  var Netmask, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
  long2ip = function(long) {
    var a2, b2, c2, d2;
    a2 = (long & 255 << 24) >>> 24;
    b2 = (long & 255 << 16) >>> 16;
    c2 = (long & 255 << 8) >>> 8;
    d2 = long & 255;
    return [a2, b2, c2, d2].join(".");
  };
  ip2long = function(ip2) {
    var b2, c2, i2, j2, n2, ref;
    b2 = [];
    for (i2 = j2 = 0; j2 <= 3; i2 = ++j2) {
      if (ip2.length === 0) {
        break;
      }
      if (i2 > 0) {
        if (ip2[0] !== ".") {
          throw new Error("Invalid IP");
        }
        ip2 = ip2.substring(1);
      }
      ref = atob2(ip2), n2 = ref[0], c2 = ref[1];
      ip2 = ip2.substring(c2);
      b2.push(n2);
    }
    if (ip2.length !== 0) {
      throw new Error("Invalid IP");
    }
    switch (b2.length) {
      case 1:
        if (b2[0] > 4294967295) {
          throw new Error("Invalid IP");
        }
        return b2[0] >>> 0;
      case 2:
        if (b2[0] > 255 || b2[1] > 16777215) {
          throw new Error("Invalid IP");
        }
        return (b2[0] << 24 | b2[1]) >>> 0;
      case 3:
        if (b2[0] > 255 || b2[1] > 255 || b2[2] > 65535) {
          throw new Error("Invalid IP");
        }
        return (b2[0] << 24 | b2[1] << 16 | b2[2]) >>> 0;
      case 4:
        if (b2[0] > 255 || b2[1] > 255 || b2[2] > 255 || b2[3] > 255) {
          throw new Error("Invalid IP");
        }
        return (b2[0] << 24 | b2[1] << 16 | b2[2] << 8 | b2[3]) >>> 0;
      default:
        throw new Error("Invalid IP");
    }
  };
  chr = function(b2) {
    return b2.charCodeAt(0);
  };
  chr0 = chr("0");
  chra = chr("a");
  chrA = chr("A");
  atob2 = function(s2) {
    var base, dmax, i2, n2, start;
    n2 = 0;
    base = 10;
    dmax = "9";
    i2 = 0;
    if (s2.length > 1 && s2[i2] === "0") {
      if (s2[i2 + 1] === "x" || s2[i2 + 1] === "X") {
        i2 += 2;
        base = 16;
      } else if ("0" <= s2[i2 + 1] && s2[i2 + 1] <= "9") {
        i2++;
        base = 8;
        dmax = "7";
      }
    }
    start = i2;
    while (i2 < s2.length) {
      if ("0" <= s2[i2] && s2[i2] <= dmax) {
        n2 = n2 * base + (chr(s2[i2]) - chr0) >>> 0;
      } else if (base === 16) {
        if ("a" <= s2[i2] && s2[i2] <= "f") {
          n2 = n2 * base + (10 + chr(s2[i2]) - chra) >>> 0;
        } else if ("A" <= s2[i2] && s2[i2] <= "F") {
          n2 = n2 * base + (10 + chr(s2[i2]) - chrA) >>> 0;
        } else {
          break;
        }
      } else {
        break;
      }
      if (n2 > 4294967295) {
        throw new Error("too large");
      }
      i2++;
    }
    if (i2 === start) {
      throw new Error("empty octet");
    }
    return [n2, i2];
  };
  Netmask = function() {
    function Netmask2(net2, mask) {
      var i2, j2, ref;
      if (typeof net2 !== "string") {
        throw new Error("Missing `net' parameter");
      }
      if (!mask) {
        ref = net2.split("/", 2), net2 = ref[0], mask = ref[1];
      }
      if (!mask) {
        mask = 32;
      }
      if (typeof mask === "string" && mask.indexOf(".") > -1) {
        try {
          this.maskLong = ip2long(mask);
        } catch (error1) {
          throw new Error("Invalid mask: " + mask);
        }
        for (i2 = j2 = 32; j2 >= 0; i2 = --j2) {
          if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
            this.bitmask = i2;
            break;
          }
        }
      } else if (mask || mask === 0) {
        this.bitmask = parseInt(mask, 10);
        this.maskLong = 0;
        if (this.bitmask > 0) {
          this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
        }
      } else {
        throw new Error("Invalid mask: empty");
      }
      try {
        this.netLong = (ip2long(net2) & this.maskLong) >>> 0;
      } catch (error1) {
        throw new Error("Invalid net address: " + net2);
      }
      if (!(this.bitmask <= 32)) {
        throw new Error("Invalid mask for ip4: " + mask);
      }
      this.size = Math.pow(2, 32 - this.bitmask);
      this.base = long2ip(this.netLong);
      this.mask = long2ip(this.maskLong);
      this.hostmask = long2ip(~this.maskLong);
      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
    }
    Netmask2.prototype.contains = function(ip2) {
      if (typeof ip2 === "string" && (ip2.indexOf("/") > 0 || ip2.split(".").length !== 4)) {
        ip2 = new Netmask2(ip2);
      }
      if (ip2 instanceof Netmask2) {
        return this.contains(ip2.base) && this.contains(ip2.broadcast || ip2.last);
      } else {
        return (ip2long(ip2) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }
    };
    Netmask2.prototype.next = function(count) {
      if (count == null) {
        count = 1;
      }
      return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
    };
    Netmask2.prototype.forEach = function(fn) {
      var index2, lastLong, long;
      long = ip2long(this.first);
      lastLong = ip2long(this.last);
      index2 = 0;
      while (long <= lastLong) {
        fn(long2ip(long), long, index2);
        index2++;
        long++;
      }
    };
    Netmask2.prototype.toString = function() {
      return this.base + "/" + this.bitmask;
    };
    return Netmask2;
  }();
  netmask.ip2long = ip2long;
  netmask.long2ip = long2ip;
  netmask.Netmask = Netmask;
}).call(commonjsGlobal);
Object.defineProperty(isInNet$1, "__esModule", { value: true });
const netmask_1 = netmask;
const util_1$2 = util$3;
async function isInNet(host, pattern, mask) {
  const family = 4;
  try {
    const ip2 = await (0, util_1$2.dnsLookup)(host, { family });
    if (typeof ip2 === "string") {
      const netmask2 = new netmask_1.Netmask(pattern, mask);
      return netmask2.contains(ip2);
    }
  } catch (err) {
  }
  return false;
}
isInNet$1.default = isInNet;
var isPlainHostName$1 = {};
Object.defineProperty(isPlainHostName$1, "__esModule", { value: true });
function isPlainHostName(host) {
  return !/\./.test(host);
}
isPlainHostName$1.default = isPlainHostName;
var isResolvable$1 = {};
Object.defineProperty(isResolvable$1, "__esModule", { value: true });
const util_1$1 = util$3;
async function isResolvable(host) {
  const family = 4;
  try {
    if (await (0, util_1$1.dnsLookup)(host, { family })) {
      return true;
    }
  } catch (err) {
  }
  return false;
}
isResolvable$1.default = isResolvable;
var localHostOrDomainIs$1 = {};
Object.defineProperty(localHostOrDomainIs$1, "__esModule", { value: true });
function localHostOrDomainIs(host, hostdom) {
  const parts = host.split(".");
  const domparts = hostdom.split(".");
  let matches = true;
  for (let i2 = 0; i2 < parts.length; i2++) {
    if (parts[i2] !== domparts[i2]) {
      matches = false;
      break;
    }
  }
  return matches;
}
localHostOrDomainIs$1.default = localHostOrDomainIs;
var myIpAddress$1 = {};
var ip = {};
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ip = void 0;
  const os_1 = __importDefault2(os);
  exports2.ip = {
    address() {
      const interfaces = os_1.default.networkInterfaces();
      const family = normalizeFamily();
      const all = Object.values(interfaces).map((addrs = []) => {
        const addresses = addrs.filter((details) => {
          const detailsFamily = normalizeFamily(details.family);
          if (detailsFamily !== family || exports2.ip.isLoopback(details.address)) {
            return false;
          }
          return true;
        });
        return addresses.length ? addresses[0].address : void 0;
      }).filter(Boolean);
      return !all.length ? exports2.ip.loopback(family) : all[0];
    },
    isLoopback(addr) {
      return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    },
    loopback(family) {
      family = normalizeFamily(family);
      if (family !== "ipv4" && family !== "ipv6") {
        throw new Error("family must be ipv4 or ipv6");
      }
      return family === "ipv4" ? "127.0.0.1" : "fe80::1";
    }
  };
  function normalizeFamily(family) {
    if (family === 4) {
      return "ipv4";
    }
    if (family === 6) {
      return "ipv6";
    }
    return family ? family.toLowerCase() : "ipv4";
  }
})(ip);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(myIpAddress$1, "__esModule", { value: true });
const ip_1 = ip;
const net_1 = __importDefault$4(require$$0$1);
async function myIpAddress() {
  return new Promise((resolve2, reject) => {
    const socket = net_1.default.connect({ host: "8.8.8.8", port: 53 });
    const onError = () => {
      resolve2(ip_1.ip.address());
    };
    socket.once("error", onError);
    socket.once("connect", () => {
      socket.removeListener("error", onError);
      const addr = socket.address();
      socket.destroy();
      if (typeof addr === "string") {
        resolve2(addr);
      } else if (addr.address) {
        resolve2(addr.address);
      } else {
        reject(new Error("Expected a `string`"));
      }
    });
  });
}
myIpAddress$1.default = myIpAddress;
var shExpMatch$1 = {};
Object.defineProperty(shExpMatch$1, "__esModule", { value: true });
function shExpMatch(str, shexp) {
  const re2 = toRegExp(shexp);
  return re2.test(str);
}
shExpMatch$1.default = shExpMatch;
function toRegExp(str) {
  str = String(str).replace(/\./g, "\\.").replace(/\?/g, ".").replace(/\*/g, ".*");
  return new RegExp(`^${str}$`);
}
var timeRange$1 = {};
Object.defineProperty(timeRange$1, "__esModule", { value: true });
function timeRange() {
  const args = Array.prototype.slice.call(arguments);
  const lastArg = args.pop();
  const useGMTzone = lastArg === "GMT";
  const currentDate = /* @__PURE__ */ new Date();
  if (!useGMTzone) {
    args.push(lastArg);
  }
  let result = false;
  const noOfArgs = args.length;
  const numericArgs = args.map((n2) => parseInt(n2, 10));
  if (noOfArgs === 1) {
    result = getCurrentHour(useGMTzone, currentDate) === numericArgs[0];
  } else if (noOfArgs === 2) {
    const currentHour = getCurrentHour(useGMTzone, currentDate);
    result = numericArgs[0] <= currentHour && currentHour < numericArgs[1];
  } else if (noOfArgs === 4) {
    result = valueInRange$1(secondsElapsedToday(numericArgs[0], numericArgs[1], 0), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), 0), secondsElapsedToday(numericArgs[2], numericArgs[3], 59));
  } else if (noOfArgs === 6) {
    result = valueInRange$1(secondsElapsedToday(numericArgs[0], numericArgs[1], numericArgs[2]), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), getCurrentSecond(useGMTzone, currentDate)), secondsElapsedToday(numericArgs[3], numericArgs[4], numericArgs[5]));
  }
  return result;
}
timeRange$1.default = timeRange;
function secondsElapsedToday(hh, mm, ss) {
  return hh * 3600 + mm * 60 + ss;
}
function getCurrentHour(gmt, currentDate) {
  return gmt ? currentDate.getUTCHours() : currentDate.getHours();
}
function getCurrentMinute(gmt, currentDate) {
  return gmt ? currentDate.getUTCMinutes() : currentDate.getMinutes();
}
function getCurrentSecond(gmt, currentDate) {
  return gmt ? currentDate.getUTCSeconds() : currentDate.getSeconds();
}
function valueInRange$1(start, value, finish) {
  return start <= value && value <= finish;
}
var weekdayRange$1 = {};
Object.defineProperty(weekdayRange$1, "__esModule", { value: true });
const util_1 = util$3;
const weekdays = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
function weekdayRange(wd1, wd2, gmt) {
  let useGMTzone = false;
  let wd1Index = -1;
  let wd2Index = -1;
  let wd2IsGmt = false;
  if ((0, util_1.isGMT)(gmt)) {
    useGMTzone = true;
  } else if ((0, util_1.isGMT)(wd2)) {
    useGMTzone = true;
    wd2IsGmt = true;
  }
  wd1Index = weekdays.indexOf(wd1);
  if (!wd2IsGmt && isWeekday(wd2)) {
    wd2Index = weekdays.indexOf(wd2);
  }
  const todaysDay = getTodaysDay(useGMTzone);
  let result;
  if (wd2Index < 0) {
    result = todaysDay === wd1Index;
  } else if (wd1Index <= wd2Index) {
    result = valueInRange(wd1Index, todaysDay, wd2Index);
  } else {
    result = valueInRange(wd1Index, todaysDay, 6) || valueInRange(0, todaysDay, wd2Index);
  }
  return result;
}
weekdayRange$1.default = weekdayRange;
function getTodaysDay(gmt) {
  return gmt ? (/* @__PURE__ */ new Date()).getUTCDay() : (/* @__PURE__ */ new Date()).getDay();
}
function valueInRange(start, value, finish) {
  return start <= value && value <= finish;
}
function isWeekday(v2) {
  if (!v2)
    return false;
  return weekdays.includes(v2);
}
(function(exports2) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.sandbox = exports2.createPacResolver = void 0;
  const degenerator_12 = dist$3;
  const dateRange_1 = __importDefault2(dateRange$1);
  const dnsDomainIs_1 = __importDefault2(dnsDomainIs$1);
  const dnsDomainLevels_1 = __importDefault2(dnsDomainLevels$1);
  const dnsResolve_1 = __importDefault2(dnsResolve$1);
  const isInNet_1 = __importDefault2(isInNet$1);
  const isPlainHostName_1 = __importDefault2(isPlainHostName$1);
  const isResolvable_1 = __importDefault2(isResolvable$1);
  const localHostOrDomainIs_1 = __importDefault2(localHostOrDomainIs$1);
  const myIpAddress_1 = __importDefault2(myIpAddress$1);
  const shExpMatch_1 = __importDefault2(shExpMatch$1);
  const timeRange_1 = __importDefault2(timeRange$1);
  const weekdayRange_1 = __importDefault2(weekdayRange$1);
  function createPacResolver(qjs, _str, _opts = {}) {
    const str = Buffer.isBuffer(_str) ? _str.toString("utf8") : _str;
    const context2 = {
      ...exports2.sandbox,
      ..._opts.sandbox
    };
    const names = Object.keys(context2).filter((k2) => isAsyncFunction(context2[k2]));
    const opts = {
      filename: "proxy.pac",
      names,
      ..._opts,
      sandbox: context2
    };
    const resolver = (0, degenerator_12.compile)(qjs, str, "FindProxyForURL", opts);
    function FindProxyForURL(url, _host) {
      const urlObj = typeof url === "string" ? new URL(url) : url;
      const host = _host || urlObj.hostname;
      if (!host) {
        throw new TypeError("Could not determine `host`");
      }
      return resolver(urlObj.href, host);
    }
    Object.defineProperty(FindProxyForURL, "toString", {
      value: () => resolver.toString(),
      enumerable: false
    });
    return FindProxyForURL;
  }
  exports2.createPacResolver = createPacResolver;
  exports2.sandbox = Object.freeze({
    alert: (message2 = "") => console.log("%s", message2),
    dateRange: dateRange_1.default,
    dnsDomainIs: dnsDomainIs_1.default,
    dnsDomainLevels: dnsDomainLevels_1.default,
    dnsResolve: dnsResolve_1.default,
    isInNet: isInNet_1.default,
    isPlainHostName: isPlainHostName_1.default,
    isResolvable: isResolvable_1.default,
    localHostOrDomainIs: localHostOrDomainIs_1.default,
    myIpAddress: myIpAddress_1.default,
    shExpMatch: shExpMatch_1.default,
    timeRange: timeRange_1.default,
    weekdayRange: weekdayRange_1.default
  });
  function isAsyncFunction(v2) {
    if (typeof v2 !== "function")
      return false;
    if (v2.constructor.name === "AsyncFunction")
      return true;
    if (String(v2).indexOf("__awaiter(") !== -1)
      return true;
    return Boolean(v2.async);
  }
})(dist$4);
var dist$2 = {};
var variants = {};
var esmHelpers = {};
Object.defineProperty(esmHelpers, "__esModule", { value: true });
esmHelpers.unwrapJavascript = esmHelpers.unwrapTypescript = void 0;
function fakeUnwrapDefault(mod) {
  return mod.default;
}
function actualUnwrapDefault(mod) {
  const maybeUnwrap = mod.default;
  return maybeUnwrap ?? mod;
}
esmHelpers.unwrapTypescript = actualUnwrapDefault;
esmHelpers.unwrapJavascript = fakeUnwrapDefault;
var module$1 = {};
var debug$4 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.debugLog = exports2.QTS_DEBUG = void 0;
  exports2.QTS_DEBUG = Boolean(typeof process === "object" && process.env.QTS_DEBUG);
  exports2.debugLog = exports2.QTS_DEBUG ? console.log.bind(console) : () => {
  };
})(debug$4);
var errors = {};
Object.defineProperty(errors, "__esModule", { value: true });
errors.QuickJSMemoryLeakDetected = errors.QuickJSAsyncifySuspended = errors.QuickJSAsyncifyError = errors.QuickJSNotImplemented = errors.QuickJSUseAfterFree = errors.QuickJSWrongOwner = errors.QuickJSUnwrapError = void 0;
class QuickJSUnwrapError extends Error {
  constructor(cause, context2) {
    super(String(cause));
    this.cause = cause;
    this.context = context2;
    this.name = "QuickJSUnwrapError";
  }
}
errors.QuickJSUnwrapError = QuickJSUnwrapError;
class QuickJSWrongOwner extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSWrongOwner";
  }
}
errors.QuickJSWrongOwner = QuickJSWrongOwner;
class QuickJSUseAfterFree extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSUseAfterFree";
  }
}
errors.QuickJSUseAfterFree = QuickJSUseAfterFree;
class QuickJSNotImplemented extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSNotImplemented";
  }
}
errors.QuickJSNotImplemented = QuickJSNotImplemented;
class QuickJSAsyncifyError extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSAsyncifyError";
  }
}
errors.QuickJSAsyncifyError = QuickJSAsyncifyError;
class QuickJSAsyncifySuspended extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSAsyncifySuspended";
  }
}
errors.QuickJSAsyncifySuspended = QuickJSAsyncifySuspended;
class QuickJSMemoryLeakDetected extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSMemoryLeakDetected";
  }
}
errors.QuickJSMemoryLeakDetected = QuickJSMemoryLeakDetected;
var lifetime = {};
var asyncifyHelpers = {};
Object.defineProperty(asyncifyHelpers, "__esModule", { value: true });
asyncifyHelpers.awaitEachYieldedPromise = asyncifyHelpers.maybeAsync = asyncifyHelpers.maybeAsyncFn = void 0;
function* awaitYield(value) {
  return yield value;
}
function awaitYieldOf(generator) {
  return awaitYield(awaitEachYieldedPromise(generator));
}
const AwaitYield = awaitYield;
AwaitYield.of = awaitYieldOf;
function maybeAsyncFn(that, fn) {
  return (...args) => {
    const generator = fn.call(that, AwaitYield, ...args);
    return awaitEachYieldedPromise(generator);
  };
}
asyncifyHelpers.maybeAsyncFn = maybeAsyncFn;
function maybeAsync(that, startGenerator) {
  const generator = startGenerator.call(that, AwaitYield);
  return awaitEachYieldedPromise(generator);
}
asyncifyHelpers.maybeAsync = maybeAsync;
function awaitEachYieldedPromise(gen) {
  function handleNextStep(step) {
    if (step.done) {
      return step.value;
    }
    if (step.value instanceof Promise) {
      return step.value.then((value) => handleNextStep(gen.next(value)), (error) => handleNextStep(gen.throw(error)));
    }
    return handleNextStep(gen.next(step.value));
  }
  return handleNextStep(gen.next());
}
asyncifyHelpers.awaitEachYieldedPromise = awaitEachYieldedPromise;
Object.defineProperty(lifetime, "__esModule", { value: true });
lifetime.Scope = lifetime.WeakLifetime = lifetime.StaticLifetime = lifetime.Lifetime = void 0;
const asyncify_helpers_1 = asyncifyHelpers;
const debug_1$4 = debug$4;
const errors_1$1 = errors;
class Lifetime {
  /**
   * When the Lifetime is disposed, it will call `disposer(_value)`. Use the
   * disposer function to implement whatever cleanup needs to happen at the end
   * of `value`'s lifetime.
   *
   * `_owner` is not used or controlled by the lifetime. It's just metadata for
   * the creator.
   */
  constructor(_value2, copier, disposer, _owner) {
    this._value = _value2;
    this.copier = copier;
    this.disposer = disposer;
    this._owner = _owner;
    this._alive = true;
    this._constructorStack = debug_1$4.QTS_DEBUG ? new Error("Lifetime constructed").stack : void 0;
  }
  get alive() {
    return this._alive;
  }
  /**
   * The value this Lifetime protects. You must never retain the value - it
   * may become invalid, leading to memory errors.
   *
   * @throws If the lifetime has been [[dispose]]d already.
   */
  get value() {
    this.assertAlive();
    return this._value;
  }
  get owner() {
    return this._owner;
  }
  get dupable() {
    return !!this.copier;
  }
  /**
   * Create a new handle pointing to the same [[value]].
   */
  dup() {
    this.assertAlive();
    if (!this.copier) {
      throw new Error("Non-dupable lifetime");
    }
    return new Lifetime(this.copier(this._value), this.copier, this.disposer, this._owner);
  }
  consume(map2) {
    this.assertAlive();
    const result = map2(this);
    this.dispose();
    return result;
  }
  /**
   * Dispose of [[value]] and perform cleanup.
   */
  dispose() {
    this.assertAlive();
    if (this.disposer) {
      this.disposer(this._value);
    }
    this._alive = false;
  }
  assertAlive() {
    if (!this.alive) {
      if (this._constructorStack) {
        throw new errors_1$1.QuickJSUseAfterFree(`Lifetime not alive
${this._constructorStack}
Lifetime used`);
      }
      throw new errors_1$1.QuickJSUseAfterFree("Lifetime not alive");
    }
  }
}
lifetime.Lifetime = Lifetime;
class StaticLifetime extends Lifetime {
  constructor(value, owner) {
    super(value, void 0, void 0, owner);
  }
  // Static lifetime doesn't need a copier to be copiable
  get dupable() {
    return true;
  }
  // Copy returns the same instance.
  dup() {
    return this;
  }
  // Dispose does nothing.
  dispose() {
  }
}
lifetime.StaticLifetime = StaticLifetime;
class WeakLifetime extends Lifetime {
  constructor(value, copier, disposer, owner) {
    super(value, copier, disposer, owner);
  }
  dispose() {
    this._alive = false;
  }
}
lifetime.WeakLifetime = WeakLifetime;
function scopeFinally(scope2, blockError) {
  let disposeError;
  try {
    scope2.dispose();
  } catch (error) {
    disposeError = error;
  }
  if (blockError && disposeError) {
    Object.assign(blockError, {
      message: `${blockError.message}
 Then, failed to dispose scope: ${disposeError.message}`,
      disposeError
    });
    throw blockError;
  }
  if (blockError || disposeError) {
    throw blockError || disposeError;
  }
}
class Scope {
  constructor() {
    this._disposables = new Lifetime(/* @__PURE__ */ new Set());
  }
  /**
   * Run `block` with a new Scope instance that will be disposed after the block returns.
   * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime
   * automatically disposed after the block returns.
   *
   * @warning Do not use with async functions. Instead, use [[withScopeAsync]].
   */
  static withScope(block) {
    const scope2 = new Scope();
    let blockError;
    try {
      return block(scope2);
    } catch (error) {
      blockError = error;
      throw error;
    } finally {
      scopeFinally(scope2, blockError);
    }
  }
  static withScopeMaybeAsync(_this, block) {
    return (0, asyncify_helpers_1.maybeAsync)(void 0, function* (awaited) {
      const scope2 = new Scope();
      let blockError;
      try {
        return yield* awaited.of(block.call(_this, awaited, scope2));
      } catch (error) {
        blockError = error;
        throw error;
      } finally {
        scopeFinally(scope2, blockError);
      }
    });
  }
  /**
   * Run `block` with a new Scope instance that will be disposed after the
   * block's returned promise settles. Inside `block`, call `scope.manage` on each
   * lifetime you create to have the lifetime automatically disposed after the
   * block returns.
   */
  static async withScopeAsync(block) {
    const scope2 = new Scope();
    let blockError;
    try {
      return await block(scope2);
    } catch (error) {
      blockError = error;
      throw error;
    } finally {
      scopeFinally(scope2, blockError);
    }
  }
  /**
   * Track `lifetime` so that it is disposed when this scope is disposed.
   */
  manage(lifetime2) {
    this._disposables.value.add(lifetime2);
    return lifetime2;
  }
  get alive() {
    return this._disposables.alive;
  }
  dispose() {
    const lifetimes = Array.from(this._disposables.value.values()).reverse();
    for (const lifetime2 of lifetimes) {
      if (lifetime2.alive) {
        lifetime2.dispose();
      }
    }
    this._disposables.dispose();
  }
}
lifetime.Scope = Scope;
var runtime = {};
var context = {};
var deferredPromise = {};
Object.defineProperty(deferredPromise, "__esModule", { value: true });
deferredPromise.QuickJSDeferredPromise = void 0;
class QuickJSDeferredPromise {
  /**
   * Use [[QuickJSContext.newPromise]] to create a new promise instead of calling
   * this constructor directly.
   * @unstable
   */
  constructor(args) {
    this.resolve = (value) => {
      if (!this.resolveHandle.alive) {
        return;
      }
      this.context.unwrapResult(this.context.callFunction(this.resolveHandle, this.context.undefined, value || this.context.undefined)).dispose();
      this.disposeResolvers();
      this.onSettled();
    };
    this.reject = (value) => {
      if (!this.rejectHandle.alive) {
        return;
      }
      this.context.unwrapResult(this.context.callFunction(this.rejectHandle, this.context.undefined, value || this.context.undefined)).dispose();
      this.disposeResolvers();
      this.onSettled();
    };
    this.dispose = () => {
      if (this.handle.alive) {
        this.handle.dispose();
      }
      this.disposeResolvers();
    };
    this.context = args.context;
    this.owner = args.context.runtime;
    this.handle = args.promiseHandle;
    this.settled = new Promise((resolve2) => {
      this.onSettled = resolve2;
    });
    this.resolveHandle = args.resolveHandle;
    this.rejectHandle = args.rejectHandle;
  }
  get alive() {
    return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive;
  }
  disposeResolvers() {
    if (this.resolveHandle.alive) {
      this.resolveHandle.dispose();
    }
    if (this.rejectHandle.alive) {
      this.rejectHandle.dispose();
    }
  }
}
deferredPromise.QuickJSDeferredPromise = QuickJSDeferredPromise;
var memory = {};
var hasRequiredMemory;
function requireMemory() {
  if (hasRequiredMemory)
    return memory;
  hasRequiredMemory = 1;
  Object.defineProperty(memory, "__esModule", { value: true });
  memory.ModuleMemory = void 0;
  const lifetime_12 = lifetime;
  class ModuleMemory {
    constructor(module2) {
      this.module = module2;
    }
    toPointerArray(handleArray) {
      const typedArray = new Int32Array(handleArray.map((handle) => handle.value));
      const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
      const ptr = this.module._malloc(numBytes);
      var heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes);
      heapBytes.set(new Uint8Array(typedArray.buffer));
      return new lifetime_12.Lifetime(ptr, void 0, (ptr2) => this.module._free(ptr2));
    }
    newMutablePointerArray(length) {
      const zeros = new Int32Array(new Array(length).fill(0));
      const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT;
      const ptr = this.module._malloc(numBytes);
      const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length);
      typedArray.set(zeros);
      return new lifetime_12.Lifetime({ typedArray, ptr }, void 0, (value) => this.module._free(value.ptr));
    }
    newHeapCharPointer(string) {
      const numBytes = this.module.lengthBytesUTF8(string) + 1;
      const ptr = this.module._malloc(numBytes);
      this.module.stringToUTF8(string, ptr, numBytes);
      return new lifetime_12.Lifetime(ptr, void 0, (value) => this.module._free(value));
    }
    consumeHeapCharPointer(ptr) {
      const str = this.module.UTF8ToString(ptr);
      this.module._free(ptr);
      return str;
    }
  }
  memory.ModuleMemory = ModuleMemory;
  return memory;
}
var types = {};
var typesFfi = {};
var hasRequiredTypesFfi;
function requireTypesFfi() {
  if (hasRequiredTypesFfi)
    return typesFfi;
  hasRequiredTypesFfi = 1;
  Object.defineProperty(typesFfi, "__esModule", { value: true });
  typesFfi.EvalFlags = typesFfi.assertSync = void 0;
  function assertSync(fn) {
    return function mustBeSync(...args) {
      const result = fn(...args);
      if (result && typeof result === "object" && result instanceof Promise) {
        throw new Error("Function unexpectedly returned a Promise");
      }
      return result;
    };
  }
  typesFfi.assertSync = assertSync;
  typesFfi.EvalFlags = {
    /** global code (default) */
    JS_EVAL_TYPE_GLOBAL: 0 << 0,
    /** module code */
    JS_EVAL_TYPE_MODULE: 1 << 0,
    /** direct call (internal use) */
    JS_EVAL_TYPE_DIRECT: 2 << 0,
    /** indirect call (internal use) */
    JS_EVAL_TYPE_INDIRECT: 3 << 0,
    JS_EVAL_TYPE_MASK: 3 << 0,
    /** force 'strict' mode */
    JS_EVAL_FLAG_STRICT: 1 << 3,
    /** force 'strip' mode */
    JS_EVAL_FLAG_STRIP: 1 << 4,
    /**
     * compile but do not run. The result is an object with a
     * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed
     * with JS_EvalFunction().
     */
    JS_EVAL_FLAG_COMPILE_ONLY: 1 << 5,
    /** don't include the stack frames before this eval in the Error() backtraces */
    JS_EVAL_FLAG_BACKTRACE_BARRIER: 1 << 6
  };
  return typesFfi;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  types.concat = types.evalOptionsToFlags = types.DefaultIntrinsics = void 0;
  const types_ffi_1 = requireTypesFfi();
  types.DefaultIntrinsics = Symbol("DefaultIntrinsics");
  function evalOptionsToFlags(evalOptions) {
    if (typeof evalOptions === "number") {
      return evalOptions;
    }
    if (evalOptions === void 0) {
      return 0;
    }
    const { type, strict, strip, compileOnly, backtraceBarrier } = evalOptions;
    let flags = 0;
    if (type === "global")
      flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_GLOBAL;
    if (type === "module")
      flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_MODULE;
    if (strict)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRICT;
    if (strip)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRIP;
    if (compileOnly)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY;
    if (backtraceBarrier)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER;
    return flags;
  }
  types.evalOptionsToFlags = evalOptionsToFlags;
  function concat2(...values) {
    let result = [];
    for (const value of values) {
      if (value !== void 0) {
        result = result.concat(value);
      }
    }
    return result;
  }
  types.concat = concat2;
  return types;
}
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext)
    return context;
  hasRequiredContext = 1;
  Object.defineProperty(context, "__esModule", { value: true });
  context.QuickJSContext = void 0;
  const debug_12 = debug$4;
  const deferred_promise_1 = deferredPromise;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const memory_1 = requireMemory();
  const types_1 = requireTypes();
  class ContextMemory extends memory_1.ModuleMemory {
    /** @private */
    constructor(args) {
      var _a3;
      super(args.module);
      this.scope = new lifetime_12.Scope();
      this.copyJSValue = (ptr) => {
        return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr);
      };
      this.freeJSValue = (ptr) => {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr);
      };
      (_a3 = args.ownedLifetimes) == null ? void 0 : _a3.forEach((lifetime2) => this.scope.manage(lifetime2));
      this.owner = args.owner;
      this.module = args.module;
      this.ffi = args.ffi;
      this.rt = args.rt;
      this.ctx = this.scope.manage(args.ctx);
    }
    get alive() {
      return this.scope.alive;
    }
    dispose() {
      return this.scope.dispose();
    }
    /**
     * Track `lifetime` so that it is disposed when this scope is disposed.
     */
    manage(lifetime2) {
      return this.scope.manage(lifetime2);
    }
    consumeJSCharPointer(ptr) {
      const str = this.module.UTF8ToString(ptr);
      this.ffi.QTS_FreeCString(this.ctx.value, ptr);
      return str;
    }
    heapValueHandle(ptr) {
      return new lifetime_12.Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner);
    }
  }
  class QuickJSContext {
    /**
     * Use {@link QuickJS.createVm} to create a QuickJSContext instance.
     */
    constructor(args) {
      this._undefined = void 0;
      this._null = void 0;
      this._false = void 0;
      this._true = void 0;
      this._global = void 0;
      this._BigInt = void 0;
      this.fnNextId = -32768;
      this.fnMaps = /* @__PURE__ */ new Map();
      this.cToHostCallbacks = {
        callFunction: (ctx, this_ptr, argc, argv, fn_id) => {
          if (ctx !== this.ctx.value) {
            throw new Error("QuickJSContext instance received C -> JS call with mismatched ctx");
          }
          const fn = this.getFunction(fn_id);
          if (!fn) {
            throw new Error(`QuickJSContext had no callback with id ${fn_id}`);
          }
          return lifetime_12.Scope.withScopeMaybeAsync(this, function* (awaited, scope2) {
            const thisHandle = scope2.manage(new lifetime_12.WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));
            const argHandles = new Array(argc);
            for (let i2 = 0; i2 < argc; i2++) {
              const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i2);
              argHandles[i2] = scope2.manage(new lifetime_12.WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));
            }
            try {
              const result = yield* awaited(fn.apply(thisHandle, argHandles));
              if (result) {
                if ("error" in result && result.error) {
                  (0, debug_12.debugLog)("throw error", result.error);
                  throw result.error;
                }
                const handle = scope2.manage(result instanceof lifetime_12.Lifetime ? result : result.value);
                return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value);
              }
              return 0;
            } catch (error) {
              return this.errorToHandle(error).consume((errorHandle) => this.ffi.QTS_Throw(this.ctx.value, errorHandle.value));
            }
          });
        }
      };
      this.runtime = args.runtime;
      this.module = args.module;
      this.ffi = args.ffi;
      this.rt = args.rt;
      this.ctx = args.ctx;
      this.memory = new ContextMemory({
        ...args,
        owner: this.runtime
      });
      args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks);
      this.dump = this.dump.bind(this);
      this.getString = this.getString.bind(this);
      this.getNumber = this.getNumber.bind(this);
      this.resolvePromise = this.resolvePromise.bind(this);
    }
    // @implement Disposable ----------------------------------------------------
    get alive() {
      return this.memory.alive;
    }
    /**
     * Dispose of this VM's underlying resources.
     *
     * @throws Calling this method without disposing of all created handles
     * will result in an error.
     */
    dispose() {
      this.memory.dispose();
    }
    // Globals ------------------------------------------------------------------
    /**
     * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).
     */
    get undefined() {
      if (this._undefined) {
        return this._undefined;
      }
      const ptr = this.ffi.QTS_GetUndefined();
      return this._undefined = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).
     */
    get null() {
      if (this._null) {
        return this._null;
      }
      const ptr = this.ffi.QTS_GetNull();
      return this._null = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).
     */
    get true() {
      if (this._true) {
        return this._true;
      }
      const ptr = this.ffi.QTS_GetTrue();
      return this._true = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).
     */
    get false() {
      if (this._false) {
        return this._false;
      }
      const ptr = this.ffi.QTS_GetFalse();
      return this._false = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).
     * A handle to the global object inside the interpreter.
     * You can set properties to create global variables.
     */
    get global() {
      if (this._global) {
        return this._global;
      }
      const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value);
      this.memory.manage(this.memory.heapValueHandle(ptr));
      this._global = new lifetime_12.StaticLifetime(ptr, this.runtime);
      return this._global;
    }
    // New values ---------------------------------------------------------------
    /**
     * Converts a Javascript number into a QuickJS value.
     */
    newNumber(num) {
      return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num));
    }
    /**
     * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.
     */
    newString(str) {
      const ptr = this.memory.newHeapCharPointer(str).consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value));
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.
     * No two symbols created with this function will be the same value.
     */
    newUniqueSymbol(description2) {
      const key = (typeof description2 === "symbol" ? description2.description : description2) ?? "";
      const ptr = this.memory.newHeapCharPointer(key).consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0));
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.
     * All symbols created with the same key will be the same value.
     */
    newSymbolFor(key) {
      const description2 = (typeof key === "symbol" ? key.description : key) ?? "";
      const ptr = this.memory.newHeapCharPointer(description2).consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1));
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.
     */
    newBigInt(num) {
      if (!this._BigInt) {
        const bigIntHandle2 = this.getProp(this.global, "BigInt");
        this.memory.manage(bigIntHandle2);
        this._BigInt = new lifetime_12.StaticLifetime(bigIntHandle2.value, this.runtime);
      }
      const bigIntHandle = this._BigInt;
      const asString = String(num);
      return this.newString(asString).consume((handle) => this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)));
    }
    /**
     * `{}`.
     * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).
     *
     * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).
     */
    newObject(prototype) {
      if (prototype) {
        this.runtime.assertOwned(prototype);
      }
      const ptr = prototype ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value) : this.ffi.QTS_NewObject(this.ctx.value);
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * `[]`.
     * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).
     */
    newArray() {
      const ptr = this.ffi.QTS_NewArray(this.ctx.value);
      return this.memory.heapValueHandle(ptr);
    }
    newPromise(value) {
      const deferredPromise2 = lifetime_12.Scope.withScope((scope2) => {
        const mutablePointerArray = scope2.manage(this.memory.newMutablePointerArray(2));
        const promisePtr = this.ffi.QTS_NewPromiseCapability(this.ctx.value, mutablePointerArray.value.ptr);
        const promiseHandle = this.memory.heapValueHandle(promisePtr);
        const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map((jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr));
        return new deferred_promise_1.QuickJSDeferredPromise({
          context: this,
          promiseHandle,
          resolveHandle,
          rejectHandle
        });
      });
      if (value && typeof value === "function") {
        value = new Promise(value);
      }
      if (value) {
        Promise.resolve(value).then(deferredPromise2.resolve, (error) => error instanceof lifetime_12.Lifetime ? deferredPromise2.reject(error) : this.newError(error).consume(deferredPromise2.reject));
      }
      return deferredPromise2;
    }
    /**
     * Convert a Javascript function into a QuickJS function value.
     * See [[VmFunctionImplementation]] for more details.
     *
     * A [[VmFunctionImplementation]] should not free its arguments or its return
     * value. A VmFunctionImplementation should also not retain any references to
     * its return value.
     *
     * To implement an async function, create a promise with [[newPromise]], then
     * return the deferred promise handle from `deferred.handle` from your
     * function implementation:
     *
     * ```
     * const deferred = vm.newPromise()
     * someNativeAsyncFunction().then(deferred.resolve)
     * return deferred.handle
     * ```
     */
    newFunction(name2, fn) {
      const fnId = ++this.fnNextId;
      this.setFunction(fnId, fn);
      return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name2));
    }
    newError(error) {
      const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));
      if (error && typeof error === "object") {
        if (error.name !== void 0) {
          this.newString(error.name).consume((handle) => this.setProp(errorHandle, "name", handle));
        }
        if (error.message !== void 0) {
          this.newString(error.message).consume((handle) => this.setProp(errorHandle, "message", handle));
        }
      } else if (typeof error === "string") {
        this.newString(error).consume((handle) => this.setProp(errorHandle, "message", handle));
      } else if (error !== void 0) {
        this.newString(String(error)).consume((handle) => this.setProp(errorHandle, "message", handle));
      }
      return errorHandle;
    }
    // Read values --------------------------------------------------------------
    /**
     * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).
     *
     * @remarks
     * Does not support BigInt values correctly.
     */
    typeof(handle) {
      this.runtime.assertOwned(handle);
      return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value));
    }
    /**
     * Converts `handle` into a Javascript number.
     * @returns `NaN` on error, otherwise a `number`.
     */
    getNumber(handle) {
      this.runtime.assertOwned(handle);
      return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value);
    }
    /**
     * Converts `handle` to a Javascript string.
     */
    getString(handle) {
      this.runtime.assertOwned(handle);
      return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value));
    }
    /**
     * Converts `handle` into a Javascript symbol. If the symbol is in the global
     * registry in the guest, it will be created with Symbol.for on the host.
     */
    getSymbol(handle) {
      this.runtime.assertOwned(handle);
      const key = this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value));
      const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value);
      return isGlobal ? Symbol.for(key) : Symbol(key);
    }
    /**
     * Converts `handle` to a Javascript bigint.
     */
    getBigInt(handle) {
      this.runtime.assertOwned(handle);
      const asString = this.getString(handle);
      return BigInt(asString);
    }
    /**
     * `Promise.resolve(value)`.
     * Convert a handle containing a Promise-like value inside the VM into an
     * actual promise on the host.
     *
     * @remarks
     * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.
     *
     * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.
     */
    resolvePromise(promiseLikeHandle) {
      this.runtime.assertOwned(promiseLikeHandle);
      const vmResolveResult = lifetime_12.Scope.withScope((scope2) => {
        const vmPromise = scope2.manage(this.getProp(this.global, "Promise"));
        const vmPromiseResolve = scope2.manage(this.getProp(vmPromise, "resolve"));
        return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle);
      });
      if (vmResolveResult.error) {
        return Promise.resolve(vmResolveResult);
      }
      return new Promise((resolve2) => {
        lifetime_12.Scope.withScope((scope2) => {
          const resolveHandle = scope2.manage(this.newFunction("resolve", (value) => {
            resolve2({ value: value && value.dup() });
          }));
          const rejectHandle = scope2.manage(this.newFunction("reject", (error) => {
            resolve2({ error: error && error.dup() });
          }));
          const promiseHandle = scope2.manage(vmResolveResult.value);
          const promiseThenHandle = scope2.manage(this.getProp(promiseHandle, "then"));
          this.unwrapResult(this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)).dispose();
        });
      });
    }
    // Properties ---------------------------------------------------------------
    /**
     * `handle[key]`.
     * Get a property from a JSValue.
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string (which will be converted automatically).
     */
    getProp(handle, key) {
      this.runtime.assertOwned(handle);
      const ptr = this.borrowPropertyKey(key).consume((quickJSKey) => this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value));
      const result = this.memory.heapValueHandle(ptr);
      return result;
    }
    /**
     * `handle[key] = value`.
     * Set a property on a JSValue.
     *
     * @remarks
     * Note that the QuickJS authors recommend using [[defineProp]] to define new
     * properties.
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string or number (which will be converted automatically to a JSValue).
     */
    setProp(handle, key, value) {
      this.runtime.assertOwned(handle);
      this.borrowPropertyKey(key).consume((quickJSKey) => this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value));
    }
    /**
     * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string or number (which will be converted automatically to a JSValue).
     */
    defineProp(handle, key, descriptor) {
      this.runtime.assertOwned(handle);
      lifetime_12.Scope.withScope((scope2) => {
        const quickJSKey = scope2.manage(this.borrowPropertyKey(key));
        const value = descriptor.value || this.undefined;
        const configurable = Boolean(descriptor.configurable);
        const enumerable = Boolean(descriptor.enumerable);
        const hasValue = Boolean(descriptor.value);
        const get2 = descriptor.get ? scope2.manage(this.newFunction(descriptor.get.name, descriptor.get)) : this.undefined;
        const set = descriptor.set ? scope2.manage(this.newFunction(descriptor.set.name, descriptor.set)) : this.undefined;
        this.ffi.QTS_DefineProp(this.ctx.value, handle.value, quickJSKey.value, value.value, get2.value, set.value, configurable, enumerable, hasValue);
      });
    }
    // Evaluation ---------------------------------------------------------------
    /**
     * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).
     * Call a JSValue as a function.
     *
     * See [[unwrapResult]], which will throw if the function returned an error, or
     * return the result handle directly. If evaluation returned a handle containing
     * a promise, use [[resolvePromise]] to convert it to a native promise and
     * [[executePendingJobs]] to finish evaluating the promise.
     *
     * @returns A result. If the function threw synchronously, `result.error` be a
     * handle to the exception. Otherwise `result.value` will be a handle to the
     * value.
     */
    callFunction(func, thisVal, ...args) {
      this.runtime.assertOwned(func);
      const resultPtr = this.memory.toPointerArray(args).consume((argsArrayPtr) => this.ffi.QTS_Call(this.ctx.value, func.value, thisVal.value, args.length, argsArrayPtr.value));
      const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
      if (errorPtr) {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
        return { error: this.memory.heapValueHandle(errorPtr) };
      }
      return { value: this.memory.heapValueHandle(resultPtr) };
    }
    /**
     * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).
     * Evaluates the Javascript source `code` in the global scope of this VM.
     * When working with async code, you many need to call [[executePendingJobs]]
     * to execute callbacks pending after synchronous evaluation returns.
     *
     * See [[unwrapResult]], which will throw if the function returned an error, or
     * return the result handle directly. If evaluation returned a handle containing
     * a promise, use [[resolvePromise]] to convert it to a native promise and
     * [[executePendingJobs]] to finish evaluating the promise.
     *
     * *Note*: to protect against infinite loops, provide an interrupt handler to
     * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to
     * create a time-based deadline.
     *
     * @returns The last statement's value. If the code threw synchronously,
     * `result.error` will be a handle to the exception. If execution was
     * interrupted, the error will have name `InternalError` and message
     * `interrupted`.
     */
    evalCode(code2, filename = "eval.js", options) {
      const detectModule = options === void 0 ? 1 : 0;
      const flags = (0, types_1.evalOptionsToFlags)(options);
      const resultPtr = this.memory.newHeapCharPointer(code2).consume((charHandle) => this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags));
      const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
      if (errorPtr) {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
        return { error: this.memory.heapValueHandle(errorPtr) };
      }
      return { value: this.memory.heapValueHandle(resultPtr) };
    }
    /**
     * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.
     * @experimental
     */
    throw(error) {
      return this.errorToHandle(error).consume((handle) => this.ffi.QTS_Throw(this.ctx.value, handle.value));
    }
    /**
     * @private
     */
    borrowPropertyKey(key) {
      if (typeof key === "number") {
        return this.newNumber(key);
      }
      if (typeof key === "string") {
        return this.newString(key);
      }
      return new lifetime_12.StaticLifetime(key.value, this.runtime);
    }
    /**
     * @private
     */
    getMemory(rt2) {
      if (rt2 === this.rt.value) {
        return this.memory;
      } else {
        throw new Error("Private API. Cannot get memory from a different runtime");
      }
    }
    // Utilities ----------------------------------------------------------------
    /**
     * Dump a JSValue to Javascript in a best-effort fashion.
     * Returns `handle.toString()` if it cannot be serialized to JSON.
     */
    dump(handle) {
      this.runtime.assertOwned(handle);
      const type = this.typeof(handle);
      if (type === "string") {
        return this.getString(handle);
      } else if (type === "number") {
        return this.getNumber(handle);
      } else if (type === "bigint") {
        return this.getBigInt(handle);
      } else if (type === "undefined") {
        return void 0;
      } else if (type === "symbol") {
        return this.getSymbol(handle);
      }
      const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value));
      try {
        return JSON.parse(str);
      } catch (err) {
        return str;
      }
    }
    /**
     * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a
     * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.
     * If the result is a success, returns the value.
     * If the result is an error, converts the error to a native object and throws the error.
     */
    unwrapResult(result) {
      if (result.error) {
        const context2 = "context" in result.error ? result.error.context : this;
        const cause = result.error.consume((error) => this.dump(error));
        if (cause && typeof cause === "object" && typeof cause.message === "string") {
          const { message: message2, name: name2, stack } = cause;
          const exception = new errors_12.QuickJSUnwrapError("");
          const hostStack = exception.stack;
          if (typeof name2 === "string") {
            exception.name = cause.name;
          }
          if (typeof stack === "string") {
            exception.stack = `${name2}: ${message2}
${cause.stack}Host: ${hostStack}`;
          }
          Object.assign(exception, { cause, context: context2, message: message2 });
          throw exception;
        }
        throw new errors_12.QuickJSUnwrapError(cause, context2);
      }
      return result.value;
    }
    /** @private */
    getFunction(fn_id) {
      const map_id = fn_id >> 8;
      const fnMap = this.fnMaps.get(map_id);
      if (!fnMap) {
        return void 0;
      }
      return fnMap.get(fn_id);
    }
    /** @private */
    setFunction(fn_id, handle) {
      const map_id = fn_id >> 8;
      let fnMap = this.fnMaps.get(map_id);
      if (!fnMap) {
        fnMap = /* @__PURE__ */ new Map();
        this.fnMaps.set(map_id, fnMap);
      }
      return fnMap.set(fn_id, handle);
    }
    errorToHandle(error) {
      if (error instanceof lifetime_12.Lifetime) {
        return error;
      }
      return this.newError(error);
    }
  }
  context.QuickJSContext = QuickJSContext;
  return context;
}
var hasRequiredRuntime;
function requireRuntime() {
  if (hasRequiredRuntime)
    return runtime;
  hasRequiredRuntime = 1;
  Object.defineProperty(runtime, "__esModule", { value: true });
  runtime.QuickJSRuntime = void 0;
  const asyncify_helpers_12 = asyncifyHelpers;
  const context_1 = requireContext();
  const debug_12 = debug$4;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const memory_1 = requireMemory();
  const types_1 = requireTypes();
  class QuickJSRuntime {
    /** @private */
    constructor(args) {
      var _a3;
      this.scope = new lifetime_12.Scope();
      this.contextMap = /* @__PURE__ */ new Map();
      this.cToHostCallbacks = {
        shouldInterrupt: (rt2) => {
          if (rt2 !== this.rt.value) {
            throw new Error("QuickJSContext instance received C -> JS interrupt with mismatched rt");
          }
          const fn = this.interruptHandler;
          if (!fn) {
            throw new Error("QuickJSContext had no interrupt handler");
          }
          return fn(this) ? 1 : 0;
        },
        loadModuleSource: (0, asyncify_helpers_12.maybeAsyncFn)(this, function* (awaited, rt2, ctx, moduleName) {
          const moduleLoader = this.moduleLoader;
          if (!moduleLoader) {
            throw new Error("Runtime has no module loader");
          }
          if (rt2 !== this.rt.value) {
            throw new Error("Runtime pointer mismatch");
          }
          const context2 = this.contextMap.get(ctx) ?? this.newContext({
            contextPointer: ctx
          });
          try {
            const result = yield* awaited(moduleLoader(moduleName, context2));
            if (typeof result === "object" && "error" in result && result.error) {
              (0, debug_12.debugLog)("cToHostLoadModule: loader returned error", result.error);
              throw result.error;
            }
            const moduleSource = typeof result === "string" ? result : "value" in result ? result.value : result;
            return this.memory.newHeapCharPointer(moduleSource).value;
          } catch (error) {
            (0, debug_12.debugLog)("cToHostLoadModule: caught error", error);
            context2.throw(error);
            return 0;
          }
        }),
        normalizeModule: (0, asyncify_helpers_12.maybeAsyncFn)(this, function* (awaited, rt2, ctx, baseModuleName, moduleNameRequest) {
          const moduleNormalizer = this.moduleNormalizer;
          if (!moduleNormalizer) {
            throw new Error("Runtime has no module normalizer");
          }
          if (rt2 !== this.rt.value) {
            throw new Error("Runtime pointer mismatch");
          }
          const context2 = this.contextMap.get(ctx) ?? this.newContext({
            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */
            contextPointer: ctx
          });
          try {
            const result = yield* awaited(moduleNormalizer(baseModuleName, moduleNameRequest, context2));
            if (typeof result === "object" && "error" in result && result.error) {
              (0, debug_12.debugLog)("cToHostNormalizeModule: normalizer returned error", result.error);
              throw result.error;
            }
            const name2 = typeof result === "string" ? result : result.value;
            return context2.getMemory(this.rt.value).newHeapCharPointer(name2).value;
          } catch (error) {
            (0, debug_12.debugLog)("normalizeModule: caught error", error);
            context2.throw(error);
            return 0;
          }
        })
      };
      (_a3 = args.ownedLifetimes) == null ? void 0 : _a3.forEach((lifetime2) => this.scope.manage(lifetime2));
      this.module = args.module;
      this.memory = new memory_1.ModuleMemory(this.module);
      this.ffi = args.ffi;
      this.rt = args.rt;
      this.callbacks = args.callbacks;
      this.scope.manage(this.rt);
      this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks);
      this.executePendingJobs = this.executePendingJobs.bind(this);
    }
    get alive() {
      return this.scope.alive;
    }
    dispose() {
      return this.scope.dispose();
    }
    newContext(options = {}) {
      if (options.intrinsics && options.intrinsics !== types_1.DefaultIntrinsics) {
        throw new Error("TODO: Custom intrinsics are not supported yet");
      }
      const ctx = new lifetime_12.Lifetime(options.contextPointer || this.ffi.QTS_NewContext(this.rt.value), void 0, (ctx_ptr) => {
        this.contextMap.delete(ctx_ptr);
        this.callbacks.deleteContext(ctx_ptr);
        this.ffi.QTS_FreeContext(ctx_ptr);
      });
      const context2 = new context_1.QuickJSContext({
        module: this.module,
        ctx,
        ffi: this.ffi,
        rt: this.rt,
        ownedLifetimes: options.ownedLifetimes,
        runtime: this,
        callbacks: this.callbacks
      });
      this.contextMap.set(ctx.value, context2);
      return context2;
    }
    /**
     * Set the loader for EcmaScript modules requested by any context in this
     * runtime.
     *
     * The loader can be removed with [[removeModuleLoader]].
     */
    setModuleLoader(moduleLoader, moduleNormalizer) {
      this.moduleLoader = moduleLoader;
      this.moduleNormalizer = moduleNormalizer;
      this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0);
    }
    /**
     * Remove the the loader set by [[setModuleLoader]]. This disables module loading.
     */
    removeModuleLoader() {
      this.moduleLoader = void 0;
      this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value);
    }
    // Runtime management -------------------------------------------------------
    /**
     * In QuickJS, promises and async functions create pendingJobs. These do not execute
     * immediately and need to be run by calling [[executePendingJobs]].
     *
     * @return true if there is at least one pendingJob queued up.
     */
    hasPendingJob() {
      return Boolean(this.ffi.QTS_IsJobPending(this.rt.value));
    }
    /**
     * Set a callback which is regularly called by the QuickJS engine when it is
     * executing code. This callback can be used to implement an execution
     * timeout.
     *
     * The interrupt handler can be removed with [[removeInterruptHandler]].
     */
    setInterruptHandler(cb) {
      const prevInterruptHandler = this.interruptHandler;
      this.interruptHandler = cb;
      if (!prevInterruptHandler) {
        this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value);
      }
    }
    /**
     * Remove the interrupt handler, if any.
     * See [[setInterruptHandler]].
     */
    removeInterruptHandler() {
      if (this.interruptHandler) {
        this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value);
        this.interruptHandler = void 0;
      }
    }
    /**
     * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are
     * executed (default all pendingJobs), the queue is exhausted, or the runtime
     * encounters an exception.
     *
     * In QuickJS, promises and async functions *inside the runtime* create
     * pendingJobs. These do not execute immediately and need to triggered to run.
     *
     * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute
     * at most `maxJobsToExecute` before returning.
     *
     * @return On success, the number of executed jobs. On error, the exception
     * that stopped execution, and the context it occurred in. Note that
     * executePendingJobs will not normally return errors thrown inside async
     * functions or rejected promises. Those errors are available by calling
     * [[resolvePromise]] on the promise handle returned by the async function.
     */
    executePendingJobs(maxJobsToExecute = -1) {
      const ctxPtrOut = this.memory.newMutablePointerArray(1);
      const valuePtr = this.ffi.QTS_ExecutePendingJob(this.rt.value, maxJobsToExecute ?? -1, ctxPtrOut.value.ptr);
      const ctxPtr = ctxPtrOut.value.typedArray[0];
      ctxPtrOut.dispose();
      if (ctxPtr === 0) {
        this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr);
        return { value: 0 };
      }
      const context2 = this.contextMap.get(ctxPtr) ?? this.newContext({
        contextPointer: ctxPtr
      });
      const resultValue = context2.getMemory(this.rt.value).heapValueHandle(valuePtr);
      const typeOfRet = context2.typeof(resultValue);
      if (typeOfRet === "number") {
        const executedJobs = context2.getNumber(resultValue);
        resultValue.dispose();
        return { value: executedJobs };
      } else {
        const error = Object.assign(resultValue, { context: context2 });
        return {
          error
        };
      }
    }
    /**
     * Set the max memory this runtime can allocate.
     * To remove the limit, set to `-1`.
     */
    setMemoryLimit(limitBytes) {
      if (limitBytes < 0 && limitBytes !== -1) {
        throw new Error("Cannot set memory limit to negative number. To unset, pass -1");
      }
      this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes);
    }
    /**
     * Compute memory usage for this runtime. Returns the result as a handle to a
     * JSValue object. Use [[QuickJSContext.dump]] to convert to a native object.
     * Calling this method will allocate more memory inside the runtime. The information
     * is accurate as of just before the call to `computeMemoryUsage`.
     * For a human-digestible representation, see [[dumpMemoryUsage]].
     */
    computeMemoryUsage() {
      const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value);
      return serviceContextMemory.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value));
    }
    /**
     * @returns a human-readable description of memory usage in this runtime.
     * For programmatic access to this information, see [[computeMemoryUsage]].
     */
    dumpMemoryUsage() {
      return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value));
    }
    /**
     * Set the max stack size for this runtime, in bytes.
     * To remove the limit, set to `0`.
     */
    setMaxStackSize(stackSize) {
      if (stackSize < 0) {
        throw new Error("Cannot set memory limit to negative number. To unset, pass 0.");
      }
      this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize);
    }
    /**
     * Assert that `handle` is owned by this runtime.
     * @throws QuickJSWrongOwner if owned by a different runtime.
     */
    assertOwned(handle) {
      if (handle.owner && handle.owner.rt !== this.rt) {
        throw new errors_12.QuickJSWrongOwner(`Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`);
      }
    }
    getSystemContext() {
      if (!this.context) {
        this.context = this.scope.manage(this.newContext());
      }
      return this.context;
    }
  }
  runtime.QuickJSRuntime = QuickJSRuntime;
  return runtime;
}
var hasRequiredModule;
function requireModule() {
  if (hasRequiredModule)
    return module$1;
  hasRequiredModule = 1;
  Object.defineProperty(module$1, "__esModule", { value: true });
  module$1.QuickJSWASMModule = module$1.applyModuleEvalRuntimeOptions = module$1.applyBaseRuntimeOptions = module$1.QuickJSModuleCallbacks = void 0;
  const debug_12 = debug$4;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const runtime_1 = requireRuntime();
  const types_1 = requireTypes();
  class QuickJSEmscriptenModuleCallbacks {
    constructor(args) {
      this.callFunction = args.callFunction;
      this.shouldInterrupt = args.shouldInterrupt;
      this.loadModuleSource = args.loadModuleSource;
      this.normalizeModule = args.normalizeModule;
    }
  }
  class QuickJSModuleCallbacks {
    constructor(module2) {
      this.contextCallbacks = /* @__PURE__ */ new Map();
      this.runtimeCallbacks = /* @__PURE__ */ new Map();
      this.suspendedCount = 0;
      this.cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({
        callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) => this.handleAsyncify(asyncify, () => {
          try {
            const vm = this.contextCallbacks.get(ctx);
            if (!vm) {
              throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call "${fn_id}"`);
            }
            return vm.callFunction(ctx, this_ptr, argc, argv, fn_id);
          } catch (error) {
            console.error("[C to host error: returning null]", error);
            return 0;
          }
        }),
        shouldInterrupt: (asyncify, rt2) => this.handleAsyncify(asyncify, () => {
          try {
            const vm = this.runtimeCallbacks.get(rt2);
            if (!vm) {
              throw new Error(`QuickJSRuntime(rt = ${rt2}) not found for C interrupt`);
            }
            return vm.shouldInterrupt(rt2);
          } catch (error) {
            console.error("[C to host interrupt: returning error]", error);
            return 1;
          }
        }),
        loadModuleSource: (asyncify, rt2, ctx, moduleName) => this.handleAsyncify(asyncify, () => {
          try {
            const runtimeCallbacks = this.runtimeCallbacks.get(rt2);
            if (!runtimeCallbacks) {
              throw new Error(`QuickJSRuntime(rt = ${rt2}) not found for C module loader`);
            }
            const loadModule = runtimeCallbacks.loadModuleSource;
            if (!loadModule) {
              throw new Error(`QuickJSRuntime(rt = ${rt2}) does not support module loading`);
            }
            return loadModule(rt2, ctx, moduleName);
          } catch (error) {
            console.error("[C to host module loader error: returning null]", error);
            return 0;
          }
        }),
        normalizeModule: (asyncify, rt2, ctx, moduleBaseName, moduleName) => this.handleAsyncify(asyncify, () => {
          try {
            const runtimeCallbacks = this.runtimeCallbacks.get(rt2);
            if (!runtimeCallbacks) {
              throw new Error(`QuickJSRuntime(rt = ${rt2}) not found for C module loader`);
            }
            const normalizeModule = runtimeCallbacks.normalizeModule;
            if (!normalizeModule) {
              throw new Error(`QuickJSRuntime(rt = ${rt2}) does not support module loading`);
            }
            return normalizeModule(rt2, ctx, moduleBaseName, moduleName);
          } catch (error) {
            console.error("[C to host module loader error: returning null]", error);
            return 0;
          }
        })
      });
      this.module = module2;
      this.module.callbacks = this.cToHostCallbacks;
    }
    setRuntimeCallbacks(rt2, callbacks) {
      this.runtimeCallbacks.set(rt2, callbacks);
    }
    deleteRuntime(rt2) {
      this.runtimeCallbacks.delete(rt2);
    }
    setContextCallbacks(ctx, callbacks) {
      this.contextCallbacks.set(ctx, callbacks);
    }
    deleteContext(ctx) {
      this.contextCallbacks.delete(ctx);
    }
    handleAsyncify(asyncify, fn) {
      if (asyncify) {
        return asyncify.handleSleep((done) => {
          try {
            const result = fn();
            if (!(result instanceof Promise)) {
              (0, debug_12.debugLog)("asyncify.handleSleep: not suspending:", result);
              done(result);
              return;
            }
            if (this.suspended) {
              throw new errors_12.QuickJSAsyncifyError(`Already suspended at: ${this.suspended.stack}
Attempted to suspend at:`);
            } else {
              this.suspended = new errors_12.QuickJSAsyncifySuspended(`(${this.suspendedCount++})`);
              (0, debug_12.debugLog)("asyncify.handleSleep: suspending:", this.suspended);
            }
            result.then((resolvedResult) => {
              this.suspended = void 0;
              (0, debug_12.debugLog)("asyncify.handleSleep: resolved:", resolvedResult);
              done(resolvedResult);
            }, (error) => {
              (0, debug_12.debugLog)("asyncify.handleSleep: rejected:", error);
              console.error("QuickJS: cannot handle error in suspended function", error);
              this.suspended = void 0;
            });
          } catch (error) {
            (0, debug_12.debugLog)("asyncify.handleSleep: error:", error);
            this.suspended = void 0;
            throw error;
          }
        });
      }
      const value = fn();
      if (value instanceof Promise) {
        throw new Error("Promise return value not supported in non-asyncify context.");
      }
      return value;
    }
  }
  module$1.QuickJSModuleCallbacks = QuickJSModuleCallbacks;
  function applyBaseRuntimeOptions(runtime2, options) {
    if (options.interruptHandler) {
      runtime2.setInterruptHandler(options.interruptHandler);
    }
    if (options.maxStackSizeBytes !== void 0) {
      runtime2.setMaxStackSize(options.maxStackSizeBytes);
    }
    if (options.memoryLimitBytes !== void 0) {
      runtime2.setMemoryLimit(options.memoryLimitBytes);
    }
  }
  module$1.applyBaseRuntimeOptions = applyBaseRuntimeOptions;
  function applyModuleEvalRuntimeOptions(runtime2, options) {
    if (options.moduleLoader) {
      runtime2.setModuleLoader(options.moduleLoader);
    }
    if (options.shouldInterrupt) {
      runtime2.setInterruptHandler(options.shouldInterrupt);
    }
    if (options.memoryLimitBytes !== void 0) {
      runtime2.setMemoryLimit(options.memoryLimitBytes);
    }
    if (options.maxStackSizeBytes !== void 0) {
      runtime2.setMaxStackSize(options.maxStackSizeBytes);
    }
  }
  module$1.applyModuleEvalRuntimeOptions = applyModuleEvalRuntimeOptions;
  class QuickJSWASMModule {
    /** @private */
    constructor(module2, ffi) {
      this.module = module2;
      this.ffi = ffi;
      this.callbacks = new QuickJSModuleCallbacks(module2);
    }
    /**
     * Create a runtime.
     * Use the runtime to set limits on CPU and memory usage and configure module
     * loading for one or more [[QuickJSContext]]s inside the runtime.
     */
    newRuntime(options = {}) {
      const rt2 = new lifetime_12.Lifetime(this.ffi.QTS_NewRuntime(), void 0, (rt_ptr) => {
        this.callbacks.deleteRuntime(rt_ptr);
        this.ffi.QTS_FreeRuntime(rt_ptr);
      });
      const runtime2 = new runtime_1.QuickJSRuntime({
        module: this.module,
        callbacks: this.callbacks,
        ffi: this.ffi,
        rt: rt2
      });
      applyBaseRuntimeOptions(runtime2, options);
      if (options.moduleLoader) {
        runtime2.setModuleLoader(options.moduleLoader);
      }
      return runtime2;
    }
    /**
     * A simplified API to create a new [[QuickJSRuntime]] and a
     * [[QuickJSContext]] inside that runtime at the same time. The runtime will
     * be disposed when the context is disposed.
     */
    newContext(options = {}) {
      const runtime2 = this.newRuntime();
      const context2 = runtime2.newContext({
        ...options,
        ownedLifetimes: (0, types_1.concat)(runtime2, options.ownedLifetimes)
      });
      runtime2.context = context2;
      return context2;
    }
    /**
     * One-off evaluate code without needing to create a [[QuickJSRuntime]] or
     * [[QuickJSContext]] explicitly.
     *
     * To protect against infinite loops, use the `shouldInterrupt` option. The
     * [[shouldInterruptAfterDeadline]] function will create a time-based deadline.
     *
     * If you need more control over how the code executes, create a
     * [[QuickJSRuntime]] (with [[newRuntime]]) or a [[QuickJSContext]] (with
     * [[newContext]] or [[QuickJSRuntime.newContext]]), and use its
     * [[QuickJSContext.evalCode]] method.
     *
     * Asynchronous callbacks may not run during the first call to `evalCode`. If
     * you need to work with async code inside QuickJS, create a runtime and use
     * [[QuickJSRuntime.executePendingJobs]].
     *
     * @returns The result is coerced to a native Javascript value using JSON
     * serialization, so properties and values unsupported by JSON will be dropped.
     *
     * @throws If `code` throws during evaluation, the exception will be
     * converted into a native Javascript value and thrown.
     *
     * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error
     * with name `"InternalError"` and  message `"interrupted"`.
     */
    evalCode(code2, options = {}) {
      return lifetime_12.Scope.withScope((scope2) => {
        const vm = scope2.manage(this.newContext());
        applyModuleEvalRuntimeOptions(vm.runtime, options);
        const result = vm.evalCode(code2, "eval.js");
        if (options.memoryLimitBytes !== void 0) {
          vm.runtime.setMemoryLimit(-1);
        }
        if (result.error) {
          const error = vm.dump(scope2.manage(result.error));
          throw error;
        }
        const value = vm.dump(scope2.manage(result.value));
        return value;
      });
    }
    /**
     * Get a low-level interface to the QuickJS functions in this WebAssembly
     * module.
     * @experimental
     * @unstable No warranty is provided with this API. It could change at any time.
     * @private
     */
    getFFI() {
      return this.ffi;
    }
  }
  module$1.QuickJSWASMModule = QuickJSWASMModule;
  return module$1;
}
var moduleAsyncify = {};
var runtimeAsyncify = {};
var contextAsyncify = {};
var hasRequiredContextAsyncify;
function requireContextAsyncify() {
  if (hasRequiredContextAsyncify)
    return contextAsyncify;
  hasRequiredContextAsyncify = 1;
  Object.defineProperty(contextAsyncify, "__esModule", { value: true });
  contextAsyncify.QuickJSAsyncContext = void 0;
  const context_1 = requireContext();
  const debug_12 = debug$4;
  const types_1 = requireTypes();
  class QuickJSAsyncContext extends context_1.QuickJSContext {
    /**
     * Asyncified version of [[evalCode]].
     */
    async evalCodeAsync(code2, filename = "eval.js", options) {
      const detectModule = options === void 0 ? 1 : 0;
      const flags = (0, types_1.evalOptionsToFlags)(options);
      let resultPtr = 0;
      try {
        resultPtr = await this.memory.newHeapCharPointer(code2).consume((charHandle) => this.ffi.QTS_Eval_MaybeAsync(this.ctx.value, charHandle.value, filename, detectModule, flags));
      } catch (error) {
        (0, debug_12.debugLog)("QTS_Eval_MaybeAsync threw", error);
        throw error;
      }
      const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
      if (errorPtr) {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
        return { error: this.memory.heapValueHandle(errorPtr) };
      }
      return { value: this.memory.heapValueHandle(resultPtr) };
    }
    /**
     * Similar to [[newFunction]].
     * Convert an async host Javascript function into a synchronous QuickJS function value.
     *
     * Whenever QuickJS calls this function, the VM's stack will be unwound while
     * waiting the async function to complete, and then restored when the returned
     * promise resolves.
     *
     * Asyncified functions must never call other asyncified functions or
     * `import`, even indirectly, because the stack cannot be unwound twice.
     *
     * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).
     */
    newAsyncifiedFunction(name2, fn) {
      return this.newFunction(name2, fn);
    }
  }
  contextAsyncify.QuickJSAsyncContext = QuickJSAsyncContext;
  return contextAsyncify;
}
var hasRequiredRuntimeAsyncify;
function requireRuntimeAsyncify() {
  if (hasRequiredRuntimeAsyncify)
    return runtimeAsyncify;
  hasRequiredRuntimeAsyncify = 1;
  Object.defineProperty(runtimeAsyncify, "__esModule", { value: true });
  runtimeAsyncify.QuickJSAsyncRuntime = void 0;
  const _1 = requireDist();
  const context_asyncify_1 = requireContextAsyncify();
  const runtime_1 = requireRuntime();
  const types_1 = requireTypes();
  class QuickJSAsyncRuntime extends runtime_1.QuickJSRuntime {
    /** @private */
    constructor(args) {
      super(args);
    }
    newContext(options = {}) {
      if (options.intrinsics && options.intrinsics !== types_1.DefaultIntrinsics) {
        throw new Error("TODO: Custom intrinsics are not supported yet");
      }
      const ctx = new _1.Lifetime(this.ffi.QTS_NewContext(this.rt.value), void 0, (ctx_ptr) => {
        this.contextMap.delete(ctx_ptr);
        this.callbacks.deleteContext(ctx_ptr);
        this.ffi.QTS_FreeContext(ctx_ptr);
      });
      const context2 = new context_asyncify_1.QuickJSAsyncContext({
        module: this.module,
        ctx,
        ffi: this.ffi,
        rt: this.rt,
        ownedLifetimes: [],
        runtime: this,
        callbacks: this.callbacks
      });
      this.contextMap.set(ctx.value, context2);
      return context2;
    }
    setModuleLoader(moduleLoader, moduleNormalizer) {
      super.setModuleLoader(moduleLoader, moduleNormalizer);
    }
    /**
     * Set the max stack size for this runtime in bytes.
     * To remove the limit, set to `0`.
     *
     * Setting this limit also adjusts the global `ASYNCIFY_STACK_SIZE` for the entire {@link QuickJSAsyncWASMModule}.
     * See the [pull request](https://github.com/justjake/quickjs-emscripten/pull/114) for more details.
     */
    setMaxStackSize(stackSize) {
      return super.setMaxStackSize(stackSize);
    }
  }
  runtimeAsyncify.QuickJSAsyncRuntime = QuickJSAsyncRuntime;
  return runtimeAsyncify;
}
var hasRequiredModuleAsyncify;
function requireModuleAsyncify() {
  if (hasRequiredModuleAsyncify)
    return moduleAsyncify;
  hasRequiredModuleAsyncify = 1;
  Object.defineProperty(moduleAsyncify, "__esModule", { value: true });
  moduleAsyncify.QuickJSAsyncWASMModule = void 0;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const module_1 = requireModule();
  const runtime_asyncify_1 = requireRuntimeAsyncify();
  class QuickJSAsyncWASMModule extends module_1.QuickJSWASMModule {
    /** @private */
    constructor(module2, ffi) {
      super(module2, ffi);
      this.ffi = ffi;
      this.module = module2;
    }
    /**
     * Create a new async runtime inside this WebAssembly module. All runtimes inside a
     * module are limited to a single async call at a time. For multiple
     * concurrent async actions, create multiple WebAssembly modules.
     */
    newRuntime(options = {}) {
      const rt2 = new lifetime_12.Lifetime(this.ffi.QTS_NewRuntime(), void 0, (rt_ptr) => {
        this.callbacks.deleteRuntime(rt_ptr);
        this.ffi.QTS_FreeRuntime(rt_ptr);
      });
      const runtime2 = new runtime_asyncify_1.QuickJSAsyncRuntime({
        module: this.module,
        ffi: this.ffi,
        rt: rt2,
        callbacks: this.callbacks
      });
      (0, module_1.applyBaseRuntimeOptions)(runtime2, options);
      if (options.moduleLoader) {
        runtime2.setModuleLoader(options.moduleLoader);
      }
      return runtime2;
    }
    /**
     * A simplified API to create a new [[QuickJSRuntime]] and a
     * [[QuickJSContext]] inside that runtime at the same time. The runtime will
     * be disposed when the context is disposed.
     */
    newContext(options = {}) {
      const runtime2 = this.newRuntime();
      const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime2]) : [runtime2];
      const context2 = runtime2.newContext({ ...options, ownedLifetimes: lifetimes });
      runtime2.context = context2;
      return context2;
    }
    /** Synchronous evalCode is not supported. */
    evalCode() {
      throw new errors_12.QuickJSNotImplemented("QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead");
    }
    /**
     * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or
     * [[QuickJSContextSync]] explicitly.
     *
     * This version allows for asynchronous Ecmascript module loading.
     *
     * Note that only a single async action can occur at a time inside the entire WebAssembly module.
     * **Multiple concurrent async actions is an error.**
     *
     * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.
     */
    evalCodeAsync(code2, options) {
      return lifetime_12.Scope.withScopeAsync(async (scope2) => {
        const vm = scope2.manage(this.newContext());
        (0, module_1.applyModuleEvalRuntimeOptions)(vm.runtime, options);
        const result = await vm.evalCodeAsync(code2, "eval.js");
        if (options.memoryLimitBytes !== void 0) {
          vm.runtime.setMemoryLimit(-1);
        }
        if (result.error) {
          const error = vm.dump(scope2.manage(result.error));
          throw error;
        }
        const value = vm.dump(scope2.manage(result.value));
        return value;
      });
    }
  }
  moduleAsyncify.QuickJSAsyncWASMModule = QuickJSAsyncWASMModule;
  return moduleAsyncify;
}
var ffi_WASM_RELEASE_SYNC = {};
var hasRequiredFfi_WASM_RELEASE_SYNC;
function requireFfi_WASM_RELEASE_SYNC() {
  if (hasRequiredFfi_WASM_RELEASE_SYNC)
    return ffi_WASM_RELEASE_SYNC;
  hasRequiredFfi_WASM_RELEASE_SYNC = 1;
  Object.defineProperty(ffi_WASM_RELEASE_SYNC, "__esModule", { value: true });
  ffi_WASM_RELEASE_SYNC.QuickJSFFI = void 0;
  class QuickJSFFI {
    constructor(module2) {
      this.module = module2;
      this.DEBUG = false;
      this.QTS_Throw = this.module.cwrap("QTS_Throw", "number", ["number", "number"]);
      this.QTS_NewError = this.module.cwrap("QTS_NewError", "number", ["number"]);
      this.QTS_RuntimeSetMemoryLimit = this.module.cwrap("QTS_RuntimeSetMemoryLimit", null, ["number", "number"]);
      this.QTS_RuntimeComputeMemoryUsage = this.module.cwrap("QTS_RuntimeComputeMemoryUsage", "number", ["number", "number"]);
      this.QTS_RuntimeDumpMemoryUsage = this.module.cwrap("QTS_RuntimeDumpMemoryUsage", "number", ["number"]);
      this.QTS_RecoverableLeakCheck = this.module.cwrap("QTS_RecoverableLeakCheck", "number", []);
      this.QTS_BuildIsSanitizeLeak = this.module.cwrap("QTS_BuildIsSanitizeLeak", "number", []);
      this.QTS_RuntimeSetMaxStackSize = this.module.cwrap("QTS_RuntimeSetMaxStackSize", null, ["number", "number"]);
      this.QTS_GetUndefined = this.module.cwrap("QTS_GetUndefined", "number", []);
      this.QTS_GetNull = this.module.cwrap("QTS_GetNull", "number", []);
      this.QTS_GetFalse = this.module.cwrap("QTS_GetFalse", "number", []);
      this.QTS_GetTrue = this.module.cwrap("QTS_GetTrue", "number", []);
      this.QTS_NewRuntime = this.module.cwrap("QTS_NewRuntime", "number", []);
      this.QTS_FreeRuntime = this.module.cwrap("QTS_FreeRuntime", null, ["number"]);
      this.QTS_NewContext = this.module.cwrap("QTS_NewContext", "number", ["number"]);
      this.QTS_FreeContext = this.module.cwrap("QTS_FreeContext", null, ["number"]);
      this.QTS_FreeValuePointer = this.module.cwrap("QTS_FreeValuePointer", null, ["number", "number"]);
      this.QTS_FreeValuePointerRuntime = this.module.cwrap("QTS_FreeValuePointerRuntime", null, ["number", "number"]);
      this.QTS_FreeVoidPointer = this.module.cwrap("QTS_FreeVoidPointer", null, ["number", "number"]);
      this.QTS_FreeCString = this.module.cwrap("QTS_FreeCString", null, ["number", "number"]);
      this.QTS_DupValuePointer = this.module.cwrap("QTS_DupValuePointer", "number", ["number", "number"]);
      this.QTS_NewObject = this.module.cwrap("QTS_NewObject", "number", ["number"]);
      this.QTS_NewObjectProto = this.module.cwrap("QTS_NewObjectProto", "number", ["number", "number"]);
      this.QTS_NewArray = this.module.cwrap("QTS_NewArray", "number", ["number"]);
      this.QTS_NewFloat64 = this.module.cwrap("QTS_NewFloat64", "number", ["number", "number"]);
      this.QTS_GetFloat64 = this.module.cwrap("QTS_GetFloat64", "number", ["number", "number"]);
      this.QTS_NewString = this.module.cwrap("QTS_NewString", "number", ["number", "number"]);
      this.QTS_GetString = this.module.cwrap("QTS_GetString", "number", ["number", "number"]);
      this.QTS_NewSymbol = this.module.cwrap("QTS_NewSymbol", "number", ["number", "number", "number"]);
      this.QTS_GetSymbolDescriptionOrKey = this.module.cwrap("QTS_GetSymbolDescriptionOrKey", "number", ["number", "number"]);
      this.QTS_IsGlobalSymbol = this.module.cwrap("QTS_IsGlobalSymbol", "number", ["number", "number"]);
      this.QTS_IsJobPending = this.module.cwrap("QTS_IsJobPending", "number", ["number"]);
      this.QTS_ExecutePendingJob = this.module.cwrap("QTS_ExecutePendingJob", "number", ["number", "number", "number"]);
      this.QTS_GetProp = this.module.cwrap("QTS_GetProp", "number", ["number", "number", "number"]);
      this.QTS_SetProp = this.module.cwrap("QTS_SetProp", null, ["number", "number", "number", "number"]);
      this.QTS_DefineProp = this.module.cwrap("QTS_DefineProp", null, ["number", "number", "number", "number", "number", "number", "boolean", "boolean", "boolean"]);
      this.QTS_Call = this.module.cwrap("QTS_Call", "number", ["number", "number", "number", "number", "number"]);
      this.QTS_ResolveException = this.module.cwrap("QTS_ResolveException", "number", ["number", "number"]);
      this.QTS_Dump = this.module.cwrap("QTS_Dump", "number", ["number", "number"]);
      this.QTS_Eval = this.module.cwrap("QTS_Eval", "number", ["number", "number", "string", "number", "number"]);
      this.QTS_Typeof = this.module.cwrap("QTS_Typeof", "number", ["number", "number"]);
      this.QTS_GetGlobalObject = this.module.cwrap("QTS_GetGlobalObject", "number", ["number"]);
      this.QTS_NewPromiseCapability = this.module.cwrap("QTS_NewPromiseCapability", "number", ["number", "number"]);
      this.QTS_TestStringArg = this.module.cwrap("QTS_TestStringArg", null, ["string"]);
      this.QTS_BuildIsDebug = this.module.cwrap("QTS_BuildIsDebug", "number", []);
      this.QTS_BuildIsAsyncify = this.module.cwrap("QTS_BuildIsAsyncify", "number", []);
      this.QTS_NewFunction = this.module.cwrap("QTS_NewFunction", "number", ["number", "number", "string"]);
      this.QTS_ArgvGetJSValueConstPointer = this.module.cwrap("QTS_ArgvGetJSValueConstPointer", "number", ["number", "number"]);
      this.QTS_RuntimeEnableInterruptHandler = this.module.cwrap("QTS_RuntimeEnableInterruptHandler", null, ["number"]);
      this.QTS_RuntimeDisableInterruptHandler = this.module.cwrap("QTS_RuntimeDisableInterruptHandler", null, ["number"]);
      this.QTS_RuntimeEnableModuleLoader = this.module.cwrap("QTS_RuntimeEnableModuleLoader", null, ["number", "number"]);
      this.QTS_RuntimeDisableModuleLoader = this.module.cwrap("QTS_RuntimeDisableModuleLoader", null, ["number"]);
    }
  }
  ffi_WASM_RELEASE_SYNC.QuickJSFFI = QuickJSFFI;
  return ffi_WASM_RELEASE_SYNC;
}
var emscriptenModule_WASM_RELEASE_SYNC = { exports: {} };
var hasRequiredEmscriptenModule_WASM_RELEASE_SYNC;
function requireEmscriptenModule_WASM_RELEASE_SYNC() {
  if (hasRequiredEmscriptenModule_WASM_RELEASE_SYNC)
    return emscriptenModule_WASM_RELEASE_SYNC.exports;
  hasRequiredEmscriptenModule_WASM_RELEASE_SYNC = 1;
  (function(module2, exports2) {
    var QuickJSRaw = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(QuickJSRaw2 = {}) {
        var a2;
        a2 || (a2 = typeof QuickJSRaw2 !== "undefined" ? QuickJSRaw2 : {});
        var m2, n2;
        a2.ready = new Promise(function(b2, c2) {
          m2 = b2;
          n2 = c2;
        });
        var p2 = Object.assign({}, a2), t2 = "./this.program", u2 = "object" == typeof window, v2 = "function" == typeof importScripts, w2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x2 = "", y2, z2, A2;
        if (w2) {
          var fs2 = fs$o, B2 = path$e;
          x2 = v2 ? B2.dirname(x2) + "/" : __dirname + "/";
          y2 = (b2, c2) => {
            var d2 = C2(b2);
            if (d2)
              return c2 ? d2 : d2.toString();
            b2 = b2.startsWith("file://") ? new URL(b2) : B2.normalize(b2);
            return fs2.readFileSync(b2, c2 ? void 0 : "utf8");
          };
          A2 = (b2) => {
            b2 = y2(b2, true);
            b2.buffer || (b2 = new Uint8Array(b2));
            return b2;
          };
          z2 = (b2, c2, d2) => {
            var e2 = C2(b2);
            e2 && c2(e2);
            b2 = b2.startsWith("file://") ? new URL(b2) : B2.normalize(b2);
            fs2.readFile(b2, function(f2, g2) {
              f2 ? d2(f2) : c2(g2.buffer);
            });
          };
          !a2.thisProgram && 1 < process.argv.length && (t2 = process.argv[1].replace(/\\/g, "/"));
          process.argv.slice(2);
          a2.inspect = function() {
            return "[Emscripten Module object]";
          };
        } else if (u2 || v2)
          v2 ? x2 = self.location.href : "undefined" != typeof document && document.currentScript && (x2 = document.currentScript.src), _scriptDir && (x2 = _scriptDir), 0 !== x2.indexOf("blob:") ? x2 = x2.substr(0, x2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : x2 = "", y2 = (b2) => {
            try {
              var c2 = new XMLHttpRequest();
              c2.open("GET", b2, false);
              c2.send(null);
              return c2.responseText;
            } catch (f2) {
              if (b2 = C2(b2)) {
                c2 = [];
                for (var d2 = 0; d2 < b2.length; d2++) {
                  var e2 = b2[d2];
                  255 < e2 && (e2 &= 255);
                  c2.push(String.fromCharCode(e2));
                }
                return c2.join("");
              }
              throw f2;
            }
          }, v2 && (A2 = (b2) => {
            try {
              var c2 = new XMLHttpRequest();
              c2.open("GET", b2, false);
              c2.responseType = "arraybuffer";
              c2.send(null);
              return new Uint8Array(c2.response);
            } catch (d2) {
              if (b2 = C2(b2))
                return b2;
              throw d2;
            }
          }), z2 = (b2, c2, d2) => {
            var e2 = new XMLHttpRequest();
            e2.open("GET", b2, true);
            e2.responseType = "arraybuffer";
            e2.onload = () => {
              if (200 == e2.status || 0 == e2.status && e2.response)
                c2(e2.response);
              else {
                var f2 = C2(b2);
                f2 ? c2(f2.buffer) : d2();
              }
            };
            e2.onerror = d2;
            e2.send(null);
          };
        var aa = a2.print || console.log.bind(console), D2 = a2.printErr || console.warn.bind(console);
        Object.assign(a2, p2);
        p2 = null;
        a2.thisProgram && (t2 = a2.thisProgram);
        var E2;
        a2.wasmBinary && (E2 = a2.wasmBinary);
        a2.noExitRuntime || true;
        "object" != typeof WebAssembly && F2("no native wasm support detected");
        var G2, H2 = false, I2, J2, K2, L2;
        function M2() {
          var b2 = G2.buffer;
          a2.HEAP8 = I2 = new Int8Array(b2);
          a2.HEAP16 = new Int16Array(b2);
          a2.HEAP32 = K2 = new Int32Array(b2);
          a2.HEAPU8 = J2 = new Uint8Array(b2);
          a2.HEAPU16 = new Uint16Array(b2);
          a2.HEAPU32 = L2 = new Uint32Array(b2);
          a2.HEAPF32 = new Float32Array(b2);
          a2.HEAPF64 = new Float64Array(b2);
        }
        var ba = [], ca = [], da = [];
        function ea() {
          var b2 = a2.preRun.shift();
          ba.unshift(b2);
        }
        var N2 = 0, P2 = null;
        function F2(b2) {
          if (a2.onAbort)
            a2.onAbort(b2);
          b2 = "Aborted(" + b2 + ")";
          D2(b2);
          H2 = true;
          b2 = new WebAssembly.RuntimeError(b2 + ". Build with -sASSERTIONS for more info.");
          n2(b2);
          throw b2;
        }
        var Q2 = "data:application/octet-stream;base64,", R2;
        R2 = "data:application/octet-stream;base64,AGFzbQEAAAAB9QZxYAJ/fwBgA39/fwF/YAR/fn9/AX5gAn9/AX9gAX8Bf2AFf35/f38BfmADf39/AGAEf39/fwF/YAJ/fgF+YAF/AGAFf39/f38Bf2ABfAF8YAJ/fgBgAn9/AX5gAn9+AX9gA39/fgF/YAN/fn8BfmADf35/AGAGf35/f39/AX5gBn9/f39/fwF/YAR/f39/AGADf35/AX9gBn9+fn9/fwF+YAR/f35/AX9gA39+fgF+YAN/f38BfmAFf39/fn4Bf2AEf39/fgF/YAR/f35+AX9gBX9+fn5+AGABfwF+YAN/fn4Bf2AEf39/fwF+YAd/f39/f39/AX9gBX9/f39/AX5gAnx8AXxgAAF/YAV/f39/fwBgBX9+f35/AX9gBX9+fn9/AX5gAX4Bf2AEf35+fwBgB39+f35+fn8Bf2AIf39/f39/f38Bf2AFf35+fn8Bf2AGf35/fn5/AX9gBH9+f34BfmAEf35/fwBgBH9+f34AYAZ/f39/f38BfmAEf35+fwF/YAl/f39/f39/f38Bf2AEf35+fwF+YAR/fn9/AX9gA39+fgBgA35/fwF/YAV/fn5/fwBgA39/fgF+YAd/fn9/f39/AX5gAABgA39/fgBgBH9+f34Bf2AFf39+f38Bf2AEf35+fgF/YAd/f39/f39/AGACfH8BfGABfAF/YAN8fH8BfGACf38BfGAEf39+fwBgBH9+fn4BfmABfgF+YAJ/fAF/YAZ/fH9/f38Bf2AAAXxgBX9+f35/AX5gBn9/fn5+fgF/YAJ+fwBgAn98AGAEf39+fwF+YAV/f39/fgF+YAd/fn5+f39/AX5gBH5+fn4Bf2AHf39/f39/fgF+YAp/f39/f39/f39/AX9gB39/fn5/f38Bf2AFf3x/f38BfmACfn8Bf2AGfH9/f39/AGAFf35/f38AYAV/f35/fwBgBn9+fn5+fwF/YAV/f35+fwF/YAZ/fn9/f38Bf2ADf3x/AX9gBX9+f39/AX9gBX9/fn5+AX5gBX9+fn5+AX9gBn9/fn5/fwF/YAd/f39+fn5/AX9gBH9/f34BfmACfH8Bf2AGf39/f39/AGAIf39/f39/f38AYAN/fnwBfmAAAX5gAnx8AX9gAn5+AXxgAX8BfGADfn5+AX9gA39/fABgCH9+fn5+f35+AX5gCX9/f39/f39/fwACWw8B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rgitCKcIqAimCKUIpAj0B44JjQmKCYgJjAnwB/EH7gfrB+QH4gfhB9MHwQeaB/EEvAmbCZoJmQmYCZcJlgmVCZQJkwmSCZEJiwntCOwInQicCJsImgiZCKAFmAiXCJYIlQiUCJMIkQiQCI8IjgiNCIwIiwiKCIkIiAiHCIYI6QOFCOkDhAiDCIIIgQieCKEIoAifCKII2QP/B/4HkQeQB5kHmAeWB5UHlAeTB5IH4AffB94H6QPdB6AF3AfbB9oH2AerCKoIqQj/BooHiQeIB4cHhgeFB4QHgweCB4EHgAfoB4sHjweOB5sHpAehB6MHogefB54HnQecB6UH5wfmB+UH/gHsB+kH7QfvB/IH9QbPBPQG8wbyBvEGyATwBu8G9wbRBPYG9gf1B/sH+gf5B/gH/QeoCeMGpwnmBqYJpQmkCaMJ4QbfBsYEogmhCaAJsQafCZ4JnQmwBrIJsQmwCa8JrgmtCawJqwmqCbgJnQO3CbYJtQm0CbMJxgnJB8gHxQnECcMJwgnWA8EJwAn3BPgEvwm+CbsJugm5CckJyAnHCdAJzwm9BLwEzgnNCcwJywnKCbQG1AnTCdIJ0Qm4BrcGtga1BroGuQa9BrwGuwbSBtEG0AbPBs4GzQbMBssGygbJBsgGxwbGBsUGxAbDBsEGwAa/Br4G0wbcBoAJ+gj7CNsGgwmECYEJnQT+CPkI6wPMAtoG9QjxCO8I2Qb4CPQI8AiCCf8I/QiXAqcD1gnyCPwI2AbXBtYG1QbUBugG5wblBuQG4gbgBt4G3QbrBuoG6QbtBuwG7gapB6cHpgfPB4EF1weABc4HzQfMB8sHxwfGB8UHxAfDB8IHwAe/B9IH0AfWB9QHtAezB7EHsAevB64HrQesB6sHqge+B70HvAe7B7oHuQe4B7cHtge1B4cJhQmGCdgD8wgK15YXyAk1AQF/AkAgAUIgiKdBdUkNACABpyICIAIoAgAiAkEBazYCACACQQFKDQAgACgCECABEJYECwtNAQJ/IAAoAkAiAkGAAmohAyACKAKcAiAAKAIERwRAIANBwgEQESADIAAoAgQQHSACIAAoAgQ2ApwCCyACIAIoAoQCNgKYAiADIAEQEQsmAQF/IwBBEGsiAiQAIAIgAToADyAAIAJBD2pBARByIAJBEGokAAv/FwIGfwJ+IwBBEGsiAiQAAn8CQCAAKAIA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NwMgIABBgH82AhAMAwsgACACQQxqIAJBCGogBkEAEOoEIgFFDQAgACABNgIgIAIoAgghBSAAQQA2AiggACAFNgIkAkAgAUElSQ0AIAFBLU0EQCAAKAJAIgMtAG5BAXENASABQS1HDQMgAy8BbCIGQQFxDQEgBkGA/gNxQYAGRw0DIAMoAmQNAyADKAIEIgNFDQMgAy0AbEEBcQ0BDAMLIAFBLkcNAiAAKAJEDQAgACgCQCIDLwFsIgZBAnENACAGQYD+A3FBgAZHDQIgAygCZA0CIAMoAgQiA0UNAiADLQBsQQJxRQ0CCyAFBEAgAEGDfzYCECAAQQE2AigMAwsgBCABQdQAazYCAAwCCyAEQap/NgIADAULIARBg382AgALIAAgAigCDDYCOEEADAQLIABBATYCMCAAIANBAWo2AggLIAIoAgwhAQwACwALQX8LIQEgAkEQaiQAIAELFQAgAUHeAU4EQCAAKAIQIAEQ6AULC7oHAgZ/AX4jAEEgayIHJABCgICAgOAAIQsCQAJAAkACQAJAAkACQAJAAkACQCABQiCIpyIGQQFqDggDBQUAAQUFCQILIAAgAkGH1AAQjwEMBgsgACACQff4ABCPAQwFCyAGQXlGDQEMAgsgAachBgwCCyABpyEGIAJBAEgEQCACQf////8HcSIFIAYpAgQiC6dB/////wdxTw0BIAZBEGohAiAAAn8gC0KAgICACINQRQRAIAIgBUEBdGovAQAMAQsgAiAFai0AAAtB//8DcRCfAyELDAULIAJBMEcNACAGKQIEQv////8HgyELDAQLIAAgARCNBKciBkUNAgsgAkH/////B3EhCQNAIAYoAhAiBUEwaiEKIAUgBSgCGCACcUF/c0ECdGooAgAhBQJAA0AgBUUNASACIAogBUEBa0EDdCIFaiIIKAIERwRAIAgoAgBB////H3EhBQwBCwsgBigCFCAFaiEFAkACQAJAAkAgCCgCAEEedkEBaw4DAAECAwsgBSgCACICRQ0GIAIgAigCAEEBajYCACAAIAKtQoCAgIBwhCADQQBBABAvIQsMBwsgBSgCACgCECkDACILQoCAgIBwg0KAgICAwABRBEAgACACENkBDAULIAtCIIinQXVJDQYgC6ciACAAKAIAQQFqNgIADAYLIAAgBiACIAUgCBDIAkUNAgwDCyAFKQMAIgtCIIinQXVJDQQgC6ciACAAKAIAQQFqNgIADAQLAkAgBi0ABSIFQQRxRQ0AIAVBCHEEQCACQQBIBEAgBigCKCAJSwRAIAAgBq1CgICAgHCEIAkQsAEhCwwHCyAGLwEGQSBrQf//A3FB9f8DTw0FDAILIAYvAQZBFWtB//8DcUEKSw0BIAAgAhCeAyIFRQ0BQoCAgIDgAEKAgICAMCAFQQBIGyELDAULIAAoAhAoAkQgBi8BBkEYbGooAhQiBUUNACAFKAIUIggEQCAGIAYoAgBBAWo2AgAgACAGrUKAgICAcIQiASACIAMgCBEuACELIAAgARAPDAULIAUoAgAiBUUNACAGIAYoAgBBAWo2AgAgACAHIAatQoCAgIBwhCIBIAIgBREXACEFIAAgARAPIAVBAEgNAiAFRQ0AIActAABBEHEEQCAAIAcpAxgQDyAAIAcpAxAgA0EAQQAQLyELDAULIAcpAwghCwwECyAGKAIQKAIsIgYNAAtCgICAgDAhCyAERQ0CIAAgAhDHAgtCgICAgOAAIQsMAQtCgICAgDAhCwsgB0EgaiQAIAsLDQAgACABIAJBBBDOAgtfAQN/IwBBEGsiBCQAIAAoAgAhAyAEIAI2AgwgA0EDIAEgAkEAEPAFIAMgAygCECkDgAEgACgCDCAAKAIIIAAoAkAiAQR/IAEoAmhBAEdBAXQFQQALEMoCIARBEGokAAsMACAAQYACaiABECoLKwAgAUHeAU4EQCAAKAIQKAI4IAFBAnRqKAIAIgAgACgCAEEBajYCAAsgAQspACAAIAEgAiADQoCAgIAwQoCAgIAwIARBgM4AchBtIQIgACADEA8gAgsZACAAKAIAIAEQGCEBIABBQGsoAgAgARA5Cy0BAX8CQCAAKAIAIgFFDQAgACgCECIARQ0AIAEoAgAgAEEAIAEoAgQRAQAaCwtcAQF/IABBQGsoAgAiAxDmAkUEQEF/DwsgAkEASARAIAMQMiECCyAAIAFB/wFxEBAgAEFAayIAKAIAIAIQOSAAKAIAKAKkAiACQRRsaiIAIAAoAgBBAWo2AgAgAgsmAQF/IwBBEGsiAiQAIAIgATYCDCAAIAJBDGpBBBByIAJBEGokAAs5ACABQQBOBEAgAEG2ARAQIABBQGsiACgCACABEDkgACgCACIAKAKkAiABQRRsaiAAKAKEAjYCBAsLMwEBfyACBEAgACEDA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAACxgBAX4gASkDACEDIAEgAjcDACAAIAMQDwsXACAAIAEgAkKAgICAMCADIARBAhDYAQvABQICfgZ/IwBB4ABrIgkkACADQQAgA0EAShshCwNAIAogC0ZFBEAgACACIApBBHRqIgMoAgAQtAUhBiADLQAEIQdCgICAgDAhBAJAAkACQAJAAkACQAJAAkACQAJAIAMtAAUOCgECAgUHAwQIBQAGCyAAIAMoAggQtAUhCAJ+AkACQAJAIAMoAgxBAWoOAwIAAQkLIAAgACkDwAEiBCAIIARBABAUDAILIAAgACgCKCkDECIEIAggBEEAEBQMAQsgACABIAggAUEAEBQLIQQgACAIEBMgBkHQAUYEQEEBIQcMCAsgBkHZAUcNB0EAIQcMBwsCQCAGQdABRgRAQQEhBwwBCyAGQdkBRw0AQQAhBwsgACABIAZBAiADIAcQlQMaDAcLQoCAgIAwIQUgAygCCARAIAkgAygCADYCECAJQSBqIghBwABBzDwgCUEQahBOGiAAIAMoAgggCEEAQQpBCCADLQAFQQJGGyADLgEGEIIBIQULIAMoAgwEQCAJIAMoAgA2AgAgCUEgaiIIQcAAQcU8IAkQThogACADKAIMIAhBAUELQQkgAy0ABUECRhsgAy4BBhCCASEECyAAIAEgBkKAgICAMCAFIAQgB0GAOnIQbRogACAFEA8gACAEEA8MBgsgAykDCCIEQoCAgIAIfEL/////D1gEQCAEQv////8PgyEEDAULQoCAgIDAfiAEub0iBEKAgICAwIGA/P8AfSAEQv///////////wCDQoCAgICAgID4/wBWGyEEDAQLQoCAgIDAfiADKQMIIgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhshBAwDCyAAIAEgBkECIAMgBxCVAxoMAwsQAQALIAM1AgghBAsgACABIAYgBCAHEBkaCyAAIAYQEyAKQQFqIQoMAQsLIAlB4ABqJAALMgEBfwJAIAFCIIinQXVJDQAgAaciAiACKAIAIgJBAWs2AgAgAkEBSg0AIAAgARCWBAsLCwAgAEGAMUEAEBULogICAn4BfwJAAkACQAJAAkACQAJAAkACQAJAAkBBByABQiCIpyIEIARBB2tBbkkbQQtqDhMEAgMIBgAAAAAAAQUHAAAAAAEFAAsgAEGVMEEAEBVCgICAgOAADwsgBEF1SQ0IIAGnIgAgACgCAEEBajYCAAwICyAAQSEQdiECDAYLIABBIhB2IQIMBQsgAEEkEHYhAgwECyAAQQQQdiECDAMLIAAgAEEFEHYiAkEwIAGnKQIEQv////8Hg0EAEBkaDAILIABBBhB2IQIMAQsgAEEHEHYhAgtCgICAgOAAIQMgAkKAgICAcINCgICAgOAAUgR+IARBdU8EQCABpyIEIAQoAgBBAWo2AgALIAAgAiABENsBIAIFQoCAgIDgAAsPCyABC9kBAgJ/AX5BfyECAkACQAJAAkACQAJAAkACQCABQiCIpyIDQQtqDhIHBwcFAgUFBQUFBAABAQEFBQYFCyABp0EARw8LIAGnDwsgAacpAgQhBCAAIAEQDyAEQv////8Hg0IAUg8LAAsgAacsAAUhAiAAIAEQDyACQQBODwsgA0EHa0FtTQRAIAFCgICAgMCBgPz/AHxC////////////AINCAX1CgICAgICAgPj/AFQPCyAAIAEQD0EBIQILIAIPCyABpygCDCECIAAgARAPIAJB/////wdqQX5JC6gEAQt/IAAoAgAhBSMAQRBrIgggAjYCDEF/IQkCQANAAkAgCCACIgNBBGoiAjYCDCADKAIAIgdBf0YNACAAKAIEIQoDQCABIgQgCk4NAyAEIAQgBWoiDC0AACIGQQJ0Ig1BgLgBai0AAGoiASAKSg0DIAZBwgFGBEAgDCgAASEJDAELCyAGIAdHBEAgBiAHQf8BcUYgBiAHQQh2Qf8BcUZyIAYgB0EQdkH/AXFGckUgB0EYdiAGR3EgBkUgB0GAAklycg0DIAAgBjYCEAsgBEEBaiEEAkACQAJAAkACQAJAAkACQCANQYO4AWotAABBBWsOGAAJAAkJAQkJAQkJAQEBAgICAgQFBgcJAwkLIAQgBWotAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCQsgAyAERg0IDAkLIAQgBWovAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCAsgAyAERg0HDAgLIAAgBCAFaigAADYCGAwGCyAAIAQgBWoiAygAADYCGCAAIAMvAAQ2AhwMBQsgACAEIAVqKAAANgIgDAQLIAAgBCAFaiIDKAAANgIgIAAgAy0ABDYCHAwDCyAAIAQgBWoiAygAADYCICAAIAMvAAQ2AhwMAgsgACAEIAVqIgMoAAA2AiAgACADKAAENgIYIAAgAy0ACDYCHAwBCwsgACAJNgIMIAAgATYCCEEBIQsLIAsLCwAgACABQQAQjgQLJAEBfyAAKAIQIgJBEGogASACKAIAEQMAIgFFBEAgABB8CyABCyYBAX8jAEEQayICJAAgAiABOwEOIAAgAkEOakECEHIgAkEQaiQACykBAX8gAgRAIAAhAwNAIAMgAToAACADQQFqIQMgAkEBayICDQALCyAACz8BAX8jAEEQayICJAACfyABIAAoAhBHBEAgAiABNgIAIABBoJgBIAIQFkF/DAELIAAQEgshACACQRBqJAAgAAsLACAAIAFBARDmBQvDCgIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgC4QhAkIAIQEgAlAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgC4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAtC////////P1gEQCAFQdAAaiABIA0gASANIA1QIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQZyAGIAhrQRBqIQYgBSkDSCEMIAUpA0AhAwsgA0IPhiILQoCA/v8PgyICIAFCIIgiBH4iECALQiCIIhMgAUL/////D4MiAX58Ig9CIIYiESABIAJ+fCILIBFUrSACIA1C/////w+DIg1+IhUgBCATfnwiESAMQg+GIhIgA0IxiIRC/////w+DIgMgAX58IhQgDyAQVK1CIIYgD0IgiIR8Ig8gAiAOQoCABIQiDH4iFiANIBN+fCIOIBJCIIhCgICAgAiEIgIgAX58IhAgAyAEfnwiEkIghnwiF3whASAHIAlqIAZqQf//AGshBgJAIAIgBH4iGCAMIBN+fCIEIBhUrSAEIAQgAyANfnwiBFatfCACIAx+fCAEIAQgESAVVK0gESAUVq18fCIEVq18IAMgDH4iAyACIA1+fCICIANUrUIghiACQiCIhHwgBCACQiCGfCICIARUrXwgAiACIBAgElatIA4gFlStIA4gEFatfHxCIIYgEkIgiIR8IgJWrXwgAiACIA8gFFStIA8gF1atfHwiAlatfCIEQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIAtCAYYhCyADIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQf8ATQRAIAVBMGogCyABIAZB/wBqIgYQZyAFQSBqIAIgBCAGEGcgBUEQaiALIAEgBxCOAiAFIAIgBCAHEI4CIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAatQjCGhAsgCoQhCiALUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAogAkIBfCIBUK18IQoMAQsgCyABQoCAgICAgICAgH+FhFBFBEAgAiEBDAELIAogAiACQgGDfCIBIAJUrXwhCgsgACABNwMAIAAgCjcDCCAFQeAAaiQACyEAIAAgASACQoCAgIAwIAMgBEECENgBIQIgACABEA8gAgumAQEEfyAAQQA2AgQgAVAEQCAAQYCAgIB4NgIIIABBABBBGkEADwsCQCABQv////8PWARAIABBARBBDQEgACgCECABIAGnZyICrYY+AgAg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IAMQ2QEMAgtBACEEIAItAAUiBUEEcUUNACAFQQhxBEAgA0EATg0BIANB/////wdxIgMgAigCKCIFSSEEIAFFIAMgBU9yDQEgAUKAgICAMDcDGCABQoCAgIAwNwMQIAFBBzYCACABIAAgAq1CgICAgHCEIAMQsAE3AwgMAwsgACgCECgCRCACLwEGQRhsaigCFCIFRQ0AIAUoAgAiBUUNACAAIAEgAq1CgICAgHCEIAMgBREXACEECyAEDwtBfw8LQQELoQQBAn8CQAJAIAFCgICAgHBUIAJC/////w9Wcg0AIAKnIgQgAaciAygCKE8NAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAy8BBkECaw4eAAsLCwsLAAsLCwsLCwsLCwsLCwIBAgMEBQYHCAkKCwsgAygCJCAEQQN0aikDACIBQiCIp0F1SQ0LIAGnIgAgACgCAEEBajYCACABDwsgAygCJCAEajAAAEL/////D4MPCyADKAIkIARqMQAADwsgAygCJCAEQQF0ajIBAEL/////D4MPCyADKAIkIARBAXRqMwEADwsgAygCJCAEQQJ0ajUCAA8LIAMoAiQgBEECdGooAgAiAEEATgRAIACtDwtCgICAgMB+IAC4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwsgACADKAIkIARBA3RqKQMAEIcCDwsgACADKAIkIARBA3RqKQMAEPsDDwtCgICAgMB+IAMoAiQgBEECdGoqAgC7vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwtCgICAgMB+IAMoAiQgBEEDdGopAwAiAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGw8LIAAgAhAxIQMgACACEA8gA0UEQEKAgICA4AAPCyAAIAEgAyABQQAQFCEBIAAgAxATCyABCyoBAX8jAEEQayIEJAAgBCADNgIMIAAgASACIAMQywIhACAEQRBqJAAgAAuMAQECfyABKAJ8IgRBgIAETgRAIABBjTpBABBGQX8PC0F/IQMgACABQfQAakEQIAFB+ABqIARBAWoQeAR/QX8FIAEgASgCfCIDQQFqNgJ8IAEoAnQgA0EEdGoiA0IANwIAIANCADcCCCADIAAgAhAYNgIA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AwsNACAAIAEgARA/EJMCC20BAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAFB/wFxIAIgA2siA0GAAiADQYACSSIBGxArGiABRQRAA0AgACAFQYACEFsgA0GAAmsiA0H/AUsNAAsLIAAgBSADEFsLIAVBgAJqJAALDAAgAEGAAmogARARC74BAgF+AX8CQAJAIAFCgICAgHCDQoCAgIAwUQRAIAAoAiggAkEDdGopAwAiA0IgiKdBdEsNAQwCCyAAIAFBOyABQQAQFCIDQoCAgIBwg0KAgICA4ABRBEAgAw8LIANC/////29WDQEgACADEA8gACABEIADIgRFBEBCgICAgOAADwsgBCgCKCACQQN0aikDACIDQiCIp0F1SQ0BCyADpyIEIAQoAgBBAWo2AgALIAAgAyACEEkhASAAIAMQDyABC3UBAX4gACABIAR+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgASACfiADQv////8Pg3wiAUIgiHw3AwggACAFQv////8PgyABQiCGhDcDAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAtVAQN/IAEgAkEFdSIESwRAIAAgBEECdGooAgAhAwsgAkEfcSICBH8gASAEQQFqIgRLBH8gACAEQQJ0aigCAAVBAAtBAXQgAkEfc3QgAyACdnIFIAMLC2QAAkACQCABQQBIDQAgACgCrAIgAUwNACAAKAKkAiABQRRsaiIAIAAoAgAgAmoiADYCACAAQQBIDQEgAA8LQYUpQa78AEHIqAFBlNUAEAAAC0GmjgFBrvwAQcuoAUGU1QAQAAALYAAgACABIAJCgICAgAh8Qv////8PWAR+IAJC/////w+DBUKAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLIANBh4ABEL0BCwwAIABBhvsAQQAQFQsLACAAIAFBARDBBQvSEAIMfwF+IwBBEGsiCiQAAkACQCABQv////9vWARAIAAQJAwBCyAGQYAwcSIORSAGIAZBCHYiEHEgEEF/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A6ciAiACKAIAQQFqNgIACyAAIAkgAyAGEMsFIQILIAZBggRxQYAERgRAIAogCSgCECIGQTBqNgIMQX8hByAAIAkgCkEMaiAGKAIwQRp2QT1xEJEDDQULIAIhBwwECyAMBEAgACAIKQMAEA8gA0IgiKdBdU8EQCADpyICIAIoAgBBAWo2AgALIAggAzcDAAsgBkGABHFFDQBBfyEHIAAgCSAKQQxqIAooAgwoAgBBGnZBPXEgBkECcXIQkQMNAwtBf0EBIAAgCSAKQQxqIBBBBXEiAEF/cyAKKAIMKAIAQRp2cSAAIAZxchCRAxshBwwCCyAAIAZB4ekAEG8hBwwBC0F/IQcLIApBEGokACAHC/8BAgJ/AXwjAEEQayIEJAACQCACQiCIpyIDQQJNBEAgASACp7c5AwBBACEADAELIANBB2tBbU0EQCABIAJCgICAgMCBgPz/AHw3AwBBACEADAELAn8gACACEI0BIgJCgICAgHCDQoCAgIDgAFEEQEQAAAAAAAD4fyEFQX8MAQsCfAJAAkBBByACQiCIpyIDIANBB2tBbkkbIgNBCmpBAk8EQCADQQdGDQIgAw0BIAKntwwDCyACp0EEaiAEQQhqELUFIAAgAhAPIAQrAwghBUEADAMLEAEACyACQoCAgIDAgYD8/wB8vwshBUEACyEAIAEgBTkDAAsgBEEQaiQAIAALXQECfyMAQRBrIgMkAAJAIAFBgIABcUUEQCABQYCAAnFFDQEgACgCECgCjAEiAUUNASABLQAoQQFxRQ0BCyADQQA2AgwgAEEEIAJBABCSBEF/IQQLIANBEGokACAEC8YJAgR/BX4jAEHwAGsiBiQAIARC////////////AIMhCQJAAkAgAVAiBSACQv///////////wCDIgpCgICAgICAwP//AH1CgICAgICAwICAf1QgClAbRQRAIANCAFIgCUKAgICAgIDA//8AfSILQoCAgICAgMCAgH9WIAtCgICAgICAwICAf1EbDQELIAUgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgCkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACAC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IAAgAaciAkEAIAIoAgRB/////wdxEFEhAiAAKAIAIAEQDyACC7UCAQd/IwBBEGsiBSQAAkAgAEFAaygCACIBRQRADAELAkAgAQJ/IAEoAsgBIgQgASgCxAEiAkgEQCABKALMASEDIAQMAQsgBEEBaiIDIAJBA2xBAm0iAiACIANIGyIGQQN0IQIgACgCACEDAkAgASgCzAEiByABQdABakYEQCADQQAgAiAFQQxqEKgBIgNFDQMgAyABKALMASABKALIAUEDdBAfGgwBCyADIAcgAiAFQQxqEKgBIgNFDQILIAUoAgwhAiABIAM2AswBIAEgAkEDdiAGajYCxAEgASgCyAELQQFqNgLIASADIARBA3RqIgIgASgCvAE2AgAgAiABKALAATYCBCAAQbQBEBAgAEFAaygCACAEQf//A3EQFyABIAQ2ArwBDAELQX8hBAsgBUEQaiQAIAQLoQECA38BfiMAIQYCQCACQoCAgIBwVA0AIAKnIgUvAQZBMEcNACAFKAIgIQQLAn8gBiAAKAIQKAJ4SQRAIAAQ6QFBAAwBCyAELQARBEAgABC2AkEADAELQQAgACAEKQMIIgIgAyACQQAQFCIHQoCAgIBwgyICQoCAgIDgAFENABogAUKAgICAMCAHIAJCgICAgCBRGzcDACAECyEFIAYkACAFCxYAIAAgASACIAMgBCAFIAApAzAQ8QELKQEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABEJMEIQAgAkEQaiQAIAALngICA38BfiACIAEpAgQiB6dB/////wdxIANHckUEQCABIAEoAgBBAWo2AgAgAa1CgICAgJB/hA8LIAFBEGohBSAHQoCAgIAIg1AgAyACayIEQQBMckUEQCADIAIgAiADSBshBkEAIQMgAiEBA0AgASAGRkUEQCAFIAFBAXRqLwEAIANyIQMgAUEBaiEBDAELCyADQf//A3FBgAJPBEAgACAFIAJBAXRqIAQQ7gMPC0EAIQEgACAEQQAQ6gEiAEUEQEKAgICA4AAPCyAAQRBqIQMDQCABIARGRQRAIAEgA2ogBSABIAJqQQF0ai0AADoAACABQQFqIQEMAQsLIAMgBGpBADoAACAArUKAgICAkH+EDwsgACACIAVqIAQQhAMLugEBAn8CQAJAIAJC/////wdYBEAgACABIAKnQYCAgIB4chBx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IANBCGogAhDiA0UEQEEAIQQgASADKQMIIgJCgICAgICAgBBaBH4gAEGAIEEAEFBBfyEEQgAFIAILNwMACyADQRBqJAAgBAsRACAAIAEgASACIANBAhCKBAtTAQF/IAAoAhAiBEEQaiABIAIgBCgCCBEBACIBIAJFckUEQCAAEHwgAQ8LIAMEQCADIAEgACgCECgCDBEEACIAIAJrIgJBACAAIAJPGzYCAAsgAQvAAQAgAAJ/IAEoAggiAEH+////B04EQEEAIAJBAXENARpB/////wcgAEH+////B0cNARogASgCBEH/////B2oMAQtBACAAQQBMDQAaIABBH00EQEEAIAEoAhAgASgCDEECdGpBBGsoAgBBICAAa3YiAmsgAiABKAIEGwwBCyACQQFxRQRAQYCAgIB4Qf////8HIAEoAgQbDAELQQAgASgCECABKAIMIgIgAkEFdCAAaxBoIgJrIAIgASgCBBsLNgIACw0AIAAgASABED8QhQML+QECA34CfyMAQRBrIgUkAAJ+IAG9IgNC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQQgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCADQjyGIQQgA0IEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgA6dnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahBnIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAu2AQEBfyMAQRBrIgMkAAJAAkAgAkEASARAIAEgAkH/////B3E2AgBBASECDAELIAAoAhAiACgCLCACTQ0BAn8CQCAAKAI4IAJBAnRqKAIAIgApAgRCgICAgICAgIBAg0KAgICAgICAgMAAUg0AIANBDGogABC9BUUNAEEBIAMoAgwiAEF/Rw0BGgtBACEAQQALIQIgASAANgIACyADQRBqJAAgAg8LQe/fAEGu/ABBvxhBryAQAAAL1QECAn8DfgJ/IAJFBEBCgICAgDAhBUEADAELIAAoAhAiAykDgAEhBSADQoCAgIAgNwOAAUF/CyEDAkAgACABQQYgAUEAEBQiB0KAgICAcIMiBkKA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BUEgahBGQX8MAQsCQCABKAIEIARODQAgASAENgIEIARB//8DSA0AIAUgAjYCBCAFIAM2AgAgAEGjkwEgBRBGQX8MAQsgASgCCCACQQF0aiIDLwEAIgZB//8DRwRAQQAgBCAGRg0BGiAFIAI2AhggBSAENgIUIAUgBjYCECAAQdSSASAFQRBqEEZBfwwBCyADIAQ7AQBBfyAAIAFBDGpBBCABQRRqIAEoAhBBAWoQeA0AGiABIAEoAhAiAEEBajYCECABKAIMIABBAnRqIAI2AgBBAAshAyAFQTBqJAAgAwsTACAAIAEgAiADIARBAEEAEPgBCzkAIABB/wBNBEAgAEEDdkH8////AXFBoIECaigCACAAdkEBcQ8LIABBfnFBjMAARiAAENIEQQBHcgtmAQF/An9BACAAKAIIIgIgAU8NABpBfyAAKAIMDQAaIAAoAhQgACgCACACQQNsQQF2IgIgASABIAJJGyIBIAAoAhARAQAiAkUEQCAAQQE2AgxBfw8LIAAgATYCCCAAIAI2AgBBAAsLrAECAX8BfiAAKQIEIgSnQf////8HcSEDAkACQCAEQoCAgIAIg1BFBEAgAiADIAIgA0obIQMgAEEQaiEAA0AgAiADRg0CIAAgAkEBdGovAQAgAUYNAyACQQFqIQIMAAsACyABQf8BSw0AIAIgAyACIANKGyEDIABBEGohACABQf8BcSEBA0AgAiADRg0BIAAgAmotAAAgAUYNAiACQQFqIQIMAAsAC0F/IQILIAILpgEBAX8jAEEQayIDJAAgAyACNwMIAkAgACABQYYBIAFBABAUIgJCgICAgHCDQoCAgIDgAFENACAAIAIQOARAIAAgAiABQQEgA0EIahAvIgJC/////29WIAJCgICAgLB/g0KAgICAIFFyDQEgACACEA8gAEGK0wBBABAVQoCAgIDgACECDAELIAAgAhAPIAAgASADIANBCGoQ8QQhAgsgA0EQaiQAIAILowECA38BfiAAQRBqIQIgASgCACIEQQFqIQMCQCAAKQIEIgVCgICAgAiDUEUEQCACIARBAXRqLwEAIgBBgPgDcUGAsANHIAMgBadB/////wdxTnINASACIANBAXRqLwEAIgJBgPgDcUGAuANHDQEgAEEKdEGA+D9xIAJB/wdxckGAgARqIQAgBEECaiEDDAELIAIgBGotAAAh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OCAaKAIkIRQgCCAVQQ9qQfD//wFxayIXJAAgBSEVIAYEQCAHIAQgByAEIAdIGyIIQQAgCEEAShsiCGsiFUEAIAcgFU8bIREDQAJAIAggCUYEQANAIAggEUYNAiAXIAhBA3RqQoCAgIAwNwMAIAhBAWohCAwACwALIAUgCUEDdCIVaikDACIBQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgFSAXaiABNwMAIBFBAWohESAJQQFqIQkMAQsLIA4gBzYCVCAXIRULIA4gFTYCQCAOIBcgBkEDdGoiETYCREEAIQgDQCAIIAtHBEAgESAIQQN0akKAgICAMDcDACAIQQFqIQgMAQsLIBMoAhQhCiAOIBYoAowBNgIwIBYgDkEwaiISNgKMASATKAIwIQYgESALQQN0aiIIIRwLQQAMAQtBAQshBwNAAkACQAJAAkAgB0UEQCAEQQN0IScgA0KAgICAcIMhMyARQQhqIR0gEUEQaiEeIBFBGGohHyAVQQhqISAgFUEQaiEhIBVBGGohIiASQRhqISggBkHIAWohGyAcQRhqISkgBkHAAWohGSACQiCIpyIkQX5xISogA0IgiKchKyAErSEyIAOnISUgDkEwaiEsIA5B6ABqISYgCCEHAkADQAJAIApBAWohDUIBIS5CgICAgDAhAQJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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ajYCAAsgCCABNwMIIAhBCGspAwAiAUIgiKdBdU8EQCABpyIHIAcoAgBBAWo2AgALIAggATcDECAIQRhqIQcM2wELIAggCEEIayIHKQMANwMAIAhBEGspAwAiAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2gELIAggCEEIayIHKQMAIgE3AwAgByAIQRBrIgcpAwA3AwAgAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2QELIAggCEEIayIHKQMAIgE3AwAgCEEQayIKKQMAIS0gCiAIQRhrIgopAwA3AwAgByAtNwMAIAFCIIinQXVPBEAgAaciByAHKAIAQQFqNgIACyAKIAE3AwAgCEEIaiEHDNgBCyAIIAhBCGsiBykDACIBNwMAIAhBEGsiCikDACEtIAogCEEYayIKKQMANwMAIAcgLTcDACAKIAhBIGsiBykDADcDACABQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgByABNwMAIAhBCGohBwzXAQsgCEEQayIHKQMAIQEgByAIQRhrIgcpAwA3AwAgByABNwMADNABCyAIQRhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQQhrIgopAwAhLSAKIAE3AwAgByAtNwMADM8BCyAIQSBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQRBrIgopAwAhLSAKIAhBCGsiCikDADcDACAHIC03AwAgCiABNwMADM4BCyAIQShrIgcpAwAhASAHIAhBIGsiBykDADcDACAIQRhrIgopAwAhLSAKIAhBEGsiCikDADcDACAHIC03AwAgCiAIQQhrIgcpAwA3AwAgByABNwMADM0BCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQRhrIgopAwAhLSAKIAE3AwAgByAtNwMADMwBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAE3AwAgByAtNwMADMsBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAhBKGsiCikDADcDACAHIC03AwAgCiABNwMADMoBCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAHIAE3AwAMyQEL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ayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSgAACAJakEEawshDSAGEHtFDXUMJwsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gDSwAACAJakEBawUgCQshDSAGEHtFDXQMJgsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSwAACAJakEBawshDSAGEHtFDXMMJQsgCCANIAooAAFqIBMoAhRrrUKAgICA0ACENwMAIApBBWohDSAIQQhqIQcMcgsgCigAASEHIAggCiATKAIUa0EFaq03AwAgByANaiENIAhBCGohBwxxCwJAIAhBCGsiBykDACIBQv////8PVg0AIAGnIgkgEygCGE8NACATKAIUIAlqIQ0McQsgBkH14QBBABBGDHQLIAhBCGsiDykDACItQiCIpyIHQQFqIglBBE1BAEEBIAl0QRlxG0UEQCAGIC0Q3AUhLQsCQCAGQRgQKSIJBEAgBkKAgICAIEEREEkiLkKAgICAcINCgICAgOAAUg0BIAYoAhAiB0EQaiAJIAcoAgQRAAALIC0hLgxlCyAJQQA2AhAgCSAtNwMAIAlBADYCCCAupyAJNgIgIAdBfnFBAkYNZSAtIgFCIIinIgdBdU8EQCAtpyILIAsoAgBBAWo2AgALA0AgBiABEIwCIgFCgICAgHCDIi9CgICAgCBSBEAgL0KAgICA4ABRDWYgBiAOQeAAaiAOQYABaiABp0EREI4BDWUgBiAOKAJgIA4oAoABIgsQWiALBEAgBiABEA8gB0F1SQ1lIC2nIgcgBygCAEEBajYCAAxlCyAGEHtFDQEMZQsLAkACQCAtpyIMLQAFQQhxRQ0AQQAhByAMKAIQIgsoAiAiEEEAIBBBAEobIRAgC0EwaiELA0AgByAQRg0CIAstAANBEHENASALQQhqIQsgB0EBaiEHDAALAAsgBiAOQeAAaiAOQYABaiAMQREQjgENZUEAIQcgDigCYCEKIA4oAoABIQkDQCAHIAlHBEAgBiAuIAogB0EDdGooAgRCgICAgCBBABDQARogB0EBaiEHDAELCyAGIAogCRBaDGYLIAlBATYCCCAJIAwoAig2AgwMZQtCgYCAgBAhLgJAIAhBCGspAwAi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/wB8v6G9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMSAsCfCAIQQhrIgcpAwAiLUIgiKciDCAIQRBrIgspAwAiLkIgiKciD3JFBEAgLcQgLsR+IgFCgICAgAh8QoCAgIAQWgRAIBItAChBBHFBACABQoCAgICAgIAQfUKBgICAgICAYFQbDQUgAbkMAgtEAAAAAAAAAIAgLSAuhEKAgICACINQIAFCAFJyRQ0BGiALIAFC/////w+DNwMADEkLIA9BB2tBbUsgDEEHa0FtS3INAyASLQAoQQRxDQMgLkKAgICAwIGA/P8AfL8gLUKAgICAwIGA/P8AfL+iCyE0IAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMRwsgCEEIayIHKQMAIgEgCEEQayILKQMAIi2EQv////8PVg0BIBItAChBBHENASALAn4gLae3IAGnt6MiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIIt71RBEAgCK0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADEYLIAhBCGsiBykDACIBIAhBEGsiCykDACIthEL/////D1YNACAtpyIMQQBIDQAgAaciD0EATA0AIAsgDCAPcK03AwAMRQsjAEEgayIHJAACfwJAAkACQAJAAn4CQAJAAkACQAJAAkACQEEHIAhBEGsiCykDACIBQiCIpyIMIAxBB2tBbkkbIgxBB0dBByAIQQhrIiMpAwAiLkIgiKciDyAPQQdrQW5JGyIPQQdHckUEQCAHIC5CgICAgMCBgPz/AHw3AwggByABQoCAgIDAgYD8/wB8NwMQDAELAkAgDEF/RiAPQX5xQQJHcUUgDEF+cUECRiAPQX9HcnENACAGIAdBGGogASAuIAlBAUEAEIUCIgxFDQAgBiABEA8gBiAuEA8gDEEASA0MIAsgBykDGDcDAAwJCyAGIAEQbCIBQoCAgIBwg0KAgICA4ABRDQogBiAuEGwiLkKAgICAcINCgICAgOAAUQRAIAYgARAPDAwLQQcgAUIgiKciDCAMQQdrQW5JGyIMQQcgLkIgiKciDyAPQQdrQW5JGyIPckUEQCAupyEMIAGnIQ8CQAJAAkACQAJAAkAgCUGaAWsOBgABAgkFAwQLIC7EIAHEfiEtAkAgBigCECIQKAKMASIYRQ0AIBgtAChBBHFFDQAgLUKAgICAgICAEH1CgYCAgICAgGBUDQgLQgAhASAtQgBSDQogDCAPckEATg0LIAtCgICAgMD+/wM3AwAMDgsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0HCyALQoCAgIDAfiAPtyAMt6O9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMDQsgDEEASiAPQQBOcUUEQCALAn4gD7cgDLcQjgMiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIJt71RBEAgCa0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADA0LIA8gDHCtIS0MCAsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0FCyAPtyE0IAsCfgJ8IAy3IjW9QoCAgICAgID4/wCDQoCAgICAgID4/wBRBEBEAAAAAAAA+H8gNJlEAAAAAAAA8D9hDQEaCyA0IDUQjwMLIjS9IgECfyA0mUQAAAAAAADgQWMEQCA0qgwBC0GAgICAeAsiCbe9UQRAIAmtDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCzcDAAwLCyAJQbIBRg0FDAQLIAHEIC7EfSEtDAULIAxBdUcgD0F1R3FFBEAgBiAJIAsgASAuIAYoAhAoAtgCERoADQwMCQsgDEF3RyAPQXdHcUUEQCAGIAkgCyABIC4gBigCECgCvAIRGgBFDQkMDAsgDEF2RyAPQXZHcUUEQCAGKAIQIRAMAgsgBiAHQRBqIAEQbg0KIAYgB0EIaiAuEG4NCwsCQCAGKAIQIhAoAowBIgxFDQAgDC0AKEEEcUUNACAHKwMQEL0CRQ0AIAcrAwgQvQINAQsCQAJAAkACQAJAAkACQCAJQZoBaw4GAAECCAUEAwsgBysDECAHKwMIoiE0DAULIAcrAxAgBysDCKMhNAwECyAHKwMQIAcrAwgQjgMhNAwDCyAJQbIBRw0EIAcrAxAgBysDCJkiNRCOAyI0RAAAAAAAAAAAY0UNAiA1IDSgITQMAgsgBysDECE1IAcrAwgiNr1CgICAgICAgPj/AINCgICAgICAgPj/AFEEQEQAAAAAAAD4fyE0IDWZRAAAAAAAAPA/YQ0CCyA1IDYQjwMhNAwBCyAHKwMQIAcrAwihITQLIAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMBwsgBiAJIAsgASAuIBAoAqACERoARQ0GDAkLEAEACyAMRQ0FIAHEIC7EIgGBIi1CAFkNACAMQQBIBEAgLSABfSEtDAELIAEgLXwhLQsgLUKAgICACHxC/////w9WDQEgLSEBCyABQv////8PgwwBC0KAgICAwH4gLbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgCyABNwMAC0EADAMLIAZBAhCEAgwBCyAGIC4QDwsgC0KAgICAMDcDACAjQoCAgIAwNwMAQX8LIQkgB0EgaiQAIAkNSCAIQQhrIQcMRAsgCEEEaygCACIHRSAHQQdrQW5Jcg09IAghByAGIAhBjQEQ5gFFDUMMRwsCQAJ8IAhBCGsiBykDACIBQiCIpyIJRQRARAAAAAAAAACAIAGnIgpFDQEaRAAAAAAAAOBBIApBgICAgHhGDQEaIAdCACABfUL/////D4M3AwAMPwsgCUEHa0FtSw0BIAFCgICAgMD+/wN9vwshNCAHQoCAgIDAfiA0vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbNwMADD0LIAghByAGIAhBjAEQ5gFFDUIMRgsgCEEIayIHKQMAIgFC/////w9WIAFC/////w+DQv////8HUXJFBEAgByABQgF8Qv////8PgzcDAAw8CyAIIQcgBiAIQY8BEOYBRQ1BDEULIAhBCGsiBykDACIBQv////8PViABQv////8Pg0KAgICACFFyRQRAIAcgAUIBfUL/////D4M3AwAMOwsgCCEHIAYgCEGOARDmAUUNQAxECyAGIAhBCGsiBykDABBsIgFCgICAgHCDQoCAgIDgAFEEQCAHQoCAgIAwNwMADEQLIAcgATcDACABQiCIp0F1TwRAIAGnIgcgBygCAEEBajYCAAsgCCABNwMAIAYgCEEIaiIHIAlBAmsQ5gFFDT8MQwsgCkECaiENIBEgCi0AAUEDdGoiBykDACIBQv////8PViABQv////8Pg0L/////B1FyRQRAIAcgAUIBfEL/////D4M3AwAMOQsgAUIgiKdBdU8EQCABpyIJIAkoAgBBAWo2AgALIA4gATcDYCAGICZBjwEQ5gENQiAGIAcgDikDYBAgDDgLIApBAmohDSARIAotAAFBA3RqIgcpAwAiAUL/////D1YgAUL/////D4NCgICAgAhRckUEQCAHIAFCAX1C/////w+DNwMADDgLIAFCIIinQXVPBEAgAaciCSAJKAIAQQFqNgIACyAOIAE3A2AgBiAmQY4BEOYBDUEgBiAHIA4pA2AQIAw3CyAIQQhrIgcpAwAiAUL/////D1gEQCAHIAFC/////w+FNwMADDcLIAghByMAQRBrIgkkAAJ/AkACQAJAIAhBCGsiCykDACIBQoCAgIBwVA0AIAYgCUEIaiABQZUBEMIFIgxBAEgNASAMRQ0AIAYgARAPIAsgCSkDCDcDAAwCCwJAIAYgARBsIgFCgICAgHCDIi1CgICAgOAAUQ0AIAYoAhAiDCgCjAEiDwR/IA8tAChBBHFBAnYFQQALRSAtQoCAgIDgflJxRQRAIAYgC0GVASABIAwoApwCERsADQEMAwsgBiAJQQRqIAEQmAENACALIAk1AgRC/////w+FNwMADAILIAtCgICAgDA3AwALQX8MAQtBAAshCyAJQRBqJAAgC0UNPAxACwJAAkACQCAIQQhrIgcpAwAiASAIQRBrIgspAwAiLYRC/////w9WDQAgAachCSASLQAoQQRxRQ0BIAlBH0sNACAtIAGGQoCAgIAIfEKAgICAEFQNAgsgBiAIQaABEMMCRQ09DEELIAlBH3EhCQsgCyAtpyAJdK03AwAMOwsgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PWARAIAkCfiAtpyABp3YiCEEATgRAIAitDAELQoCAgIDAfiAIuL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGws3AwAMOwsjAEEQayIJJAAgCEEIayIMKQMAIS0CfwJAAkAgBiAIQRBrIgspAwAQbCIBQoCAgIBwgyIuQoCAgIDgAFEEQCAGIC0QDwwBCyAGIC0QbCItQoCAgIBw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gICAgOAAIQEgACACKQMAEOgBIgZCgICAgHCDQoCAgIDgAFEEQCAAIAUQDwwGCyAAIAYQDyAGpyAFp0YNBAsgACAFEA8gAEGE5ABBABAVC0KAgICA4AAhAQwDCyACKAIQKAIsIgBFBEBCgICAgCAhAQwDCyAAIAAoAgBBAWo2AgAgAK1CgICAgHCEIQEMAgsgACABEI0EIgFCIIinQXVJDQEgAaciACAAKAIAQQFqNgIADAELIAUhAQsgA0EQaiQAIAELCwAgAEGNIkEAEEYLGgAgACgCECABIAIQ7wQiAUUEQCAAEHwLIAELgAEBAn8CQAJAIAFFDQAgASgCACICQQBMDQEgASACQQFrIgI2AgAgAg0AIAEtAAVBAXEEQCAAIAEpAxgQIwsgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUIANwIIIABBEGogASAAKAIEEQAACw8LQdaNAUGu/ABB9ChB6t0AEAAACxIAIAFB3gFOBEAgACABEOgFCwvbAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAECy0BAX9BASEBAkACQAJAIABBDWsOBAIBAQIACyAAQTRGDQELIABBOEYhAQsgAQsfACAAIAEgACACEKoBIgIgAyAEEBkhBCAAIAIQEyAEC0QBAX9BfyEDIAAgACgCBCACahDGAQR/QX8FIAAoAgAgAWoiAyACaiADIAAoAgQgAWsQnAEgACAAKAIEIAJqNgIEQQALC44BAQF/IAAgBkEMEEkiBkKAgICAcINCgICAgOAAUgRAIAAgACgCAEEBajYCACAGpyIHIAU7ASogByAEOgApIAcgAzoAKCAHIAE2AiQgByAANgIgIAcgBy0ABUHvAXEgBEECa0EESUEEdHI6AAUgACAGIAAgAkHMngEgAhsQqgEiASADEJYDIAAgARATCyAGCykBAX9B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IAAgD0ElEEsiCEUNACAAIANB3QEgA0EAEBQiDkKAgICAcIMiDUKAgICA4ABRDQAgDUKAgICAMFEEQCAAIA8QD0EADAILIAAgDkElEEsiC0UNAAJAIAgoAgRFDQAgCygCBEUNACAAIA8QDyAAIA4QD0EADAILIAQQ9wMhBwJ/IAgoAgAiCiALKAIAIgxGBEAgCCAHQQJ0aigCCAwBCyAKIAxLBEAgCEHUAGogDCAHELgFDAELIAtB3ABqIAogBxC4BQsiCkUEQCAJIAdBAnRBwMABajYCACAAQZL6ACAJEBUMAQsCQCAIKAIEBEACfiAFBEAgACACELkCDAELIAAgAiAGEJACCyICQoCAgIBwg0KAgICA4ABSDQEMAgsgAkIgiKdBdUkNACACpyIIIAgoAgBBAWo2AgALAkAgCygCBARAAn4gBQRAIAAgAxC5AgwBCyAAIAMgBhCQAgsiA0KAgICAcINCgICAgOAAUg0BIAAgAhAPDAILIANCIIinQXVJDQAgA6ciBSAFKAIAQQFqNgIACyAKIAooAgBBAWo2AgAgCSACIAMgBEF+cUGkAUYgB0ENRnEiBRs3AxggCSADIAIgBRs3AxAgACAKrUKAgICAcIRCgICAgDBBAiAJQRBqEC8hDSAAIAIQDyAAIAMQDyANQoCAgIBwgyICQoCAgIDgAFENAAJ+IAdBDEYEQCAAIA0QJiAEQaoBRketQoCAgIAQhAwBCyANIAdBDUcNABpCgICAgBAgAkKAgICAMFENABogACANECYgBEF9cUGkAUZHrUKAgICAEIQLIQMgACAPEA8gACAOEA8gASADNwMAQQEMAQsgACAPEA8gACAOEA8gAUKAgICAMDcDAEF/CyEHIAlBIGokACAHC2MCAX8BfiMAQRBrIgIkACAAAn4gAUUEQEIADAELIAIgAa1CACABZyIBQdEAahBnIAIpAwhCgICAgICAwACFQZ6AASABa61CMIZ8IQMgAikDAAs3AwAgACADNwMIIAJBEGokAAvHAQIBfgF/AkAgACgCECgCjAEiA0UgAUL/////////D3xC/v///////x9Wcg0AIAMoAihBBHFFDQAgAUKAgICACHxC/////w9YBEAgAUL/////D4MPC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA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ACAAIAEQiANBH3YLvgEBB38gACgCDCIFIQMCQANAIAMiBEUNASAAKAIQIgkgBEEBayIDQQJ0aiIGKAIARQ0ACyAAIAAoAgggBCAFa0EFdGo2AgggBigCAGciBwRAQSAgB2shBUEAIQMDQCADIARGRQRAIAkgA0ECdGoiBiAIIAV2IAYoAgAiCCAHdHI2AgAgA0EBaiEDDAELCyAAIAAoAgggB2s2AggLIAAgASACIARBABCqAw8LIABBgICAgHg2AgggAEEAEEEaQQALTgIBfwF+An4jACICIAAoAhAoAnhJBEAgABDpAUKAgICA4AAMAQsgACABrSABKQMAQoCAgIAwIAEoAgggASgCIEEEENgBCyEDIAIkACADCwwAIABB+swAQQAQFQsLACAAQcMaQQAQFQvVAQEDfyMAQRBrIgUkAEF/IQMCQCAAKAIUDQACQAJAIAFBgICAgAROBEAgACgCAEHA2gBBABBGDAELIAEgACgCDEEDbEECbSIEIAEgBEobIQEgACgCECIEIAJBgAJIckUEQCAAIAEQ9QMhAwwDCyAAKAIAIAAoAgQgASAEdCAEa0ERaiAFQQxqEKgBIgINAQsgABCDAwwBCyAFKAIMIQMgACACNgIEIABB/////wMgAyAAKAIQdiABaiIAIABB/////wNOGzYCDEEAIQMLIAVBEGokACADCxEAIAAgASACIAMgBEEAELcFCyYBAX8gAUIgiKdBdU8EQCABpyICIAIoAgBBAWo2AgALIAAgARBsCycBAX8gAUIAUwRAIABCACABfRAwIQIgAEEBNgIEIAIPCyAAIAEQMAvsAQEBfwJAAkACQAJAAkACQAJAQQcgAkIgiKciAyADQQdrQW5JGyIDDggAAAAEBAQEAQMLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACxBC6Ag0BDAQLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACQoCAgIDAgYD8/wB8vxC6BUUNAwsgARAbQQAPCyADQQpqQQJJDQILIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgARA1CyABDwsgAqdBBGoL5AEBBH8jAEEQayICJAAgACACQQhqIAEQ5QEhAyAAIAEQDwJAIANFBEBC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IAMoAgAgAygCBHEMBAsgAygCACADKAIEcgwDCyADKAIAIAMoAgRzDAILEAEACyADKAIEIAMoAgB0C603AwAMAQsgAUKAgICAMDcDACAGQoCAgIAwNwMAQX8MAQtBAAshACADQRBqJAAgAAuGBQIHfwJ+AkAgAUKAgICAcINCgICAgJB/UgRAQoCAgIDgACEKIAAgARA3IgFCgICAgHCDQoCAgIDgAFENAQsCQCACQoCAgIBwg0KAgICAkH9RDQBCgICAgOAAIQogACACEDciAkKAgICAcINCgICAgOAAUg0AIAEhAgwBCwJAIAKnIgUpAgQiCkL/////B4NQDQAgAaciAykCBCELAkAgAygCAEEBRyAKIAuFQoCAgIAIg0IAUnINACADIAAoAhAoAgwRBAAgBSkCBCIKpyIEQf////8HcSIHIAMpAgQiC6ciBkH/////B3EiCGogBEEfdnQgBkEfdiIJQRFzakkNACAFQRBqIQYgA0EQaiEEIAkEQCAEIAhBAXRqIAYgB0EBdBAfGiADIAMpAgQiCiAFKQIEfEL/////B4MgCkKAgICAeIOENwIEDAILIAQgCGogBiAHEB8aIAMgAykCBCIKIAUpAgR8Qv////8HgyILIApCgICAgHiDhDcCBCAEIAunakEAOgAADAELAn4CQAJAIAunQf////8HcSAKp0H/////B3FqIgdBgICAgARPBEAgAEHA2gBBABBGDAELIAAgByAKIAuEpyIGQR92EOoBIggNAQtCgICAgOAADAELIAhBEGohBAJAIAZBAE4EQCAEIANBEGogAygCBEH/////B3EQHyIEIAMoAgRB/////wdxaiAFQRBqIAUoAgRB/////wdxEB8aIAQgB2pBADoAAAwBCyAEIAMgAygCBEH/////B3EQwwUgBCADKAIEQQF0aiAFIAUoAgRB/////wdxEMMFCyAIrUKAgICAkH+ECyEKIAAgARAPDAELIAEhCgsgACACEA8gCgtAACAAAn8CfyADBEAgASgCJCACQQN0akEEagwBC0EAIAEoAiAiA0UNARogAyABLwEoIAJqQQR0agsoAgALENkBCw0AIAAgASACQQIQzgILNQEBfyMAQdAAayICJAAgAiAAKAIQIAJBEGogARCQATYCACAAQef5ACACEMYCIAJB0ABqJAALowECAX8BfiMAQRBr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AiAAKAIQQf0ARw0ACyAAEPMBC0F/QQAgABASGyEBCyABC2gAIAAgASACEE8iAEEATgRAIAEoAnQgAEEEdGoiAiACKAIMQYd/cSADQQN0QfgAcXI2AgwgAiABKAK8ASIDNgIEIAIgASgCwAE2AgggASgCzAEgA0EDdGogADYCBCABIAA2AsABCyAAC20BAX8gACABQfwBakEQIAFB+AFqIAEoAvQBQQFqEHhFBEAgASABKAL0ASIDQQFqNgL0ASABKAL8ASADQQR0aiIDQX82AgAgAyADLQAEQfgBcToABCADIAEoArwBNgIIIAMgACACEBg2AgwLIAMLxgMBBH8gAEFAayIFKAIAQbACaiEDA0BBACECAkADQCADKAIAIgNFDQEgAygCHARAIAFFBEAgAEEGEBALIABBhAEQEEGDASECIAAgBSgCAC0AbEEDRgR/IABBDhAQIABBDhAQIABBwgAQECAAQQYQGiAAQREQECAAQbABEBAgAEHqAEF/EBwhASAAQSQQECAFKAIAQQAQFyAAQYEBEBAgAEGLARAQIABB6wBBfxAcIQQgACABEB4gAEEOEBAgACAEEB5BDgVBgwELEBBBfSECQQEhAQsgAygCECACaiECIAMoAhRBf0YNAAtBD0EOIAEbIQQDQCACBEAgACAEEBAgAkEBayECDAELCyABRQRAIABBBhAQCyAAQe0AIAMoAhQQHBpBASEBDAELCwJAIABBQGsoAgAiAigCYARAAkAgAUUEQEF/IQIMAQsgAEEqEBAgAEHpAEF/EBwhAiAAQQ4QEAsgAEG4ARAQIABBCBAaIABBQGsoAgBBABAXIAAgAhAeQSghAgwBCyACLQBsIgMEQCABRQRAIABBBhAQQS4hAgwCC0EuIQIgA0EDRw0BIABBiwEQEAwBC0EoQSkgARshAgsgACACEBALXQECfwJAAkAgACgCmAIiAUEASA0AIAAoAoACIAFqLQAAIgBBI2siAUENTUEAQQEgAXRB5fAAcRsNAQJAIABB6wBrDgQCAQECAAsgAEHsAWtBAkkNAQtBASECCyACCy8AIAAgASACIAMQ4wIiAEEATgRAIAEoAnQgAEEEdGoiASABKAIMQQNyNgIMCyAACy4AIABBDBApIgAEQCAAIAM2AgggACACNgIEIAAgASgCEDYCACABIAA2AhALIAALawEBfwJA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CyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAvwBIQMgAiABKAL0AU5FBEAgACADIAJBBHRqKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAsgCIQMgAiABKALAAk5FBEAgACADIAJBA3RqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAEoAswBIgIgAUHQAWpHBEAgACgCECIDQRBqIAIgAygCBBEAAAsgACABKALsAhATIAFB9AJqEPYBIAAoAhAiAkEQaiABKAKMAyACKAIEEQAAIAEoAgQEQCABKAIYIgIgASgCHCIDNgIEIAMgAjYCACABQgA3AhgLIAAoAhAiAEEQaiABIAAoAgQRAAALggEBAn8gACABQRBqEM8FAkAgASgCICICBEAgASgCPCIDRQ0BA0AgAiADT0UEQCAAIAIpAwAQIyACQQhqIQIgASgCPCEDDAELCyAAQRBqIAEoAiAgACgCBBEAAAsgACABKQMYECMgACABKQMAECMPC0GEhAFBrvwAQYmUAUHC6wAQAAALaAEBfgJAAkAgABA0IgNCgICAgHCDQoCAgIDgAFEEQCABIQMMAQsgACADQcAAIAFBBxAZQQBIDQAgACADQekAIAJBAEetQoCAgIAQhEEHEBlBAE4NAQsgACADEA9CgICAgOAAIQMLIAMLjAEBAn8CQANAIAFCgICAgHBUDQECQAJAAkACQAJAAkAgAaciAi8BBiIDQQxrDgUFAQMHAQALIANBMEYNASADQTRrDgUABgYGAAYLIAIoAiAoAjAPCyACKAIgIgJFDQQgAi0AEUUNASAAELYCQQAPCyACKAIgIQILIAIpAwAhAQwBCwsgAigCICEACyAACyIAIAAgAkEBahApIgAEQCAAIAEgAhAfIAJqQQA6AAALIAALjQMCA34EfwJAIAEoAggiBkH+////B04EQEEBIQcgAkEBcQ0BQv///////////wAhAyAGQf7///8HRw0BIAE0AgRC////////////AHwhAwwBCyAGQQBMBEAMAQsgBkE/TQRAIAEoAhAiCSABKAIMIgJBAnRqQQRrKAIAIQhCACAGQSBNBH4gCEEgIAZrdq0FIAJBAk8EfiACQQJ0IAlqQQhrNQIABUIACyAIrUIghoRBwAAg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LQAFQf4BcToABSABIAs3A0ALIAtCIIinQXVPBEAgC6ciACAAKAIAQQFqNgIACyALIQwLIANBIGokACAMC4kEAgR+An8CQAJAIAG9IgRCAYYiA1ANACABvSECIAC9IgVCNIinQf8PcSIGQf8PRg0AIAJC////////////AINCgYCAgICAgPj/AFQNAQsgACABoiIAIACjDwsgAyAFQgGGIgJaBEAgAEQAAAAAAAAAAKIgACACIANRGw8LIARCNIinQf8PcSEHAn4gBkUEQEEAIQYgBUIMhiICQgBZBEADQCAGQQFrIQYgAkIBhiICQgBZDQALCyAFQQEgBmuthgwBCyAFQv////////8Hg0KAgICAgICACIQLIQICfiAHRQRAQQAhByAEQgyGIgNCAFkEQANAIAdBAWshByADQgGGIgNCAFkNAAsLIARBASAHa62GDAELIARC/////////weDQoCAgICAgIAIhAshBCAGIAdKBEADQAJAIAIgBH0iA0IAUw0AIAMiAkIAUg0AIABEAAAAAAAAAACiDwsgAkIBhiECIAZBAWsiBiAHSg0ACyAHIQYLAkAgAiAEfSIDQgBTDQAgAyICQgBSDQAgAEQAAAAAAAAAAKIPCwJAIAJC/////////wdWBEAgAiEDDAELA0AgBkEBayEGIAJCgICAgICAgARUIQcgAkIBhiIDIQIgBw0ACwsgBUKAgICAgICAgIB/gyADQoCAgICAgIAIfSAGrUI0hoQgA0EBIAZrrYggBkEAShuEvwvoDwMHfAh/An5EAAAAAAAA8D8hAwJAAkACQCABvSIRQiCIpyIPQf////8HcSIJIBGnIgxyRQ0AIAC9IhJCIIinIQogEqciEEUgCkGAgMD/A0ZxDQAgCkH/////B3EiC0GAgMD/B0sgC0GAgMD/B0YgEEEAR3FyIAlBgIDA/wdLckUgDEUgCUGAgMD/B0dycUUEQCAAIAGgDwsCQAJAAkACQAJAAn9BACASQgBZDQAaQQIgCUH///+ZBEsNABpBACAJQYCAwP8DSQ0AGiAJQRR2IQ0gCUGAgICKBEkNAUEAIAxBswggDWsiDnYiDSAOdCAMRw0AGkECIA1BAXFrCyEOIAwNAiAJQYCAwP8HRw0BIAtBgIDA/wNrIBByRQ0FIAtBgIDA/wNJDQMgAUQAAAAAAAAAACARQgBZGw8L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A38jAEFAaiIGJAACQCAEIANrIghBAUYEQAJAIANFBEAgAUIDEDAaDAELIAEgA60QMBogAUEBNgIECyACIANBAXRBAXKtEDAaIAIgAigCCEECajYCCCAAIAEQRBoMAQsgACgCACEHIAAgASACIAMgCEEBdiADaiIDQQEQoAQgBkIANwI4IAZCgICAgICAgICAfzcCMCAGIAc2AiwgBkIANwIkIAZCgICAgICAgICAfzcCHCAGIAc2AhggBkIANwIQIAZCgICAgICAgICAfzcCCCAGIAc2AgQgBkEsaiIHIAZBGGogBkEEaiIIIAMgBCAFEKAEIAAgACAIQf////8DQQEQQxogByAHIAFB/////wNBARBDGiAAIAAgB0H/////A0EBEMsBGiAFBEAgASABIAZBGGpB/////wNBARBDGgsgAiACIAZBBGoiAEH/////A0EBEEMaIAZBLGoQGyAGQRhqEBsgABAbCyAGQUBrJAALzgUCB38DfiMAQTBrIggkAAJ/AkACQAJAAkACQCADDgMAAQIDC0HcjAFB1PwAQbUaQZb8ABAAAAsgASACKAIQIAIoAgwiACAAQQV0IAIoAghrEGg2AgAMAgsgAigCECIDIAIoAgwiACAAQQV0IAIoAghrIgJBIGoQaK1CIIYgAyAAIAIQaK2EIQ8gBkGAlOvcA0YEQCABIA9CgJTr3AOAIhA+AgQgASAQQoDslKMMfiAPfD4CAAwCCyABIA8gBq0iEIAiET4CBCABIA8gECARfn0+AgAMAQsgAigCACEKIAhCADcCKCAIQoCAgICAgICAgH83AiAgCCAKNgIcIAhCADcCFCAIQoCAgICAgICAgH83AgwgCCAKNgIIIAMgBUEBdCAEQQFqIgt2QQFqQQF2IgprIQwgACAEQQF0QQFyQRRsaiENQQAhAyAAIARBKGxqIgQoAgxFBEAgBCAGIApB/////wNBARD8AiAIQQhqIglCARAwciANIAkgBCAKQQFqIAdsQQJqQQAQlQFyIQkLAkACQCAIQRxqIg4gAiANIAcgDGxBABBDIAlyIA5BARDRAXIgCEEIaiIJIA4gBEH/////A0EBEENyIAkgAiAJQf////8DQQEQ5AFyQSBxDQADQAJAIAgoAgxFDQAgCCgCFEUNACAIQQhqIgIgAiAEQf////8DQQEQywENAiADQQFrIQMM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3gQBCX8jAEEQayIGJAAgACAAKQOAARAjIABBEGohAyAAQaABaiEEIAAoAqQBIQEDQCABIARGRQRAIAEoAgQhBUEAIQIDQCACIAEoAhBORQRAIAAgASACQQN0aikDGBAjIAJBAWohAgwBCwsgAyABIAAoAgQRAAAgBSEBDAELCyAAIAQ2AqQBIAAgAEGgAWo2AqABIAAQogUgACgCVCAAQdAAakYEQEEAIQIDQAJAIAAoAkQhASACIAAoAkBODQAgASACQRhsaiIBKAIABEAgACABKAIEEOwBCyACQQFqIQIMAQsLIAMgASAAKAIEEQAAIAAoApACIgQEQEEAIQEDQEEAIQUgAUEFRkUEQANAQQAhAiAFQQJGRQRAA0AgAkEURwRAIAQgAUGgAWxqIAVB0ABsaiACQQJ0akGoDWoiBygCACIIBEAgBCgCACIJKAIAIAhBACAJKAIEEQEAGiAHQQA2AgALIAJBAWohAgwBCwsgBUEBaiEFDAELCyABQQFqIQEMAQsLIAAoAtgBIARBACAAKALcAREBABogAEEANgKQAgsgAEHgAWoQoQUgAEH4AWoQoQVBACECA0ACQCAAKAI4IQEgAiAAKAIsTg0AIAEgAkECdGooAgAiAUEBcUUEQCADIAEgACgCBBEAAAsgAkEBaiECDAELCyADIAEgACgCBBEAACADIAAoAjQgACgCBBEAACADIAAoAtQBIAAoAgQRAAAgBiADKQIINwMIIAYgAykCADcDACAGIAAgACgCBBEAACAGQRBqJAAPC0GNkQFBrvwAQb8PQaTlABAAAAtDAQJ/IAAoAogBIQJBfyEDAkADQCACQQBMDQEgACgCgAEgAkEBayICQQR0aigCACABRw0ACyACQYCAgIACciEDCyADC8YBAgR/AX4jAEEQayIDJAAgACABEC0iB0KAgICAcINCgICAgOAAUgRAAkAgACADQQxqIAcQ5QEiBkUEQAwBCwJAIAAgAhA/IgEgAygCDGpBAWoQKSIERQRAQQAhBAwBCyAEIAYgAygCDBAfIgUgAygCDGogAiABEB8aIAUgAygCDCABampBADoAACAAIAUgAygCDCABahCFAyEEIAAoAhAiAUEQaiAFIAEoAgQRAAALIAAgBhBUCyAAIAcQDwsgA0EQaiQAIAQLvwEBAX8gASADai0AAEE8RgRAIAAgBEH/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BEAgCygCJCIEIAJBA3RqIAQgAadBA3QQnAFBAAwBCyABpwshDUEAIQQgAkEAIAJBAEobIQIDQCACIARHBEAgAyAEQQN0aikDACIBQiCIp0F1TwRAIAGnIg4gDigCAEEBajYCAAsgCygCJCAEIA1qQQN0aiABNwMAIARBAWohBAwBCwsgCyAFPgIoIAsoAhQgBUL/////D4M3AwAgBUKAgICACHwhAQwBCyAAIAxBCGogBhA8DQEgDCkDCCIBIAKsIgh8IgVCgICAgICAgBBZBEAgAEHQ2gBBABAVDAILAkAgBEUgAkEATHJFBEBCACEHIAAgBiAIQgAgAUF/EPQCDQMMAQsgASEHCyACQQAgAkEAShutIQlCACEBA0AgASAJUgRAIAMgAadBA3RqKQMAIghCIIinQXVPBEAgCKciAiACKAIAQQFqNgIACyABIAd8IQogAUIBfCEBIAAgBiAKIAgQhgFBAE4NAQwDCwsgACAGQTAgBUKAgICACHwiAUL/////D1gEfiAFQv////8PgwVCgICAgMB+IAW5vSIHQoCAgIDAgYD8/wB9IAdC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQELIAAgBhAPIAVC/////w+DIAFC/////w9YDQEaQoCAgIDAfiAFub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwwBCyAAIAYQD0KAgICA4AALIQEgDEEQaiQAIAEL0gMCB38DfiMAQSBrIgQkACAEQQA2AgwgBEEANgIIAkACQCAEIAAoAhAoAnhJBEAgABDpAQwBCyAAIAEgAiABQQAQFCILQoCAgIBwg0KAgICA4ABRBEAgCyEBDAILAkACQCALQoCAgIBwVA0AIAAgCxDKASIKQQBIDQECQCAKBEAgACAEQQxqIAsQ1gFFDQEMAwsgACAEQQhqIARBDGogC6dBERCOASEJIAQoAgghBSAJQQBIDQILIAQoAgwhCANAIAcgCEYNAQJAIAoEQCAAIAcQqQUiBkUNBAwBCyAAIAUgB0EDdGooAgQQGCEGCwJ/AkAgACALIAYgAxD5BCINQoCAgIBwgyIMQoCAgIAwUgRAIAxCgICAgOAAUg0BIAAgBhATDAULIAAgCyAGQQAQ1QEMAQsgACALIAYgDUEHEBkLIQkgACAGEBMgB0EBaiEHIAlBAE4NAAsMAQsgACAFIAgQWkEAIQUgACACEFwiDEKAgICAcINCgICAgOAAUQ0AIAQgCzcDGCAEIAw3AxAgACADIAFBAiAEQRBqECEhASAAIAwQDyAAIAsQDwwCCyAAIAUgBCgCDBBaIAAgCxAPC0KAgICA4AAhAQsgBEEgaiQAIAELPwEBfyABQQAgAUEAShshAQNAAkAgASADRgRAQX8hAwwBCyAAIANBA3RqKAIEIAJGDQAgA0EBaiEDDAELCyADC/8EAgJ/BH4CQCACQv////9vWARAIAAQJAwBCwJAIAAgAkE9EHEEf0KAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPSACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBgQJBgAIgACAHECYbBUEACyEDIAAgAkE+EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPiACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBggRBgAQgACAHECYbIANyIQMLIAAgAkE/EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPyACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBhAhBgAggACAHECYbIANyIQMLQoCAgIAwIQYCQCAAIAJBwAAQcUUEQEKAgICAMCEIDAELQoCAgIAwIQUgACACQcAAIAJBABAUIghCgICAgHCDQoCAgIDgAFEEQAwCCyADQYDAAHIhAwsCQAJAIAAgAkHBABBxRQ0AQoCAgIAwIQUgA0GAEHIhAyAAIAJBwQAgAkEAEBQiBkKAgICAcIMiB0KAgICAMFENAEHDwgAhBCAHQoCAgIDgAFENASAAIAYQOEUNAQsCQCAAIAJBwgAQcUUEQEKAgICAMCEFDAELIANBgCByIQMgACACQcIAIAJBABAUIgVCgICAgHCDIgJCgICAgDBRDQBBtMIAIQQgAkKAgICA4ABRDQEgACAFEDhFDQELIANBgDBxBEBBsekAIQQgA0GAxABxDQELIAEgBTcDGCABIAY3AxAgASAINwMIIAEgAzYCAEEADwsgACAEQQAQFQsgACAIEA8gACAGEA8gACAFEA8LQX8LwgEBAn8gAigCBEUEQCACKAIYIgMgAigCHCIENgIEIAQgAzYCACACQgA3AhgCQCABKAIABEAgAhCfBQwBCyAAIAIpAyAQIwsgACACKQMoECMgAiACKAIAQQFrIgM2AgACQCADRQRAIAIoAhAiAyACKAIUIgQ2AgQgBCADNgIAIAJCADcCECAAQRBqIAIgACgCBBEAAAwBCyACQoCAgIAwNwMoIAJCgICAgDA3AyAgAkEBNgIECyABIAEoAgxBAWs2AgwLC5UBAQN+IAG9IgJC////////////AIMhAyAAvSIEQv///////////wCDQoGAgICAgID4/wBaBEAgA0KBgICAgICA+P8AVA8LAn9BfyADQoCAgICAgID4/wBWIAAgAWNyDQAaQQEgACABZA0AGkEAIABEAAAAAAAAAABiDQAaIARCAFMEQCACQj+Hp0F/cw8LIAJCP4inCwswACABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgACABEDcPCyAAIAFBOEEAQQAQrQILKQEBfyACQiCIp0F1TwRAIAKnIgMgAygCAEEBajYCAAsgACABIAIQxQULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCEAVCgICAgOAACws4ACAAIAEgAhCTASIARQRAQoCAgIDgAA8LIAAoAiAoAgwiACAAKAIAQQFqNgIAIACtQoCAgIBwhAtRAgF+AX8gACAAKQOQAUEDEEkiAkKAgICAcINCgICAgOAAUgRAIAFCIIinQXVPBEAgAaciAyADKAIAQQFqNgIACyAAIAJBNCABQQMQGRoLIAILlQEBA38jAEEQayIEJAAgBCACNwMIIAEoAgAiBSABKAIEIgY2AgQgBiAFNgIAIAFCADcCACAAIAAgAUEgaiADQQN0aikDAEKAgICAMEEBIARBCGoQIRAPIAAgASkDEBAPIAAgASkDGBAPIAAgASkDIBAPIAAgASkDKBAPIAAoAhAiAEEQaiABIAAoAgQRAAAgBEEQaiQAC40BAQN/IwBBEGsiBCQAIAQgATcDCCADQQF0IQZBACEDA0ACQAJAIANBAkYNACAAQcwAQQEgAyAGakEBIARBCGoQzwEiAUKAgICAcINCgICAgOAAUg0BQX8hBSADQQFHDQAgACACKQMAEA8LIARBEGokACAFDwsgAiADQQN0aiABNwMAIANBAWohAwwACwALyAYCBn8CfiMAQTBrIgMkACABQQhqIQUgAUHIAGohBgJAAkACQAJAA0AgASgCTCICIAZGDQQCQAJAAn8CQAJAAkACQCABKAIEIgQOBgACAgULAQYLIAIoAghFDQIgACABEOADDAYLAkACQCACKAIIDgIIAAELIAFBBDYCBCADIAIpAxA3AyggACAAKQNQIAEgA0EoakEAEP4BIghCgICAgHCDQoCAgIDgAFENCiAAIAE1AgBCgICAgHCEIANBARCEBUUEQCADQoCAgIAwNwMYIANCgICAgDA3AxAgACAIIAMgA0EQahCvAhogACADKQMAEA8gACADKQMIEA8LIAAgCBAPDAoLIAAgAiACKQMQEN8DDAkLIAIpAxAiCEIgiKdBdU8EQCAIpyIHIAcoAgBBAWo2AgALIARBAUcgAigCCCIEQQJHckUEQCAAIAgQigFBAQwCCyABKAJEIgIgBK03AwAgAkEIayAINwMAIAEgAkEIajYCRAtBAAshAiABQQM2AgQgASACNgIUCyAAIAUQtAIiCUKAgICAcIMiCEKAgICA4ABRBEAgACgCECICKQOAASEIIAJCgICAgCA3A4ABIAAgARDgAyAAIAEoAkwgCBDfAyAAIAgQDwwCCyAJQv////8PWARAIAEoAkRBCGsiAikDACEIIAJCgICAgDA3AwACQAJAIAmnIgIOAwEAAAMLIAEgAjYCBCAAIAEgCEEAEPoCIAAgCBAPDAMLIAMgCDcDKCAAIAApA1AgASADQShqQQAQ/gEiCUKAgICAcINCgICAgOAAUQ0FIAAgATUCAEKAgICAcIQgA0EQakEAEIQFBEAgACAJEA8MBgsgA0KAgICAMDcDCCADQoCAgIAwNwMAIAAgCSADQRBqIAMQrwIaIAAgCRAPQQAhAQNAIAFBAkYNBiAAIANBEGogAUEDdGopAwAQDyABQQFqIQEMAAsACyAIQoCAgIAwUg0DIAEoAkRBCGsiAikDACEIIAJCgICAgDA3AwAgACABEOADIAAgASAIQQEQ+gIgACAIEA8MAQsLEAEACyAAIAFCgICAgDBBARD6AgwCC0HZkQFBrvwAQbWZAUHbJRAAAAsgACAIEA8LIANBMGokAAulAwIEfwF+IwBBEGsiBiQAAkACQAJAAkAgAkEASARAIAYgAkH/////B3E2AgAgAUHAAEHcIiAGEE4aDAELIAAoAiwgAk0NAiACRQRAIAFB9ogBKAAANgADIAFB84gBKAAANgAADAELIAAoAjggAkECdGooAgAiBEEBcQ0DIAEhAgJAIARFDQAgBCkCBCIHQoCAgIAIg1AEQCAEQRBqIQMgB6dB/////wdxIQVBACECQQAhAANAIAIgBUZFBEAgACACIANqLQAAciEAIAJBAWohAgwBCwsgAEGAAUgNAwsgBEEQaiEFQQAhACABIQIDQCAAIAenQf////8HcU8NAQJ/IAdCgICAgAiDUEUEQCAFIABBAXRqLwEADAELIAAgBWotAAALIQMgAiABa0E5Sg0BAn8gA0H/AE0EQCACIAM6AAAgAkEBagwBCyACIAMQoQMgAmoLIQIgAEEBaiEAIAQpAgQhBwwACwALIAJBADoAAAsgASEDCyAGQRBqJAAgAw8LQe/fAEGu/ABB3xdBoYEBEAAAC0GPkgFBrvwAQekXQaGBARAAAAuHAQEEfyAAQRBqIQMgAUHIAGohBCABKAJMIQIDQCACIARGRQRAIAIoAgQhBSAAIAIpAxAQIyAAIAIpAxgQIyAAIAIpAyAQIyAAIAIpAygQIyADIAIgACgCBBEAACAFIQIMAQsLIAEoAgRBfnFBBEcEQCAAIAFBCGoQ/gILIAMgASAAKAIEEQAAC2ABAn8gASABKAIAQQFrIgI2AgAgAkUEQCAAIAEQ3QMgACABKQMQECMgACABKQMYECMgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUIANwIIIABBEGogASAAKAIEEQAACwvzAwIDfwJ+IwBBMGsiAiQAAkACQCAAIAFBKGoQtAIiBUKAgICAcIMiBkKAgICA4ABRDQAgAiABKAJkQQhrIgMpAwA3AyAgA0KAgICAMDcDACAGQoCAgIAwUQRAIAAgACABKQMQQoCAgIAwQQEgAkEgahAhEA8gACACKQMgEA8gACgCECABEN0DDAILIAAgBRAPQQAhAyAAIAApA1AgACACQSBqQQAQ/gEhBSAAIAIpAyAQDyAFQoCAgIBwg0KAgICA4ABRDQADQAJAIANBAkcEQCACQRBqIANBA3RqIAAgACkDMCADQTVqEEkiBjcDACAGQoCAgIBwg0KAgICA4ABSDQEgA0EBRgRAIAAgAikDEBAPCyAAIAUQDwwDCyACQoCAgIAwNwMIIAJCgICAgDA3AwAgACAFIAJBEGogAhCvAiEEIAAgBRAPQQAhAwNAIANBAkZFBEAgACACQRBqIANBA3RqKQMAEA8gA0EBaiEDDAELCyAEDQIMAwsgASABKAIAQQFqNgIAIAanIAE2AiAgA0EBaiEDDAALAAsgACgCECIDKQOAASEFIANCgICAgCA3A4ABIAIgBTcDKCAAIAEpAxhCgICAgDBBASACQShqECEhBSAAIAIpAygQDyAAKAIQIAEQ3QMgACAFEA8LIAJBMGokAAufAwIHfwF+IwBBMGsiBiQAAkAgAUKAgICAcFQNACABpyIELwEGQTFHDQAgBCgCICIFRQ0AIAUoAgANACACQiCIp0F1TwRAIAKnIgQgBCgCAEEBajYCAAsgACAFQRhqIAIQICAFIANBAWoiBDYCAAJAIARBAkcNACAFKAIUDQAgACgCECIEKAKYASIHRQ0AIAAgASACQQAgBCgCnAEgBxE4AAsgA0EAR61CgICAgBCEIQEgBSADQQN0aiIEQQRqIQggBCgCCCEEA0AgBCAIRkUEQCAEKAIEIQcgBiAEKQMINwMAIAYgBCkDEDcDCCAEKQMYIQsgBiACNwMgIAYgATcDGCAGIAs3AxAgAEHLAEEFIAYQmgMgBCgCACIJIAQoAgQiCjYCBCAKIAk2AgAgBEIANwIAIAAoAhAgBBCuAiAHIQQMAQsLIAVBASADa0EDdGoiA0EEaiEHIAMoAgghBANAIAQgB0YNASAEKAIAIgUgBCgCBCIDNgIEIAMgBTYCACAEQgA3AgAgACgCECAEEK4CIAMhBAwACwALIAZBMGokAAuoAgIEfwF8IwBBEGsiBSQAA0ACQEF/IQQCQAJAAkACQEEHIAJCIIinIgYgBkEHa0FuSRtBCWoOEQIDAwMDAwMDAwAAAAADAwQBAwsgAqchA0EAIQQMAwtBACEEIAJCgICAgMCBgPz/AHwiAkL///////////8Ag0KAgICAgICA+P8AVgRADAMLQYCAgIB4IQMgAr8iB0QAAAAAAADgwWMNAkH/////ByEDIAdEAADA////30FkDQIgB5lEAAAAAAAA4EFjBEAgB6ohAwwDC0GAgICAeCEDDAILQQAhBCAFQQxqIAKnQQRqQQAQqQEgACACEA8gBSgCDCEDDAELIAAgAhCNASICQoCAgIBwg0KAgICA4ABSDQELCyABIAM2AgAgBUEQaiQAIAQLsQYBDX8jAEHwAGsiByQAAkACQAJ/IAIgAkEBayIFcUUEQCABKAIMQQV0IAEoAghBICAFZ2siCW8iBWsgCUEAIAVBAEobaiENIAlBICAJQf8BcW4iDGwhDiABDAELIAIQlwUhCCABKAIAIQUgB0IANwIYIAdCgICAgICAgICAfzcCECAHIAU2AgwgB0EMaiADIAJB3qgEai0AACIMakEBayAMbiINEEENAUEAIQUgBygCDCILKAIAQQBBBEHEACAHKAIYIglBAWtnQQF0ayAJQQJJGyIKQRRsIAsoAgQRAQAiBkUNAQNAIAUgCkZFBEAgBygCDCEQIAYgBUEUbGoiDkIANwIMIA5CgICAgICAgICAfzcCBCAOIBA2AgAgBUEBaiEFDAELC0EAIQUgBiAHKAIcIAEgCUEAIAkgCEEgIAhBAWtna0EAIAhBAk8bEKEEIQgDQCAFIApGRQRAIAYgBUEUbGoQGyAFQQFqIQUMAQsLQQAhCSALKAIAIAZBACALKAIEEQEAGiAIDQEgDCANbCADayELQQEhDiAHQQxqCyEIQX8gCXRBf3MhEEEAIQogAkEKRyERIAwhBQNAIAMgCk0NAiAFIAxGBEAgDSAOayENAkAgCUUEQEEAIQUgDSAIKAIMSQRAIAgoAhAgDUECdGooAgAhBQsgDCEGIBFFBEADQCAGQQBMDQMgBkEBayIGIAdBIGpqIAUgBUEKbiIFQfYBbGpBMHI6AAAMAAsACwNAIAZBAEwNAiAGQQFrIgYgB0EgampBMEHXACAFIAUgAm4iBSACbGsiD0EKSBsgD2o6AAAMAAsACyAIKAIQIAgoAgwgDRBoIQYgDCEFA0AgBUEATA0BIAVBAWsiBSAHQSBqakEwQdcAIAYgEHEiD0EKSBsgD2o6AAAgBiAJdiEGDAALAAsgCyEFQQAhCwsCQCAKIAQiBkkNACADIQYgBCAKRw0AIABBLhARCyAAIAdBIGogBWogDCAFayIPIAYgCmsiBiAGIA9KGyIGEHIgBiAKaiEKIAUgBmohBQwACwALIABBATYCDCAHQQxqIQgLIAEgCEcEQCAIEBsLIAdB8ABqJAALwgECA38BfiAAIABBH3UiA3MgA2shA0EAAn8gASABQQFrIgRxRQRAQSAgBGciBWshBCACBEBBHyAFa0EAIABBAE4bIANqIARuDAILIARBACABQQJPGyADbAwBCyAAQX9zQR92IQQgAUECayEBIAQCfiACBEAgA60iBiABQQN0IgFB5KEEajUCAH5CIIggAUHgoQRqNQIAIAZ+fEIfiAwBCyABQQJ0QYCkBGo1AgAgA61+Qh2IC6dqCyIBayABIABBAEgbC0gBAn8jAEEQayICJABBfyEDAkAgACACQQxqIAEQugENACACKAIMIgNBJWtBXEsNACAAQdmJAUEAEFBBfyEDCyACQRBqJAAgAwt1AQF/AkAgAUKAgICAcINCgICAgOB+UQRADAELAkAgAUKAgICAcFQNACABpyICLwEGQSFHDQAgAikDICIBQoCAgIBwg0KAgICA4H5SDQAMAQsgAEGiLEEAEBVCgICAgOAADwsgAaciACAAKAIAQQFqNgIAIAELrgICAXwBfwJAA0ACQAJAAkACQAJAQQcgAkIgiKciBCAEQQdrQW5JG0EJag4RAgMDAwMDAwMDAAAAAAMDBAEDCyABIALENwMADAULIAJCgICAgMCBgPz/AHwiAkL///////////8Ag0KBgICAgICA+P8AWgRAIAFCADcDAAwFCyACvyIDRAAAAAAAAODDYwRAIAFCgICAgICAgICAfzcDAAwFCyADRAAAAAAAAOBDZARAIAFC////////////ADcDAAwFCyABAn4gA5lEAAAAAAAA4ENjBEAgA7AMAQtCgICAgICAgICAfws3AwAMBAsgASACp0EEakEAEIIDGiAAIAIQDwwDCyAAIAIQjQEiAkKAgICAcINCgICAgOAAUg0BCwsgAUIANwMAQX8PC0EAC7ECAQJ/IwBBIGsiBCQAAkACQAJAIAIoAgxFBEACQAJAAkACQCACKAIIQf7///8Haw4CAQACCyAAEDUMAgsgAigCBA0DCyAAIAIQRBoLQQAhAiABRQ0DIAFCABAwGgwDCyACKAIERQ0BCyAAEDVBASECIAFFDQEgAUIAEDAaDAELIAAgAiACKAIIQQFqQQJtQQEQkQYgAEEBENEBGiABIgNFBEAgACgCACEDIARCADcCGCAEQoCAgICAgICAgH83AhAgBCADNgIMIARBDGohAwsgAyAAIABB/////wNBARBDGiADIAMoAgRBAXM2AgQgAyADIAJB/////wNBARDLARpBICECIAMoAghB/////wdHBEAgAygC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AkEAEI0FIQVBECEEA0AgA0E0aiILIAJBACAEIAVqIglBAWoiB0HgDxD8AiALIAsgA0EgaiAHQeAPEENyIgdBIHENAyAHQRBxRQ0CIANBNGogAygCPEEBIAkQ4QMNAiAEQQJtIARqIQQMAAsACyADQTRqIANBIGoQRA0BDAMLIANBNGpBARDRAUEgcUUNAgsgA0E0ahAbDAQLIANByABqIANBNGogAiAFIAUQjAUMAQsgAygCTCEFIANByABqIANBNGogAiAIIAgQjAUgAygCTCIJIAVBAWoiAiACIAlJG0EBayEIIAMoAkghByAFIQQDQAJAIAkgBCICQQFqIgRNBEAgCCECDAELIAIgB2otAABBMEcNACAEIAdqLQAAQS5HDQELCyACIAVNDQAgBSAHaiACIAdqIAkgAmsQnAEgAyAFIAJrIAlqNgJMCyADQTRqEBsLIANByABqQQAQESADKAJUDQAgAygCSAwBC0EAIAMoAkgiAkUNABogCigCACACQQAgCigCBBEBABpBAAshBCAGIAw2AgQgACAGIANBDGoQXiAERQRAIAAQfAwBCyAAIAQQYiENIAAoAtgBIgAoAgAgBEEAIAAoAgQRAQAaCyADQeAAaiQAIA0Lw3UCEn8BfiMAQaAGayIDJAAgASgCyAEiBEEAIARBAEobIQYDQCACIAZGRQRAIAEoAswBIAJBA3RqQX82AgQgAkEBaiECDAELCyABKAI8BEAgASgCzAFBfjYCDAtBACECIAEoAnwiBkEAIAZBAEobIQYCfgJAAkADQCACIAZGBEACQEECIQJBAiAEIARBAkwbIQgDQAJAIAIgCEYEQEEAIQIDQCACIAZGDQICQCABKAJ0IAJBBHRqIgQoAghBAE4NACAEKAIEIghBAkgNACAEIAEoAswBIgQgBCAIQQN0aigCAEEDdGooAgQ2AggLIAJBAWohAgwACwALIAEoAswBIgcgAkEDdGoiBCgCBEEASARAIAQgByAEKAIAQQN0aigCBDYCBAsgAkEBaiECDAELCwJAIAEoAkRFDQACQCABKAIgDQAgAS0AbkEBcQ0AIAEgACABQdIAEE82ApABIAEoAjxFDQAgASAAIAFB0wAQTzYClAELAkAgASgCTCIIRQ0AIAEoAqgBQQBIBEAgASAAIAEQygM2AqgBCyABKAKsAUEASARAIAEgACAB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KAIAEB0gAkHAABARIAIgACAJKAIMEBgQHSACIBEQEQsgACAJKAIMEBMgBEEBaiEEDAALAAtBhSlBrvwAQYzyAUH7ORAAAAtBmoIBQa78AEHY6wFB3/QAEAAAC0GuhAFBrvwAQZvrAUHf9AAQAAALA0AgAiAOTkUEQCADQYAGaiACIA1qIgQgBC0AAEECdEGAuAFqLQAAIgQQciACIARqIQIMAQsLIAwQ9gEgDCADKQOQBjcCECAMIAMpA4gGNwIIIAwgAykDgAY3AgAMDAsgDBD2ASAMIAMpA5AGNwIQIAwgAykDiAY3AgggDCADKQOABjcCAAJAIAEoAowCDQAgASgCpAIhDSADIAEoAvACNgKYBiADIAEoAoACIgk2AtwFIAMgASgChAIiCzYC4AUgACgCECECIANCADcDiAYgA0IANwOABiADIAI2ApQGIANBOzYCkAYgASgC0AIiAgRAIAEgASgCACACQQR0EF8iAjYCzAIgAkUNDQsCQCABKALcAiICRQ0AIAEtAG5BAnENACABIAEoAgAgAkEDdBBfIgI2AtgCIAJFDQ0gAUEANgLoAiABIAEoAvACNgLkAgsgASgCtAFBAE4EQCADQYAGaiICQQwQESACQQQQESACQdkAIAEoArQBEF0LIAEoArABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKwARBdCyABKAKsAUEATgRAIANBgAZqIgJBDBARIAJBAxARIAJB2QAgASgCrAEQXQsCQCABKAKoAUEASA0AIAEoAmAEQCADQYAGaiICQeEAEBEgAiABLwGoARAqDAELIANBgAZqIgJBCBARIAJB2QAgASgCqAEQXQsgASgCmAFBAE4EQEEAIQIgAS0AbkEBcUUEQCABKAI4QQBHIQILIANBgAZqIgRBDBARIAQgAhARIAEoApwBIgJBAE4EQCADQYAGakHaACACEF0LIANBgAZqQdkAIAEoApgBEF0LIAEoAqABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKgARBdCyABKAKQAUEATgRAIANBgAZqIgJBDBARIAJBBRARIAJB2QAgASgCkAEQXQsgASgClAFBAE4EQCADQYAGaiICQQwQESACQQUQESACQdkAIAEoApQBEF0LQQAhAgJAA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAiALTgRAQQAhAiABKAKsAiIEQQAgBEEAShshBANAIAIgBEYNAiACQRRsIQYgAkEBaiECIAYgDWooAhBFDQALQdWDAUGu/ABB/foBQZQ4EAAACyACIAIgCWoiBi0AACIFQQJ0QYC4AWotAAAiB2ohBAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBUHYAGsOIBASGhESGhESGhoaGhoaGhoaBAQBAwIaGgwMBQUFBQUFAAsCQCAFQQFrDhUJCgoLGg0HGggIGhoaBhoaDxoaGg4ACyAFQSJrIghBH0sNGEEBIAh0IgpBwOEBcQ0SIApBBXFFBEAgCEEfRw0ZIAYoAAFBMEcNGiABIAMoAoQGIAMoApgGEDMgA0GABmpB6QEQESAEIQIMIwsgBi8AASECIANCqICAgHA3A1AgA0HcBWogBCADQdAAahAnBEACQCADKALoBSIEQQBIBEAgAygCmAYhBAwBCyADIAQ2ApgGCyABIAMoAoQGIAQQMyADQYAGaiAFQQFqIAIQXSABIAkgCyADKALkBSADQZgGahCkAiECDCMLIAEgAygChAYgAygCmAYQMyADQYAGaiAFIAIQXSAEIQIMIgsgBigAASEFIAQhBgwWCyAGKAABIQdB7QAhBQwUCyAGKAABIQdB7AAhBQwTCyABIAYoAAEgA0GcBmpBABDHAyEHIAMoAtwFIAMoAuAFIAQgBxDGAwRAIAEgB0F/EGkaIANBgAZqQQ4QESAEIQIMHwsgA0LrgICAcDcDYCADQdwFaiAEIANB4ABqECdFDRIgAygC6AUhCCADKALcBSADKALgBSADKALkBSIGIAcQxgNFDRIgCEEATgRAIAMgCDYCmAYLIAEgB0F/EGkaIAVBA3MhBSADKAL0BSEHDBwLIAYtAAkhCCAGKAABIQcgASAGKAAFIANBnAZqQQAQxwMiAkEASA0PIAIgASgCrAJODQ8gASADKAKEBiADKAKYBhAzIAEgASgC1AIiBkEBajYC1AIgASgCzAIgBkEEdGoiBkEENgIEIAYgBTYCACADKAKEBiEKIAYgAjYCDCAGIApBBWo2AgggA0GABmoiBiAFEBEgBiAHEB0gBiANIAJBFGxqIgIoAgwgAygChAZrEB0gAigCDEF/RgRAIAAgAiADKAKEBkEEa0EEEOgCRQ0dCyADQYAGaiAIEBEgBCECDB0LIANCqYCAgHA3A3AgA0HcBWogBCADQfAAahAnRQ0TIAQhAiADKALoBSIEQQBIDRwgAyAENgKYBgwcCyADQquBgIBwNwOgASADQdwFaiAEIANBoAFqECcEQAJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqQfMBEBEMGAsgA0F/NgKYASADQqyBgICQzRo3A5ABIANB3AVqIAQgA0GQAWoQJ0UNAAJAIAMoAugFIgVBAEgEQCADKAKYBiEFDAELIAMgBTYCmAYLIAEgAygChAYgBRAzIANBgAZqQfMBEBEgAygC7AVBA3MhBQwYCyADQunUgYBwNwOAASADQdwFaiAEIANBgAFqECdFDREgBUEKRiEKDA0LAkAgBigAASIGQYCAgIB4ckGAgICAeEYNACADQoyBgIBwNwPgASADQdwFaiAEIANB4AFqECdFDQAgAygC6AUiAkEATgRAIAMgAjYCmAYLIANCjoCAgHA3A9ABIANB3AVqIAMoAuQFIANB0AFqECcEQCADKALoBSICQQBIDRcgAyACNgKYBgwXCyABIAMoAoQGIAMoApgGEDMgA0GABmpBACAGaxDFAwwWCyADQo6AgIBwNwPAASADQdwFaiAEIANBwAFqECcEQCADKALoBSICQQBIDRYgAyACNgKYBgwWCyADQunUgYBwNwOwASADQdwFaiAEIANBsAFqECcEQCAGQQBHIQoMDQsgASADKAKEBiADKAKYBhAzIANBgAZqIAYQxQMgBCECDBkLIAYoAAEiAkH/AUoNDyABIAMoAoQGIAMoApgGEDMgA0GABmoiBiAFQcMAa0H/AXEQESAGIAJB/wFxEBEgBCECDBgLIAYoAAEhAiADQo6AgIBwNwPwASADQdwFaiAEIANB8AFqECcEQCAAIAIQEyADKALoBSICQQBIDRQgAyACNgKYBgwUCyACQS9HDQ4gASADKAKEBiADKAKYBhAzIANBgAZqQcEBEBEgBCECDBcLIANCyYCAgHA3A6gCIANC2Lb5gnA3A6ACIANB3AVqIAQiAiADQaACahAnDRYgA0F/NgKYAiADQoGEkICQCTcDkAIgA0HcBWogAiADQZACahAnDRYgA0F/NgKIAiADQoaOqMiQCTcDgAIgA0HcBWogAiADQYACahAnDRYMDQsgA0KOgICAcDcD8AIgA0HcBWogBCADQfACahAnBEAgAygC6AUiAkEASA0SIAMgAjYCmAYMEgsgA0KogICAcDcD4AIgA0HcBWogBCADQeACahAnBEACQCADKALoBSICQQBIBEAgAygCmAYhAgwBCyADIAI2ApgGCyABIAMoAoQGIAIQMyADQYAGakEpEBEMEgsgA0Lp1IGAcDcD0AJBACEKIANB3AVqIAQgA0HQAmoQJw0IIANCq4GAgHA3A8ACIANB3AVqIAQgA0HAAmoQJwRAAkAgAygC6AUiAkEASARAIAMoApgGIQIMAQsgAyACNgKYBgsgASADKAKEBiACEDMgA0GABmpB8gEQEQwSCyADQX82ArgCIANCrIGAgJDNGjcDsAIgA0HcBWogBCADQbACahAnRQ0MAkAgAygC6AUiBUEASARAIAMoApgGIQUMAQsgAyAFNgKYBgsgASADKAKEBiAFEDMgA0GABmpB8gEQESADKALsBUEDcyEFDBILIANBfzYCiAMgA0LD9oCA4AE3A4ADIANB3AVqIAQgA0GAA2oQJ0UNCwJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqIgIgAy0A7AUQESACIAMoAvwFEB0MEAsgA0F/NgK4AyADQtm4/YJwNwOwAyADQdwFaiAEIANBsANqECdFDQogAygC6AUiAkEATgRAIAMgAjYCmAYLIANCjoCAgHA3A6ADIAMoAuwFIgVBAWohBgJAIANB3AVqIAMoAuQFIgIgA0GgA2oQJwR/IAMoAugFIgJBAE4EQCADIAI2ApgGCyADIAMoAvAFNgKUA0F/IQQgA0F/NgKYAyADIAVBAWs2ApADIANB3AVqIAMoAuQFIgIgA0GQA2oQJ0UNASADKALkBSECIAMoAugFBUF/CyEEIAYhBQsgASADKAKEBiADKAKYBhAzIANBgAZqIAUgAygC8AUQXSAEQQBIDRMgAyAENgKYBgwTCyAGLwABIgJB/wFLDQkgA0KOgICAcDcCzAQgAyACNgLIBCADQpCjgoCQCzcDwAQCQCADQdwFaiAEIANBwARqECdFBEAgA0KOgICAcDcDsAQgAyACNgKsBCADQdkANgKoBCADQo6fgoCQAjcDoAQgA0HcBWogBCADQaAEahAnRQ0BCwJAIAMoAugFIgVBAEgEQCADKAKYBiEFDAELIAMgBTYCmAYLIAEgAygChAYgBRAzIANBgAZqIgZBkwFBkwFBkgEgAygC7AUiBEGRAUYbIARBjwFGGxARIAYgAkH/AXEQEQwPCyADQo6AgIBwNwKUBCADIAI2ApAEIANCkYCAgJALNwOIBCADQoSAgIDQEzcDgAQgA0HcBWogBCADQYAEahAnBEACQCADKALoBSIFQQBIBEAgAygCmAYhBQwBCyADIAU2ApgGCyABIAMoAoQGIAUQMwJAIAMoAvwFQS9GBEAgA0GABmpBwQEQEQwBCyADQYAGaiIEQQQQESAEIAMoAvwFEB0LIANBgAZqIgRBlAEQESAEIAJB/wFxEBEMDwsgA0KOgICAcDcC9AMgAyACNgLwAyADQpGAgICQCzcD6AMgA0KBgICA0BM3A+ADIANB3AVqIAQgA0HgA2oQJwRAAkAgAygC6AUiBUEASARAIAMoApgGIQUMAQsgAyAFNgKYBgsgASADKAKEBiAFEDMgA0GABmoiBCADKAL0BRDFAyAEQZQBEBEgBCACQf8BcRARDA8LIANCjoCAgHA3A9gDIAMgAjYC1AMgA0HZADYC0AMgA0KdgYCAkAI3A8gDIANC2Lb5gnA3A8ADIANB3AVqIAQgA0HAA2oQJwRAAkAgAygC6AUiBUEASARAIAMoApgGIQUMAQsgAyAFNgKYBgsgASADKAKEBiAFEDMgA0GABmoiBCADKALsBSADKALwBRBdIARBlAEQESAEIAJB/wFxEBEMDwsgASADKAKEBiADKAKYBhAzIANBgAZqQdgAIAIQXSAEIQIMEgsgBi8AASECIAEgAygChAYgAygCmAYQMyADQYAGaiAFIAIQXSAEIQIMEQsgAyAGLwABIgI2AuQEIANBfzYC6AQgAyAFQQFrNgLgBCADQdwFaiAEIANB4ARqECcEQAJAIAMoAugFIgRBAEgEQCADKAKYBiEEDAELIAMgBDYCmAYLIAEgAygChAYgBBAzIANBgAZqIAVBAWogAhBdDA0LIAEgAygChAYgAygCmAYQMyADQYAGaiAFIAIQXSAEIQIMEAsgASAJIAsgBCADQZgGahCkAiEEDAYLIAEoAtQCIQsgASgCzAIhBkEAIQpBACEJA0ACQCAKIAtIBEBBAyEIIAYoAgAiAkHpAGtBA08EQCACQe0BRw0CQQEhCAsCQCABKAKkAiAGKAIMQRRsaigCDCAGKAIIIgVrIgRBgH9IIAQgCEH/AGpKckUEQCAGQQE2AgQgAkHtAUYEQEHsASECIAZB7AE2AgAMAgsgBiACQYEBaiICNgIADAELIAJB6wBHIARBgIACakH//wNLcg0CIAZC7YGAgCA3AgBBAiEIQe0BIQILIAUgAygCgAZqQQFrIAI6AAAgBigCBCICIAMoAoAGIAVqaiIEIAQgCGogAygChAYgBSAIaiACamsQnAEgAyADKAKEBiAIazYChAZBACEEIAEoAqwCIgJBACACQQBKGyEHIAEoAqQCIQIDQCAEIAdGBEAgASgC1AIhCyAGIQcgCiEEA0ACQCALIARBAWoiBEwEQEEAIQIgASgC4AIiBEEAIARBAEobIQQDQCACIARGDQIgBSABKALYAiACQQN0aiIHKAIAIg1JBEAgByANIAhrNgIACyACQQFqIQIMAAsACyAHIgJBEGohByACKAIYIg0gBUwNASACIA0gCGs2AhgMAQsLIAlBAWohCQwDCyAFIAIoAgwiC0gEQCACIAsgCGs2AgwLIAJBFGohAiAEQQFqIQQMAAsACwJAIAlFDQAgASgCzAIhAkEAIQUDQCAFIAtODQEgASgCpAIgAigCDEEUbGooAgwgAigCCCIEayEGAkACQAJAAkAgAigCBEEBaw4EAAEDAgMLIAMoAoAGIARqIAY6AAAgASgC1AIhCwwCCyADKAKABiAEaiAGOwAADAELIAMoAoAGIARqIAY2AAALIAJBEGohAiAFQQFqIQUMAAsACyAAKAIQIgJBEGogASgCzAIgAigCBBEAACABQQA2AswCIAAoAhAiAkEQaiABKAKkAiACKAIEEQAAIAFBADYCpAICQCABLQBuQQJxDQAgASgC2AJFDQAgASgCACgCECECIAFCADcC9AIgAUIANwL8AiABIAI2AogDIAFBOzYChAMgAUH0AmohBSABKALwAiEHQQAhAkEAIQgDQCACIAEoAuACTg0BAkAgASgC2AIgAkEDdGoiBigCBCIEQQBIIAQgB0ZyDQAgBigCACIGIAhrIgpBAEgNAAJAIAQgB2siCEEBaiIHQQRLIApBMktyRQRAIAUgByAKQQVsakEBakH/AXEQEQwBCyAFQQAQESAFIAoQ5gQgBSAIQQF0IAhBH3VzEOYECyAGIQggBCEHCyACQQFqIQIMAAsACyAAKAIQIgJBEGogASgC2AIgAigCBBEAACABQQA2AtgCIAwQ9gEgDCADKQOQBjcCECAMIAMpA4gGNwIIIAwgAykDgAY3AgAgAUEBNgKgAiABKAKMAg0SIAEoAoACIQcgAyABKAKEAiIENgLcBSADIAAgBEEBdBApIgY2AuQFIAZFDR5BACECIARBACAEQQBKGyEEA0AgAiAERkUEQCAGIAJBAXRqQf//AzsBACACQQFqIQIMAQsLIANBADYC8AUgA0IANwLoBSADQQA2AuAFAkAgACADQdwFakEAQQBBABDDAQ0AA0ACQAJAAkAgAygC7AUiAkEASgRAIAMgAkEBayICNgLsBSAHIAMoAugFIAJBAnRqKAIAIgRqIggtAAAiAkEKakH/AXFBC0kEQEHgkwEhBQwECyAEIAJBD2ogAiACQbMBSxsiBkECdCIKQYC4AWotAABqIgkgAygC3AVKBEBB+5IBIQUMBAsgAygC5AUgBEEBdGovAQAhDCAKQYG4AWotAAAhBQJAIAZBIWsiC0EQS0EBIAt0Qb+ABHFFckUEQCAILwABIAVqIQUMAQsgBkH9AWtBA0sNACACIAVqQe4BayEFCyAFIAxKBEBBwZMBIQUMBAsCQCAKQYK4AWotAAAgBWsgDGoiBiADKALgBUwNACADIAY2AuAFIAZB/v8DTA0AQaOTASEFDAQLAkACQAJAAkACQAJAAkAgAkHpAGsODwICAQIDCwkJCQQGBAUFBQALIAJBI2siBUENSw0HQQEgBXRB5fAAcQ0KDAcLIAQgCCgAAWpBAWohCQwHCyAAIANB3AVqIAQgCCgAAWpBAWogAiAGEMMBRQ0GDAkLIAAgA0HcBWogBCAIKAABakEBaiACIAZBAWoQwwFFDQUMCAsgACADQdwFaiAEIAgoAAVqQQVqIAIgBkEBahDDAUUNBAwHCyAAIANB3AVqIAQgCCgABWpBBWogAiAGQQJqEMMBRQ0DDAYLIAAgA0HcBWogBCAIKAAFakEFaiACIAZBAWsQwwENBQwCCyAAKAIQIgJBEGogAygC5AUgAigCBBEAACAAKAIQIgJBEGogAygC6AUgAigCBBEAAEHAAEHYACABLQBuQQJxIgQbIgggASgCuAJBA3RqIQIgAygC4AUhCiAAAn8gBARAIAIgASgCREUNARoLIAEoAnwgASgCiAFqQQR0IAJqCyIHIAEoAsACQQN0aiIEIAEoAoQCahBfIgZFDSMgBkEBNgIAIAYgBCAGaiIENgIUIAYgASgChAIiBTYCGCAEIAEoAoACIAUQHxogACgCECIEQRBqIAEoAoACIAQoAgQRAAAgAUEANgKAAiAGIAEoAnA2AhwgASgCfCIEIAEoAogBIgVqQQBKBEACQAJAIAEtAG5BAnFFDQAgASgCRA0AQQAhBQNAIAQgBUwEQEEAIQUDQCABKAKIASAFTARAQQAhBQNAIAUgASgCwAJODQYgACAFQQN0IgIgASgCyAJqKAIEEBMgASgCyAIgAmpBADYCBCAFQQFqIQUMAAsABSAAIAEoAoABIAVBBHRqKAIAEBMgBUEBaiEFDAELAAsABSAAIAEoAnQgBUEEdGooAgAQEyAFQQFqIQUgASgCfCEEDAELAAsACyAGIAIgBmoiAjYCICACIAEoAoABIAVBBHQQHxogBigCICABKAKIAUEEdGogASgCdCABKAJ8QQR0EB8aCyAGIAEoAnw7ASogBiABKAKIATsBKCAGIAEoAowBOwEsIAAoAhAiAkEQaiABKAKAASACKAIEEQAAIAAoAhAiAkEQaiABKAJ0IAIoAgQRAAALIAYgASgCuAIiAjYCOCACBEAgBiAGIAhqIgQ2AjQgBCABKAK0AiACQQN0EB8aCyAAKAIQIgJBEGogASgCtAIgAigCBBEAACABQQA2ArQCIAYgCjsBLgJAIAEtAG5BAnEEQCAAIAEoAuwCEBMgAUH0AmoQ9gEMAQsgBiAGLwARQYAIcjsAESAGIAEoAuwCNgJAIAYgASgC8AI2AkQgBiAAIAEoAvQCIAEoAvgCEIkCIgI2AlAgAkUEQCAGIAEoAvQCNgJQCyAGIAEoAvgCNgJMIAYgASgCjAM2AlQgBiABKAKQAzYCSAsgASgCzAEiAiABQdABakcEQCAAKAIQIgRBEGogAiAEKAIEEQAACyAGIAEoAsACIgI2AjwgAgRAIAYgBiAHaiIENgIkIAQgASgCyAIgAkEDdBAfGgsgACgCECICQRBqIAEoAsgCIAIoAgQRAAAgAUEANgLIAiAGIAYvABFBfnEgAS8BNEEBcXIiAjsAESAGIAEvAThBAXRBAnEgAkF9cXIiAjsAESAGIAEtAG46ABAgBiABLwFgQQJ0QQRxIAJBe3FyIgI7ABEgBiACQU9xIAEvAWxBBHRBMHFyIgI7ABFBCCEFIAYgASgCtAFBAEgEfyABKAK4AUEAR0EDdAVBCAsgAkF3cXIiAjsAESAGIAEvAVBBBnRBwABxIAJBv39xciICOwARIAYgAkH/fnEgAS8BVEEHdEGAAXFyIgI7ABEgBiACQf99cSABLwFYQQh0QYACcXIiAjsAESAGIAJB/3txIAEvAVxBCXRBgARxciICOwARIAYgAkH/7wNxIAEvAWhBC3RBgBBxcjsAESAAIAAoAgBBAWo2AgAgBiAANgIwIAAoAhAhAiAGQQE6AAQgAigCUCIEIAZBCGoiCDYCBCAGIAJB0ABqNgIMIAYgBDYCCCACIAg2AlAgASgCBARAIAEoAhgiAiABKAIcIgQ2AgQgBCACNgIAIAFCADcCGAsgACgCECIAQRBqIAEgACgCBBEAACAGrUKAgICAYIQMJAsCQAJAAkAgAkHqAWsOBAICAQADCyAEIAguAAFqQQFqIQkMAgsgBEEBaiIEIAQgB2osAABqIQkMAQsgACADQdwFaiAEQQFqIgQgBCAHaiwAAGogAiAGEMMBDQMLIAAgA0HcBWogCSACIAYQwwFFDQEMAgsLIAMgBDYC1AUgAyACNgLQBSAAIAUgA0HQBWoQRgsgACgCECICQRBqIAMoAuQFIAIoAgQRAAAgACgCECICQRBqIAMoAugFIAIoAgQRAAAMHgsgBkEQaiEGIApBAWohCgwACwALQYUpQa78AEGs9wFBlDgQAAALIAMoAugFIgRBAE4EQCADIAQ2ApgGCyADKAL0BSEFIAMoAuQFIQYgAygC7AVB6QBrIApGDQEgASAFQX8QaRogBiECDAwLIAQhBgwJCyADQX82AtgFIAEgBSADQZwGaiADQdgFahDHAyEHIAMoAtwFIAMoAuAFIAYgBxDGAwRAIAEgB0F/EGkaIAYhAgwLCyADKAKcBiIEQShrIghBB0tBASAIdEGDAXFFckUEQCABIAdBfxBpGiABIAMoAoQGIAMoApgGEDMgA0GABmogBEH/AXEQESABIAkgCyAGIANBmAZqEKQCIQIMCwtB6wAhBQwICwJAIAVBkAFrQQJPBEAgBUGXAUYNASAFQbYBRwRAIAVBwgFHDQMgAyAGKAABNgKYBiAEIQIMDAsgBigAASICQQBIDQMgAiABKAKsAk4NAyANIAJBFGxqIggoAgxBf0cNBCAIIAMoAoQGNgIMIAgoAhAhBwNAIAciAgRAIAgoAgwgAigCBCIFayEGIAIoAgAhBwJAAkACQAJAIAIoAghBAWsOBAIBAwADCyADKAKABiAFaiAGNgAADAILIAZBgIACakGAgARPDQkgAygCgAYgBWogBjsAAAwBCyAGQYABakGAAk8NCSADKAKABiAFaiAGOgAACyAAKAIQIgZBEGogAiAGKAIEEQAADAELCyAIQQA2AhAgBCECDAsLIANCjoCAgHA3A6gFIANC2bj9gnA3A6AFIANB3AVqIAQgA0GgBWoQJwRAIAMoAugFIgJBAE4EQCADIAI2ApgGCyADIAMoAvAFIgY2ApQFIANBfzYCmAUgAyADKALsBSIEQQFrNgKQBSADQdwFaiADKALkBSICIANBkAVqECcEQCADKALoBSICQQBOBEAgAyACNgKYBgsgBEEBaiEEIAMoAuQFIQILIAEgAygChAYgAygCmAYQMyADQYAGaiIHIAVBAmtB/wFxEBEgByAEIAYQXQwLCyADQo6AgIBwNwOIBSADQpiAgICw6A43A4AFIANB3AVqIAQgA0GABWoQJwRAAkAgAygC6AUiAkEASARAIAMoApgGIQIMAQsgAyACNgKYBgsgASADKAKEBiACEDMgA0GABmoiAiAFQQJrQf8BcRARIAIgAy0A7AUQESACIAMoAvwFEB0MBwsgA0KOgICAcDcD+AQgA0KZgICAkAk3A/AEIANB3AVqIAQgA0HwBGoQJ0UNAQJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqIgIgBUECa0H/AXEQESACQckAEBEMBgsgA0F/NgLIBSADQoSAgICwlevUqn83A8AFIANB3AVqIAQgA0HABWoQJ0UNACADKALoBSIIQQBOBEAgAyAINgKYBgsgAygC7AUhCCADKAL8BSIFQcUARgR/QfQBBSAFQRtHDQFB9QELIQogCEF9cUGpAUYEQCABIAMoAoQGIAMoApgGEDMgA0GABmogChARIAAgAygC/AUQEwwGCyADQumAgIBwNwOwBSADQdwFaiADKALkBSADQbAFahAnRQ0A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DAELIAEgAzYCACACIAY2AgBBACEECyAHQRBqJAAgBAvCAwEJfyABKAIIIgZBACAGQQBKGyEFAkACQANAIAQgBUYNASAEQQJ0IQcgBEEBaiEEIAcgASgCAGooAgAgAkcNAAtBACEFDAELQX8hBSAAIAFBBCABQQRqIAZBAWoQeA0AIAEgASgCCCIEQQFqNgIIIAEoAgAgBEECdGogAjYCACABQRBqIQkgAUEMaiEHQQAhBQNAAkAgAigCICAFTARAQQAhBUEAIQQDQCAEIAIoAixODQQgBEECdCEDIARBAWohBCAAIAEgAigCECADIAIoAihqKAIAQQN0aigCBEEBEK8FRQ0ACwwBCwJAIANBACACKAIcIAVBFGxqIgYoAhAiCkEWRhsNAEEAIQQgASgCFCIIQQAgCEEAShshCwJAAkADQCAEIAtGDQEgCiAHKAIAIARBDGxqIgwoAgBHBEAgBEEBaiEEDAELCyAEQQBODQELIAAgB0EMIAkgCEEBahB4DQIgASABKAIUIgRBAWo2AhQgASgCDCAEQQxsaiIEIAYoAhA2AgACQCADRQRAIAYoAghFDQELIARBADYCCAwCCyAEIAY2AggMAQsgDEEANgIICyAFQQFqIQUMAQsLQX8PCyAFC2gCAn8BfiAAQRBqIQIgACkCBCIEp0H/////B3EhAwJAIARCgICAgAiDUEUEQEEAIQADQCAAIANGDQIgAiAAQQF0ai8BACABQYcCbGohASAAQQFqIQAMAAsACyACIAMgARCyBSEBCyABCxIAIAAgASACIANBgIABENABGgssAQF/A0AgASADRkUEQCAAIANqLQAAIAJBhwJsaiECIANBAWohAwwBCwsgAgvOAQIDfwF+IAEgAkEBELIFIgNB/////wNxIQUgACgCNCAAKAIkQQFrIANxQQJ0aiEDA0AgAygCACIERQRAQQAPCwJAIAAoAjggBEECdGooAgAiAykCBCIGQiCIp0H/////A3EgBUcgBkKAgICAgICAgECDQoCAgICAgICAwABSciAGp0H/////B3EgAkcgBkKAgICACINCAFJycg0AIANBEGogASACEGENACAEQd4BTgRAIAMgAygCAEEBajYCAAsgBA8LIANBDGohAwwACwALfwEEfyABLQAAQdsARgRAIAFBAWoiAxA/QQFrIQIgACgCECgCOCEEQdABIQEDQCABQd4BRwRAAkAgBCABQQJ0aigCACIFKAIEQf////8HcSACRw0AIAVBEGogAyACEGENACAAIAEQGA8LIAFBAWohAQwBCwsQAQALIAAgARCqAQusAgMCfwJ+AXwjAEEgayICJABEAAAAAAAA+H8hBiAAKAIIQf////8HRwRAIAAoAgAhAyACQgA3AhggAkKAgICAgICAgIB/NwIQIAIgAzYCDCACQQxqIAAQRBoCfiACKAIUIgBB/f///wdMBEAgAkEMakE1QcgEEM4BGiACKAIUIQALQoCAgICAgID4/wAgAEH+////B0YNABogAEGAgICAeEYEQEIADAELIAIoAhwhAwJ+IAIoAhhBAkYEQCADKQIADAELIAM1AgBCIIYLIQQgAEGCeEwEQCAEQY54IABrrYghBEIADAELIARCC4hC/////////weDIQQgAEH+B2qtQjSGCyEFIAQgBYQgAjUCEEI/hoS/IQYgAkEMahAbCyABIAY5AwAgAkEgaiQACw4AIABCgICAgPB+EIAGC+4PAwt/A34BfCMAQUBqIhAkAEHfAEGAAiAEQSBxGyEJIARBgANxIQsCQAJAAkACfwJAAkACQAJAAkACQAJAAkACQCABLQAAIgZBK2sOAwEDAAMLQQEhDiABQQFqIQEMAQsgAUEBaiEBCyAEQYAIcUUNASABLQAAIQYLIAZB/wFxQTBHDQACQAJAAkAgAS0AASIHQfgARwRAIAdB7wBGDQIgB0HYAEcNAQsgA0FvcQ0FIAFBAmohB0EQIQMMCQsgAyAHQc8AR3INAQwFCyADRQ0EDAMLAkACQCAHQeIARwRAIANFIAdBwgBGcQ0BIAMgB0Ewa0H/AXFBCUtyDQQgBEEQcQ0CDAcLIAMNBAsgBEEEcUUNBUECIQMgAUECaiEHDAcLIAFBAWohB0EBIQYDQCABIAZqIQMgBkEBaiEGIAMtAAAiCEH4AXFBMEYNAAtBCCEDQYACIQlBASEKIAhB/gFxQThGDQQMBgsgBEEBcSALQYACckGAAkdyDQAgAUEIaiEHQfUcIQYgASEIA0AgBkH9HEcEQCAILQAAIAYtAABHDQIgBkEBaiEGIAhBAWohCAwBCwsgC0GAAkYEQCAAELYFIhFCgICAgHCDQoCAgIDgAFEEQEKAgICA4AAhEQwJCyARp0EEaiAOEIwBDAgLRAAAAAAAAPD/RAAAAAAAAPB/IA4bIhS9IhECfyAUmUQAAAAAAADgQWMEQCAUqgwBC0GAgICAeAsiBre9UQRAIAatIREMCAtCgICAgMB+IBFCgICAgMCBgPz/AH0gEUL///////////8Ag0KAgICAgICA+P8AVhshEQwHCyABIgcgA0UNAxoMBQsgASEHDAQLIARBBHFFDQAgAUECaiEHQQghAwwCCyABCyEHQQohAwwBC0KAgICAwH4hESAHLQAAEJYBIANPDQELQQAhBiADQQpHIQwgByEBA0ACQCAGIAdqIg0tAAAiCMAhDyAIEJYBIANOBEAgCSAPRw0BAkAgDCAGQQFHcg0AIA1BAWstAABBMEcNAEEBIQYMAgsgDS0AARCWASADTg0BCyAHIAZBAWoiBmohAQwBCwtBACEMAkACQCAEQQFxDQACQCAIQS5HDQAgDS0AASEIIAZFBEAgCBCWASADTg0BCyANQQFqIQFCgICAgMB+IREgCSAIwEYNAgNAAkAgCEH/AXEQlgEgA0gEQCABLQABIQgMAQtBASEMIAkgCMBHDQIgAS0AASIIEJYBIANODQILIAFBAWohAQwACwALIAEgB00NAAJAIAEtAAAiBkHlAEcEQCADQQpGIAZBxQBGcQ0BIAZBIHJB8ABHIANBEEtyDQJBASADdEGEggRxDQEMAgsgA0EKRw0BC0EBIQwgAUEBaiEGAkACQAJAIAEtAAFBK2sOAwACAQILIAFBAmohBgwBCyABQQJqIQYLIAYtAABBOmtBdkkNACAGIQEDQCABIgZBAWohASAGLQABIgjAIQ0gCEE6a0F1Sw0AIAkgDUcNASAGLQACQTprQXVLDQALCyABIAdGBEBCgICAgMB+IREMAQsgECEJAkAgASAHayINQQJqIg9BwQBPBEAgACgCECIGQRBqIA8gBigCABEDACIJRQ0BC0EAIQZBACEIIA4EQCAJQS06AABBASEICyANQQAgDUEAShshDgNAIAYgDkZFBEAgBiAHai0AACINQd8ARwRAIAggCWogDToAACAIQQFqIQgLIAZBAWohBgwBCwsgCCAJakEAOgAAAn4CQAJAIARBwABxBEACQAJAAkACQCABLQAAQewAaw4DAQIAAwsgAUEBaiEBQYABIQsMBQsgAUEBaiEBQYACIQsMBAsgAUEBaiEBQYADIQsM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IAFBEGohAgJ/IAdCgICAgAiDUCIFRQRAIAIvAQAMAQsgAi0AAAsiAUEwayIDQQlLDQACfwJAIAFBMEcEQEEBIQEDQCABIARGDQICfyAFRQRAIAIgAUEBdGovAQAMAQsgASACai0AAAtBMGsiBkEJSw0EIAFBAWohASAGrSADrUIKfnwiB6chAyAHQoCAgIAQVA0ACwwDC0EAIgMgBEEBRw0BGgsgACADNgIAQQELDwtBAAupAgIDfwF+AkAgACACEDhFDQAgAqciBC8BBkEORgRAIAAgASAEKAIgKQMAENAFDwsgAUKAgICAcFQNAAJAIAAgAkE7IAJBABAUIgJC/////29YBEBBfyEDIAJCgICAgHCDQoCAgIDgAFENASAAQcYwQQAQFQwBCyABpyEEIAKnIQUCQANAAkAgBCgCECgCLCIDRQRAQQAhAyAELwEGQTBHDQQgBCAEKAIAQQFqNgIAIAStQoCAgIBwhCEBA0AgACABEIwCIgFCgICAgHCDIgZCgICAgCBRDQRBfyEDIAZCgICAgOAAUQ0FIAGnIAVGBEAgACABEA8MAwsgABB7RQ0ACyAAIAEQDwwECyADIgQgBUcNAQsLQQEhAwwBC0EAIQMLIAAgAhAPCyADC9IDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEGcgBCAAIAJBgfgAIAVrEI4CIAQpAwhCBIYgBCkDACIAQjyIhCECIAQpAxAgBCkDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgAkIBfCECDAELIABCgICA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cINCgICAgJB/UXFFBEAgAEGN9wBBABAVDAELIAAgAUESEGUiAUKAgICAcINCgICAgOAAUQ0AIAGnIgQgAz4CJCAEIAI+AiAgACABQdUAQgBBAhAZGiABDwsgACADEA8gACACEA9CgICAgOAACw0AIAAgAUHOlQEQ/wMLZwEBfwJAIAFBAE4EQCAAKAIQIgIoAiwgAU0NASACKAI4IAFBAnRqKAIAIgEgASgCAEEBajYCACAAIAFBBBCABA8LQfKRAUGu/ABBzhdBmdIAEAAAC0HZ3wBBrvwAQc8XQZnSABAAAAtEAQF/IABB+AFqIQIgAEH0AWohAAN/IAAgAigCACICRgRAQQAPCyABIAJBBGsoAgBGBH8gAkEIawUgAkEEaiECDAELCwtSAgJ/AX4CQCAAKAIQKAKMASIBRQ0AIAEpAwgiA0KAgICAcFQNACADpyIBLwEGEO4BRQ0AIAEoAiAiAS0AEkEEcUUNACAAIAEoAkAQGCECCyACC6oPAgV/D34jAEHQAmsiBSQAIARC////////P4MhCyACQv///////z+DIQogAiAEhUKAgICAgICAgIB/gyENIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQ0MAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDSADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQ0MAwsgDUKAgICAgIDA//8AhCENQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIAyEUARAQoCAgICAgOD//wAgDSACIAOEUBshDUIAIQEMAgsgAiADhFAEQCANQoCAgICAgMD//wCEIQ1CACEBDAILIAxC////////P1gEQCAFQcACaiABIAogASAKIApQIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDyAIhCiAFKQPAAiEBCyACQv///////z9WDQAgBUGw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AgQLIBIgFHwhEgwDCyADRSEFIABBAEgNAQsgAikDcEIAUw0AIAIgAigCBEEBazYCBAsgBUUNAEGg1ARBHDYCACACEJoEQgAhE0IADAELIAEoApAGIgBFBEAgASAGt0QAAAAAAAAAAKIQqwEgASkDACETIAEpAwgMAQsgEiATUiATQglVckUEQCABQTBqIAYQeSABQSBqIAAQhgIgAUEQaiABKQMwIAEpAzggASkDICABKQMoEC4gASkDECETIAEpAxgMAQsgEkKaBFkEQEGg1ARBxAA2AgAgAUHgAGogBhB5IAFB0ABqIAEpA2AgASkDaEJ/Qv///////7///wAQLiABQUBrIAEpA1AgASkDWEJ/Qv///////7///wAQLiABKQNAIRMgASkDSAwBCyASQut1VwRAQaDUBEHEADYCACABQZABaiAGEHkgAUGAAWogASkDkAEgASkDmAFCAEKAgICAgIDAABAuIAFB8ABqIAEpA4ABIAEpA4gBQgBCgICAgICAwAAQLiABKQNwIRMgASkDeAwBCyAKBEAgCkEITARAIAFBkAZqIAdBAnRqIgAoAgAhCQNAIAlBCmwhCSAKQQFqIgpBCUcNAAsgACAJNgIACyAHQQFqIQcLAkAgCyASpyIISiALQQhKciAIQRFKcg0AIAhBCUYEQCABQcABaiAGEHkgAUGwAWogASgCkAYQhgIgAUGgAWogASkDwAEgASkDyAEgASkDsAEgASkDuAEQLiABKQOgASETIAEpA6gBDAILIAhBCEwEQCABQZACaiAGEHkgAUGAAmogASgCkAYQhgIgAUHwAWogASkDkAIgASkDmAIgASkDgAIgASkDiAIQLiABQeABakEAIAhrQQJ0QeDBBGooAgAQeSABQdABaiABKQPwASABKQP4ASABKQPgASABKQPoARDjBSABKQPQASETIAEpA9gBDAILIAhBEU5BACABKAKQBiIAIAhBfWxB0ABqdhsNACABQeACaiAGEHkgAUHQAmogABCGAiABQcACaiABKQPgAiABKQPoAiABKQPQAiABKQPYAhAuIAFBsAJqIAhBAnRBmMEEaigCABB5IAFBoAJqIAEpA8ACIAEpA8gCIAEpA7ACIAEpA7gCEC4gASkDoAIhEyABKQOoAgwBCwNAIAFBkAZqIAciAEEBayIHQQJ0aigCAEUNAAsCQCAI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AAEiAjoAASAAQQFqIQAgAUEBaiEBIAINAAsLC/UBAgF/AX4jAEHQAGsiAyQAAkACfiABQQBIBEAgAyABQf////8HcTYCACADQRBqIgFBwABB3CIgAxBOGiAAIAEQYgwBCyAAKAIQIgAoAiwgAU0NAQJAAkAgACgCOCIAIAFBAnRqKAIAIgEpAgQiBEKAgICAgICAgECDQoCAgICAgICAwABRDQAgAkUNASAEp0GAgICAeEcNACAAKAK8ASEBCyABIAEoAgBBAWo2AgAgAa1CgICAgJB/hAwBCyABIAEoAgBBAWo2AgAgAa1CgICAgIB/hAshBCADQdAAaiQAIAQPC0Hv3wBBrvwAQZgYQYfiABAAAAvrAgECfyAAIAEoAgQQEwNAIAEoAhAhAyACIAEoAhRORQRAIAAgAyACQQN0aigCABATIAJBAWohAgwBCwsgACgCECICQRBqIAMgAigCBBEAAEEAIQIDQAJAIAEoAhwhAyACIAEoAiBODQAgAyACQRRsaiIDKAIIRQRAIAAoAhAgAygCBBDrAQsgACADKAIQEBMgACADKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAoAhAiAkEQaiABKAIoIAIoAgQRAABBACECA0AgASgCNCEDIAIgASgCOE5FBEAgACADIAJBDGxqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAgASkDQBAPIAAgASkDSBAPIAAgASkDYBAPIAAgASkDaBAPIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFCADcCCCAAKAIQIgBBEGogASAAKAIEEQAACzABAX8gACgCOCABQQJ0aigCACIBIAEoAgAiAkEBazYCACACQQFMBEAgACABEKIDCwvAAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQAgAkL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFJxDQAgACAEIAWEhFAEQEEADwsgASACg0IAWQRAIAEgAlIgASACU3ENASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADCwoAIABBfHEQpAMLZQEEfwNA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sgEhAyAAIAIQDyAAIAAgA0HdwAAQsgEiAiADQQEgARAhIQQgACACEA8gACADEA8gBAsMACAAIAEpAwAQswELygYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABDtAUUNAAJ/IARC////////P4MhCgJ/IARCMIinQf//AXEiBkH//wFHBEBBBCAGDQEaQQJBAyADIAqEUBsMAgsgAyAKhFALCyEGIAJCMIinIghB//8BcSIHQf//AUYNACAGDQELIAVBEGogASACIAMgBBAuIAUgBSkDECICIAUpAxgiASACIAEQ4wUgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCiADIARC////////////AIMiCRDtAUEATARAIAEgCiADIAkQ7QEEQCABIQQMAgsgBUHwAGogASACQgBCABAuIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGIAcEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAEC4gBSkDaCIKQjCIp0H4AGshByAFKQNgCyEEIAZFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABAuIAUpA1giCUIwiKdB+ABrIQYgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSARAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABAuIAUpAyghAiAFKQMgIQQMBQsgCUIBhiAEQj+IhAwBCyAKQgGGIARCP4iECyEKIARCAYYhBCAHQQFrIgcgBkoNAAsgBiEHCwJAIAogC30gAyAEVq19IglCAFMEQCAKIQkMAQsgCSAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEC4gBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIQEgB0EBayEHIARCAYYhBCABIAlCAYaEIglCgICAgICAwABUDQALCyAIQYCAAnEhBiAHQQBMBEAgBUFAayAEIAlC////////P4MgB0H4AGogBnKtQjCGhEIAQoCAgICAgMDDPxAuIAUpA0ghAiAFKQNAIQQMAQsgCUL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAF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QCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC14BBH8gACgCACECA0AgAiwAACIDENECBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFQX8LIQEMAQsLIAEL3BICEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRICQAJAAkACQANAIAEhDCAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCAMIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAHIQkDQCAJLQABQSVHBEAgCSEBDAILIAdBAWohByAJLQACIQogCUECaiIBIQkgCkElRg0ACwsgByAMayIHIA5B/////wdzIhhKDQcgAARAIAAgDCAHEFsLIAcNBiAIIAE2AkwgAUEBaiEHQX8hDwJAIAEsAAEiChDRAkUNACABLQACQSRHDQAgAUEDaiEHIApBMGshD0EBIRMLIAggBzYCTEEAIQ0CQCAHLAAAIglBIGsiAUEfSwRAIAchCgwBCyAHIQpBASABdCIBQYnRBHFFDQADQCAIIAdBAWoiCjYCTCABIA1yIQ0gBywAASIJQSBrIgFBIE8NASAKIQdBASABdCIBQYnRBHENAAsLAkAgCUEqRgRAAn8CQCAKLAABIgEQ0QJFDQAgCi0AAkEkRw0AIAFBAnQgBGpBwAFrQQo2AgAgCkEDaiEJQQEhEyAKLAABQQN0IANqQYADaygCAAwBCyATDQYgCkEBaiEJIABFBEAgCCAJNgJMQQAhE0EAIRAM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IAgoAgRBAWsiBzYCBCAEIAlqQRBqIQQgBw0JIAAgACgCMEEBazYCMAwJCyAHCyEFIARBAWohBAwACwALIANBACAEQQFGGw0EQQAhCSADDQAgBEECRg0DCyAAIAU2AjAMAAsACyAJDwsgASAIQRBqIAAoAgxBA3QQHxoLIAgoAgghBSAIKAIMIQQgAiAIIAAoAgxBA3RqQRBqIAgtAAEiA0ECdBAfGiAAIAAoAjBBAWs2AjAMAAsAC4sCAQd/IAFBAnRBwP4DaigCACICIAFBAXRBkIAEai8BAGohCEEAIQECQANAIAIgCE8NASACQQFqIQYCQAJAIAItAAAiBEE/TQRAIAMgBEEDdmpBAWohAiABBEAgACADIAIQfg0DCyABQQFzIQEgBEEHcSACakEBaiEFDAELAn8gAyAEakH/AGsgBMBBAEgNABogBi0AACEFIARB3wBNBEAgAkECaiEGIAMgBEEIdGogBWpB//8AawwBCyACQQNqIQYgAi0AAiADIARBEHRqIAVBCHRqakH///8CawshBSADIQILIAEEQCAAIAIgBRB+DQELIAFBAXMhASAGIQIgBSEDDAELC0F/IQcLIAcLOABBsNQCIAEQrwQiAUEASARAQX4PCyAAIAFBHU0Ef0IBIAGthqcFIAFBAnRB2NgCaigCAAsQoQYLNQEBfyMAQRBrIgMkACADIAE2AgggAyACQQFqNgIMIAAgA0EIakECELEEIQAgA0EQaiQAIAALlwIBA38gASgCACICQf7/B08EQCAAQYY7QQAQOkF/DwsCQCACQQFNBEAgAEECQX8QuAEaDAELIAEoAgggAkECdGoiBEEEaygCACIDQX9GBEAgBEEIaygCACEDCyACQQF2IQIgA0H//wNNBEAgAEEVIAIQsgRBACECA0AgAiABKAIATg0CIAAgAkECdCIDIAEoAghqLwEAECogAEF/IAEoAgggA0EEcmooAgBBAWsiAyADQX5GG0H//wNxECogAkECaiECDAALAAsgAEEWIAIQsgRBACECA0AgAiABKAIATg0BIAAgAkECdCIDIAEoAghqKAIAEB0gACABKAIIIANBBHJqKAIAQQFrEB0gAkECaiECDAALAAtBAAsmAQF/IAAoAjgiAUEASARAIAAgACAAQTxqQQAQqwYiATYCOAsgAQvgAgEFfyMAQZABayIEJAAg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IgMgAkohBEKAgICAECEBIAMhAiAERQ0BDAILIAYoAgwgBWsiAyECC0KAgICAECEBIANBAEggAiADSHINAANAIAkgByADQQAgBRCzA0UEQEKBgICAECEBDAILIAIgA0chBCADQQFqIQMgBA0ACwsgACAKEA8gACALEA8LIAZBEGokACABC7ADAwd/AXwBfiMAQRBrIgUkAAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENAAJAAkAgACADKQMAECgiDUKAgICAcINCgICAgOAAUQ0AIA2nIgkoAgRB/////wdxIQYgAaciCigCBEH/////B3EhBwJAIAQEQCAFIAcgBmsiCzYCDEF/IQhBACEEIAJBAkgNASAAIAUgAykDCBBCDQIgBSsDACIMvUL///////////8Ag0KAgICAgICA+P8AVg0BIAxEAAAAAAAAAABlBEAgBUEANgIMDAILIAwgC7djRQ0BIAUCfyAMmUQAAAAAAADgQWMEQCAMqgwBC0GAgICAeAs2AgwMAQsgBUEANgIMIAJBAk4EQCAAIAVBDGogAykDCCAHQQAQVw0CCyAHIAZrIQRBASEIC0F/IQIgBiAHSw0BIAQgBSgCDCIDayAIbEEASA0BA0AgCiAJIANBACAGELMDRQRAIAMhAgwDCyADIARGDQIgAyAIaiEDDAALAAsgACABEA8gACANEA9CgICAgOAAIQEMAQsgACABEA8gACANEA8gAq0hAQsgBUEQaiQAIAELkwECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AQoCAgIAwIQQgAigCDCIDQQBIDQAgAyABpyIFKAIEQf////8HcU8NACAFIAJBDGoQyQGtIQQLIAAgARAPCyACQRBqJAAgBAtpAgJ/AX4gACABEFkhAQNAIAIgBEwgAUKAgICAcINCgICAgOAAUXJFBEAgAyAEQQN0aikDACIGQiCIp0F1TwRAIAanIgUgBSgCAEEBajYCAAsgBEEBaiEEIAAgASAGEMQCIQEMAQsLIAELyAECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AAkAgAigCDCIDQQBOBEAgAyABpyIFKQIEIgSnQf////8HcUkNAQsgAEEvEC0hBAwBCyAFQRBqIQUgAAJ/IARCgICAgAiDUEUEQCAFIANBAXRqLwEADAELIAMgBWotAAALQf//A3EQnwMhBAsgACABEA8LIAJBEGokACAEC7gBAgJ+AX8jAEEQayICJABCgICAgOAAIQQCQCAAIAEQWSIBQoCAgIBwg0KAgICA4ABRBEAgASEEDAELAkAgACACQQxqIAMpAwAQugENAEKAgICAwH4hBCACKAIMIgNBAEgNACADIAGnIgYpAgQiBadB/////wdxTw0AIAZBEGohBiAFQoCAgIAIg1BFBEAgBiADQQF0ajMBACEEDAELIAMgBmoxAAAhBAsgACABEA8LIAJBEGokACAEC+MBAgF+An8jAEEQayICJAACQCAAIAFBLRBLIgNFBEAgBEEANgIAQoCAgIDgACEBDAELQoCAgIAwIQECQCADKQMAIgZCgICAgHCDQoCAgIAwUgRAIAIgAygCDCIFNgIMIAUgBqciBygCBEH/////B3FJDQEgACAGEA8gA0KAgICAMDcDAAsgBEEBNgIADAELIAcgAkEMahDJASEIIAMgAigCDDYCDCAEQQA2AgAgCEH//wNNBEAgACAIQf//A3EQnwMhAQwBCyAAIAcgBUEBdGpBEGpBAhDuAyEBCyACQRBqJAAgAQs3ACMAQRBrIgIkACAAIAJBDGogAykDABB3IQAgAigCDCEDIAJBEGokAEKAgICA4AAgA2etIAAbC04AIwBBEGsiAiQAQoCAgIDgACEBAkAgACACQQxqIAMpAwAQdw0AIAAgAkEIaiADKQMIEHcNACACKAIIIAIoAgxsrSEBCyACQRBqJAAgAQsGACAAtrsLfwAgACAAKQPQASIBQgyIIAGFIgFCGYYgAYUiAUIbiCABhSIBNwPQAUKAgICAwH4gAUKdurP7lJL9oiV+QgyIQoCAgICAgID4P4S/RAAAAAAAAPC/oL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwujBAMDfAV/A34jAEEQayIIJAAgCEIANwMIAkACQCACQQBMDQBCgICAgOAAIQEgACAIQQhqIAMpAwAQQg0BQQEhCSAIKwMIIQQgAkEBRwRAA0AgAiAJRg0CIAAgCCADIAlBA3RqKQMAEEINAyAJQQFqIQkgCCsDACEFIwBBIGsiByQAIAS9Qv///////////wCDIg0gBb1C////////////AIMiDCAMIA1WGyIOvyEEAkAgDkI0iKciCkH/D0YNACANIAwgDCANVBsiDL8hBQJAIA5QDQAgDEI0iKciC0H/D0YNACALIAprQcEATgRAIAUgBKAhBAwCCwJ8IAtB/gtPBEAgBEQAAAAAAAAwFKIhBCAFRAAAAAAAADAUoiEFRAAAAAAAALBrDAELRAAAAAAAAPA/IApBvARLDQAaIAREAAAAAAAAsGuiIQQgBUQAAAAAAACwa6IhBUQAAAAAAAAwFAshBiAHQRhqIAdBEGogBRCKBiAHQQhqIAcgBBCKBiAGIAcrAwAgBysDEKAgBysDCKAgBysDGKCfoiEEDAELIAUhBAsgB0EgaiQADAALAAsgBJkhBAsgBL0iAQJ/IASZRAAAAAAAAOBBYwRAIASqDAELQYCAgIB4CyIAt71RBEAgAK0hAQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGyEBCyAIQRBqJAAgAQtOACAAIABEAAAAAAAA8L9EAAAAAAAA8D8gAEQAAAAAAAAAAGMbIAC9Qv///////////wCDQoCAgICAgID4/wBWGyAARAAAAAAAAAAAYRsLQwACfCABvUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRARAAAAAAAAPh/IACZRAAAAAAAAPA/YQ0BGgsgACABEI8DCwuDAQICfgF/IAC9IgFCNIinQf8PcSIDQf4HTQRAIAFCgICAgICAgICAf4MhAiADQf4HRyABQoCAgICAgIDwv39RckUEQCACQoCAgICAgID4P4S/DwsgAr8PCyADQbIITQR8IAFCP4cgAXxCAUGzCCADa62GIgFCAYh8QgAgAX2DvwUgAAsLggUDAnwFfwF+IwBBEGsiCSQAAn5CgICAgMD+//v/AEKAgICAwP7/eyAEGyACRQ0AGgJ8IAMpAwAiAUL/////D1gEQEEBIAIgAkEBTBshCiABpyEIQQEhBwNAIAcgCkcEQCAItyADIAdBA3RqKQMAIgFCgICAgBBaDQMaIAggAaciCyAIIAtKGyAIIAsgCCALSBsgBBshCCAHQQFqIQcMAQsLIAitDAILQoCAgIDgACAAIAlBCGogARBCDQEaQQEhByAJKwMICyEFIAcgAiACIAdIGyECA0AgAiAHRwRAQoCAgIDgACAAIAkgAyAHQQN0aikDABBCDQIaAkAgBb0iDEL///////////8Ag0KAgICAgICA+P8AVg0AIAkrAwAiBr0iAUL///////////8Ag0KAgICAgICA+P8AVgRAIAYhBQwBCyAFRAAAAAAAAAAAYSAGRAAAAAAAAAAAYXEhCiAEBEAgCgRAIAEgDIO/IQUMAgsgBSAFIAalIAa9Qv///////////wCDQoCAgICAgID4/wBWGyAGIAW9Qv///////////wCDQoCAgICAgID4/wBYGyEFDAELIAoEQCABIAyEvyEFDAELIAUgBSAGpCAGvUL///////////8Ag0KAgICAgICA+P8AVhsgBiAFvUL///////////8Ag0KAgICAgICA+P8AWBshBQsgB0EBaiEHDAELCyAFvSIBAn8gBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASAJQRBqJAAgAQstAEKAgICA4AAgACADKQMAIAMpAwhBABCLAiIAQQBHrUKAgICAEIQgAEEASBsLoAEBA34gAykDACIFIQQgAkEETgRAIAMpAxghBAsgBUL/////b1gEQCAAECRCgICAgOAADwsgAykDECEBQoCAgIDgACEGAkAgACADKQMIEDEiAkUNACABQiCIp0F1TwRAIAGnIgMgAygCAEEBajYCAAsgACAFIAIgASAEQQAQhgQhAyAAIAIQEyADQQBIDQAgA0EAR61CgICAgBCEIQYLIAYLjwEAAkACQCADKQMAIgFC/////29YBEAgBARAIAAQJAwDCyABQiCIp0F1SQ0BIAGnIgAgACgCAEEBajYCACABDwsgACABELYDIgJBAEgNASAEBEAgAkEAR61CgICAgBCEDwsgAkUEQCAAQfjiAEEAEBUMAgsgAaciACAAKAIAQQFqNgIACyABDwtCgICAgOAACyoAIAMpAwAiAUL/////b1gEQCAAECRCgICAgOAADwsgACABQQNBABCqAgtPAAJAAkAgAykDACIBQv////9vWARAIARFBEBCgICAgBAPCyAAECQMAQsgACABEJkBIgBBAE4NAQtCgICAgOAADwsgAEEAR61CgICAgBCEC2MBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAIQcSEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQs2ACADKQMAIgFCIIinIgJBf0YgBEUgAkF+cUECR3FyRQRAIAAQJEKAgICA4AAPCyAAIAEQ6AELYwECfgJAAkAgAykDACIBQv////9vWARAIAAQJAwBCyADKQMIIQUgASEEIAJBA04EQCADKQMQIQQLIAAgBRAxIgINAQtCgICAgOAADwsgACABIAIgBEEAEBQhASAAIAIQEyABC2YBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAJBABDVASEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQuLAQECfiADKQMAIgFC/////29YBEAgABAkQoCAgIDgAA8LIAMpAxAhBkKAgICA4AAhBQJAIAAgAykDCBAxIgJFDQAgACABIAIgBiAERUEOdBDHBCEDIAAgAhATIANBAEgNACAEBEAgA0EAR61CgICAgBCEDwsgAaciACAAKAIAQQFqNgIAIAEhBQsgBQuaAQIBfwJ+IwBBEGsiBCQAIAMpAwghBSADKQMAIgYhAQJAAkACQAJAIAJBA0gNACADKQMQIgFCgICAgHBaBEAgAactAAVBEHENAQsgAEGiPkEAEBUMAQsgACAEQQxqIAUQiQQiAg0BC0KAgICA4AAhAQwBCyAAIAYgASAEKAIMIgMgAhCQAyEBIAAgAiADEJsDCyAEQRBqJAAgAQsVACAAIAMpAwAgAyADQQhqQQIQnQMLVgIBfgF/IAAgARC0AyIBQoCAgIBwg0KAgICA4ABRBEAgAQ8LQoCAgIAwIQIgAaciAygCBEGAgICAeEcEQCAAIAAoAhAgAxDBAhAtIQILIAAgARAPIAILCQAgACABELQDC1sBAX4jAEEQayICJAAgAiAAIAEQtAMiATcDCAJAIAFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgAEKAgICAMEEBIAJB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IQMCQAJAAkAgAkHGAGsOBgIDAQMDAgALIAJBFkcNAgtBECEDCyAAIAEgAxCQAg8LIABBtitBABAVC0KAgICA4AALlgEBAXwjAEEQayICJAACfkKAgICA4AAgACACQQhqIAEQmwINABogAisDCCIEvSIBAn8gBJlEAAAAAAAA4EFjBEAgBKoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASACQRBqJAAgAQvsAgIDfwF8IwBB0ABrIgQkACAEQRBqQQBBOBArGiAEQoCAgICAgID4PzcDIEKAgICAwH4hAQJAIAJFDQBBByACIAJBB04bIgJBACACQQBKGyECA0AgAiAFRwRAIAAgBEEIaiADIAVBA3QiBmopAwAQQgRAQoCAgIDgACEBDAMLIAQrAwgiB71CgICAgICAgPj/AINCgICAgICAgPj/AFENAiAEQRBqIAZqIAedOQMAAkAgBQ0AIAQrAxAiB0QAAAAAAAAAAGZFIAdEAAAAAAAAWUBjRXINACAEIAdEAAAAAACwnUCgOQMQCyAFQQFqIQUMAQsLIARBEGpBABDgAiIHvSIBAn8gB5lEAAAAAAAA4EFjBEAgB6oMAQtBgICAgHgLIgW3vVEEQCAFrSEBDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQELIARB0ABqJAAgAQtWABDQBCIBQoCAgIAIfEL/////D1gEQCABQv////8Pgw8LQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsIAEKAgICAMAuqHQIGfwR+IwBB0ABrIgYkAAJAAkAgAEEQaiIDQYgCIAAoAgARAwAiAUUNACABQQVqQQBBgwIQKxogAUEFOgAEIAFBATYCACAAKAJQIgQgAUEIaiIFNgIEIAEgAEHQAGo2AgwgASAENgIIIAAgBTYCUCABIAMgACgCQEEDdCAAKAIAEQMAIgQ2AiggBEUEQCADIAEgACgCBBEAAAwBCyABIAA2AhAgACgCSCIDIAFBFGoiBTYCBCABIABByABqNgIYIAEgAzYCFCAAIAU2AkggAULxgICAgDk3AtwB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aiAAIAFB1QAgAUEAEBQQowENACAAIAVB1QACfiACKQMIIgFCgICAgAh8Qv////8PWARAIAFC/////w+DDAELQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0AQoCAgIDgACEIIABBLhB2IgFCgICAgHCDQoCAgIDgAFENACAAQSAQKSIDRQRAIAEhCAwBCyADIAk3AwggAyAFNwMAIAMgBKciCkHnAEEAEMcBQX9zQR92NgIQIApB9QBBABDHASEKIANBADYCGCADIApBf3NBH3Y2AhQgAUKAgICAcFoEQCABpyADNgIgCyAAIAYQDyAAIAQQDyABIQcMAQsgACAJEA8gACAGEA8gACAEEA8gACAFEA8gACAIEA8LIAJBIGokACAHC74EAgd+An8jAEEQayICJAACQCABQv////9vWARAIAAQJEKAgICA4AAhBgwBC0KAgICA4AAhBkKAgICAMCEFAkAgAAJ+AkAgACADKQMAECgiB0KAgICAcINCgICAgOAAUQ0AIAAgACABQe4AIAFBABAUECYiA0EASA0AIANFBEAgACABIAcQyAEhBgwDCyAAIAAgAUHvACABQQAQFBAmIgtBAEgNACAAIAFB1QBCABBFQQBIDQBCgICAgOAAIAAQPiIIQoCAgIBwg0KAgICA4ABRDQEaIAenIQwCQANAIAAgBRAPIAAgASAHEMgBIgVCgICAgHCDIgRCgICAgCBRDQECQCAEQoCAgIDgAFENAAJ/IAAgACAFQgAQTRA3IgRCgICAgHCDIgpCgICAgJB/UgRAQQAgCkKAgICA4ABSDQEaDAILIASnKAIEQf////8HcUULIQMgACAIIAkgBBCGAUEASA0AIAlCAXwhCSADRQ0BIAAgAkEIaiAAIAFB1QAgAUEAEBQQowFBAEgNACAAIAFB1QACfiAMIAIpAwggCxDxAiIEQoCAgIAIfEL/////D1gEQCAEQv////8PgwwBC0KAgICAwH4gBLm9IgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhsLEEVBAE4NAQsLIAgMAgsgCacEQCAIIQYMAwsgACAIEA9CgICAgCAhBgwCC0KAgICAMAsQDwsgACAFEA8gACAHEA8LIAJBEGokACAG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/////w+DEGpBAEgNDSADRQRAIAkgCSgCAEEBajYCAAsgACABIAZBAWqtIBQQakEASA0NIA5CgICAgDBSBEAgEUIgiKdBdU8EQCARpyICIAIoAgBBAWo2AgALIAAgASAGQQJqrSAREGpBAEgNDgsgBCABNwNYIARCgICAgDA3A1AgACATEA8gACAAIBkgBCAEQdAAakEAEJ0DEDchEwwBC0KAgICAMCEVIA5CgICAgDBSBEAgACARECUiFUKAgICAcINCgICAgOAAUQ0NCyAEIBc3A3ggBCAVNwNwIAQgATcDaCAEIBQ3A1ggBCAPNwNQIAQgEkL/////D4M3A2AgACATEA8gACAEQdAAahDtBCETIAAgFRAPCyATQoCAgIBwg0KAgICA4ABRDQsgB6wgElcEQCAEQThqIgIgCSAHIBKnEFEaIAIgExCHARogD6cpAgRC/////weDIBJ8pyEHCyAFQQFqIQUMAQsLIARBOGoiAiAJIAcgCSgCBEH/////B3EQURogAhA2IRAMCgsgACAPEA9CgICAgDAhEwJAAn8CQCAAIAAgEkIAEE0QNyIPQoCAgIBwgyIOQoCAgICQf1IEQCAOQoCAgIDgAFINASAOIRAMAwsgD6coAgRB/////wdxDQAgACAEQdAAaiAAIAFB1QAgAUEAEBQQowFBAEgNAiAAIAFB1QACfiAJIAQpA1AgDRDxAiIOQoCAgIAIfEL/////D1gEQCAOQv////8PgwwBC0KAgICAwH4gDrm9Ig5CgICAgMCBgPz/AH0gDkL///////////8Ag0KAgICAgICA+P8AVhsLEEUiAkEATg0AIAJBHnZBAnEMAQtBAAtFDQELCwwCCwwGC0KAgICAMCETC0KAgICAMCEBDAQLIARB0ABqIAsgCCALKAIEQf////8HcRBRDQAgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEQdAAahA2IRAMAQsgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEKAJQKAIQIgJBEGogBCgCVCACKAIEEQAAC0KAgICAMCERC0KAgICAMCETQoCAgIAwIQFCgICAgDAhDwsgBCgCOCgCECICQRBqIAQoAjwgAigCBBEAAAsgBBDuBCAAIBcQDyAAIA8QDyAAIAEQDyAAIBMQDyAAIBEQDyAAIBQQDwsgBEGQAWokACAQC6IBACMAQSBrIgIkAAJ+AkAgAUL/////b1gEQCAAECQMAQsgACACQQhqIgNBABA9GiADQS8QOxoCQCADIAAgAUHsACABQQAQFBB/DQAgAkEIaiIDQS8QOxogAyAAIAFB7QAgAUEAEBQQfw0AIAJBCGoQNgwCCyACKAIIKAIQIgBBEGogAigCDCAAKAIEEQAAC0KAgICA4AALIQEgAkEgaiQAIAELTgECfkKAgICA4AAhBCAAIAEgAykDABDIASIBQoCAgIBwgyIFQoCAgIDgAFIEfiAAIAEQDyAFQoCAgIAgUq1CgICAgBCEBUKAgICA4AALC/gCAgN+AX8CQAJAIAAgARDwAiICRQ0AIAMpAwghBgJAAkACQCADKQMAIgRCgICAgHBUDQAgBKciAy8BBkESRw0AIAZCgICAgHCDQoCAgIAwUgRAIABBnvkAQQAQFUKAgICA4AAPCyADKAIgIgcgBygCAEEBajYCACADKAIkIgMgAygCAEEBajYCACAHrUKAgICAkH+EIQQgA61CgICAgJB/hCEFDAELQoCAgIAwIQUCfiAEQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAQQKAsiBEKAgICAcINCgICAgOAAUQ0BIAAgBCAGEJgEIgVCgICAgHCDQoCAgIDgAFENAQsgACACNQIAQoCAgICQf4QQDyAAIAI1AgRCgICAgJB/hBAPIAIgBT4CBCACIAQ+AgAgACABQdUAQgAQRUEASA0BIAFCIIinQXVJDQIgAaciACAAKAIAQQFqNgIADAILIAAgBBAPIAAgBRAPC0KAgICA4AAPCyABC2oBAX8gAUL/////b1gEQCAAECRCgICAgOAADwsCfiABpyIDLwEGQRJHBEBCgICAgDAgACABIAAoAigpA5ABEFINARogAEESEIYDQoCAgIDgAA8LIAMoAiQtABAgAnFBAEetQoCAgIAQhAsLvQQBCX8jAEEgayIHJAACQAJAAkACQAJAIAFC/////29YBEAgABAkDAELIAAgASAAKAIoKQOQARBSDQIgACABEPACIgINAQtCgICAgOAAIQEMAwsgAigCACIIKAIEIgJB/////wdxIgMNAQsgAEH+kwEQYiEBDAELIAAgB0EIaiADIAJBH3YQigMaIAhBEGohBiAIKAIEQf////8HcSEJQQAhAANAAkACQCAAIAlIBEAgAEEBaiECQX8hBQJAAn8CQAJAAkACQAJAAkACQAJ/IAgpAgRCgICAgAiDIgFQIgpFBEAgBiAAQQF0ai8BAAwBCyAAIAZqLQAACyIDQdsAaw4DAwECAAsgAiEAAkAgA0EKaw4EBAsLBQALIANBL0cNByAERQ0FQQEhBEEvIQMMBwtB3AAhAyACIAlODQYgAEECaiEAIApFBEAgBiACQQF0ai8BACEFDAoLIAIgBmotAAAhBQwJC0EAIQRB3QAhAwwFC0HbACEDIAQgAiAJTnINBiAAQQJqIQAgAVAEQEHdAEF/IAIgBmotAABB3QBGIgQbIQUgACACIAQbIQBBASEEDAgLQQEhBEHdAEF/IAYgAkEBdGovAQBB3QBGIgobIQUgACACIAobIQAMBwtB7gAMAgtB8gAMAQtBACEEQS8LIQVB3AAhAwsgAiEADAILIAdBCGoQNiEBDAMLIAIhAEEBIQQLIAdBCGogAxCLARogBUEASA0AIAdBCGogBRCLARoMAAsACyAHQSBqJAAgAQvWAgIDfwF+IwBBEGsiBCQAAkAgAUL/////b1gEQCAAECRCgICAgOAAIQUMAQtCgICAgOAAIQUgACAAIAFB7gAgAUEAEBQQJiICQQBIDQAgAgR/IARB5wA6AAggBEEJagUgBEEIagshAiAAIAAgAUHr4wAQsgEQJiIDQQBIDQAgAwRAIAJB6QA6AAAgAkEBaiECCyAAIAAgAUGL5QAQsgEQJiIDQQBIDQAgAwRAIAJB7QA6AAAgAkEBaiECCyAAIAAgAUH01AAQsgEQJiIDQQBIDQAgAwRAIAJB8wA6AAAgAkEBaiECCyAAIAAgAUHvACABQQAQFBAmIgNBAEgNACADBEAgAkH1ADoAACACQQFqIQILIAAgACABQfsdELIBECYiA0EASA0AIAAgBEEIaiIAIAMEfyACQfkAOgAAIAJBAWoFIAILIABrEJMCIQULIARBEGokACAFC6UDAQR+IwBBEGsiAyQAIAQCfwJAAkACQAJAIAAgAUEuEEsiAkUEQEKAgICAMCEBDAELIAIoAhgEQEKAgICAMCEBQQEMBQsgACACKQMAIgggAikDCCIGEMgBIgFCgICAgHCDIgdCgICAgOAAUg0BC0KAgICAMCEHDAELIAdCgICAgCBRBEAgAkEBNgIYQoCAgIAwIQFBAQwDCyACKAIQBEAgACAAIAFCABBNEDciB0KAgICAcIMiCUKAgICA4ABRDQECQCAJQoCAgICQf1INACAHpygCBEH/////B3ENACAAIANBCGogACAIQdUAIAhBABAUEKMBQQBIDQIgACAIQdUAAn4gBqcgAykDCCACKAIUEPECIgZCgICAgAh8Qv////8PWARAIAZC/////w+DDAELQoCAgIDAfiAGub0iBkKAgICAwIGA/P8AfSAGQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0CCyAAIAcQDwwCCyACQQE2AhgMAQsgACABEA8gACAHEA9CgICAgOAAIQELQQALNgIAIANBEGokACABCw4AIAAQtQJCgICAgOAACwkAQoCAgIDAfgsWACAAIAMpAwAgAykDCCADKQMQEJQEC9EBAgN+An8jAEEQayIHJAACQCAAIAdBDGogAykDABDlASIIRQRAQoCAgIDgACEEDAELIAAgCCAHKAIMQdKIARD1BSEBIAAgCBBUAkAgAkECSCABQoCAgIBwg0KAgICA4ABRcg0AIAAgAykDCCIGEDhFDQBCgICAgOAAIQQCQCAAEDQiBUKAgICAcINCgICAgOAAUQRAIAEhBQwBCyAAIAVBLyABQQcQGUEASA0AIAAgBUEvIAYQ+QQhBAsgACAFEA8MAQsgASEECyAHQRBqJAAgBAsNACAAIAEgAkEwEP0FCwsAIAAgAUEwEP4FC7QDAgN/An4jAEHQAGsiBiQAQX8hBwJAIAAgBkHIAGogAUHCABCBASIIRQ0AIAYpA0giAUKAgICAcINCgICAgDBRBEAgCCkDACEBIANCIIinQXVPBEAgA6ciByAHKAIAQQFqNgIACyAAIAEgAiADIAQgBRCGBCEHDAELIAAgAhBcIglCgICAgHCDQoCAgIDgAFEEQCAAIAEQDwwBCyAIKQMAIQogBiAENwM4IAYgAzcDMCAGIAk3AyggBiAKNwMgIAAgASAIKQMIQQQgBkEgahAvIQEgACAJEA8gAUKAgICAcINCgICAgOAAUQ0AAkACQCAAIAEQJiIHBEAgACAGIAgoAgAgAhBMIgJBAEgNASACRQ0DAkAgBigCACICQRNxRQRAIAAgBikDCCADEFJFDQEMBAsgAkERcUEQRw0DIAY1AhxCIIZCgICAgDBSDQMLIAAgBhBI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gICAwH4gALi9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLOQEBfkKAgICAwH4gASkDACICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCzsBAX5CgICAgMB+IAEqAgC7vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCwwAIAAgASkDABD7AwsMACAAIAEpAwAQhwILSQEBfiABKAIAIgBBAE4EQCAArQ8LQoCAgIDAfiAAuL0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsHACABNQIACwcAIAEzAQALDgAgATIBAEL/////D4MLCQAgABC1AkF/Cw4AIAEwAABC/////w+DCwcAIAExAAALDwAgACsDACABKwMAEP0ECxEAIAAqAgC7IAEqAgC7EP0ECxkBAn4gASkDACIDIAApAwAiBFQgAyAEVmsLGQECfiABKQMAIgMgACkDACIEUyADIARVawsXACABKAIAIgEgACgCACIASSAAIAFJawsXACABKAIAIgEgACgCACIASCAAIAFIawsNACAALwEAIAEvAQBrCw0AIAAuAQAgAS4BAGsLDQAgACwAACABLAAAawsNACAALQAAIAEtAABrC8wNBAd/AXwBfgF9IwBBIGsiBiQAQoCAgIDgACENAkAgACABEJIBIgpBAEgNAEF/IQUCQAJAAkAgCkUNAEEBIQgCQAJAIARBAUYEQEF/IQggBiAKQQFrIgU2AhwgAkECSA0BIAAgBkEIaiADKQMIEEINBiAGKwMIIgy9Qv///////////wCDQoGAgICAgID4/wBaBEAgBkEANgIcDAILIAxEAAAAAAAAAABmBEAgDCAFt2NFDQIgBgJ/IAyZRAAAAAAAAOBBYwRAIAyqDAELQYCAgIB4CzYCHAwCC0F/IQUgDCAKt6AiDEQAAAAAAAAAAGMNBCAGAn8gDJlEAAAAAAAA4EFjBEAgDKoMAQtBgICAgHgLNgIcDAELIAZBADYCHCACQQJIBEAgCiECDAILIAAgBkEcaiADKQMIIAoiAiACEFcNBQwBC0F/IQILIAGnIgkoAiAoAgwoAiAtAAQEQEF/IQUgBEF/Rw0CQX9BACADNQIEQiCGQoCA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IA1CgICAgDBBBCAFQRBqECEhCiAAIAsQDyAAIA8QDyAFQoCAgIAwNwM4IApCgICAgHCDQoCAgIDgAFENASAAIAkQDyAKIQkLIAhCAXwhCAwBCwsgBSAJNwMwIAUpAzghCwsgACAFKQMwEA8gACALEA9CgICAgOAAIQkLIAAgARAPIAVBQGskACAJC6wIAgN/CX4jAEEwayIFJABCgICAgDAhCSAFQoCAgIAwNwMoAkACQAJAAkAgBEEIcSIHBEAgAUIgiKdBdU8EQCABpyIGIAYoAgBBAWo2AgALIAUgACABEJIBIgasNwMIIAZBAE4NAQwCCyAAIAVBCGogACABECUiARA8DQELIAMpAwAhD0KAgICAMCEOIAJBAk4EQCADKQMIIQ4LIAAgDxBgDQACQAJAAkACQAJAAkACQCAEDg0FAAYBAgYGBgUABgMEBgtCgICAgBAhCQwFCyAAIAECfiAFKQMIIghCgICAgAh8Qv////8PWARAIAhC/////w+DDAELQoCAgIDAfiAIub0iCEKAgICAwIGA/P8AfSAIQv///////////wCDQoCAgICAgID4/wBWGwsQqwIiCUKAgICAcINCgICAgOAAUg0EDAULIAAgAUIAEKsCIglCgICAgHCDQoCAgIDgAFINAwwECyAFIAE3AxAgBSAFNQIINwMYIABBAiAFQRBqEPYCIglCgICAgHCDQoCAgIDgAFINAgwDCyAAED4iCUKAgICAcINCgICAgOAAUg0BQoCAgIDgACEJDAILQoGAgIAQIQkLQgAhCCAFKQMIIgpCACAKQgBVGyEQA0AgCCAQUgRAAkACQCAHBEAgBSAAIAEgCBBzIgo3AyggCkKAgICAcINCgICAgOAAUg0BDAULIAAgASAIIAVBKGoQhQEiAkEASA0EIAJFDQELIAghCiAIQoCAgIAIWgRAQoCAgIDAfiAIub0iCkKAgICAwIGA/P8AfSAKQv///////////wCDQoCAgICAgID4/wBWGyEKCyAKQoCAgIBwg0KAgICA4ABRDQMgBSABNwMgIAUgCjcDGCAFIAUpAygiDTcDECAAIA8gDkEDIAVBEGoQISELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENAwJAAkACQAJAAkACQAJAIAQODQABBQIEBQUFAAEFAwQFCyAAIAsQJg0FQoCAgIAQIQgM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AUL///////////8Ag0KAgICAgICA+P8AVhshBQwCCxABAAsgAjAAAEL/////D4MhBQsgB0EQaiQAIAULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCFAVCgICAgOAACwvXAQEDfwJAIAFCgICAgHBUDQAgAaciAy8BBkE5Rw0AIAMoAiAiBEUNACAEQcwAaiEDIARByABqIQUDQCAFIAMoAgAiA0cEQCADKQMQIgFCgICAgGBaBEAgACABpyACEQAACyADKQMYIgFCgICAgGBaBEAgACABpyACEQAACyADKQMgIgFCgICAgGBaBEAgACABpyACEQAACyADKQMoIgFCgICAgGBaBEAgACABpyACEQAACyADQQRqIQMMAQsLIAQoAgRBfnFBBEYNACAAIARBCGogAhDvAwsLBgBB4MYECzABAX8CQCABQoCAgIBwVA0AIAGnIgIvAQZBOUcNACACKAIgIgJFDQAgACACEIcFCwsNACAAIAEgAkE3EP0FCwsAIAAgAUE3EP4FCxYBAX8gAacoAiAiAgRAIAAgAhCIBQsLMQEBfyABpygCICICBEAgACACKAIIEKMFIAAgAikDABAjIABBEGogAiAAKAIEEQAACwvcAQEEfwJAIAFCgICAgHBUDQAgAaciBC8BBkExRw0AIAQoAiAiBkUNAEEAIQQDQCAEQQJGRQRAIAYgBEEDdGoiBUEIaiEDIAVBBGohBQNAIAUgAygCACIDRwRAIAMpAwgiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxgiAUKAgICAYFoEQCAAIAGnIAIRAAALIANBBGohAwwBCwsgBEEBaiEEDAELCyAGKQMYIgFCgICAgGBUDQAgACABpyACEQAACwuMAQEFfwJAIAFCgICAgHBUDQAgAaciAi8BBkExRw0AIAIoAiAiBEUNAANAIANBAkZFBEAgBCADQQN0aiICQQRqIQUgAigCCCECA0AgAiAFRkUEQCACKAIEIQYgACACEK4CIAYhAgwBCwsgA0EBaiEDDAELCyAAIAQpAxgQIyAAQRBqIAQgACgCBBEAAAsLJQAgBSkDACIBQiCIp0F1TwRAIAGn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IAMpAwAQpgENACAAEJcBIgVCgICAgHCDQoCAgIDgAFENACAAIAJBFGogAykDCBC7ASIGRQRAIAAgBRAPDAELIAAoAtgBIQMgAkIANwIMIAJCgICAgICAgICAfzcCBCACIAM2AgAgAkIBEDAaIAIgAikDKCIBpyIHQf////8DQQEQzAEaIAIgAkJ/Qf////8DQQEQdRogBadBBGoiAyAGIAIQkwUaAkAgBEUgAVByDQAgAkIBEDAaIAIgB0EBa0H/////A0EBEMwBGiADIAIQ0wFBAEgNACACQgEQMBogAiAHQf////8DQQEQzAEaIAMgAyACQf////8DQQEQ5AEaCyACEBsgACAGIAJBFGoQXiAAIAUQzQEhAQsgAkEwaiQAIAEL6hMCAn4BfyMAQdABayIEJAAgACAEEJgFIAEgARA0IgNBqi0CfiAEKQMIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB3+AAAn4gBCkDECICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQboqAn4gBCkDGCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQagqAn4gBCkDICICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfooAn4gBCkDKCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfrfAAJ+IAQpAzAiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HYKAJ+IAQpAzgiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G23wACfiAEKQNAIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBzSkCfiAEKQNIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBl+AAAn4gBCkDUCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeIoAn4gBCkDWCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQc/fAAJ+IAQpA2AiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0GGKgJ+IAQpA2giAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0Gt4AACfiAEKQNwIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBxyoCfiAEKQN4IgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB8OAAAn4gBCkDgAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HN4AACfiAEKQOIASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQZIqAn4gBCkDkAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G44AACfiAEKQOYASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQdUqAn4gBCkDoAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HvJwJ+IAQpA6gBIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB6icCfiAEKQOwASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeszAn4gBCkDuAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0H7JwJ+IAQpA8ABIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBo98AAn4gBCkDyAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAMQUyEAIARB0AFqJAAgAAufAgEDfiABQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhBQJ+IAAgAUE2IAFBABAUIgRCgICAgHCDQoCAgIAwUQRAIABBlAEQLQwBCyAAIAQQNwsiBEKAgICAcIMiBkKAgICA4ABSBH4CfiAAIAFBMyABQQAQFCIBQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAEQNwsiAUKAgICAcIMiBUKAgICA4ABRBEAgACAEEA9CgICAgOAADwsCQCAGQoCAgICQf1EEQCAEpygCBEH/////B3FFDQELIAVCgICAgJB/UQRAIAGnKAIEQf////8HcUUNAQsgAEHMngEgBEH4mQEQvgEhBAsgACAEIAEQxAIFQoCAgIDgAAsLXwEBfwJAIAFFBEAgAkUNASAAIAIQ2QMPCyACRQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQwBCyAAKAIIIAAoAgQgAmpPBH8gASACEPMFBUEACw8LQQALJgAgAQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQsLCQAgACABNgIYCygBAX8CQCABpygCICIDRQ0AIAMoAgBBBEYNACAAIANBCGogAhDvAwsLPwEBfwJAIAFCgICAgHBUDQAgAaciAi8BBkEvRw0AIAIoAiAiAkUNACAAIAIQ7AMgAEEQaiACIAAoAgQRAAALC0cBAX8CQCABpygCICIDRQ0AIAMpAwAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAwgiAUKAgICAYFQNACAAIAGnIAIRAAALCzABAX8gAacoAiAiAgRAIAAgAikDABAjIAAgAikDCBAjIABBEGogAiAAKAIEEQAACwsnAQF/IAGnKAIgIgIEQCAAIAIpAwAQIyAAQRBqIAIgACgCBBEAAAsLWgECfyABpygCICICBEACQCACKQMAIgFCgICAgHBUDQAgAactAAVBAnENACACKAIMIgNFDQAgACADEOoDIAIpAwAhAQsg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ACIGRQ0AIAYtAAVBAXFFDQAgACAGIAIRAAALIANBAWohAwwACwALIAAgBCACEQAACwt8AQN/IAGnIgIoAigiAwRAIAAgA61CgICAgHCEECMLIAIoAiAiAwRAIAIoAiQiBARAQQAhAgNAIAIgAygCPE5FBEAgACAEIAJBAnRqKAIAEOsBIAJBAWohAgwBCwsgAEEQaiAEIAAoAgQRAAALIAAgA61CgICAgGCEECMLCxIAIAGnKAIgIgAEQCAAEKQDCwseACABpykDICIBQoCAgIBgWgRAIAAgAacgAhEAAAsLGQAgACABpyIAKQMgECMgAEKAgICAMDcDIAtEAQJ/IAGnIQQDQCAEKAIoIANLBEAgBCgCJCADQQN0aikDACIBQoCAgIBgWgRAIAAgAacgAhEAAAsgA0EBaiEDDAELCwtGAQN/IAGnIQMDQCADKAIkIQQgAiADKAIoT0UEQCAAIAQgAkEDdGopAwAQIyACQQFqIQIMAQsLIABBEGogBCAAKAIEEQAAC2kBAn8jAEEQayIHJAACfwJAIAGnIggtAAVBCHFFDQAgACAHQQxqIAIQrAFFDQAgBygCDCAIKAIoTw0AQX8gACAIEJIDDQEaCyAAIAEgAiADIAQgBSAGQYCACHIQbQshACAHQRBqJAAgAAuBAgIDfwF+AkACQCACQQBODQAgAacpAyAiCkKAgICAcINCgICAgJB/Ug0AIAJB/////wdxIgggCqciBykCBCIKp0H/////B3FPDQACQEEEIAYQkwNFDQBBASECIAZBgMAAcUUNAiADQoCAgIBwg0KAgICAkH9SDQAgA6ciCSkCBCIBQv////8Hg0IBUg0AIAdBEGohBwJ/IApCgICAgAiDUEUEQCAHIAhBAXRqLwEADAELIAcgCGotAAALAn8gAUKAgICACINQRQRAIAkvARAMAQsgCS0AEAtGDQILIAAgBkHh6QAQbw8LIAAgASACIAMgBCAFIAZBgIAIchBtIQILIAILRgACfwJAIAJBAE4NACABpykDICIBQoCAgIBwg0KAgICAkH9SDQBBACACQf////8HcSABpygCBEH/////B3FJDQEaC0EBCwuzAQECfwJAIANBAE4NACACpykDICICQoCAgIBwg0KAgICAkH9SDQAgA0H/////B3EiAyACpyIEKQIEIgKnQf////8HcU8NAEEBIQUgAUUNACAEQRBqIQQCfyACQoCAgIAIg1BFBEAgBCADQQF0ai8BAAwBCyADIARqLQAACyEDIAFBBDYCACAAIANB//8DcRCfAyECIAFCgICAgDA3AxggAUKAgICAMDcDECABIAI3AwgLIAULWwECfyABpygCECIAQTBqIQMgACAAKAIYIAJxQX9zQQJ0aigCACEAA0ACQCAARQ0AIAMgAEEBa0EDdGoiBCgCBCACRg0AIAQoAgBB////H3EhAAwBCwsgAEEARws1AQF+IAEpAwAiAkIgiKdBdU8EQCACpyIBIAEoAgBBAWo2AgALIAAgAhCKAUKAgICA4AAQUwuOAQECfyABKAIAIgJBAEoEQCABIAJBAWsiAjYCAAJAIAINACABLQAEQfABcUEQRw0AIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFBADYCCCAAKAJgIgIgAUEIaiIDNgIEIAEgAEHgAGo2AgwgASACNgIIIAAgAzYCYAsPC0HFjQFBrvwAQbAsQc/0ABAAAAtvAQJ/IAEgASgCACICQQFqNgIAIAJFBEAgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUEANgIIIAAoAlAiAiABQQhqIgM2AgQgASAAQdAAajYCDCABIAI2AgggACADNgJQIAEgAS0ABEEPcToABAsLDwAgASABKAIAQQFqNgIAC4gBAgF+AX9BACECQoCAgIAwIQEDQAJAIAJBAkcEfiAFIAJBA3QiBGoiBzUCBEIghkKAgICAMFENASAAQawuQQAQFUKAgICA4AAFQoCAgIAwCw8LIAMgBGopAwAiBkIgiKdBdU8EQCAGpyIEIAQoAgBBAWo2AgALIAcgBjcDACACQQFqIQIMAAsAC1wBAn4gAiAAKAIAEC0hA0EAIQAgA0KAgICAcINCgICAgOAAUSACIAEoAgAQLSIEQoCAgIBwg0KAgICA4ABRckUEQCADpyAEpxCDAiEACyACIAMQDyACIAQQDyAAC2sBAX4CQAJAAkACQAJAIAMtAAUiAQ4EAwICAAELIAAgAygCCBDKBA8LIAFBCEYNAgsQAQALIAAgAygCDCADKAIAIAMtAAggAy0ACSADLgEGEIIBDwsgACAAEDQiBCADKAIIIAMoAgwQIiAECwkAIAAgAxCNAwtTAQF+IAAQNCIEQoCAgIBwg0KAgICA4ABSBEAgASABKAIAQQFqNgIAIAAgBEE8IAGtQoCAgIBwhEEDEBlBAE4EQCAEDwsgACAEEA8LQoCAgIDgAAsDAAELagEBfyMAQRBrIgMkACABKAIEIQEgAiADQQxqIAAoAgQQrAFBACACIANBCGogARCsARtFBEBB0MUAQa78AEGDOkH8yQAQAAALIAMoAgghACADKAIMIQEgA0EQaiQAQX8gACABRyAAIAFLGwvaAwICfgF/IwBBIGsiBSQAAkACQCAAIAFBLBBLIgJFDQBCgICAgDAhAQJAIAIpAwAiBkKAgICAcINCgICAgDBSBEACfwJAIAanIgMvAQZBFWtB//8DcUEKTQRAIAMoAiAoAgwoAiAtAARFDQEgABBrDAULIAAgBUEcaiAGENYBDQQgBUEcagwBCyADQShqCyEIIAIoAgwiAyAIKAIASQ0BIAAgAikDABAPIAJCgICAgDA3AwALIARBATYCAAwCCyACIANBAWo2AgwgBEEANgIAIAIoAghFBEAgA0EATgRAIAOtIQEMAwtCgICAgMB+IAO4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQEMAgtCgICAgOAAIQEgACACKQMAIAMQsAEiBkKAgICAcINCgICAgOAAUQ0BIAIoAghBAUYEQCAGIQEMAgsgBSAGNwMIIAUgA0EATgR+IAOtBUKAgICAwH4gA7i9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIgc3AwAgAEECIAUQiQMhASAAIAYQDyAAIAcQDwwBCyAEQQA2AgBCgICAgOAAIQELIAVBIGokACABCxAAIwAgAGtBcHEiACQAIAALBgAgACQACwQAIwAL7gICBH8CfiMAQRBrIgMkAAJAAkAgAikDECIHQoCAgIBwg0KAgICAkH9SBEAgAEGDlAFBABAVDAELIAIpAxghCCAAIAcQswEiBEUEQEEAIQQMAQsgACAIELMBIgZFDQACQCAAIAQgBhDJBSIBRQ0AIAAgARD+A0EASARAIABBARCPBAwBCyABIAEoAgBBAWo2AgAgACABrUKAgICAUIQgACkDwAFBAEEAEMgFIgdCgICAgHCDQoCAgIDgAFENACAAIAcQDyABIQULIAAgBhBUIAVFDQAgAyAAIAUQjQMiBzcD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ACEEIANCADcCaCADQoCAgICAgICAgH83AmAgAyAENgJcIANB3ABqIgUgARBEGiADQgA3AlQgA0KAgICAgICAgIB/NwJMIAMgBDYCSCADKAJkIQYgA0EANgJkIANByABqIgFCqtWq1QoQMBogA0EANgJQIAUgARCyAgRAIAMgAygCZEEBajYCZCAGQQFrIQYLIANByABqEBsgAkEBakEBdhCVBiEFIANCADcCVCADQoCAgICAgICAgH83AkwgAyAENgJIIANCADcCQCADQoCAgICAgICAgH83AjggAyAENgI0IANB3ABqIgEgAUJ/Qf////8DQQAQdRogBUEAIAVBAEobIQkgAiAFaiACIAVBAXRuQQFqIgpBAXRqQSBqIQJBACEBA0AgASAJRkUEQCADQcgAaiIHIANB3ABqIghCASACQQAQdRogA0E0aiILIAcgAkEGEJEGIAcgC0IBIAJBABB1GiAIIAggByACQQAQlQEaIAFBAWohAQwBCwsgA0IANwIsIANCgICAgICAgICAfzcCJCADIAQ2AiAgA0IANwIYIANCgICAgICAgICAfzcCECADIAQ2AgwgA0EgaiIBIANB3ABqIgRCAiACQQAQdRogASAEIAEgAkEAEJUBGiADQQxqIAEgASACQQAQQxogAEIAEDAaIAqsIQwDQCAMQgBXRQRAIANByABqIgFCARAwGiADQTRqIgQgDKdBAXRBAXKsEDAaIAEgASAEIAJBABCVARogACAAIAEgAkEAEMsBGiAAIAAgA0EMaiACQQAQQxogDEIBfSEMDAELCyAAIABCASACQQAQdRogACAAIANBIGoiASACQQAQQxogARAbIANBDGoQGyADQTRqEBsgA0HIAGoQGyAAIAVBAWpB/////wNBARDMARogA0HcAGoiASACQQYQ0wIgASABIAasIAJBABDUAiAAIAAgASACQQAQywEaIAEQGyADQfAAaiQAQRAPC0HY/QBB1PwAQdciQajWABAAAAsRACAAIAEgAiADIARBABCWBgsRACAAIAEgAiADIARBARCWBgvYAwEHfyACKAIEIAEoAgRzIQcCQAJAAkACQAJAAkACQCABKAIIIgZB/f///wdMBEAgAigCCCIFQf3///8HSg0BIAZBgICAgHhHDQYgBUGAgICAeEYNBAwHCyAGQf////8HRg0BIAIoAggh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gICAMEEBENQFDQIgACABEA8LIAJBAWohAgwACwALIAAgBBAPIAAgARAPQoCAgIDgAAsYACAAIAMpAwAgAykDCBBSrUKAgICAEIQL4gICA34DfyMAQSBrIgIkAEKAgICA4AAhBCAAIAMpAwAQJSIFQoCAgIBwg0KAgICA4ABSBEBCgICAgDAhAQJAAkAgACACQRxqIAJBGGogBadBAxCOAQ0AQoCAgIDgACEBIAAQNCIEQoCAgIBwg0KAgICA4ABRDQAgAigCHCEHIAIoAhghCEEAIQMDQCADIAhHBEACQAJAIAAgByADQQN0aiIJKAIEEFwiAUKAgICAcINCgICAgOAAUQ0AIAIgATcDCCACIAU3AwAgACAEIAAgAkEAEMYEIQYgACABEA8gBkKAgICAcIMiAUKAgICAMFENASABQoCAgIDgAFENACAAIAQgCSgCBCAGQYeAARAZQQBODQELIAQhAQwDCyADQQFqIQMMAQsLIAAgByAIEFogBSEBDAELIAAgAigCHCACKAIYEFogACAFEA9CgICAgOAAIQQLIAAgARAPCyACQSBqJAAgBAsQACAAIAMpAwBBESAEEKoCCxAAIAAgAykDAEECQQAQqgILEAAgACADKQMAQQFBABCqAgtHAQF+QoCAgIDgACEEIAAgAykDACIBIAMpAwgQrgYEfkKAgICA4AAFIAFCIIinQXVPBEAgAaciACAAKAIAQQFqNgIACyABCwtBACAAIAMpAwAiASADKQMIQQEQiwJBAEgEQEKAgICA4AAPCyABQiCIp0F1TwRAIAGnIgAgACgCAEEBajYCAAsgAQuJAQEBfiADKQMAIgFC/////29WIAFCgICAgHCDQoCAgIAgUXJFBEAgAEG35ABBABAVQoCAgIDgAA8LAkAgACABEEciAUKAgICAcINCgICAgOAAUgRAIAMpAwgiBEKAgICAcINCgICAgDBRDQEgACABIAQQrgZFDQEgACABEA8LQoCAgIDgAA8LIAELpQQCBX8CfiMAQSBrIgUkACAAIAVBCGoiBkEAED0aIAZBKBA7GiAEQX5xQQJGBEAgBUEIakHxmQEQiAEaCyAFQQhqQbrMABCIARogBEF9cUEBRgRAIAVBCGpBKhA7GgsgBUEIakGvlAEQiAEaQQAhBiACQQFrIgdBACAHQQBKGyEIAkACQAJAA0AgBiAIRwRAIAYEQCAFQQhqQSwQOxoLIAZBA3QhCSAGQQFqIQYgBUEIaiADIAlqKQMAEIcBRQ0BDAILCyAFQQhqQYaaARCIARogAkEASgRAIAVBCGogAyAHQQN0aikDABCHAQ0BCyAFQQhqIgJBiZEBEIgBGkKAgICAMCELIAIQNiIKQoCAgIBwg0KAgICA4ABRDQEgACAAKQPAASAKQQNBfxCcAyELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENASABQoCAgIBwg0KAgICAMFENAiAAIAFBOyABQQAQFCIKQoCAgIBwg0KAgICA4ABRDQECQCAKQv////9vVg0AIAAgChAPIAAgARCAAyICRQ0CIAIoAiggBEEBdEGuwAFqLwEAQQN0aikDACIKQiCIp0F1SQ0AIAqnIgIgAigCAEEBajYCAAsgACALIApBARCLAiECIAAgChAPIAJBAE4NAgwBCyAFKAIIKAIQIgJBEGogBSgCDCACKAIEEQAAQoCAgIAwIQsLIAAgCxAPQoCAgIDgACELCyAFQSBqJAAgCwuAAgICfgF/IwBBIGsiByQAQoCAgIDgACEFAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNAANAIAAgByABpyADEEwiAkEASA0CIAIEQEKAgICAMCEFAkAgBy0AAEEQcUUNACAHQRhBECAEG2opAwAiBUIgiKdBdUkNACAFpyICIAIoAgBBAWo2AgALIAAgBxBIDAMLIAAgARCMAiIBQoCAgIBwgyIGQoCAgIAgUgRAIAZCgICAgOAAUQRAIAYhBQwECyAAEHtFDQEMAwsLQoCAgIAwIQUMAQtBACEDCyAAIAMQEyAAIAEQDyAHQSBqJAAgBQuxAQEDfiADKQMIIQUgAykDACEGQoCAgIDgACEHAkAgACABECUiAUKAgICAcINCgICAgOAAUgR+IAAgBRBgDQEgACAGEDEiAkUNASAAIAEgAkKAgICAMEKAgICAMCAFIAQbIAVCgICAgDAgBBtBhaoBQYWaASAEGxBtIQMgACABEA8gACACEBNCgICAgOAAQoCAgIAwIANBAEgbBUKAgICA4AALDwsgACABEA9CgICAgOAAC3IBAX5CgICAgDAhAyABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgABAkQoCAgIDgAA8LIAJCgICAgHCDQoCAgIAgUiACQv////9vWHEEfkKAgICAMAVCgICAgOAAQoCAgIAwIAAgASACQQEQiwJBAEgbCwsyAQF+IAAgARAlIgFCgICAgHCDQoCAgIDgAFEEQCABDwsgACABEOgBIQIgACABEA8gAgugAQIBfgF/IwBBIGsiAiQAQoCAgIDgACEEAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNACAAIAIgAacgAxBMIgVBAEgNASAFRQRAQoCAgIAQIQQMAgsgAjUCACEEIAAgAhBIIARCAohCAYNCgICAgBCEIQQMAQtBACEDCyAAIAMQEyAAIAEQDyACQSBqJAAgBAvBAQECfgJAAn5CgICAgBAgAykDACIEQoCAgIBwVA0AGkKAgICA4AAgACABECUiAUKAgICAcINCgICAgOAAUQ0AGiAEpyICIAIoAgBBAWo2AgAgAachAgNAIAAgBBCMAiIEQoCAgIBwgyIFQoCAgIDgAFIEQCACIASnRiAFQoCAgIAgUXINAyAAEHtFDQELCyAAIAQQDyAAIAEQD0KAgICA4AALDwsgACAEEA8gACABEA8gBUKAgICAIFKtQoCAgIAQhAt6AQF+IAAgAykDABAxIgJFBEBCgICAgOAADwtCgICAgOAAIQQgACABECUiAUKAgICAcINCgICAgOAAUQRAIAAgAhATIAEPCyAAQQAgAacgAhBMIQMgACACEBMgACABEA9CgICAgOAAIANBAEetQoCAgIAQhCADQQBIGwsIACAAIAEQJQsPACAAIAFBN0EAQQAQrAILLQEBfkKAgICAMCECAkAgARCjAyIARQ0AIAAtABJBBHFFDQAgADUCRCECCyACCzMCAX4Bf0KAgICAMCECAkAgARCjAyIDRQ0AIAMtABJBBHFFDQAgACADKAJAEC0hAgsgAgsoAEKAgICA4AAgACADKQMAIAEQvgUiAEEAR61CgICAgBCEIABBAEgbC7cBAgF+An9CgICAgOAAIQQgACABEGAEfkKAgICA4AAFQcqZASECAkAgAaciAy8BBhDuAUUNAAJAIAMoAiAiAy8AESIFQYAIcUUNACADKAJUIgZFDQAgACAGIAMoAkgQkwIPCyAFQQR2QQNxQQFrIgNBAksNACADQQJ0QfT/AWooAgAhAgsgACACIAAgAUE2IAFBABAUIgFCgICAgHCDQoCAgIAwUQR+IABBLxAtBSABC0G+GRC+AQsL6QUDA34GfwN8AkACfkKAgICA4AAgACABEGANABpCgICAgOAAIAAgACkDMEEOEEkiBUKAgICAcINCgICAgOAAUQ0AGiAFpyIKIAFCgICAgHBaBH8gAactAAVBEHEFQQALIAotAAVB7wFxcjoABSAAQQEgAiACQQFMGyILQQFrIghBA3RBGGoQKSIHRQ0BIAFCIIinQXVPBEAgAaciAiACKAIAQQFqNgIACyAHIAE3AwAgAykDACIEQiCIp0F1TwRAIASnIgIgAigCAEEBajYCAAsgByAINgIQIAcgBDcDCEEAIQIDQCACIAhHBEAgAyACQQFqIglBA3RqKQMAIgRCIIinQXVPBEAgBKciDCAMKAIAQQFqNgIACyAHIAJBA3RqIAQ3AxggCSECDAELCyAKIAc2AiAgAUL/////b1gEQCAAECQMAgsgAEEAIAGnQTAQTCICQQBIDQFCACEEAkAgAkUNACAAIAFBMCABQQAQFCIGQoCAgIBwg0KAgICA4ABRDQIgBkL/////D1gEQCAGpyICIAhrQQAgAiALThutIQQMAQsgBkIgiKdBB2tBbU0EQAJAIAZCgICAgMCBgPz/AHwiBEL///////////8Ag0KAgICAgICA+P8AVg0AIAS/nSIOIAi3Ig9lDQAgDiAPoSENCyANvSIEAn8gDZlEAAAAAAAA4EFjBEAgDaoMAQtBgICAgHgLIgK3vVEEQCACrSEEDAILQoCAgIDAfiAEQoCAgIDAgYD8/wB9IARC////////////AINCgICAgICAgPj/AFYbIQQMAQsgACAGEA8LIAAgBUEwIARBARAZGiAAQdSZASAAIAFBNiABQQAQFCIEQoCAgIBwgyIBQoCAgICQf1IEfiABQoCAgIDgAFENAiAAIAQQDyAAQS8QLQUgBAtBzJ4BEL4BIgFCgICAgHCDQoCAgIDgAFENASAAIAVBNiABQQEQGRogBQsPCyAAIAUQD0KAgICA4AALMAAgAkEATARAIAAgAUKAgICAMEEAQQAQIQ8LIAAgASADKQMAIAJBAWsgA0EIahAhC6MCAgF/BH4jAEEQayIFJABCgICAgDAhBgJAAkAgACAFQQhqIAAgARAlIgkQPA0AIAVBATYCBAJAIAQEQCAD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gDBSBEAgB0KAgICA4ABRDQcgACABECYMAQsgACAFEMoBCyICQQBIDQUgAkUNACAAIAkgBRA8DQUgCSkDACIHIAR8Qv////////8PVQ0EQgAhASAHQgAgB0IAVRshBwNAIAEgB1ENAiAAIAUgASAJQQhqEIUBIgJBAEgNBiACBEAgACAGIAQgCSkDCBBqQQBIDQcLIARCAXwhBCABQgF8IQEMAAsACyAEQv7///////8PVQ0DIAVCIIinQXVPBEAgBaciAiACKAIAQQFqNgIACyAAIAYgBCAFEGpBAEgNBCAEQgF8IQQLIApBAWohCgwBCwsgACAGQTAgBEKAgICACHxC/////w9YBH4gBEL/////D4MFQoCAgIDAfiAEub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0BDAILIABB0NoAQQAQFQsgACAGEA9CgICAgOAAIQYLIAAgCBAPIAlBEGokACAGC7ECAgR+An8jAEEQayIIJABCgICAgOAAIQUCQAJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAIIAKtNwMIIAAgAUEBIAhBCGoQpwEMAQsgABA+CyIEQoCAgIBwg0KAgICA4ABRDQAgAkEAIAJBAEobrSEHQgAhAQJAA0AgASAHUgRAIAMgAadBA3RqKQMAIgZCIIinQXVPBEAgBqciCSAJKAIAQQFqNgIACyAAIAQgASAGQYCAARDSASEJIAFCAXwhASAJQQBODQEMAgsLIAAgBEEwIAJBAE4EfiACrQVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQAgBCEFDAELIAAgBBAPCyAIQRBqJAAgBQu6CQICfwh+IwBBMGsiBCQAIAMpAwAhBiAEQoCAgIAwNwMYQQEhBQJAAkACfiACQQJIBEBCgICAgDAhDEKAgICAMAwBC0KAgICAMCADKQMIIgxCgICAgHCDQoCAgIAwUQ0AGkKAgICAMCEKQoCAgIAwIQlCgICAgDAhCEKAgICAMCELIAAgDBBgDQFBACEFQoCAgIAwIAJBA0kNABogAykDEAshDQJAAkACQAJAIAAgBkHRASAGQQAQFCIHQoCAgIBwgyIIQoCAgIAwUgRAAkACQCAIQoCAgIDgAFEEQEKAgICAMCEKQoCAgIAwIQlCgICAgDAhCAwBCyAAIAcQDwJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAAIAFBAEEAEKcBDAELIAAQPgsiCEKAgICAcINCgICAgOAAUQRAQoCAgIAwIQpCgICAgDAhCQwBCyAGQiCIp0F1TwRAIAanIgIgAigCAEEBajYCAAsgBCAGNwMQIAAgBEEQakEIckEAEJkDIQIgBCkDGCEKIAQpAxAhCSACRQ0BC0KAgICAMCELDAYLQgAhBwNAIAAgCSAKIARBCGoQrgEiBkKAgICAcINCgICAgOAAUQ0CIAQoAggEQEKAgICAMCELDAYLAkAgBQRAIAYhAQwBCyAEIAY3AyAgBCAHQv////8PgzcDKCAAIAwgDUECIARBIGoQISEBIAAgBhAPIAFCgICAgHCDQoCAgIDgAFENAwsgACAIIAcgARBqQQBIDQIgB0IBfCEHDAALAAsgACAGECUiC0KAgICAcINCgICAgOAAUQ0CIAAgBEEIaiALEDxBAEgNAiAEAn4gBCkDCCIGQoCAgIAIfEL/////D1gEQCAGQv////8PgwwBC0KAgICAwH4gBrm9IgdCgICAgMCBgPz/AH0gB0L///////////8Ag0KAgICAgICA+P8AVhsLIgc3AyACfgJAIAFCgICAgHBUDQAgAactAAVBEHFFDQAgACABQQEgBEEgahCnAQwBCyAAQoCAgIAwQQEgBEEgahCuAwshCCAAIAcQDyAIQoCAgIBwg0KAgICA4ABRBEBCgICAgDAhCgwCC0IAIQcgBkIAIAZCAFUbIQkDQCAHIAlRBEBCgICAgDAhCkKAgICAMCEJDAULQoCAgIAwIQogACALIAcQcyIGQoCAgIBwg0KAgICA4ABRDQICQCAFBEAgBiEBDAELIAQgBjcDICAEIAdC/////w+DNwMoIAAgDCANQQIgBEEgahAhIQEgACAGEA8gAUKAgICAcINCgICAgOAAUQ0DCyAAIAggByABEGpBAEgNAiAHQgF8IQcMAAsAC0KAgICAMCELIAlCgICAgHCDQoCAgIAwUQ0DIAAgCUEBEK0BGgwDC0KAgICAMCEJDAILQoCAgIAwIQpCgICAgDAhCUKAgICAMCEIDAELIAAgCEEwIAenIgJBAE4EfiAHQv////8PgwVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBODQELIAAgCBAPQoCAgIDgACEICyAAIAsQDyAAIAkQDyAAIAoQDyAEQTBqJAAgCAsmAEKAgICA4AAgACADKQMAEMoBIgBBAEetQoCAgIAQhCAAQQBIGwuAAQAjAEEQayIAJAAgABCjBAJ+IAA0AgggACkDAELAhD1+fCIBQoCAgIAIfEL/////D1gEQCABQv////8PgwwBC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgAEEQaiQAIAELxwIBBX8jAEEgayIEJAAgACADKQMAECgiAUKAgICAcINCgICAgOAAUgRAIAAgBEEIakEAED0aIAGnIgVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB05FBEACQAJ/IAUpAgRCgICAgAiDUCIIRQRAIAYgA0EBdGovAQAMAQsgAyAGai0AAAsiAkElRw0AAkAgA0EGaiAHSg0AIANBAWohAgJ/IAhFBEAgBiACQQF0ai8BAAwBCyACIAZqLQAAC0H1AEcNACAFIANBAmpBBBC4BCICQQBIDQAgA0EFaiEDDAELQSUhAiADQQNqIAdKDQAgBSADQQFqQQIQuAQiAkElIAJBAE4iCBshAiADQQJqIAMgCBshAwsgBEEIaiACEIsBGiADQQFqIQMMAQsLIAAgARAPIARBCGoQNiEBCyAEQSBqJAAgAQvkAQEEfyMAQSBrIgIkACAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABSBEAgACACQQhqIAGnIgUoAgRB/////wdxED0aIAVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB0ZFBEACQAJAAkAgBS0AB0GAAXFFBEAgAyAGai0AACEEDAELIAYgA0EBdGovAQAiBEH/AUsNAQtBkOEBIARBxQAQ+wFFDQAgAkEIaiAEEIsBGgwBCyACQQhqIAQQmgILIANBAWohAwwBCwsgACABEA8gAkEIahA2IQELIAJBIGokACABC84EAgZ/AX4jAEEgayIGJAACQCAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABRDQAgACAGQQhqIAGnIgkoAgRB/////wdxED0aIAlBEGohCEEAIQICQANAIAkpAgQiC6dB/////wdxIgogAkoEQCACQQFqIQUCQAJAIAtCgICAgAiDIgtQBEAgAiAIai0AACEDDAELIAggAkEBdGovAQAiA0H/AUsNAQsCQCADQTBrQQpJIANB3/8DcUHBAGtBGklyDQBBpZQBIANBCRD7AQ0AIAQNASADELIGRQ0BCyAGQQhqIAMQiwEaIAUhAgwCCwJ/An8CQCADQYD4A3EiB0GAsANHBEAgB0GAuANHDQFBv8MAIQcMBgtB5MAAIQcgBSAKTg0FAn8gC1BFBEAgCCAFQQF0ai8BAAwBCyAFIAhqLQAACyIFQYDAA2tBgHhJDQUgBkEIaiAFQf8HcSADQQp0QYD4P3FyQYCABGoiA0ESdkHwAXIQmgIgA0EMdkE/cUGAAXIhByACQQJqDAELIANB/wBNBEAgBkEIaiADEJoCIAUhAgwECyADQf8PTQRAIAUhAiADQQZ2QcABcgwCCyADQQx2QeABciEHIAULIQIgBkEIaiAHEJoCIANBBnZBP3FBgAFyCyEHIAZBCGoiBSAHEJoCIAUgA0E/cUGAAXIQmgIMAQsLIAAgARAPIAZBCGoQNiEBDAELIAAgBxC5BCAAIAEQDyAGKAIIKAIQIgBBEGogBigCDCAAKAIEEQAAQoCAgIDgACEBCyAGQSBqJAAgAQuVBAIGfwF+IwBBIGsiBSQAAkAgACADKQMAECgiAUKAgICAcINCgICAgOAAUQ0AIAAgBUEIakEAED0aIAGnIghBEGohCUEAIQIDQAJAAkACQCAIKQIEIgunQf////8HcSACSgRAAn8gC0KAgICACINQRQRAIAkgAkEBdGovAQAMAQsgAiAJai0AAAsiA0ElRgRAIAAgCCACELMGIgNBAEgNAyACQQNqIQYgA0H/AE0EQCAEBEAgBiECDAYLQSUgAyADELIGIgcbIQMgAkEBaiAGIAcbIQIMBQsCfyADQWBxQcABRgRAIANBH3EhA0GAASEHQQEMAQsgA0FwcUHgAUYEQCADQQ9xIQNBgBAhB0ECDAELIANBeHFB8AFHBEBBASEHQQAhA0EADAELIANBB3EhA0GAgAQhB0EDCyECA0AgAkEATA0DIAAgCCAGELMGIgpBAEgNBCAGQQNqIQYgCkHAAXFBgAFHBEBBACEDDAQFIAJBAWshAiAKQT9xIANBBnRyIQMMAQsACwALIAJBAWohAgwDCyAAIAEQDyAFQQhqEDYhAQwECyAGIQIgAyAHSCADQf//wwBKckUgA0GAcHFBgLADR3ENASAAQcmJARC5BAsgACABEA8gBSgCCCgCECIAQRBqIAUoAgwgACgCBBEAAEKAgICA4AAhAQwCCyAFQQhqIAMQuQEaDAALAAsgBUEgaiQAIAELNwAgACADKQMAELMBIgJFBEBCgICAgOAADwsgACACEIECIAJqQQBBCkEAELgCIQEgACACEFQgAQuHAQEBfyMAQRBrIgIkAAJAIAAgAykDABCzASIERQRAQoCAgIDgACEBDAELAn5CgICAgOAAIAAgAkEMaiADKQMIEHcNABogAigCDCIDBEBCgICAgMB+IANBJWtBXUkNARoLIAAgBBCBAiAEakEAIANBgQgQuAILIQEgACAEEFQLIAJBEGokACABCwkAIAAgARDdAgujAQIBfgF/IwBBEGsiAiQAAn4gACABEN0CIgVCgICAgHCDQoCAgIDgAFEEQCAFDAELQQohBgJAAkAgBA0AIAMpAwAiAUKAgICAcINCgICAgDBRDQAgACABEI4FIgZBAEgNAQtCgICAgOAAIAAgAkEIaiAFEG4NARogACACKwMIIAZBAEEAEI8CDAELIAAgBRAPQoCAgIDgAAshASACQRBqJAAgAQuMAgIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AAkACQCADKQMAIgFCgICAgHCDQoCAgIAwUQRAIAIpAwAhAQwBCyAAIAJBDGogARC6AQ0CIAIrAwAiBb0iAUKAgICAgICA+P8Ag0KAgICAgICA+P8AUg0BCyAAQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbEDchBAwBCyACKAIMIgNB5QBrQZt/TQRAIABBijRBABBQDAELIAAgBUEKIANBARCPAiEECyACQRBqJAAgBAvYAQIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AIAAgAkEMaiADKQMAELoBDQAgAigCDCIDQeUATwRAIABBijRB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LUiv7z8IIKpBvMOOPCdaYe4buu8/Muupw5QrhDyXums3K8XvP+6F0TGpZIo8QEVuW3bQ7z/t4zvkujeOvBS+nK392+8/nc2RTTuJdzzYkJ6BwefvP4nMYEHBBVM88XGPK8Lz7z8AAAAAAADwPwAAAAAAAPg/AAAAAAAAAAAG0M9D6/1MPgBBmxkL54UBQAO44j8oKXt9ACgpe3N1cGVyKC4uLmFyZ3VtZW50cyk7fQAoKSB7CiAgICBbbmF0aXZlIGNvZGVdCn0AY2Fubm90IG1peCA/PyB3aXRoICYmIG9yIHx8AGN0egBwcm94eTogcHJvcGVydHkgbm90IHByZXNlbnQgaW4gdGFyZ2V0IHdlcmUgcmV0dXJuZWQgYnkgbm9uIGV4dGVuc2libGUgcHJveHkAcmV2b2tlZCBwcm94eQBQcm94eQBhZGRfcHJvcGVydHkAcHJveHk6IGNhbm5vdCBzZXQgcHJvcGVydHkAbm8gc2V0dGVyIGZvciBwcm9wZXJ0eQB2YWx1ZSBoYXMgbm8gcHJvcGVydHkAY291bGQgbm90IGRlbGV0ZSBwcm9wZXJ0eQBwcm94eTogZHVwbGljYXRlIHByb3BlcnR5AEpTX0RlZmluZUF1dG9Jbml0UHJvcGVydHkAaGFzT3duUHJvcGVydHkAcHJveHk6IGluY29uc2lzdGVudCBkZWxldGVQcm9wZXJ0eQBwcm94eTogaW5jb25zaXN0ZW50IGRlZmluZVByb3BlcnR5AEpTX0RlZmluZVByb3BlcnR5ACFtci0+ZW1wdHkAaW5maW5pdHkASW5maW5pdHkAb3V0IG9mIG1lbW9yeQB1bmtub3duIHVuaWNvZGUgZ2VuZXJhbCBjYXRlZ29yeQBHZW5lcmFsX0NhdGVnb3J5AGV2ZXJ5AGFueQBhcHBseQAnJXMnIGlzIHJlYWQtb25seQBleHBlY3RpbmcgY2F0Y2ggb3IgZmluYWxseQBzdGlja3kAYmlnaW50IGFyZSBmb3JiaWRkZW4gaW4gSlNPTi5zdHJpbmdpZnkAc3ViYXJyYXkAZW1wdHkgYXJyYXkAbm9uIGludGVnZXIgaW5kZXggaW4gdHlwZWQgYXJyYXkAbmVnYXRpdmUgaW5kZXggaW4gdHlwZWQgYXJyYXkAb3V0LW9mLWJvdW5kIGluZGV4IGluIHR5cGVkIGFycmF5AGNhbm5vdCBjcmVhdGUgbnVtZXJpYyBpbmRleCBpbiB0eXBlZCBhcnJheQBpc0FycmF5AFR5cGVkQXJyYXkAZ2V0RGF5AGdldFVUQ0RheQBqc19nZXRfYXRvbV9pbmRleABpbnZhbGlkIGFycmF5IGluZGV4AG91dC1vZi1ib3VuZCBudW1lcmljIGluZGV4AEpTX0F0b21Jc0FycmF5SW5kZXgAZmluZEluZGV4AGludmFsaWQgZXhwb3J0IHN5bnRheABpbnZhbGlkIGFzc2lnbm1lbnQgc3ludGF4AG1heABcdSUwNHgAaW52YWxpZCBvcGNvZGU6IHBjPSV1IG9wY29kZT0weCUwMngALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABsaW5lIHRlcm1pbmF0b3Igbm90IGFsbG93ZWQgYWZ0ZXIgdGhyb3cAYmZfcG93AG5vdwBpbnRlZ2VyIG92ZXJmbG93AHN0YWNrIG92ZXJmbG93AG11c3QgYmUgY2FsbGVkIHdpdGggbmV3AGlzVmlldwBEYXRhVmlldwByYXcAdGRpdgBmZGl2AGVkaXYAY2RpdgAldQBjbGFzcyBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABmdW5jdGlvbiBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABsZXhpY2FsIGRlY2xhcmF0aW9ucyBjYW4ndCBhcHBlYXIgaW4gc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0AGR1cGxpY2F0ZSBhcmd1bWVudCBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAaW1wb3J0Lm1ldGEgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGNvbnRleHQASlNfRnJlZUNvbnRleHQASlNDb250ZXh0AGpzX21hcF9pdGVyYXRvcl9uZXh0AGpzX2FzeW5jX2dlbmVyYXRvcl9yZXN1bWVfbmV4dAB1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dAB0dABleHBvcnRlZCB2YXJpYWJsZSAnJXMnIGRvZXMgbm90IGV4aXN0AHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBkb2VzIG5vdCBleGlzdAB0ZXN0AGFzc2lnbm1lbnQgcmVzdCBwcm9wZXJ0eSBtdXN0IGJlIGxhc3QAYmZfc3FydABzb3J0AGNicnQAdHJpbVN0YXJ0AHBhZFN0YXJ0AHVua25vd24gdW5pY29kZSBzY3JpcHQAU2NyaXB0AGh5cG90AGZyZWVfemVyb19yZWZjb3VudABmYXN0X2FycmF5X2NvdW50AGJpbmFyeV9vYmplY3RfY291bnQAc3RyX2luZGV4ID09IG51bV9rZXlzX2NvdW50ICsgc3RyX2tleXNfY291bnQAbnVtX2luZGV4ID09IG51bV9rZXlzX2NvdW50AHN0cl9jb3VudABwcm9wX2NvdW50AHN5bV9pbmRleCA9PSBhdG9tX2NvdW50AGxhYmVsID49IDAgJiYgbGFiZWwgPCBzLT5sYWJlbF9jb3VudABsYWIxID49IDAgJiYgbGFiMSA8IHMtPmxhYmVsX2NvdW50AG9ial9jb3VudAB2YWwgPCBzLT5jYXB0dXJlX2NvdW50AHZhbDIgPCBzLT5jYXB0dXJlX2NvdW50AHNoYXBlX2NvdW50AGpzX2Z1bmNfcGMybGluZV9jb3VudABtZW1vcnlfdXNlZF9jb3VudABtYWxsb2NfY291bnQAanNfZnVuY19jb3VudABjX2Z1bmNfY291bnQAaW52YWxpZCByZXBlYXQgY291bnQAaW52YWxpZCByZXBldGl0aW9uIGNvdW50AGZvbnQAaW52YWxpZCBjb2RlIHBvaW50AGZyb21Db2RlUG9pbnQAaW52YWxpZCBoaW50AGNhbm5vdCBjb252ZXJ0IE5hTiBvciBJbmZpbml0eSB0byBiaWdpbnQAY2Fubm90IGNvbnZlcnQgdG8gYmlnaW50AGJvdGggb3BlcmFuZHMgbXVzdCBiZSBiaWdpbnQAbm90IGEgYmlnaW50AGVuY29kZVVSSUNvbXBvbmVudABkZWNvZGVVUklDb21wb25lbnQAdW5leHBlY3RlZCBlbmQgb2YgY29tbWVudABpbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQAQmlnSW50AHBhcnNlSW50AGR1cGxpY2F0ZSBkZWZhdWx0AG1hbGxvY19saW1pdABzcGxpdABleHBlY3RpbmcgaGV4IGRpZ2l0AHRyaW1SaWdodAByZWR1Y2VSaWdodAB1bnNoaWZ0AHRyaW1MZWZ0AGludmFsaWQgb2Zmc2V0AGludmFsaWQgYnl0ZU9mZnNldABnZXRUaW1lem9uZU9mZnNldAByZXNvbHZpbmcgZnVuY3Rpb24gYWxyZWFkeSBzZXQAcHJveHk6IGluY29uc2lzdGVudCBzZXQAZmluZF9qdW1wX3RhcmdldABleHBlY3RpbmcgdGFyZ2V0AGludmFsaWQgZGVzdHJ1Y3R1cmluZyB0YXJnZXQAcHJveHk6IGluY29uc2lzdGVudCBnZXQAV2Vha1NldABjb25zdHJ1Y3QASlNfRnJlZUF0b21TdHJ1Y3QAdXNlIHN0cmljdABSZWZsZWN0AHJlamVjdABub3QgYW4gQXN5bmNHZW5lcmF0b3Igb2JqZWN0AGNhbm5vdCBjb252ZXJ0IHRvIG9iamVjdABpbnZhbGlkIGJyYW5kIG9uIG9iamVjdABvcGVyYW5kICdwcm90b3R5cGUnIHByb3BlcnR5IGlzIG5vdCBhbiBvYmplY3QAcmVjZWl2ZXIgaXMgbm90IGFuIG9iamVjdABpdGVyYXRvciBtdXN0IHJldHVybiBhbiBvYmplY3QAbm90IGEgRGF0ZSBvYmplY3QAbm90IGEgb2JqZWN0AEpTT2JqZWN0AGJpZ2Zsb2F0AHBhcnNlRmxvYXQAZmxhdABub3RoaW5nIHRvIHJlcGVhdABjb25jYXQAY29kZVBvaW50QXQAY2hhckF0AGNoYXJDb2RlQXQAa2V5cwBwcm94eTogdGFyZ2V0IHByb3BlcnR5IG11c3QgYmUgcHJlc2VudCBpbiBwcm94eSBvd25LZXlzACAgZmFzdCBhcnJheXMAZXhwb3J0ICclcycgaW4gbW9kdWxlICclcycgaXMgYW1iaWd1b3VzAHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBhbHJlYWR5IGV4aXN0cwB0b28gbWFueSBhcmd1bWVudHMAVG9vIG1hbnkgY2FsbCBhcmd1bWVudHMAZmFzdF9hcnJheV9lbGVtZW50cwAgIGVsZW1lbnRzAGludmFsaWQgbnVtYmVyIG9mIGRpZ2l0cwBiaW5hcnkgb2JqZWN0cwBpbnZhbGlkIHByb3BlcnR5IGFjY2VzcwBqc19vcF9kZWZpbmVfY2xhc3MAZmQtPmJ5dGVfY29kZS5idWZbZGVmaW5lX2NsYXNzX3Bvc10gPT0gT1BfZGVmaW5lX2NsYXNzAF9fZ2V0Q2xhc3MAc2V0SG91cnMAZ2V0SG91cnMAc2V0VVRDSG91cnMAZ2V0VVRDSG91cnMAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycwB0b28gbWFueSBpbWJyaWNhdGVkIHF1YW50aWZpZXJzAHVuaWNvZGVfcHJvcF9vcHMAYWNvcwBmb3IgYXdhaXQgaXMgb25seSB2YWxpZCBpbiBhc3luY2hyb25vdXMgZnVuY3Rpb25zAG5ldy50YXJnZXQgb25seSBhbGxvd2VkIHdpdGhpbiBmdW5jdGlvbnMAYnl0ZWNvZGUgZnVuY3Rpb25zAEMgZnVuY3Rpb25zAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJldmVudEV4dGVuc2lvbnMAU2NyaXB0X0V4dGVuc2lvbnMAYXRvbXMAcHJveHk6IHByb3BlcnRpZXMgbXVzdCBiZSBzdHJpbmdzIG9yIHN5bWJvbHMAZ2V0T3duUHJvcGVydHlTeW1ib2xzAHJlc29sdmVfbGFiZWxzAEpTX0V2YWxUaGlzAHN0cmluZ3MAaW52YWxpZCBkZXNjcmlwdG9yIGZsYWdzAGludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdzAHZhbHVlcwBzZXRNaW51dGVzAGdldE1pbnV0ZXMAc2V0VVRDTWludXRlcwBnZXRVVENNaW51dGVzAHRvbyBtYW55IGNhcHR1cmVzACAgc2hhcGVzAGdldE93blByb3BlcnR5TmFtZXMAZ2NfZnJlZV9jeWNsZXMAYWRkX2V2YWxfdmFyaWFibGVzAHJlc29sdmVfdmFyaWFibGVzAHRvbyBtYW55IGxvY2FsIHZhcmlhYmxlcwB0b28gbWFueSBjbG9zdXJlIHZhcmlhYmxlcwBjb21wYWN0X3Byb3BlcnRpZXMAICBwcm9wZXJ0aWVzAGRlZmluZVByb3BlcnRpZXMAZW50cmllcwBmcm9tRW50cmllcwB0b28gbWFueSByYW5nZXMAaW5jbHVkZXMAc2V0TWlsbGlzZWNvbmRzAGdldE1pbGxpc2Vjb25kcwBzZXRVVENNaWxsaXNlY29uZHMAZ2V0VVRDTWlsbGlzZWNvbmRzAHNldFNlY29uZHMAZ2V0U2Vjb25kcwBzZXRVVENTZWNvbmRzAGdldFVUQ1NlY29uZHMAaXRhbGljcwBhYnMAcHJveHk6IGluY29uc2lzdGVudCBoYXMAJS4qcwAgKCVzAHNldCAlcwBnZXQgJXMAICAgIGF0ICVzAG5vIG92ZXJsb2FkZWQgb3BlcmF0b3IgJXMAbm90IGEgJXMAdW5zdXBwb3J0ZWQga2V5d29yZDogJXMAc3Vic3RyAHByb3h5OiBpbmNvbnNpc3RlbnQgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAHN1cGVyKCkgaXMgb25seSB2YWxpZCBpbiBhIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IAcGFyZW50IGNsYXNzIG11c3QgYmUgY29uc3RydWN0b3IAbm90IGEgY29uc3RydWN0b3IAQXJyYXkgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAE1hcCBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAG5vdCBhbiBBc3luYy1mcm9tLVN5bmMgSXRlcmF0b3IAY2Fubm90IGludm9rZSBhIHJ1bm5pbmcgZ2VuZXJhdG9yAG5vdCBhIGdlbmVyYXRvcgBBc3luY0dlbmVyYXRvcgBzeW50YXggZXJyb3IAU3ludGF4RXJyb3IARXZhbEVycm9yAEludGVybmFsRXJyb3IAQWdncmVnYXRlRXJyb3IAVHlwZUVycm9yAFJhbmdlRXJyb3IAUmVmZXJlbmNlRXJyb3IAVVJJRXJyb3IAZmxvb3IAZm9udGNvbG9yAGFuY2hvcgBmb3IAa2V5Rm9yAGV4cGVjdGluZyBzdXJyb2dhdGUgcGFpcgBhIGRlY2xhcmF0aW9uIGluIHRoZSBoZWFkIG9mIGEgZm9yLSVzIGxvb3AgY2FuJ3QgaGF2ZSBhbiBpbml0aWFsaXplcgAnYXJndW1lbnRzJyBpZGVudGlmaWVyIGlzIG5vdCBhbGxvd2VkIGluIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyAGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgZ2V0dGVyIG9yIHNldHRlcgBpbnZhbGlkIHNldHRlcgBpbnZhbGlkIGdldHRlcgBmaWx0ZXIAbWlzc2luZyBmb3JtYWwgcGFyYW1ldGVyACJ1c2Ugc3RyaWN0IiBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiB3aXRoIGRlZmF1bHQgb3IgZGVzdHJ1Y3R1cmluZyBwYXJhbWV0ZXIAaW52YWxpZCBjaGFyYWN0ZXIAdW5leHBlY3RlZCBjaGFyYWN0ZXIAcHJpdmF0ZSBjbGFzcyBmaWVsZCBmb3JiaWRkZW4gYWZ0ZXIgc3VwZXIAaW52YWxpZCByZWRlZmluaXRpb24gb2YgbGV4aWNhbCBpZGVudGlmaWVyACdsZXQnIGlzIG5vdCBhIHZhbGlkIGxleGljYWwgaWRlbnRpZmllcgBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllcgB5aWVsZCBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAJyVzJyBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAb3RoZXIAYXRvbTFfaXNfaW50ZWdlciAmJiBhdG9tMl9pc19pbnRlZ2VyAGNhbm5vdCBjb252ZXJ0IHRvIGJpZ2ludDogbm90IGFuIGludGVnZXIAaXNJbnRlZ2VyAGlzU2FmZUludGVnZXIAYnVmZmVyAFNoYXJlZEFycmF5QnVmZmVyAGNhbm5vdCB1c2UgaWRlbnRpY2FsIEFycmF5QnVmZmVyAGNhbm5vdCBjb252ZXJ0IGJpZ2ludCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZmxvYXQgdG8gbnVtYmVyAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZGVjaW1hbCB0byBudW1iZXIAbm90IGEgbnVtYmVyAGxpbmVOdW1iZXIAbWFsZm9ybWVkIHVuaWNvZGUgY2hhcgBjbGVhcgBzZXRZZWFyAGdldFllYXIAc2V0RnVsbFllYXIAZ2V0RnVsbFllYXIAc2V0VVRDRnVsbFllYXIAZ2V0VVRDRnVsbFllYXIAcSAhPSByAHVuZXhwZWN0ZWQgbGluZSB0ZXJtaW5hdG9yIGluIHJlZ2V4cAB1bmV4cGVjdGVkIGVuZCBvZiByZWdleHAAUmVnRXhwAHN1cABpbnZhbGlkIGdyb3VwAHBvcABjb250aW51ZSBtdXN0IGJlIGluc2lkZSBsb29wAGJmX2xvZ2ljX29wAG51bV9rZXlzX2NtcAB1c2Ugc3RyaXAAbWFwAGZsYXRNYXAAV2Vha01hcABleHBlY3RpbmcgJ3snIGFmdGVyIFxwAGxvZzFwAGRpdmlzaW9uIGJ5IHplcm8AdW5rbm93bgBpdGVyYXRvcl9jbG9zZV9yZXR1cm4AcHJvbWlzZSBzZWxmIHJlc29sdXRpb24Ab3V0IG9mIG1lbW9yeSBpbiByZWdleHAgZXhlY3V0aW9uAGRlc2NyaXB0aW9uAHByb3h5OiBkZWZpbmVQcm9wZXJ0eSBleGNlcHRpb24AanNfYXN5bmNfZ2VuZXJhdG9yX3Jlc29sdmVfZnVuY3Rpb24AanNfY3JlYXRlX2Z1bmN0aW9uAHNldC9hZGQgaXMgbm90IGEgZnVuY3Rpb24AcmV0dXJuIG5vdCBpbiBhIGZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24AQXN5bmNGdW5jdGlvbgBpbnZhbGlkIG9wZXJhdGlvbgB1bnN1cHBvcnRlZCBvcGVyYXRpb24AYXdhaXQgaW4gZGVmYXVsdCBleHByZXNzaW9uAHlpZWxkIGluIGRlZmF1bHQgZXhwcmVzc2lvbgBpbnZhbGlkIGRlY2ltYWwgZXNjYXBlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBiYWNrIHJlZmVyZW5jZSBvdXQgb2YgcmFuZ2UgaW4gcmVndWxhciBleHByZXNzaW9uAGludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBleHBlY3RlZCAnb2YnIG9yICdpbicgaW4gZm9yIGNvbnRyb2wgZXhwcmVzc2lvbgB0b28gY29tcGxpY2F0ZWQgZGVzdHJ1Y3R1cmluZyBleHByZXNzaW9uAGV4cGVjdGVkICd9JyBhZnRlciB0ZW1wbGF0ZSBleHByZXNzaW9uAHRvUHJlY2lzaW9uAGFzaW4Aam9pbgBtaW4AY29weVdpdGhpbgB0ZW1wbGF0ZSBsaXRlcmFsIGNhbm5vdCBhcHBlYXIgaW4gYW4gb3B0aW9uYWwgY2hhaW4AY2lyY3VsYXIgcHJvdG90eXBlIGNoYWluAGFzc2lnbgAheS0+c2lnbgBpc0Zyb3plbgBtYXJrX2NoaWxkcmVuAChwb3MgKyBsZW4pIDw9IGJjX2J1Zl9sZW4AdW5leHBlY3RlZCBlbGxpcHNpcyB0b2tlbgB0aGVuAHNldHRlciBpcyBmb3JiaWRkZW4AbnVsbCBvciB1bmRlZmluZWQgYXJlIGZvcmJpZGRlbgBhdGFuAG5hbgBub3QgYSBib29sZWFuAEJvb2xlYW4AZ2Nfc2NhbgBiYWQgbm9ybWFsaXphdGlvbiBmb3JtAEpTX05ld1N5bWJvbEZyb21BdG9tAGZyb20AcmFuZG9tAHRyaW0AdGRpdnJlbQBmZGl2cmVtAGVkaXZyZW0AY2RpdnJlbQBiZl9kaXZyZW0Ac3FydHJlbQBpbXVsAG5vdCBhIHN5bWJvbABTeW1ib2wAUmVnRXhwIGV4ZWMgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsAHBhcmVudCBwcm90b3R5cGUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgbnVsbABjYW5ub3Qgc2V0IHByb3BlcnR5ICclcycgb2YgbnVsbABjYW5ub3QgcmVhZCBwcm9wZXJ0eSAnJXMnIG9mIG51bGwATnVsbABmaWxsAG5ldyBBcnJheUJ1ZmZlciBpcyB0b28gc21hbGwAVHlwZWRBcnJheSBsZW5ndGggaXMgdG9vIHNtYWxsAGNhbGwAZG90QWxsAG1hdGNoQWxsAHJlcGxhY2VBbGwAY2VpbAB1cGRhdGVfbGFiZWwAYmNfYnVmW3Bvc10gPT0gT1BfbGFiZWwAZXZhbABpbnZhbGlkIGJpZ2ludCBsaXRlcmFsAGludmFsaWQgbnVtYmVyIGxpdGVyYWwAbWFsZm9ybWVkIGVzY2FwZSBzZXF1ZW5jZSBpbiBzdHJpbmcgbGl0ZXJhbABiZl9leHBfaW50ZXJuYWwAYmZfbG9nX2ludGVybmFsAEpTX1NldFByb3BlcnR5SW50ZXJuYWwASlNfR2V0T3duUHJvcGVydHlOYW1lc0ludGVybmFsAF9fSlNfRXZhbEludGVybmFsAGJpZ2RlY2ltYWwAbnR0X2ZmdF9wYXJ0aWFsAHRvRXhwb25lbnRpYWwAc2VhbABnbG9iYWwAYmxpbmsAX19kYXRlX2Nsb2NrAHN0YWNrAGxyZV9leGVjX2JhY2t0cmFjawBzLT5pc193ZWFrAGJmX3Bvd191aQBzZXRNb250aABnZXRNb250aABzZXRVVENNb250aABnZXRVVENNb250aABpbnZhbGlkIGtleXdvcmQ6IHdpdGgAc3RhcnRzV2l0aABlbmRzV2l0aABwcm9wID09IEpTX0FUT01fbGVuZ3RoAGludmFsaWQgYXJyYXkgbGVuZ3RoAGludmFsaWQgYXJyYXkgYnVmZmVyIGxlbmd0aABpbnZhbGlkIGxlbmd0aABpbnZhbGlkIGJ5dGVMZW5ndGgAdXNlIG1hdGgATWF0aABwdXNoAGFjb3NoAEpTX1Jlc2l6ZUF0b21IYXNoAGFzaW5oAGF0YW5oAGJyZWFrIG11c3QgYmUgaW5zaWRlIGxvb3Agb3Igc3dpdGNoAG1hdGNoAGNhdGNoAHNlYXJjaABmb3JFYWNoAGJmX2xvZwBBcnJheSB0b28gbG9uZwBzdHJpbmcgdG9vIGxvbmcAQXJyYXkgbG9vIGxvbmcAc3Vic3RyaW5nAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBzdHJpbmcAdW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nAG5vdCBhIHN0cmluZwBpbnZhbGlkIGNoYXJhY3RlciBpbiBhIEpTT04gc3RyaW5nAHRvU3RyaW5nAHRvRGF0ZVN0cmluZwB0b0xvY2FsZURhdGVTdHJpbmcAdG9UaW1lU3RyaW5nAHRvTG9jYWxlVGltZVN0cmluZwB0b0xvY2FsZVN0cmluZwB0b0dNVFN0cmluZwBKU1N0cmluZwB0b0lTT1N0cmluZwB0b1VUQ1N0cmluZwBkdXBsaWNhdGUgaW1wb3J0IGJpbmRpbmcAaW52YWxpZCBpbXBvcnQgYmluZGluZwBiaWcAcmVnZXhwIG11c3QgaGF2ZSB0aGUgJ2cnIGZsYWcAb2YAaW5mAGRpZmYgPT0gKGludDhfdClkaWZmAGRpZmYgPT0gKGludDE2X3QpZGlmZgBocmVmAGdjX2RlY3JlZgBmcmVlX3Zhcl9yZWYAb3B0aW1pemVfc2NvcGVfbWFrZV9nbG9iYWxfcmVmAHJlc2V0X3dlYWtfcmVmAGRlbGV0ZV93ZWFrX3JlZgBvcHRpbWl6ZV9zY29wZV9tYWtlX3JlZgBpbmRleE9mAGxhc3RJbmRleE9mAHZhbHVlT2YAc2V0UHJvdG90eXBlT2YAZ2V0UHJvdG90eXBlT2YAaXNQcm90b3R5cGVPZgAlLipmAGZvbnRzaXplAGJpbmFyeV9vYmplY3Rfc2l6ZQBzdHJfc2l6ZQBuZXdfc2l6ZSA8PSBzaC0+cHJvcF9zaXplAGRlc2NyIDwgcnQtPmF0b21fc2l6ZQBhdG9tIDwgcnQtPmF0b21fc2l6ZQBjb21wdXRlX3N0YWNrX3NpemUAb2JqX3NpemUAbiA8IGJ1Zl9zaXplAHNoYXBlX3NpemUAanNfZnVuY19wYzJsaW5lX3NpemUAanNfZnVuY19jb2RlX3NpemUAbWVtb3J5X3VzZWRfc2l6ZQBqc19mdW5jX3NpemUAbm9ybWFsaXplAGZyZWV6ZQByZXNvbHZlAHRvUHJpbWl0aXZlAHB1dF9sdmFsdWUAdW5rbm93biB1bmljb2RlIHByb3BlcnR5IHZhbHVlAHJlc3QgZWxlbWVudCBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUAaW52YWxpZCByZXQgdmFsdWUAX19KU19BdG9tVG9WYWx1ZQBfX3F1b3RlAGlzRmluaXRlAGRlbGV0ZQBjcmVhdGUAc2V0RGF0ZQBnZXREYXRlAHNldFVUQ0RhdGUAZ2V0VVRDRGF0ZQBJbnZhbGlkIERhdGUAcmV2ZXJzZQBwYXJzZQBwcm94eSBwcmV2ZW50RXh0ZW5zaW9ucyBoYW5kbGVyIHJldHVybmVkIGZhbHNlAFByb21pc2UAdG9Mb3dlckNhc2UAdG9Mb2NhbGVMb3dlckNhc2UAdG9VcHBlckNhc2UAdG9Mb2NhbGVVcHBlckNhc2UAaWdub3JlQ2FzZQBsb2NhbGVDb21wYXJlAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJvdG90eXBlAHByb3h5OiBiYWQgcHJvdG90eXBlAG5vdCBhIHByb3RvdHlwZQBpbnZhbGlkIG9iamVjdCB0eXBlAHVuZXNjYXBlAG5vbmUAcmVzdCBlbGVtZW50IG11c3QgYmUgdGhlIGxhc3Qgb25lAG11bHRpbGluZQAgIHBjMmxpbmUAc29tZQBKU19GcmVlUnVudGltZQBKU1J1bnRpbWUAc2V0VGltZQBnZXRUaW1lAHNldF9vYmplY3RfbmFtZQBleHBlY3RpbmcgcHJvcGVydHkgbmFtZQB1bmtub3duIHVuaWNvZGUgcHJvcGVydHkgbmFtZQBpbnZhbGlkIHByb3BlcnR5IG5hbWUAZHVwbGljYXRlIF9fcHJvdG9fXyBwcm9wZXJ0eSBuYW1lAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIHBhcmFtZXRlciBuYW1lAGV4cGVjdGluZyBncm91cCBuYW1lAGR1cGxpY2F0ZSBncm91cCBuYW1lAGludmFsaWQgZ3JvdXAgbmFtZQBkdXBsaWNhdGUgbGFiZWwgbmFtZQBpbnZhbGlkIGZpcnN0IGNoYXJhY3RlciBvZiBwcml2YXRlIG5hbWUAaW52YWxpZCBsZXhpY2FsIHZhcmlhYmxlIG5hbWUAaW52YWxpZCBtZXRob2QgbmFtZQBleHBlY3RpbmcgZmllbGQgbmFtZQBpbnZhbGlkIGZpZWxkIG5hbWUAY2xhc3Mgc3RhdGVtZW50IHJlcXVpcmVzIGEgbmFtZQBmaWxlTmFtZQBjb21waWxlAG9iamVjdCBpcyBub3QgZXh0ZW5zaWJsZQBwcm94eTogaW5jb25zaXN0ZW50IGlzRXh0ZW5zaWJsZQBjYW5ub3QgaGF2ZSBzZXR0ZXIvZ2V0dGVyIGFuZCB2YWx1ZSBvciB3cml0YWJsZQBwcm9wZXJ0eSBpcyBub3QgY29uZmlndXJhYmxlAHZhbHVlIGlzIG5vdCBpdGVyYWJsZQBwcm9wZXJ0eUlzRW51bWVyYWJsZQBtaXNzaW5nIGluaXRpYWxpemVyIGZvciBjb25zdCB2YXJpYWJsZQBsZXhpY2FsIHZhcmlhYmxlAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIGEgdmFyaWFibGUAcmV2b2NhYmxlAHN0cmlrZQBtcF9kaXZub3JtX2xhcmdlAGludmFsaWQgY2xhc3MgcmFuZ2UAbWVzc2FnZQBhc3luY19mdW5jX2ZyZWUAaW52YWxpZCBsdmFsdWUgaW4gc3RyaWN0IG1vZGUAaW52YWxpZCB2YXJpYWJsZSBuYW1lIGluIHN0cmljdCBtb2RlAGNhbm5vdCBkZWxldGUgYSBkaXJlY3QgcmVmZXJlbmNlIGluIHN0cmljdCBtb2RlAG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlAG9jdGFsIGxpdGVyYWxzIGFyZSBkZXByZWNhdGVkIGluIHN0cmljdCBtb2RlAHVuaWNvZGUAICBieXRlY29kZQBKU0Z1bmN0aW9uQnl0ZWNvZGUAc2tpcF9kZWFkX2NvZGUAaW52YWxpZCBhcmd1bWVudCBuYW1lIGluIHN0cmljdCBjb2RlAGludmFsaWQgZnVuY3Rpb24gbmFtZSBpbiBzdHJpY3QgY29kZQBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllciBpbiBtb2R1bGUgY29kZQBpbXBvcnQubWV0YSBvbmx5IHZhbGlkIGluIG1vZHVsZSBjb2RlAGZyb21DaGFyQ29kZQBpbnZhbGlkIGZvciBpbi9vZiBsZWZ0IGhhbmQtc2lkZQBpbnZhbGlkIGFzc2lnbm1lbnQgbGVmdC1oYW5kIHNpZGUAcmVkdWNlAHNvdXJjZQAndGhpcycgY2FuIGJlIGluaXRpYWxpemVkIG9ubHkgb25jZQBwcm9wZXJ0eSBjb25zdHJ1Y3RvciBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlAGludmFsaWQgVVRGLTggc2VxdWVuY2UAY2lyY3VsYXIgcmVmZXJlbmNlAHNsaWNlAHNwbGljZQByYWNlAHJlcGxhY2UAJSsuKmUAdW5leHBlY3RlZCAnYXdhaXQnIGtleXdvcmQAdW5leHBlY3RlZCAneWllbGQnIGtleXdvcmQAbWFwX2RlY3JlZl9yZWNvcmQAaXRlcmF0b3IgZG9lcyBub3QgaGF2ZSBhIHRocm93IG1ldGhvZABvYmplY3QgbmVlZHMgdG9JU09TdHJpbmcgbWV0aG9kACdzdXBlcicgaXMgb25seSB2YWxpZCBpbiBhIG1ldGhvZABmcm91bmQAX19iZl9yb3VuZABicmVhay9jb250aW51ZSBsYWJlbCBub3QgZm91bmQAb3V0IG9mIGJvdW5kAGZpbmQAYmluZABpbnZhbGlkIGluZGV4IGZvciBhcHBlbmQAZXh0cmFuZW91cyBjaGFyYWN0ZXJzIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBkYXRhIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBlbmQAaW52YWxpZCBpbmNyZW1lbnQvZGVjcmVtZW50IG9wZXJhbmQAaW52YWxpZCAnaW5zdGFuY2VvZicgcmlnaHQgb3BlcmFuZABpbnZhbGlkICdpbicgb3BlcmFuZAB0cmltRW5kAHBhZEVuZABib2xkACVsbGQAZ2NfZGVjcmVmX2NoaWxkAHJlc29sdmVfc2NvcGVfcHJpdmF0ZV9maWVsZABjYW5ub3QgZGVsZXRlIGEgcHJpdmF0ZSBjbGFzcyBmaWVsZABleHBlY3RpbmcgPGJyYW5kPiBwcml2YXRlIGZpZWxkACVzIGlzIG5vdCBpbml0aWFsaXplZABmaXhlZAB0b0ZpeGVkAHNldF9vYmplY3RfbmFtZV9jb21wdXRlZAByZWdleCBub3Qgc3VwcG9ydGVkAGV2YWwgaXMgbm90IHN1cHBvcnRlZABSZWdFeHAgYXJlIG5vdCBzdXBwb3J0ZWQAaW50ZXJydXB0ZWQAJXMgb2JqZWN0IGV4cGVjdGVkAGlkZW50aWZpZXIgZXhwZWN0ZWQAYnl0ZWNvZGUgZnVuY3Rpb24gZXhwZWN0ZWQAc3RyaW5nIGV4cGVjdGVkAGZyb20gY2xhdXNlIGV4cGVjdGVkAGZ1bmN0aW9uIG5hbWUgZXhwZWN0ZWQAdmFyaWFibGUgbmFtZSBleHBlY3RlZABtZXRhIGV4cGVjdGVkAHJlamVjdGVkAG1lbW9yeSBhbGxvY2F0ZWQAbWVtb3J5IHVzZWQAZGVyaXZlZCBjbGFzcyBjb25zdHJ1Y3RvciBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkAGNhbm5vdCBzZXQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAY2Fubm90IHJlYWQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAZmxhZ3MgbXVzdCBiZSB1bmRlZmluZWQAVW5kZWZpbmVkAHByaXZhdGUgY2xhc3MgZmllbGQgaXMgYWxyZWFkeSBkZWZpbmVkACclcycgaXMgbm90IGRlZmluZWQAZ3JvdXAgbmFtZSBub3QgZGVmaW5lZABvcGVyYXRvciAlczogbm8gZnVuY3Rpb24gZGVmaW5lZABhbGxTZXR0bGVkAGZ1bGZpbGxlZABjYW5ub3QgYmUgY2FsbGVkAGlzU2VhbGVkACFzaC0+aXNfaGFzaGVkAHZhcl9yZWYtPmlzX2RldGFjaGVkAEFycmF5QnVmZmVyIGlzIGRldGFjaGVkAGFkZAAlKzA3ZAAlMDRkACUwMmQlMDJkACUwMmQvJTAyZC8lMCpkACUuM3MgJS4zcyAlMDJkICUwKmQAOiVkAGludmFsaWQgdGhyb3cgdmFyIHR5cGUgJWQAc2MAanNfZGVmX21hbGxvYwB0cnVuYwBnYwBleGVjAGJmX2ludGVnZXJfdG9fcmFkaXhfcmVjAHF1aWNranMvcXVpY2tqcy5jAHF1aWNranMvbGlicmVnZXhwLmMAcXVpY2tqcy9saWJiZi5jAHF1aWNranMvbGlidW5pY29kZS5jAHN1YgBwcm9taXNlX3JlYWN0aW9uX2pvYgBqc19wcm9taXNlX3Jlc29sdmVfdGhlbmFibGVfam9iAHIgIT0gYSAmJiByICE9IGIAcSAhPSBhICYmIHEgIT0gYgByd2EAciAhPSBhAF9fbG9va3VwU2V0dGVyX18AX19kZWZpbmVTZXR0ZXJfXwBfX2xvb2t1cEdldHRlcl9fAF9fZGVmaW5lR2V0dGVyX18AX19wcm90b19fAFtTeW1ib2wuc3BsaXRdAFtTeW1ib2wuc3BlY2llc10AW1N5bWJvbC5pdGVyYXRvcl0AW1N5bWJvbC5hc3luY0l0ZXJhdG9yXQBbU3ltYm9sLm1hdGNoQWxsXQBbU3ltYm9sLm1hdGNoXQBbU3ltYm9sLnNlYXJjaF0AW1N5bWJvbC50b1N0cmluZ1RhZ10AW1N5bWJvbC50b1ByaW1pdGl2ZV0AW3Vuc3VwcG9ydGVkIHR5cGVdAFtmdW5jdGlvbiBieXRlY29kZV0AW1N5bWJvbC5oYXNJbnN0YW5jZV0AW1N5bWJvbC5yZXBsYWNlXQBbACUwMmQ6JTAyZDolMDJkLiUwM2RaAFBPU0lUSVZFX0lORklOSVRZAE5FR0FUSVZFX0lORklOSVRZAHAtPmNsYXNzX2lkID09IEpTX0NMQVNTX0FSUkFZAHN0YWNrX2xlbiA8IFBPUF9TVEFDS19MRU5fTUFYAC0lMDJkLSUwMmRUAEpTX0F0b21HZXRTdHJSVABvcGNvZGUgPCBSRU9QX0NPVU5UAEJZVEVTX1BFUl9FTEVNRU5UACUwMmQ6JTAyZDolMDJkIEdNVABKU19WQUxVRV9HRVRfVEFHKHNmLT5jdXJfZnVuYykgPT0gSlNfVEFHX09CSkVDVAB2YXJfa2luZCA9PSBKU19WQVJfUFJJVkFURV9TRVRURVIATUFYX1NBRkVfSU5URUdFUgBNSU5fU0FGRV9JTlRFR0VSAGFzVWludE4AYXNJbnROAGlzTmFOAERhdGUgdmFsdWUgaXMgTmFOAHRvSlNPTgBFUFNJTE9OAE5BTgAlMDJkOiUwMmQ6JTAyZCAlY00Acy0+bGFiZWxfc2xvdHNbbGFiZWxdLmZpcnN0X3JlbG9jID09IE5VTEwAbGFiZWxfc2xvdHNbaV0uZmlyc3RfcmVsb2MgPT0gTlVMTABwcnMgIT0gTlVMTABzZi0+Y3VyX3NwICE9IE5VTEwAc2YgIT0gTlVMTABtcjEgIT0gTlVMTAB2YXJfa2luZCAhPSBKU19WQVJfTk9STUFMAGItPmZ1bmNfa2luZCA9PSBKU19GVU5DX05PUk1BTABlbmNvZGVVUkkAZGVjb2RlVVJJAFBJAHNwZWNpYWwgPT0gUFVUX0xWQUxVRV9OT0tFRVAgfHwgc3BlY2lhbCA9PSBQVVRfTFZBTFVFX05PS0VFUF9ERVBUSABzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfRVhFQ1VUSU5HAHByZWMxICE9IEJGX1BSRUNfSU5GADAxMjM0NTY3ODlBQkNERUYAU0laRQBNQVhfVkFMVUUATUlOX1ZBTFVFAE5BTUUAZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9HTE9CQUwgfHwgZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9NT0RVTEUAcC0+Z2Nfb2JqX3R5cGUgPT0gSlNfR0NfT0JKX1RZUEVfSlNfT0JKRUNUIHx8IHAtPmdjX29ial90eXBlID09IEpTX0dDX09CSl9UWVBFX0ZVTkNUSU9OX0JZVEVDT0RFAExPRzJFAExPRzEwRQBzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfQVdBSVRJTkdfUkVUVVJOIHx8IHMtPnN0YXRlID09IEpTX0FTWU5DX0dFTkVSQVRPUl9TVEFURV9DT01QTEVURUQAVVRDADxpbnB1dD4APHNldD4APGFub255bW91cz4APGR1bXA+ADxudWxsPgBiaWdpbnQgb3BlcmFuZHMgYXJlIGZvcmJpZGRlbiBmb3IgPj4+ACZxdW90OwBzZXRVaW50OABnZXRVaW50OABzZXRJbnQ4AGdldEludDgAbWFsZm9ybWVkIFVURi04AHJhZGl4IG11c3QgYmUgYmV0d2VlbiAyIGFuZCAzNgBzZXRVaW50MTYAZ2V0VWludDE2AHNldEludDE2AGdldEludDE2AGFyZ2MgPT0gNQBzZXRCaWdVaW50NjQAZ2V0QmlnVWludDY0AHNldEJpZ0ludDY0AGdldEJpZ0ludDY0AHNldEZsb2F0NjQAZ2V0RmxvYXQ2NABhcmdjID09IDMAYXRhbjIAbG9nMgBmbG9vckxvZzIAU1FSVDFfMgBTUVJUMgBMTjIAY2x6MzIAc2V0VWludDMyAGdldFVpbnQzMgBzZXRJbnQzMgBnZXRJbnQzMgBzZXRGbG9hdDMyAGdldEZsb2F0MzIAc3RhY2tfbGVuID49IDIASlNfQXRvbUlzTnVtZXJpY0luZGV4MQBqc19mY3Z0MQBKU19Db21wYWN0QmlnSW50MQBleHBtMQByICE9IGExICYmIHIgIT0gYjEAbHMtPmFkZHIgPT0gLTEAbnEgPj0gMQBzdGFja19sZW4gPj0gMQBwLT5oZWFkZXIucmVmX2NvdW50ID09IDEAcC0+c2hhcGUtPmhlYWRlci5yZWZfY291bnQgPT0gMQBzdGFja19sZW4gPT0gMQBqc19mcmVlX3NoYXBlMABsb2cxMABMTjEwAHAtPnJlZl9jb3VudCA+IDAAdmFyX3JlZi0+aGVhZGVyLnJlZl9jb3VudCA+IDAAc3RhY2tfc2l6ZSA+IDAAY3Bvb2xfaWR4ID49IDAAcnQtPmF0b21fY291bnQgPj0gMABscy0+cmVmX2NvdW50ID49IDAAcy0+aXNfZXZhbCB8fCBzLT5jbG9zdXJlX3Zhcl9jb3VudCA9PSAwAHAtPnJlZl9jb3VudCA9PSAwAGN0eC0+aGVhZGVyLnJlZl9jb3VudCA9PSAwAHNoLT5oZWFkZXIucmVmX2NvdW50ID09IDAAcC0+bWFyayA9PSAwAChuMiAlIHN0cmlwX2xlbikgPT0gMAAocHItPnUuaW5pdC5yZWFsbV9hbmRfaWQgJiAzKSA9PSAwAChuZXdfaGFzaF9zaXplICYgKG5ld19oYXNoX3NpemUgLSAxKSkgPT0gMABpICE9IDAAc2l6ZSAhPSAwAF4kXC4qKz8oKVtde318LwA8LwAwLgBtaXNzaW5nIGJpbmRpbmcgcGF0dGVybi4uLgBiaWdpbnQgYXJndW1lbnQgd2l0aCB1bmFyeSArAGFzeW5jIGZ1bmN0aW9uICoACn0pAGxpc3RfZW1wdHkoJnJ0LT5nY19vYmpfbGlzdCkAaiA9PSAoc2gtPnByb3BfY291bnQgLSBzaC0+ZGVsZXRlZF9wcm9wX2NvdW50KQBKU19Jc1VuZGVmaW5lZChmdW5jX3JldCkAIV9fSlNfQXRvbUlzVGFnZ2VkSW50KGRlc2NyKQAhYXRvbV9pc19mcmVlKHApAChudWxsKQAgKG5hdGl2ZSkAanNfY2xhc3NfaGFzX2J5dGVjb2RlKHAtPmNsYXNzX2lkKQB1bmNvbnNpc3RlbnQgc3RhY2sgc2l6ZTogJWQgJWQgKHBjPSVkKQBieXRlY29kZSBidWZmZXIgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgdW5kZXJmbG93IChvcD0lZCwgcGM9JWQpAGludmFsaWQgb3Bjb2RlIChvcD0lZCwgcGM9JWQpACg/OikAbm8gZnVuY3Rpb24gZmlsZW5hbWUgZm9yIGltcG9ydCgpAC1fLiF+KicoKQAgYW5vbnltb3VzKABTeW1ib2woAGV4cGVjdGluZyAnfScAY2xhc3MgY29uc3RydWN0b3JzIG11c3QgYmUgaW52b2tlZCB3aXRoICduZXcnAGV4cGVjdGluZyAnYXMnAHVuZXhwZWN0ZWQgdG9rZW4gaW4gZXhwcmVzc2lvbjogJyUuKnMnAHVuZXhwZWN0ZWQgdG9rZW46ICclLipzJwByZWRlY2xhcmF0aW9uIG9mICclcycAZHVwbGljYXRlIGV4cG9ydGVkIG5hbWUgJyVzJwBjaXJjdWxhciByZWZlcmVuY2Ugd2hlbiBsb29raW5nIGZvciBleHBvcnQgJyVzJyBpbiBtb2R1bGUgJyVzJwBDb3VsZCBub3QgZmluZCBleHBvcnQg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AJYAAADBAAAAlwAAAJgAAADCAAAAlwAAAJgAAADDAAAAawAAAGwAAADEAAAAmQAAAJoAAADFAAAAmQAAAJoAAAAvAAAAmwAAAJwAAADGAAAAawAAAGwAAADHAAAAnQAAAJ4AAAAAAAAA7h8AAB8gAAAqIAAA4h8AABUgAAA5IAAA+B8AAAYgAABjb3B5V2l0aGluAGVudHJpZXMAZmlsbABmaW5kAGZpbmRJbmRleABmbGF0AGZsYXRNYXAAaW5jbHVkZXMAa2V5cwB2YWx1ZXMAAAAAAAEBAgIDAwIDAEGQpwEL3xBudWxsAGZhbHNlAHRydWUAaWYAZWxzZQByZXR1cm4AdmFyAHRoaXMAZGVsZXRlAHZvaWQAdHlwZW9mAG5ldwBpbgBpbnN0YW5jZW9mAGRvAHdoaWxlAGZvcgBicmVhawBjb250aW51ZQBzd2l0Y2gAY2FzZQBkZWZhdWx0AHRocm93AHRyeQBjYXRjaABmaW5hbGx5AGZ1bmN0aW9uAGRlYnVnZ2VyAHdpdGgAY2xhc3MAY29uc3QAZW51bQBleHBvcnQAZXh0ZW5kcwBpbXBvcnQAc3VwZXIAaW1wbGVtZW50cwBpbnRlcmZhY2UAbGV0AHBhY2thZ2UAcHJpdmF0ZQBwcm90ZWN0ZWQAcHVibGljAHN0YXRpYwB5aWVsZABhd2FpdAAAbGVuZ3RoAGZpbGVOYW1lAGxpbmVOdW1iZXIAbWVzc2FnZQBlcnJvcnMAc3RhY2sAbmFtZQB0b1N0cmluZwB0b0xvY2FsZVN0cmluZwB2YWx1ZU9mAGV2YWwAcHJvdG90eXBlAGNvbnN0cnVjdG9yAGNvbmZpZ3VyYWJsZQB3cml0YWJsZQBlbnVtZXJhYmxlAHZhbHVlAGdldABzZXQAb2YAX19wcm90b19fAHVuZGVmaW5lZABudW1iZXIAYm9vbGVhbgBzdHJpbmcAb2JqZWN0AHN5bWJvbABpbnRlZ2VyAHVua25vd24AYXJndW1lbnRzAGNhbGxlZQBjYWxsZXIAPGV2YWw+ADxyZXQ+ADx2YXI+ADxhcmdfdmFyPgA8d2l0aD4AbGFzdEluZGV4AHRhcmdldABpbmRleABpbnB1dABkZWZpbmVQcm9wZXJ0aWVzAGFwcGx5AGpvaW4AY29uY2F0AHNwbGl0AGNvbnN0cnVjdABnZXRQcm90b3R5cGVPZgBzZXRQcm90b3R5cGVPZgBpc0V4dGVuc2libGUAcHJldmVudEV4dGVuc2lvbnMAaGFzAGRlbGV0ZVByb3BlcnR5AGRlZmluZVByb3BlcnR5AGdldE93blByb3BlcnR5RGVzY3JpcHRvcgBvd25LZXlzAGFkZABkb25lAG5leHQAdmFsdWVzAHNvdXJjZQBmbGFncwBnbG9iYWwAdW5pY29kZQByYXcAbmV3LnRhcmdldAB0aGlzLmFjdGl2ZV9mdW5jADxob21lX29iamVjdD4APGNvbXB1dGVkX2ZpZWxkPgA8c3RhdGljX2NvbXB1dGVkX2ZpZWxkPgA8Y2xhc3NfZmllbGRzX2luaXQ+ADxicmFuZD4AI2NvbnN0cnVjdG9yAGFzAGZyb20AbWV0YQAqZGVmYXVsdCoAKgBNb2R1bGUAdGhlbgByZXNvbHZlAHJlamVjdABwcm9taXNlAHByb3h5AHJldm9rZQBhc3luYwBleGVjAGdyb3VwcwBzdGF0dXMAcmVhc29uAGdsb2JhbFRoaXMAYmlnaW50AGJpZ2Zsb2F0AGJpZ2RlY2ltYWwAcm91bmRpbmdNb2RlAG1heGltdW1TaWduaWZpY2FudERpZ2l0cwBtYXhpbXVtRnJhY3Rpb25EaWdpdHMAdG9KU09OAE9iamVjdABBcnJheQBFcnJvcgBOdW1iZXIAU3RyaW5nAEJvb2xlYW4AU3ltYm9sAEFyZ3VtZW50cwBNYXRoAEpTT04ARGF0ZQBGdW5jdGlvbgBHZW5lcmF0b3JGdW5jdGlvbgBGb3JJbkl0ZXJhdG9yAFJlZ0V4cABBcnJheUJ1ZmZlcgBTaGFyZWRBcnJheUJ1ZmZlcgBVaW50OENsYW1wZWRBcnJheQBJbnQ4QXJyYXkAVWludDhBcnJheQBJbnQxNkFycmF5AFVpbnQxNkFycmF5AEludDMyQXJyYXkAVWludDMyQXJyYXkAQmlnSW50NjRBcnJheQBCaWdVaW50NjRBcnJheQBGbG9hdDMyQXJyYXkARmxvYXQ2NEFycmF5AERhdGFWaWV3AEJpZ0ludABCaWdGbG9hdABCaWdGbG9hdEVudgBCaWdEZWNpbWFsAE9wZXJhdG9yU2V0AE9wZXJhdG9ycwBNYXAAU2V0AFdlYWtNYXAAV2Vha1NldABNYXAgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAEFycmF5IEl0ZXJhdG9yAFN0cmluZyBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAEdlbmVyYXRvcgBQcm94eQBQcm9taXNlAFByb21pc2VSZXNvbHZlRnVuY3Rpb24AUHJvbWlzZVJlamVjdEZ1bmN0aW9uAEFzeW5jRnVuY3Rpb24AQXN5bmNGdW5jdGlvblJlc29sdmUAQXN5bmNGdW5jdGlvblJlamVjdABBc3luY0dlbmVyYXRvckZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yAEV2YWxFcnJvcgBSYW5nZUVycm9yAFJlZmVyZW5jZUVycm9yAFN5bnRheEVycm9yAFR5cGVFcnJvcgBVUklFcnJvcgBJbnRlcm5hbEVycm9yADxicmFuZD4AU3ltYm9sLnRvUHJpbWl0aXZlAFN5bWJvbC5pdGVyYXRvcgBTeW1ib2wubWF0Y2gAU3ltYm9sLm1hdGNoQWxsAFN5bWJvbC5yZXBsYWNlAFN5bWJvbC5zZWFyY2gAU3ltYm9sLnNwbGl0AFN5bWJvbC50b1N0cmluZ1RhZwBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlAFN5bWJvbC5oYXNJbnN0YW5jZQBTeW1ib2wuc3BlY2llcwBTeW1ib2wudW5zY29wYWJsZXMAU3ltYm9sLmFzeW5jSXRlcmF0b3IAU3ltYm9sLm9wZXJhdG9yU2V0AEGAuAELtQgBAAAABQABFAUAARUFAAEVBQABFwUAARcBAAEAAQABAAEAAQABAAEAAQABAAEAAQACAAEFAwABCgEBAAABAgEAAQMCAAEBAgABAgMAAQIEAAEDBgABAgMAAQMEAAEEBQABAwMAAQQEAAEFBQABAgIAAQQEAAEDAwABAwMAAQQEAAEFBQADAgENAwEBDQMBAA0DAgENAwIADQMAAQ0DAwEKAQEAAAEAAAABAQIAAQAAAAECAgABAgAAAQEAAAEBAAAGAAAYBQEBDwMCAQoBAgEAAQEBAAEBAQAFAAEXBQABFwUAARcFAQAXBQEAFwUCABcBAgMAAQMAAAYAABgGAAAYBgEAGAUBARcFAQIXBQIAFwECAQABAwAAAQMBAAECAQABAgIAAQMAAAEDAQABBAAABQIBFwUBARcBAgIAAQIB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AAABADAAOgBB0IECCxEEADAAOgBBAFsAXwBgAGEAewBB8IECC8QLAQMFAQEBAQUFBQECAgMFBQEBAQICAwMFBQEFAREAAAAwmiAAAJowAHOBWgAwF2AAMAdsALOBbwAAF3AAAAd8AACBfwBAMIAAwwGYAJCBmABABpkAQJCcALSBpABALqUAMAG8AECGvABwgb8AAAHAADCBwABABMEAMAHDAECCwwAwgsQAQILFADABxwAwgccAMAHIAECCyAAwgckAMAHKAACBygAwAcsAMIHLAEACzAAAAc0AMAHOADCBzgAAAc8AMIHPAEAG0AAwAdMAQILTADCB1ABAAtYAMAHXAECC1wAwgtgAQITZADCB2wBAAtwAQALeAACB3wBQA+IAUIPjAFAD5QBAkOYAAIHuAEAS7wC0AfgAUIP4AEAC+gAwAfsAMIH7AEAo/AAwARABQBIRATEBHQFAgh0BMIEeATEBHwEBgh8BQIIgATCBIQEwASIBMIEiAUAKIwEBASgBAYEoAQEBKQEAgSkBAAEqAQACKwEAgSwBAIEtAQEBLgEAATABAYEwAQCBMQEBgTIBAQEzAQABNAEAgTQBAQE1AQGBNQEBATYBAIE3AQGBOAEAATkBAIE6AQGBPgEAAUABAQFBAQCBQQEBgUMBAAFEAQCBRAEAAkUBAAFGAQABSQEBgU4BAQFPAXOBogFABLgBQAK7AQCDvQEwgb8BMAHDATADxAEwAcYBMALHAdAByAEwkcgBMInRAQAB1gEAg9YB0wHYAQCR2AFzAeEBAInhAQAB5gEAguYBMIHnAXMB6AFzgegBc4HqAXMB6wEAgesBQBjsAXMB+AFzgfgBAAH5AQCB+QGgAfoBc4H6AUCC+wEwgfwBQAL9ATCD/gEwEAACMCAIAgAgGAIAECgCQCIwAkA2RQIwAWACQI5gAgCBZwJAYGgCMKaYAgCmsAK1gcMCMSZQCDGBYwgxgWYIACtoCACDfggRUNAJEAb4CSAG/Al0AUAOdIFADnQBQQ50gUEOdAFCDnSBQg50AUMOgIFDDoABRA4wK0gOMINeDgGBvA4Bgb4OAQHHDkB+AA9AGD8PtQFLD7aBSw+2AUwPtoFMD7cBTQ+AgU0PMAFPD0BgUA8ACIAPMAiEDwAGiA8wBowPAAiQDzAIlA8ACJgPMAicDwAGoA8wBqQPsAGoDwCBqA/T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iaCCsQARDAiAqCSBQOs4CYlgTyOAQuCPj48Rl4JAv4mkgEK8gEDhgECUhEEkiUVWEAyDpxOAQKSBQjwfiUFwgUCYikCugrSOnomOg6yKtIkqo42AiSGrgIuCr407gIvRiyhAn4uEiSu2CDEJgoiAiQkyhEC/kYiJGNCTi4lA1DGImoHRkI6J0IyHidKOg4lA8Y5ApInFKAkYAIGLifYxMoCbiacwH4CIiq2PQZQ4h4+Jt5WAjfkqAAgwB4mvIAgniUFIg2BLaIlAhYS6hpiJQ/QAtjPQgIqBYEyqgVTFIi85hp2DQJOCRYixQf+2g7E4jYCVII5FTzCQDgEEQQSGiIlBoY1F1YbsNIlSlYlsBQVA7wBBoKcCC6MS+gYAhAkA8AoAcAwA9A0AShAgGhggdBsg3SAADKgAWqogGv8ArQ4BOBIhwRUh5Rkhqh0hjNFBSuEh8AEOAAAAAEFkbGFtLEFkbG0AQWhvbSxBaG9tAEFuYXRvbGlhbl9IaWVyb2dseXBocyxIbHV3AEFyYWJpYyxBcmFiAEFybWVuaWFuLEFybW4AQXZlc3RhbixBdnN0AEJhbGluZXNlLEJhbGkAQmFtdW0sQmFtdQBCYXNzYV9WYWgsQmFzcwBCYXRhayxCYXRrAEJlbmdhbGksQmVuZwBCaGFpa3N1a2ksQmhrcwBCb3BvbW9mbyxCb3BvAEJyYWhtaSxCcmFoAEJyYWlsbGUsQnJhaQBCdWdpbmVzZSxCdWdpAEJ1aGlkLEJ1aGQAQ2FuYWRpYW5fQWJvcmlnaW5hbCxDYW5zAENhcmlhbixDYXJpAENhdWNhc2lhbl9BbGJhbmlhbixBZ2hiAENoYWttYSxDYWttAENoYW0sQ2hhbQBDaGVyb2tlZSxDaGVyAENob3Jhc21pYW4sQ2hycwBDb21tb24sWnl5eQBDb3B0aWMsQ29wdCxRYWFjAEN1bmVpZm9ybSxYc3V4AEN5cHJpb3QsQ3BydABDeXJpbGxpYyxDeXJsAERlc2VyZXQsRHNydABEZXZhbmFnYXJpLERldmEARGl2ZXNfQWt1cnUsRGlhawBEb2dyYSxEb2dyAER1cGxveWFuLER1cGwARWd5cHRpYW5fSGllcm9nbHlwaHMsRWd5cABFbGJhc2FuLEVsYmEARWx5bWFpYyxFbHltAEV0aGlvcGljLEV0aGkAR2VvcmdpYW4sR2VvcgBHbGFnb2xpdGljLEdsYWcAR290aGljLEdvdGgAR3JhbnRoYSxHcmFuAEdyZWVrLEdyZWsAR3VqYXJhdGksR3VqcgBHdW5qYWxhX0dvbmRpLEdvbmcAR3VybXVraGksR3VydQBIYW4sSGFuaQBIYW5ndWwsSGFuZwBIYW5pZmlfUm9oaW5neWEsUm9oZwBIYW51bm9vLEhhbm8ASGF0cmFuLEhhdHIASGVicmV3LEhlYnIASGlyYWdhbmEsSGlyYQBJbXBlcmlhbF9BcmFtYWljLEFybWkASW5oZXJpdGVkLFppbmgsUWFhaQBJbnNjcmlwdGlvbmFsX1BhaGxhdmksUGhsaQBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuLFBydGkASmF2YW5lc2UsSmF2YQBLYWl0aGksS3RoaQBLYW5uYWRhLEtuZGEAS2F0YWthbmEsS2FuYQBLYXlhaF9MaSxLYWxpAEtoYXJvc2h0aGksS2hhcgBLaG1lcixLaG1yAEtob2praSxLaG9qAEtoaXRhbl9TbWFsbF9TY3JpcHQsS2l0cwBLaHVkYXdhZGksU2luZABMYW8sTGFvbwBMYXRpbixMYXRuAExlcGNoYSxMZXBjAExpbWJ1LExpbWIATGluZWFyX0EsTGluYQBMaW5lYXJfQixMaW5iAExpc3UsTGlzdQBMeWNpYW4sTHljaQBMeWRpYW4sTHlkaQBNYWthc2FyLE1ha2EATWFoYWphbmksTWFoagBNYWxheWFsYW0sTWx5bQBNYW5kYWljLE1hbmQATWFuaWNoYWVhbixNYW5pAE1hcmNoZW4sTWFyYwBNYXNhcmFtX0dvbmRpLEdvbm0ATWVkZWZhaWRyaW4sTWVkZgBNZWV0ZWlfTWF5ZWssTXRlaQBNZW5kZV9LaWtha3VpLE1lbmQATWVyb2l0aWNfQ3Vyc2l2ZSxNZXJjAE1lcm9pdGljX0hpZXJvZ2x5cGhzLE1lcm8ATWlhbyxQbHJkAE1vZGksTW9kaQBNb25nb2xpYW4sTW9uZwBNcm8sTXJvbwBNdWx0YW5pLE11bHQATXlhbm1hcixNeW1yAE5hYmF0YWVhbixOYmF0AE5hbmRpbmFnYXJpLE5hbmQATmV3X1RhaV9MdWUsVGFsdQBOZXdhLE5ld2EATmtvLE5rb28ATnVzaHUsTnNodQBOeWlha2VuZ19QdWFjaHVlX0htb25nLEhtbnAAT2doYW0sT2dhbQBPbF9DaGlraSxPbGNrAE9sZF9IdW5nYXJpYW4sSHVuZwBPbGRfSXRhbGljLEl0YWwAT2xkX05vcnRoX0FyYWJpYW4sTmFyYgBPbGRfUGVybWljLFBlcm0AT2xkX1BlcnNpYW4sWHBlbwBPbGRfU29nZGlhbixTb2dvAE9sZF9Tb3V0aF9BcmFiaWFuLFNhcmIAT2xkX1R1cmtpYyxPcmtoAE9yaXlhLE9yeWEAT3NhZ2UsT3NnZQBPc21hbnlhLE9zbWEAUGFoYXdoX0htb25nLEhtbmcAUGFsbXlyZW5lLFBhbG0AUGF1X0Npbl9IYXUsUGF1YwBQaGFnc19QYSxQaGFnAFBob2VuaWNpYW4sUGhueABQc2FsdGVyX1BhaGxhdmksUGhscABSZWphbmcsUmpuZwBSdW5pYyxSdW5yAFNhbWFyaXRhbixTYW1yAFNhdXJhc2h0cmEsU2F1cgBTaGFyYWRhLFNocmQAU2hhdmlhbixTaGF3AFNpZGRoYW0sU2lkZABTaWduV3JpdGluZyxTZ253AFNpbmhhbGEsU2luaABTb2dkaWFuLFNvZ2QAU29yYV9Tb21wZW5nLFNvcmEAU295b21ibyxTb3lvAFN1bmRhbmVzZSxTdW5kAFN5bG90aV9OYWdyaSxTeWxvAFN5cmlhYyxTeXJjAFRhZ2Fsb2csVGdsZwBUYWdiYW53YSxUYWdiAFRhaV9MZSxUYWxlAFRhaV9UaGFtLExhbmEAVGFpX1ZpZXQsVGF2dABUYWtyaSxUYWtyAFRhbWlsLFRhbWwAVGFuZ3V0LFRhbmcAVGVsdWd1LFRlbHUAVGhhYW5hLFRoYWEAVGhhaSxUaGFpAFRpYmV0YW4sVGlidABUaWZpbmFnaCxUZm5nAFRpcmh1dGEsVGlyaABVZ2FyaXRpYyxVZ2FyAFZhaSxWYWlpAFdhbmNobyxXY2hvAFdhcmFuZ19DaXRpLFdhcmEAWWV6aWRpLFllemkAWWksWWlpaQBaYW5hYmF6YXJfU3F1YXJlLFphbmIAQdC5AguxFMAZmUWFGZlFrhmARY4ZgEWEGZZFgBmeRYAZ4WBFphmERYQZgQ2TGeAPN4MrgBmCKwGDK4AZgCsDgCuAGYArgBmCKwCAKwCT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ayxNb2RpZmllcl9TeW1ib2wAU28sT3RoZXJfU3ltYm9sAFBjLENvbm5lY3Rvcl9QdW5jdHVhdGlvbgBQZCxEYXNoX1B1bmN0dWF0aW9uAFBzLE9wZW5fUHVuY3R1YXRpb24AUGUsQ2xvc2VfUHVuY3R1YXRpb24AUGksSW5pdGlhbF9QdW5jdHVhdGlvbgBQZixGaW5hbF9QdW5jdHVhdGlvbgBQbyxPdGhlcl9QdW5jdHVhdGlvbgBacyxTcGFjZV9TZXBhcmF0b3IAWmwsTGluZV9TZXBhcmF0b3IAWnAsUGFyYWdyYXBoX1NlcGFyYXRvcgBDYyxDb250cm9sLGNudHJsAENmLEZvcm1hdABDcyxTdXJyb2dhdGUAQ28sUHJpdmF0ZV9Vc2UATEMsQ2FzZWRfTGV0dGVyAEwsTGV0dGVyAE0sTWFyayxDb21iaW5pbmdfTWFyawBOLE51bWJlcgBTLFN5bWJvbABQLFB1bmN0dWF0aW9uLHB1bmN0AFosU2VwYXJhdG9yAEMsT3RoZXIAQdDZAguwCA4AAAA+AAAAwAEAAAAOAAAA8AAAAAB/AAAAgAMBAAA8QVNDSUlfSGV4X0RpZ2l0LEFIZXgAQmlkaV9Db250cm9sLEJpZGlfQwBEYXNoAERlcHJlY2F0ZWQsRGVwAERpYWNyaXRpYyxEaWEARXh0ZW5kZXIsRXh0AEhleF9EaWdpdCxIZXgASURTX0JpbmFyeV9PcGVyYXRvcixJRFNCAElEU19UcmluYXJ5X09wZXJhdG9yLElEU1QASWRlb2dyYXBoaWMsSWRlbwBKb2luX0NvbnRyb2wsSm9pbl9DAExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uLExPRQBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCxOQ2hhcgBQYXR0ZXJuX1N5bnRheCxQYXRfU3luAFBhdHRlcm5fV2hpdGVfU3BhY2UsUGF0X1dTAFF1b3RhdGlvbl9NYXJrLFFNYXJrAFJhZGljYWwAUmVnaW9uYWxfSW5kaWNhdG9yLFJJAFNlbnRlbmNlX1Rlcm1pbmFsLFNUZXJtAFNvZnRfRG90dGVkLFNEAFRlcm1pbmFsX1B1bmN0dWF0aW9uLFRlcm0AVW5pZmllZF9JZGVvZ3JhcGgsVUlkZW8AVmFyaWF0aW9uX1NlbGVjdG9yLFZTAFdoaXRlX1NwYWNlLHNwYWNlAEJpZGlfTWlycm9yZWQsQmlkaV9NAEVtb2ppAEVtb2ppX0NvbXBvbmVudCxFQ29tcABFbW9qaV9Nb2RpZmllcixFTW9kAEVtb2ppX01vZGlmaWVyX0Jhc2UsRUJhc2UARW1vamlfUHJlc2VudGF0aW9uLEVQcmVzAEV4dGVuZGVkX1BpY3RvZ3JhcGhpYyxFeHRQaWN0AERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQsREkASURfU3RhcnQsSURTAENhc2VfSWdub3JhYmxlLENJAEFTQ0lJAEFscGhhYmV0aWMsQWxwaGEAQW55AEFzc2lnbmVkAENhc2VkAENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkLENXQ0YAQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQsQ1dDTQBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCxDV0wAQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCxDV0tDRgBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCxDV1QAQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQsQ1dVAEdyYXBoZW1lX0Jhc2UsR3JfQmFzZQBHcmFwaGVtZV9FeHRlbmQsR3JfRXh0AElEX0NvbnRpbnVlLElEQwBMb3dlcmNhc2UsTG93ZXIATWF0aABVcHBlcmNhc2UsVXBwZXIAWElEX0NvbnRpbnVlLFhJREMAWElEX1N0YXJ0LFhJRFMAQZDiAgu0IIEAKACXACoAgYAqAJfAKwAVgSwAlwAtAIFALQCXAC4AFUEuAJkBLwAWIDAAQghAAEKKRABCBEoAlgBMABeBTABCAk0AQkNOAC/BTwBCw1AAv0BSAEIDUwBCCVUAQghaAJYAXgBCQ14AgcBfAEIBaABCwWsAhQFxABfDcQBESHMARIN3AEKDeQC+AnsAl0F8AEIBfQBEBH4AQg6AAEKBhwBEh4kAgwSsABcDtgCDArgAFALQAJYA0QCAAN0Al4DeAICA3wCXAOEAPkHhAIDA4QC+BOIAroPqAK6C8gCtAfQALsH0AANB9QADA/wAgUD+AD4CAAG+wAEBvgEDAb5ABgG+QA4BPgIUAb7AFQG+ARcBRIEdAURBMAFEAjQBRIE1AUSDNgFEgzgBRIY6AUQBPgGFwGEB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SHpUSHq8AxMhbQATIWQAEyFrABMhZgBtbgBtvANtbQBtYwBtawBtYwAKCk8ACk9tALIAYwAICk8KClAAClBtALMAawBtALMAbQAVInMAbQAVInMAsgBQYWtQYU1QYUdQYXJhZHJhZNFzcgBhAGQAFSJzALIAcABzbgBzvANzbQBzcABWbgBWvANWbQBWawBWTQBWcABXbgBXvANXbQBXawBXTQBXawCpA00AqQNhLm0uQnFjY2NkQ9FrZ0NvLmRCR3loYUhQaW5LS0tNa3RsbWxubG9nbHhtYm1pbG1vbFBIcC5tLlBQTVBSc3JTdldiVtFtQdFtMQDlZTEAMADlZTIAMADlZTMAMADlZWdhbEoETAQmAVMBJ6c3q2sCUqtIjPRmyo7IjNFuMk7lU5yfnJ9RWdGRh1VIWfZhaXaFfz+Guof4iI+QAmobbdlw3nM9hGqR8ZmCTnVTBGsbci2GHp5QXetvzYVkicli2IEfiMpeF2dqbfxyzpCGT7dR3lLEZNNqEHLndgGABoZchu+NMpdvm/qdjHh/eaB9yYMEk3+e1orfWARfYHx+gGJyynjCjPeW2FhiXBNq2m0Pby99N35LltJSi4DcUcxRHHq+ffGDdZaAi89iAmr+ijlO51sSYIdzcHUXU/t4v0+pXw1OzGx4ZSJ9w1NeWAF3SYSqirprsI+IbP5i5YKgY2V1rk5pUclRgWjnfG+C0orPkfVSQlRzWexexWX+byp5rZVqmpeezp6bUsZmd2tij3RekGEAYppkI29JcYl0ynn0fW+AJo/uhCOQSpMXUqNSvVTIcMKIqorJXvVfe2Ouaz58dXPkTvlW51u6XRxgsnNpdJp/RoA0kvaWSJcYmItPrnm0kbiW4WCGTtpQ7ls/XJllAmrOcUJ2/IR8kI2fiGYulolSe2fzZ0FtnG4JdFl1a3gQfV6YbVEuYniWK1AZXeptKo+LX0RhF2iHc4aWKVIPVGVcE2ZOZ6ho5WwGdOJ1eX/PiOGIzJHilj9Tum4dVNBxmHT6haOWV5yfnpdny23ogct6IHuSfMBymXBYi8BONoM6UgdSpl7TYtZ8hVsebbRmO49MiE2Wi4nTXkBRwFUAAAAAWlgAAHRmAAAAAN5RKnPKdjx5XnlleY95Vpe+fL1/AAAShgAA+IoAAAAAOJD9kO+Y/JgombSd3pC3lq5P51BNUclS5FJR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";
        if (!R2.startsWith(Q2)) {
          var fa = R2;
          R2 = a2.locateFile ? a2.locateFile(fa, x2) : x2 + fa;
        }
        function ha(b2) {
          try {
            if (b2 == R2 && E2)
              return new Uint8Array(E2);
            var c2 = C2(b2);
            if (c2)
              return c2;
            if (A2)
              return A2(b2);
            throw "both async and sync fetching of the wasm failed";
          } catch (d2) {
            F2(d2);
          }
        }
        function ia(b2) {
          if (!E2 && (u2 || v2)) {
            if ("function" == typeof fetch && !b2.startsWith("file://"))
              return fetch(b2, { credentials: "same-origin" }).then(function(c2) {
                if (!c2.ok)
                  throw "failed to load wasm binary file at '" + b2 + "'";
                return c2.arrayBuffer();
              }).catch(function() {
                return ha(b2);
              });
            if (z2)
              return new Promise(function(c2, d2) {
                z2(b2, function(e2) {
                  c2(new Uint8Array(e2));
                }, d2);
              });
          }
          return Promise.resolve().then(function() {
            return ha(b2);
          });
        }
        function ja(b2, c2, d2) {
          return ia(b2).then(function(e2) {
            return WebAssembly.instantiate(e2, c2);
          }).then(function(e2) {
            return e2;
          }).then(d2, function(e2) {
            D2("failed to asynchronously prepare wasm: " + e2);
            F2(e2);
          });
        }
        function ka(b2, c2) {
          var d2 = R2;
          return E2 || "function" != typeof WebAssembly.instantiateStreaming || d2.startsWith(Q2) || d2.startsWith("file://") || w2 || "function" != typeof fetch ? ja(d2, b2, c2) : fetch(d2, { credentials: "same-origin" }).then(function(e2) {
            return WebAssembly.instantiateStreaming(e2, b2).then(c2, function(f2) {
              D2("wasm streaming compile failed: " + f2);
              D2("falling back to ArrayBuffer instantiation");
              return ja(d2, b2, c2);
            });
          });
        }
        function S2(b2) {
          for (; 0 < b2.length; )
            b2.shift()(a2);
        }
        var la = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function na(b2, c2, d2) {
          var e2 = c2 + d2;
          for (d2 = c2; b2[d2] && !(d2 >= e2); )
            ++d2;
          if (16 < d2 - c2 && b2.buffer && la)
            return la.decode(b2.subarray(c2, d2));
          for (e2 = ""; c2 < d2; ) {
            var f2 = b2[c2++];
            if (f2 & 128) {
              var g2 = b2[c2++] & 63;
              if (192 == (f2 & 224))
                e2 += String.fromCharCode((f2 & 31) << 6 | g2);
              else {
                var h2 = b2[c2++] & 63;
                f2 = 224 == (f2 & 240) ? (f2 & 15) << 12 | g2 << 6 | h2 : (f2 & 7) << 18 | g2 << 12 | h2 << 6 | b2[c2++] & 63;
                65536 > f2 ? e2 += String.fromCharCode(f2) : (f2 -= 65536, e2 += String.fromCharCode(55296 | f2 >> 10, 56320 | f2 & 1023));
              }
            } else
              e2 += String.fromCharCode(f2);
          }
          return e2;
        }
        function T2(b2, c2) {
          return b2 ? na(J2, b2, c2) : "";
        }
        var oa = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], pa = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        function U2(b2) {
          for (var c2 = 0, d2 = 0; d2 < b2.length; ++d2) {
            var e2 = b2.charCodeAt(d2);
            127 >= e2 ? c2++ : 2047 >= e2 ? c2 += 2 : 55296 <= e2 && 57343 >= e2 ? (c2 += 4, ++d2) : c2 += 3;
          }
          return c2;
        }
        function V2(b2, c2, d2) {
          var e2 = J2;
          if (!(0 < d2))
            return 0;
          var f2 = c2;
          d2 = c2 + d2 - 1;
          for (var g2 = 0; g2 < b2.length; ++g2) {
            var h2 = b2.charCodeAt(g2);
            if (55296 <= h2 && 57343 >= h2) {
              var k2 = b2.charCodeAt(++g2);
              h2 = 65536 + ((h2 & 1023) << 10) | k2 & 1023;
            }
            if (127 >= h2) {
              if (c2 >= d2)
                break;
              e2[c2++] = h2;
            } else {
              if (2047 >= h2) {
                if (c2 + 1 >= d2)
                  break;
                e2[c2++] = 192 | h2 >> 6;
              } else {
                if (65535 >= h2) {
                  if (c2 + 2 >= d2)
                    break;
                  e2[c2++] = 224 | h2 >> 12;
                } else {
                  if (c2 + 3 >= d2)
                    break;
                  e2[c2++] = 240 | h2 >> 18;
                  e2[c2++] = 128 | h2 >> 12 & 63;
                }
                e2[c2++] = 128 | h2 >> 6 & 63;
              }
              e2[c2++] = 128 | h2 & 63;
            }
          }
          e2[c2] = 0;
          return c2 - f2;
        }
        function qa(b2) {
          var c2 = U2(b2) + 1, d2 = ra(c2);
          d2 && V2(b2, d2, c2);
          return d2;
        }
        var W2 = {};
        function sa() {
          if (!X2) {
            var b2 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: t2 || "./this.program" }, c2;
            for (c2 in W2)
              void 0 === W2[c2] ? delete b2[c2] : b2[c2] = W2[c2];
            var d2 = [];
            for (c2 in b2)
              d2.push(c2 + "=" + b2[c2]);
            X2 = d2;
          }
          return X2;
        }
        var X2, ta = [null, [], []];
        function ua(b2, c2, d2, e2) {
          var f2 = { string: (l2) => {
            var q2 = 0;
            if (null !== l2 && void 0 !== l2 && 0 !== l2) {
              q2 = U2(l2) + 1;
              var ma = Y2(q2);
              V2(l2, ma, q2);
              q2 = ma;
            }
            return q2;
          }, array: (l2) => {
            var q2 = Y2(l2.length);
            I2.set(l2, q2);
            return q2;
          } };
          b2 = a2["_" + b2];
          var g2 = [], h2 = 0;
          if (e2)
            for (var k2 = 0; k2 < e2.length; k2++) {
              var r2 = f2[d2[k2]];
              r2 ? (0 === h2 && (h2 = va()), g2[k2] = r2(e2[k2])) : g2[k2] = e2[k2];
            }
          d2 = b2.apply(null, g2);
          return d2 = function(l2) {
            0 !== h2 && wa(h2);
            return "string" === c2 ? T2(l2) : "boolean" === c2 ? !!l2 : l2;
          }(d2);
        }
        var xa = "function" == typeof atob ? atob : function(b2) {
          var c2 = "", d2 = 0;
          b2 = b2.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b2.charAt(d2++));
            var f2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b2.charAt(d2++));
            var g2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b2.charAt(d2++));
            var h2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b2.charAt(d2++));
            e2 = e2 << 2 | f2 >> 4;
            f2 = (f2 & 15) << 4 | g2 >> 2;
            var k2 = (g2 & 3) << 6 | h2;
            c2 += String.fromCharCode(e2);
            64 !== g2 && (c2 += String.fromCharCode(f2));
            64 !== h2 && (c2 += String.fromCharCode(k2));
          } while (d2 < b2.length);
          return c2;
        };
        function C2(b2) {
          if (b2.startsWith(Q2)) {
            b2 = b2.slice(Q2.length);
            if ("boolean" == typeof w2 && w2) {
              var c2 = Buffer.from(b2, "base64");
              c2 = new Uint8Array(c2.buffer, c2.byteOffset, c2.byteLength);
            } else
              try {
                var d2 = xa(b2), e2 = new Uint8Array(d2.length);
                for (b2 = 0; b2 < d2.length; ++b2)
                  e2[b2] = d2.charCodeAt(b2);
                c2 = e2;
              } catch (f2) {
                throw Error("Converting base64 string to bytes failed.");
              }
            return c2;
          }
        }
        var ya = {
          a: function(b2, c2, d2, e2) {
            F2("Assertion failed: " + T2(b2) + ", at: " + [c2 ? T2(c2) : "unknown filename", d2, e2 ? T2(e2) : "unknown function"]);
          },
          l: function(b2, c2) {
            b2 = new Date(1e3 * (L2[b2 >> 2] + 4294967296 * K2[b2 + 4 >> 2]));
            K2[c2 >> 2] = b2.getSeconds();
            K2[c2 + 4 >> 2] = b2.getMinutes();
            K2[c2 + 8 >> 2] = b2.getHours();
            K2[c2 + 12 >> 2] = b2.getDate();
            K2[c2 + 16 >> 2] = b2.getMonth();
            K2[c2 + 20 >> 2] = b2.getFullYear() - 1900;
            K2[c2 + 24 >> 2] = b2.getDay();
            var d2 = b2.getFullYear();
            K2[c2 + 28 >> 2] = (0 !== d2 % 4 || 0 === d2 % 100 && 0 !== d2 % 400 ? pa : oa)[b2.getMonth()] + b2.getDate() - 1 | 0;
            K2[c2 + 36 >> 2] = -(60 * b2.getTimezoneOffset());
            d2 = new Date(b2.getFullYear(), 6, 1).getTimezoneOffset();
            var e2 = new Date(b2.getFullYear(), 0, 1).getTimezoneOffset();
            K2[c2 + 32 >> 2] = (d2 != e2 && b2.getTimezoneOffset() == Math.min(e2, d2)) | 0;
          },
          k: function(b2, c2, d2) {
            function e2(r2) {
              return (r2 = r2.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? r2[1] : "GMT";
            }
            var f2 = (/* @__PURE__ */ new Date()).getFullYear(), g2 = new Date(f2, 0, 1), h2 = new Date(f2, 6, 1);
            f2 = g2.getTimezoneOffset();
            var k2 = h2.getTimezoneOffset();
            L2[b2 >> 2] = 60 * Math.max(f2, k2);
            K2[c2 >> 2] = Number(f2 != k2);
            b2 = e2(g2);
            c2 = e2(h2);
            b2 = qa(b2);
            c2 = qa(c2);
            k2 < f2 ? (L2[d2 >> 2] = b2, L2[d2 + 4 >> 2] = c2) : (L2[d2 >> 2] = c2, L2[d2 + 4 >> 2] = b2);
          },
          b: function() {
            F2("");
          },
          m: function() {
            return Date.now();
          },
          j: function(b2) {
            var c2 = J2.length;
            b2 >>>= 0;
            if (2147483648 < b2)
              return false;
            for (var d2 = 1; 4 >= d2; d2 *= 2) {
              var e2 = c2 * (1 + 0.2 / d2);
              e2 = Math.min(e2, b2 + 100663296);
              var f2 = Math, g2 = f2.min;
              e2 = Math.max(b2, e2);
              e2 += (65536 - e2 % 65536) % 65536;
              a: {
                var h2 = G2.buffer;
                try {
                  G2.grow(g2.call(f2, 2147483648, e2) - h2.byteLength + 65535 >>> 16);
                  M2();
                  var k2 = 1;
                  break a;
                } catch (r2) {
                }
                k2 = void 0;
              }
              if (k2)
                return true;
            }
            return false;
          },
          e: function(b2, c2) {
            var d2 = 0;
            sa().forEach(function(e2, f2) {
              var g2 = c2 + d2;
              f2 = L2[b2 + 4 * f2 >> 2] = g2;
              for (g2 = 0; g2 < e2.length; ++g2)
                I2[f2++ >> 0] = e2.charCodeAt(g2);
              I2[f2 >> 0] = 0;
              d2 += e2.length + 1;
            });
            return 0;
          },
          f: function(b2, c2) {
            var d2 = sa();
            L2[b2 >> 2] = d2.length;
            var e2 = 0;
            d2.forEach(function(f2) {
              e2 += f2.length + 1;
            });
            L2[c2 >> 2] = e2;
            return 0;
          },
          d: function() {
            return 52;
          },
          i: function() {
            return 70;
          },
          c: function(b2, c2, d2, e2) {
            for (var f2 = 0, g2 = 0; g2 < d2; g2++) {
              var h2 = L2[c2 >> 2], k2 = L2[c2 + 4 >> 2];
              c2 += 8;
              for (var r2 = 0; r2 < k2; r2++) {
                var l2 = J2[h2 + r2], q2 = ta[b2];
                0 === l2 || 10 === l2 ? ((1 === b2 ? aa : D2)(na(q2, 0)), q2.length = 0) : q2.push(l2);
              }
              f2 += k2;
            }
            L2[e2 >> 2] = f2;
            return 0;
          },
          o: function(b2, c2, d2, e2, f2) {
            return a2.callbacks.callFunction(void 0, b2, c2, d2, e2, f2);
          },
          n: function(b2) {
            return a2.callbacks.shouldInterrupt(void 0, b2);
          },
          h: function(b2, c2, d2) {
            d2 = T2(d2);
            return a2.callbacks.loadModuleSource(void 0, b2, c2, d2);
          },
          g: function(b2, c2, d2, e2) {
            d2 = T2(d2);
            e2 = T2(e2);
            return a2.callbacks.normalizeModule(void 0, b2, c2, d2, e2);
          }
        };
        (function() {
          function b2(d2) {
            d2 = d2.exports;
            a2.asm = d2;
            G2 = a2.asm.p;
            M2();
            ca.unshift(a2.asm.q);
            N2--;
            a2.monitorRunDependencies && a2.monitorRunDependencies(N2);
            if (0 == N2 && P2) {
              var e2 = P2;
              P2 = null;
              e2();
            }
            return d2;
          }
          var c2 = { a: ya };
          N2++;
          a2.monitorRunDependencies && a2.monitorRunDependencies(N2);
          if (a2.instantiateWasm)
            try {
              return a2.instantiateWasm(c2, b2);
            } catch (d2) {
              D2("Module.instantiateWasm callback failed with error: " + d2), n2(d2);
            }
          ka(c2, function(d2) {
            b2(d2.instance);
          }).catch(n2);
          return {};
        })();
        var ra = a2._malloc = function() {
          return (ra = a2._malloc = a2.asm.r).apply(null, arguments);
        };
        a2._QTS_Throw = function() {
          return (a2._QTS_Throw = a2.asm.s).apply(null, arguments);
        };
        a2._QTS_NewError = function() {
          return (a2._QTS_NewError = a2.asm.t).apply(null, arguments);
        };
        a2._QTS_RuntimeSetMemoryLimit = function() {
          return (a2._QTS_RuntimeSetMemoryLimit = a2.asm.u).apply(null, arguments);
        };
        a2._QTS_RuntimeComputeMemoryUsage = function() {
          return (a2._QTS_RuntimeComputeMemoryUsage = a2.asm.v).apply(null, arguments);
        };
        a2._QTS_RuntimeDumpMemoryUsage = function() {
          return (a2._QTS_RuntimeDumpMemoryUsage = a2.asm.w).apply(null, arguments);
        };
        a2._QTS_RecoverableLeakCheck = function() {
          return (a2._QTS_RecoverableLeakCheck = a2.asm.x).apply(null, arguments);
        };
        a2._QTS_BuildIsSanitizeLeak = function() {
          return (a2._QTS_BuildIsSanitizeLeak = a2.asm.y).apply(null, arguments);
        };
        a2._QTS_RuntimeSetMaxStackSize = function() {
          return (a2._QTS_RuntimeSetMaxStackSize = a2.asm.z).apply(null, arguments);
        };
        a2._QTS_GetUndefined = function() {
          return (a2._QTS_GetUndefined = a2.asm.A).apply(null, arguments);
        };
        a2._QTS_GetNull = function() {
          return (a2._QTS_GetNull = a2.asm.B).apply(null, arguments);
        };
        a2._QTS_GetFalse = function() {
          return (a2._QTS_GetFalse = a2.asm.C).apply(null, arguments);
        };
        a2._QTS_GetTrue = function() {
          return (a2._QTS_GetTrue = a2.asm.D).apply(null, arguments);
        };
        a2._QTS_NewRuntime = function() {
          return (a2._QTS_NewRuntime = a2.asm.E).apply(null, arguments);
        };
        a2._QTS_FreeRuntime = function() {
          return (a2._QTS_FreeRuntime = a2.asm.F).apply(null, arguments);
        };
        a2._QTS_NewContext = function() {
          return (a2._QTS_NewContext = a2.asm.G).apply(null, arguments);
        };
        a2._QTS_FreeContext = function() {
          return (a2._QTS_FreeContext = a2.asm.H).apply(null, arguments);
        };
        a2._QTS_FreeValuePointer = function() {
          return (a2._QTS_FreeValuePointer = a2.asm.I).apply(null, arguments);
        };
        a2._free = function() {
          return (a2._free = a2.asm.J).apply(null, arguments);
        };
        a2._QTS_FreeValuePointerRuntime = function() {
          return (a2._QTS_FreeValuePointerRuntime = a2.asm.K).apply(null, arguments);
        };
        a2._QTS_FreeVoidPointer = function() {
          return (a2._QTS_FreeVoidPointer = a2.asm.L).apply(null, arguments);
        };
        a2._QTS_FreeCString = function() {
          return (a2._QTS_FreeCString = a2.asm.M).apply(null, arguments);
        };
        a2._QTS_DupValuePointer = function() {
          return (a2._QTS_DupValuePointer = a2.asm.N).apply(null, arguments);
        };
        a2._QTS_NewObject = function() {
          return (a2._QTS_NewObject = a2.asm.O).apply(null, arguments);
        };
        a2._QTS_NewObjectProto = function() {
          return (a2._QTS_NewObjectProto = a2.asm.P).apply(null, arguments);
        };
        a2._QTS_NewArray = function() {
          return (a2._QTS_NewArray = a2.asm.Q).apply(null, arguments);
        };
        a2._QTS_NewFloat64 = function() {
          return (a2._QTS_NewFloat64 = a2.asm.R).apply(null, arguments);
        };
        a2._QTS_GetFloat64 = function() {
          return (a2._QTS_GetFloat64 = a2.asm.S).apply(null, arguments);
        };
        a2._QTS_NewString = function() {
          return (a2._QTS_NewString = a2.asm.T).apply(null, arguments);
        };
        a2._QTS_GetString = function() {
          return (a2._QTS_GetString = a2.asm.U).apply(null, arguments);
        };
        a2._QTS_NewSymbol = function() {
          return (a2._QTS_NewSymbol = a2.asm.V).apply(null, arguments);
        };
        a2._QTS_GetSymbolDescriptionOrKey = function() {
          return (a2._QTS_GetSymbolDescriptionOrKey = a2.asm.W).apply(null, arguments);
        };
        a2._QTS_IsGlobalSymbol = function() {
          return (a2._QTS_IsGlobalSymbol = a2.asm.X).apply(null, arguments);
        };
        a2._QTS_IsJobPending = function() {
          return (a2._QTS_IsJobPending = a2.asm.Y).apply(null, arguments);
        };
        a2._QTS_ExecutePendingJob = function() {
          return (a2._QTS_ExecutePendingJob = a2.asm.Z).apply(null, arguments);
        };
        a2._QTS_GetProp = function() {
          return (a2._QTS_GetProp = a2.asm._).apply(null, arguments);
        };
        a2._QTS_SetProp = function() {
          return (a2._QTS_SetProp = a2.asm.$).apply(null, arguments);
        };
        a2._QTS_DefineProp = function() {
          return (a2._QTS_DefineProp = a2.asm.aa).apply(null, arguments);
        };
        a2._QTS_Call = function() {
          return (a2._QTS_Call = a2.asm.ba).apply(null, arguments);
        };
        a2._QTS_ResolveException = function() {
          return (a2._QTS_ResolveException = a2.asm.ca).apply(null, arguments);
        };
        a2._QTS_Dump = function() {
          return (a2._QTS_Dump = a2.asm.da).apply(null, arguments);
        };
        a2._QTS_Eval = function() {
          return (a2._QTS_Eval = a2.asm.ea).apply(null, arguments);
        };
        a2._QTS_Typeof = function() {
          return (a2._QTS_Typeof = a2.asm.fa).apply(null, arguments);
        };
        a2._QTS_GetGlobalObject = function() {
          return (a2._QTS_GetGlobalObject = a2.asm.ga).apply(null, arguments);
        };
        a2._QTS_NewPromiseCapability = function() {
          return (a2._QTS_NewPromiseCapability = a2.asm.ha).apply(null, arguments);
        };
        a2._QTS_TestStringArg = function() {
          return (a2._QTS_TestStringArg = a2.asm.ia).apply(null, arguments);
        };
        a2._QTS_BuildIsDebug = function() {
          return (a2._QTS_BuildIsDebug = a2.asm.ja).apply(null, arguments);
        };
        a2._QTS_BuildIsAsyncify = function() {
          return (a2._QTS_BuildIsAsyncify = a2.asm.ka).apply(null, arguments);
        };
        a2._QTS_NewFunction = function() {
          return (a2._QTS_NewFunction = a2.asm.la).apply(null, arguments);
        };
        a2._QTS_ArgvGetJSValueConstPointer = function() {
          return (a2._QTS_ArgvGetJSValueConstPointer = a2.asm.ma).apply(null, arguments);
        };
        a2._QTS_RuntimeEnableInterruptHandler = function() {
          return (a2._QTS_RuntimeEnableInterruptHandler = a2.asm.na).apply(null, arguments);
        };
        a2._QTS_RuntimeDisableInterruptHandler = function() {
          return (a2._QTS_RuntimeDisableInterruptHandler = a2.asm.oa).apply(null, arguments);
        };
        a2._QTS_RuntimeEnableModuleLoader = function() {
          return (a2._QTS_RuntimeEnableModuleLoader = a2.asm.pa).apply(null, arguments);
        };
        a2._QTS_RuntimeDisableModuleLoader = function() {
          return (a2._QTS_RuntimeDisableModuleLoader = a2.asm.qa).apply(null, arguments);
        };
        function va() {
          return (va = a2.asm.sa).apply(null, arguments);
        }
        function wa() {
          return (wa = a2.asm.ta).apply(null, arguments);
        }
        function Y2() {
          return (Y2 = a2.asm.ua).apply(null, arguments);
        }
        a2.___start_em_js = 74916;
        a2.___stop_em_js = 75818;
        a2.cwrap = function(b2, c2, d2, e2) {
          var f2 = !d2 || d2.every((g2) => "number" === g2 || "boolean" === g2);
          return "string" !== c2 && f2 && !e2 ? a2["_" + b2] : function() {
            return ua(b2, c2, d2, arguments);
          };
        };
        a2.UTF8ToString = T2;
        a2.stringToUTF8 = function(b2, c2, d2) {
          return V2(b2, c2, d2);
        };
        a2.lengthBytesUTF8 = U2;
        var Z2;
        P2 = function za() {
          Z2 || Aa();
          Z2 || (P2 = za);
        };
        function Aa() {
          function b2() {
            if (!Z2 && (Z2 = true, a2.calledRun = true, !H2)) {
              S2(ca);
              m2(a2);
              if (a2.onRuntimeInitialized)
                a2.onRuntimeInitialized();
              if (a2.postRun)
                for ("function" == typeof a2.postRun && (a2.postRun = [a2.postRun]); a2.postRun.length; ) {
                  var c2 = a2.postRun.shift();
                  da.unshift(c2);
                }
              S2(da);
            }
          }
          if (!(0 < N2)) {
            if (a2.preRun)
              for ("function" == typeof a2.preRun && (a2.preRun = [a2.preRun]); a2.preRun.length; )
                ea();
            S2(ba);
            0 < N2 || (a2.setStatus ? (a2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                a2.setStatus("");
              }, 1);
              b2();
            }, 1)) : b2());
          }
        }
        if (a2.preInit)
          for ("function" == typeof a2.preInit && (a2.preInit = [a2.preInit]); 0 < a2.preInit.length; )
            a2.preInit.pop()();
        Aa();
        return QuickJSRaw2.ready;
      };
    })();
    module2.exports = QuickJSRaw;
  })(emscriptenModule_WASM_RELEASE_SYNC);
  return emscriptenModule_WASM_RELEASE_SYNC.exports;
}
var hasRequiredVariants;
function requireVariants() {
  if (hasRequiredVariants)
    return variants;
  hasRequiredVariants = 1;
  (function(exports2) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RELEASE_ASYNC = exports2.DEBUG_ASYNC = exports2.RELEASE_SYNC = exports2.DEBUG_SYNC = exports2.memoizePromiseFactory = exports2.newQuickJSAsyncWASMModule = exports2.newQuickJSWASMModule = void 0;
    const esmHelpers_1 = esmHelpers;
    async function newQuickJSWASMModule(variant = exports2.RELEASE_SYNC) {
      const [wasmModuleLoader, QuickJSFFI, { QuickJSWASMModule }] = await Promise.all([
        variant.importModuleLoader(),
        variant.importFFI(),
        Promise.resolve().then(() => __importStar2(requireModule())).then(esmHelpers_1.unwrapTypescript)
      ]);
      const wasmModule = await wasmModuleLoader();
      wasmModule.type = "sync";
      const ffi = new QuickJSFFI(wasmModule);
      return new QuickJSWASMModule(wasmModule, ffi);
    }
    exports2.newQuickJSWASMModule = newQuickJSWASMModule;
    async function newQuickJSAsyncWASMModule(variant = exports2.RELEASE_ASYNC) {
      const [wasmModuleLoader, QuickJSAsyncFFI, { QuickJSAsyncWASMModule }] = await Promise.all([
        variant.importModuleLoader(),
        variant.importFFI(),
        Promise.resolve().then(() => __importStar2(requireModuleAsyncify())).then(esmHelpers_1.unwrapTypescript)
      ]);
      const wasmModule = await wasmModuleLoader();
      wasmModule.type = "async";
      const ffi = new QuickJSAsyncFFI(wasmModule);
      return new QuickJSAsyncWASMModule(wasmModule, ffi);
    }
    exports2.newQuickJSAsyncWASMModule = newQuickJSAsyncWASMModule;
    function memoizePromiseFactory(fn) {
      let promise;
      return () => {
        return promise ?? (promise = fn());
      };
    }
    exports2.memoizePromiseFactory = memoizePromiseFactory;
    exports2.DEBUG_SYNC = {
      type: "sync",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    };
    exports2.RELEASE_SYNC = {
      type: "sync",
      async importFFI() {
        const mod = await Promise.resolve().then(() => __importStar2(requireFfi_WASM_RELEASE_SYNC()));
        return (0, esmHelpers_1.unwrapTypescript)(mod).QuickJSFFI;
      },
      async importModuleLoader() {
        const mod = await Promise.resolve().then(() => __importStar2(requireEmscriptenModule_WASM_RELEASE_SYNC()));
        return (0, esmHelpers_1.unwrapJavascript)(mod);
      }
    };
    exports2.DEBUG_ASYNC = {
      type: "async",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    };
    exports2.RELEASE_ASYNC = {
      type: "async",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    };
  })(variants);
  return variants;
}
var vmInterface = {};
Object.defineProperty(vmInterface, "__esModule", { value: true });
vmInterface.isFail = vmInterface.isSuccess = void 0;
function isSuccess(successOrFail) {
  return "error" in successOrFail === false;
}
vmInterface.isSuccess = isSuccess;
function isFail(successOrFail) {
  return "error" in successOrFail === true;
}
vmInterface.isFail = isFail;
var moduleTest = {};
Object.defineProperty(moduleTest, "__esModule", { value: true });
moduleTest.TestQuickJSWASMModule = void 0;
const errors_1 = errors;
const lifetime_1 = lifetime;
class TestQuickJSWASMModule {
  constructor(parent) {
    this.parent = parent;
    this.contexts = /* @__PURE__ */ new Set();
    this.runtimes = /* @__PURE__ */ new Set();
  }
  newRuntime(options) {
    const runtime2 = this.parent.newRuntime({
      ...options,
      ownedLifetimes: [
        new lifetime_1.Lifetime(void 0, void 0, () => this.runtimes.delete(runtime2)),
        ...(options == null ? void 0 : options.ownedLifetimes) ?? []
      ]
    });
    this.runtimes.add(runtime2);
    return runtime2;
  }
  newContext(options) {
    const context2 = this.parent.newContext({
      ...options,
      ownedLifetimes: [
        new lifetime_1.Lifetime(void 0, void 0, () => this.contexts.delete(context2)),
        ...(options == null ? void 0 : options.ownedLifetimes) ?? []
      ]
    });
    this.contexts.add(context2);
    return context2;
  }
  evalCode(code2, options) {
    return this.parent.evalCode(code2, options);
  }
  disposeAll() {
    const allDisposables = [...this.contexts, ...this.runtimes];
    this.runtimes.clear();
    this.contexts.clear();
    allDisposables.forEach((d2) => {
      if (d2.alive) {
        d2.dispose();
      }
    });
  }
  assertNoMemoryAllocated() {
    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck();
    if (leaksDetected) {
      throw new errors_1.QuickJSMemoryLeakDetected("Leak sanitizer detected un-freed memory");
    }
    if (this.contexts.size > 0) {
      throw new errors_1.QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`);
    }
    if (this.runtimes.size > 0) {
      throw new errors_1.QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`);
    }
  }
  /** @private */
  getFFI() {
    return this.parent.getFFI();
  }
}
moduleTest.TestQuickJSWASMModule = TestQuickJSWASMModule;
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist)
    return dist$2;
  hasRequiredDist = 1;
  (function(exports2) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
          __createBinding2(exports3, m2, p2);
    };
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldInterruptAfterDeadline = exports2.newAsyncContext = exports2.newAsyncRuntime = exports2.getQuickJSSync = exports2.getQuickJS = exports2.errors = exports2.RELEASE_SYNC = exports2.RELEASE_ASYNC = exports2.DEBUG_SYNC = exports2.DEBUG_ASYNC = exports2.newQuickJSAsyncWASMModule = exports2.newQuickJSWASMModule = void 0;
    const variants_1 = requireVariants();
    Object.defineProperty(exports2, "newQuickJSWASMModule", { enumerable: true, get: function() {
      return variants_1.newQuickJSWASMModule;
    } });
    Object.defineProperty(exports2, "newQuickJSAsyncWASMModule", { enumerable: true, get: function() {
      return variants_1.newQuickJSAsyncWASMModule;
    } });
    Object.defineProperty(exports2, "DEBUG_ASYNC", { enumerable: true, get: function() {
      return variants_1.DEBUG_ASYNC;
    } });
    Object.defineProperty(exports2, "DEBUG_SYNC", { enumerable: true, get: function() {
      return variants_1.DEBUG_SYNC;
    } });
    Object.defineProperty(exports2, "RELEASE_ASYNC", { enumerable: true, get: function() {
      return variants_1.RELEASE_ASYNC;
    } });
    Object.defineProperty(exports2, "RELEASE_SYNC", { enumerable: true, get: function() {
      return variants_1.RELEASE_SYNC;
    } });
    __exportStar2(vmInterface, exports2);
    __exportStar2(lifetime, exports2);
    exports2.errors = __importStar2(errors);
    __exportStar2(deferredPromise, exports2);
    __exportStar2(moduleTest, exports2);
    let singleton = void 0;
    let singletonPromise = void 0;
    async function getQuickJS() {
      singletonPromise ?? (singletonPromise = (0, variants_1.newQuickJSWASMModule)().then((instance) => {
        singleton = instance;
        return instance;
      }));
      return await singletonPromise;
    }
    exports2.getQuickJS = getQuickJS;
    function getQuickJSSync() {
      if (!singleton) {
        throw new Error("QuickJS not initialized. Await getQuickJS() at least once.");
      }
      return singleton;
    }
    exports2.getQuickJSSync = getQuickJSSync;
    async function newAsyncRuntime(options) {
      const module2 = await (0, variants_1.newQuickJSAsyncWASMModule)();
      return module2.newRuntime(options);
    }
    exports2.newAsyncRuntime = newAsyncRuntime;
    async function newAsyncContext(options) {
      const module2 = await (0, variants_1.newQuickJSAsyncWASMModule)();
      return module2.newContext(options);
    }
    exports2.newAsyncContext = newAsyncContext;
    function shouldInterruptAfterDeadline(deadline) {
      const deadlineAsNumber = typeof deadline === "number" ? deadline : deadline.getTime();
      return function() {
        return Date.now() > deadlineAsNumber;
      };
    }
    exports2.shouldInterruptAfterDeadline = shouldInterruptAfterDeadline;
  })(dist$2);
  return dist$2;
}
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$2(result, mod, k2);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$d, "__esModule", { value: true });
dist$d.PacProxyAgent = void 0;
const net$2 = __importStar$2(require$$0$1);
const tls$2 = __importStar$2(require$$1$1);
const crypto$1 = __importStar$2(require$$2$1);
const events_1$1 = require$$3$2;
const debug_1$3 = __importDefault$3(srcExports);
const url_1$2 = require$$5$1;
const agent_base_1$2 = dist$c;
const http_proxy_agent_1 = dist$b;
const https_proxy_agent_1 = dist$a;
const socks_proxy_agent_1 = dist$9;
const get_uri_1 = dist$7;
const pac_resolver_1 = dist$4;
const quickjs_emscripten_1 = requireDist();
const debug$3 = (0, debug_1$3.default)("pac-proxy-agent");
class PacProxyAgent extends agent_base_1$2.Agent {
  constructor(uri, opts) {
    super(opts);
    this.clearResolverPromise = () => {
      this.resolverPromise = void 0;
    };
    const uriStr = typeof uri === "string" ? uri : uri.href;
    this.uri = new url_1$2.URL(uriStr.replace(/^pac\+/i, ""));
    debug$3("Creating PacProxyAgent with URI %o", this.uri.href);
    this.opts = { ...opts };
    this.cache = void 0;
    this.resolver = void 0;
    this.resolverHash = "";
    this.resolverPromise = void 0;
    if (!this.opts.filename) {
      this.opts.filename = this.uri.href;
    }
  }
  /**
   * Loads the PAC proxy file from the source if necessary, and returns
   * a generated `FindProxyForURL()` resolver function to use.
   *
   * @api private
   */
  getResolver() {
    if (!this.resolverPromise) {
      this.resolverPromise = this.loadResolver();
      this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);
    }
    return this.resolverPromise;
  }
  async loadResolver() {
    try {
      const [qjs, code2] = await Promise.all([
        (0, quickjs_emscripten_1.getQuickJS)(),
        this.loadPacFile()
      ]);
      const hash = crypto$1.createHash("sha1").update(code2).digest("hex");
      if (this.resolver && this.resolverHash === hash) {
        debug$3("Same sha1 hash for code - contents have not changed, reusing previous proxy resolver");
        return this.resolver;
      }
      debug$3("Creating new proxy resolver instance");
      this.resolver = (0, pac_resolver_1.createPacResolver)(qjs, code2, this.opts);
      this.resolverHash = hash;
      return this.resolver;
    } catch (err) {
      if (this.resolver && err.code === "ENOTMODIFIED") {
        debug$3("Got ENOTMODIFIED response, reusing previous proxy resolver");
        return this.resolver;
      }
      throw err;
    }
  }
  /**
   * Loads the contents of the PAC proxy file.
   *
   * @api private
   */
  async loadPacFile() {
    debug$3("Loading PAC file: %o", this.uri);
    const rs = await (0, get_uri_1.getUri)(this.uri, { ...this.opts, cache: this.cache });
    debug$3("Got `Readable` instance for URI");
    this.cache = rs;
    const buf = await (0, agent_base_1$2.toBuffer)(rs);
    debug$3("Read %o byte PAC file from URI", buf.length);
    return buf.toString("utf8");
  }
  /**
   * Called when the node-core HTTP client library is creating a new HTTP request.
   */
  async connect(req2, opts) {
    const { secureEndpoint } = opts;
    const resolver = await this.getResolver();
    const defaultPort = secureEndpoint ? 443 : 80;
    let path2 = req2.path;
    let search = null;
    const firstQuestion = path2.indexOf("?");
    if (firstQuestion !== -1) {
      search = path2.substring(firstQuestion);
      path2 = path2.substring(0, firstQuestion);
    }
    const urlOpts = {
      ...opts,
      protocol: secureEndpoint ? "https:" : "http:",
      pathname: path2,
      search,
      // need to use `hostname` instead of `host` otherwise `port` is ignored
      hostname: opts.host,
      host: null,
      href: null,
      // set `port` to null when it is the protocol default port (80 / 443)
      port: defaultPort === opts.port ? null : opts.port
    };
    const url = (0, url_1$2.format)(urlOpts);
    debug$3("url: %o", url);
    let result = await resolver(url);
    if (!result) {
      result = "DIRECT";
    }
    const proxies = String(result).trim().split(/\s*;\s*/g).filter(Boolean);
    if (this.opts.fallbackToDirect && !proxies.includes("DIRECT")) {
      proxies.push("DIRECT");
    }
    for (const proxy of proxies) {
      let agent = null;
      let socket = null;
      const [type, target] = proxy.split(/\s+/);
      debug$3("Attempting to use proxy: %o", proxy);
      if (type === "DIRECT") {
        if (secureEndpoint) {
          const servername = opts.servername || opts.host;
          socket = tls$2.connect({
            ...opts,
            servername: !servername || net$2.isIP(servername) ? void 0 : servername
          });
        } else {
          socket = net$2.connect(opts);
        }
      } else if (type === "SOCKS" || type === "SOCKS5") {
        agent = new socks_proxy_agent_1.SocksProxyAgent(`socks://${target}`, this.opts);
      } else if (type === "SOCKS4") {
        agent = new socks_proxy_agent_1.SocksProxyAgent(`socks4a://${target}`, this.opts);
      } else if (type === "PROXY" || type === "HTTP" || type === "HTTPS") {
        const proxyURL = `${type === "HTTPS" ? "https" : "http"}://${target}`;
        if (secureEndpoint) {
          agent = new https_proxy_agent_1.HttpsProxyAgent(proxyURL, this.opts);
        } else {
          agent = new http_proxy_agent_1.HttpProxyAgent(proxyURL, this.opts);
        }
      }
      try {
        if (socket) {
          await (0, events_1$1.once)(socket, "connect");
          req2.emit("proxy", { proxy, socket });
          return socket;
        }
        if (agent) {
          const s2 = await agent.connect(req2, opts);
          if (!(s2 instanceof net$2.Socket)) {
            throw new Error("Expected a `net.Socket` to be returned from agent");
          }
          req2.emit("proxy", { proxy, socket: s2 });
          return s2;
        }
        throw new Error(`Could not determine proxy type for: ${proxy}`);
      } catch (err) {
        debug$3("Got error for proxy %o: %o", proxy, err);
        req2.emit("proxy", { proxy, error: err });
      }
    }
    throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);
  }
}
PacProxyAgent.protocols = [
  "pac+data",
  "pac+file",
  "pac+ftp",
  "pac+http",
  "pac+https"
];
dist$d.PacProxyAgent = PacProxyAgent;
var dist$1 = {};
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding$1(result, mod, k2);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.HttpProxyAgent = void 0;
const net$1 = __importStar$1(require$$0$1);
const tls$1 = __importStar$1(require$$1$1);
const debug_1$2 = __importDefault$2(srcExports);
const events_1 = require$$3$2;
const agent_base_1$1 = dist$e;
const url_1$1 = require$$5$1;
const debug$2 = (0, debug_1$2.default)("http-proxy-agent");
class HttpProxyAgent2 extends agent_base_1$1.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.proxy = typeof proxy === "string" ? new url_1$1.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug$2("Creating new HttpProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      ...opts ? omit$1(opts, "headers") : null,
      host,
      port
    };
  }
  addRequest(req2, opts) {
    req2._header = null;
    this.setRequestProps(req2, opts);
    super.addRequest(req2, opts);
  }
  setRequestProps(req2, opts) {
    const { proxy } = this;
    const protocol = opts.secureEndpoint ? "https:" : "http:";
    const hostname = req2.getHeader("host") || "localhost";
    const base = `${protocol}//${hostname}`;
    const url = new url_1$1.URL(req2.path, base);
    if (opts.port !== 80) {
      url.port = String(opts.port);
    }
    req2.path = String(url);
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      const value = headers[name2];
      if (value) {
        req2.setHeader(name2, value);
      }
    }
  }
  async connect(req2, opts) {
    req2._header = null;
    if (!req2.path.includes("://")) {
      this.setRequestProps(req2, opts);
    }
    let first2;
    let endOfHeaders;
    debug$2("Regenerating stored HTTP header string for request");
    req2._implicitHeader();
    if (req2.outputData && req2.outputData.length > 0) {
      debug$2("Patching connection write() output buffer with updated header");
      first2 = req2.outputData[0].data;
      endOfHeaders = first2.indexOf("\r\n\r\n") + 4;
      req2.outputData[0].data = req2._header + first2.substring(endOfHeaders);
      debug$2("Output buffer: %o", req2.outputData[0].data);
    }
    let socket;
    if (this.proxy.protocol === "https:") {
      debug$2("Creating `tls.Socket`: %o", this.connectOpts);
      socket = tls$1.connect(this.connectOpts);
    } else {
      debug$2("Creating `net.Socket`: %o", this.connectOpts);
      socket = net$1.connect(this.connectOpts);
    }
    await (0, events_1.once)(socket, "connect");
    return socket;
  }
}
HttpProxyAgent2.protocols = ["http", "https"];
dist$1.HttpProxyAgent = HttpProxyAgent2;
function omit$1(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var dist = {};
var parseProxyResponse$1 = {};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(parseProxyResponse$1, "__esModule", { value: true });
parseProxyResponse$1.parseProxyResponse = void 0;
const debug_1$1 = __importDefault$1(srcExports);
const debug$1 = (0, debug_1$1.default)("https-proxy-agent:parse-proxy-response");
function parseProxyResponse(socket) {
  return new Promise((resolve2, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b2 = socket.read();
      if (b2)
        ondata(b2);
      else
        socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug$1("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug$1("onerror %o", err);
      reject(err);
    }
    function ondata(b2) {
      buffers.push(b2);
      buffersLength += b2.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug$1("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +firstLineParts[1];
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header of headerParts) {
        if (!header)
          continue;
        const firstColon = header.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === "string") {
          headers[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key] = value;
        }
      }
      debug$1("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve2({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}
parseProxyResponse$1.parseProxyResponse = parseProxyResponse;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o2, k22, desc);
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist, "__esModule", { value: true });
dist.HttpsProxyAgent = void 0;
const net = __importStar(require$$0$1);
const tls = __importStar(require$$1$1);
const assert_1 = __importDefault(require$$2);
const debug_1 = __importDefault(srcExports);
const agent_base_1 = dist$e;
const url_1 = require$$5$1;
const parse_proxy_response_1 = parseProxyResponse$1;
const debug = (0, debug_1.default)("https-proxy-agent");
class HttpsProxyAgent2 extends agent_base_1.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.options = { path: void 0 };
    this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit(opts, "headers") : null,
      host,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req2, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls.connect({
        ...this.connectOpts,
        servername: servername && net.isIP(servername) ? void 0 : servername
      });
    } else {
      debug("Creating `net.Socket`: %o", this.connectOpts);
      socket = net.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      payload += `${name2}: ${headers[name2]}\r
`;
    }
    const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
    socket.write(`${payload}\r
`);
    const { connect, buffered } = await proxyResponsePromise;
    req2.emit("proxyConnect", connect);
    this.emit("proxyConnect", connect, req2);
    if (connect.statusCode === 200) {
      req2.once("socket", resume);
      if (opts.secureEndpoint) {
        debug("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls.connect({
          ...omit(opts, "host", "path", "port"),
          socket,
          servername: net.isIP(servername) ? void 0 : servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net.Socket({ writable: false });
    fakeSocket.readable = true;
    req2.once("socket", (s2) => {
      debug("Replaying proxy buffer for failed request");
      (0, assert_1.default)(s2.listenerCount("data") > 0);
      s2.push(buffered);
      s2.push(null);
    });
    return fakeSocket;
  }
}
HttpsProxyAgent2.protocols = ["http", "https"];
dist.HttpsProxyAgent = HttpsProxyAgent2;
function resume(socket) {
  socket.resume();
}
function omit(obj, ...keys) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ProxyAgent = exports2.proxies = void 0;
  const http2 = __importStar2(require$$0$2);
  const https2 = __importStar2(require$$1);
  const url_12 = require$$5$1;
  const lru_cache_1 = __importDefault2(lruCache);
  const agent_base_12 = dist$e;
  const debug_12 = __importDefault2(srcExports);
  const proxy_from_env_1 = proxyFromEnv;
  const pac_proxy_agent_1 = dist$d;
  const http_proxy_agent_12 = dist$1;
  const https_proxy_agent_12 = dist;
  const socks_proxy_agent_12 = dist$9;
  const debug2 = (0, debug_12.default)("proxy-agent");
  const PROTOCOLS = [
    ...http_proxy_agent_12.HttpProxyAgent.protocols,
    ...socks_proxy_agent_12.SocksProxyAgent.protocols,
    ...pac_proxy_agent_1.PacProxyAgent.protocols
  ];
  exports2.proxies = {
    http: [http_proxy_agent_12.HttpProxyAgent, https_proxy_agent_12.HttpsProxyAgent],
    https: [http_proxy_agent_12.HttpProxyAgent, https_proxy_agent_12.HttpsProxyAgent],
    socks: [socks_proxy_agent_12.SocksProxyAgent, socks_proxy_agent_12.SocksProxyAgent],
    socks4: [socks_proxy_agent_12.SocksProxyAgent, socks_proxy_agent_12.SocksProxyAgent],
    socks4a: [socks_proxy_agent_12.SocksProxyAgent, socks_proxy_agent_12.SocksProxyAgent],
    socks5: [socks_proxy_agent_12.SocksProxyAgent, socks_proxy_agent_12.SocksProxyAgent],
    socks5h: [socks_proxy_agent_12.SocksProxyAgent, socks_proxy_agent_12.SocksProxyAgent],
    "pac+data": [pac_proxy_agent_1.PacProxyAgent, pac_proxy_agent_1.PacProxyAgent],
    "pac+file": [pac_proxy_agent_1.PacProxyAgent, pac_proxy_agent_1.PacProxyAgent],
    "pac+ftp": [pac_proxy_agent_1.PacProxyAgent, pac_proxy_agent_1.PacProxyAgent],
    "pac+http": [pac_proxy_agent_1.PacProxyAgent, pac_proxy_agent_1.PacProxyAgent],
    "pac+https": [pac_proxy_agent_1.PacProxyAgent, pac_proxy_agent_1.PacProxyAgent]
  };
  function isValidProtocol(v2) {
    return PROTOCOLS.includes(v2);
  }
  class ProxyAgent extends agent_base_12.Agent {
    constructor(opts) {
      super(opts);
      this.cache = new lru_cache_1.default({ max: 20 });
      debug2("Creating new ProxyAgent instance: %o", opts);
      this.connectOpts = opts;
      this.httpAgent = (opts == null ? void 0 : opts.httpAgent) || new http2.Agent(opts);
      this.httpsAgent = (opts == null ? void 0 : opts.httpsAgent) || new https2.Agent(opts);
      this.getProxyForUrl = (opts == null ? void 0 : opts.getProxyForUrl) || proxy_from_env_1.getProxyForUrl;
    }
    async connect(req2, opts) {
      const { secureEndpoint } = opts;
      const isWebSocket = req2.getHeader("upgrade") === "websocket";
      const protocol = secureEndpoint ? isWebSocket ? "wss:" : "https:" : isWebSocket ? "ws:" : "http:";
      const host = req2.getHeader("host");
      const url = new url_12.URL(req2.path, `${protocol}//${host}`).href;
      const proxy = await this.getProxyForUrl(url);
      if (!proxy) {
        debug2("Proxy not enabled for URL: %o", url);
        return secureEndpoint ? this.httpsAgent : this.httpAgent;
      }
      debug2("Request URL: %o", url);
      debug2("Proxy URL: %o", proxy);
      const cacheKey = `${protocol}+${proxy}`;
      let agent = this.cache.get(cacheKey);
      if (!agent) {
        const proxyUrl = new url_12.URL(proxy);
        const proxyProto = proxyUrl.protocol.replace(":", "");
        if (!isValidProtocol(proxyProto)) {
          throw new Error(`Unsupported protocol for proxy URL: ${proxy}`);
        }
        const ctor = exports2.proxies[proxyProto][secureEndpoint || isWebSocket ? 1 : 0];
        agent = new ctor(proxy, this.connectOpts);
        this.cache.set(cacheKey, agent);
      } else {
        debug2("Cache hit for proxy URL: %o", proxy);
      }
      return agent;
    }
    destroy() {
      for (const agent of this.cache.values()) {
        agent.destroy();
      }
      super.destroy();
    }
  }
  exports2.ProxyAgent = ProxyAgent;
})(dist$f);
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function httpRequest(url, method, response, keepAlive = true) {
  const options = {
    protocol: url.protocol,
    hostname: url.hostname,
    port: url.port,
    path: url.pathname + url.search,
    method,
    headers: keepAlive ? { Connection: "keep-alive" } : void 0,
    auth: require$$5$1.urlToHttpOptions(url).auth,
    agent: new dist$f.ProxyAgent()
  };
  const requestCallback = (res) => {
    if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
      httpRequest(new require$$5$1.URL(res.headers.location), method, response);
      res.resume();
    } else {
      response(res);
    }
  };
  const request = options.protocol === "https:" ? require$$1__namespace.request(options, requestCallback) : require$$0__namespace.request(options, requestCallback);
  request.end();
  return request;
}
async function getJSON(url) {
  const text = await getText(url);
  try {
    return JSON.parse(text);
  } catch {
    throw new Error("Could not parse JSON from " + url.toString());
  }
}
function getText(url) {
  return new Promise((resolve2, reject) => {
    const request = httpRequest(url, "GET", (response) => {
      let data2 = "";
      if (response.statusCode && response.statusCode >= 400) {
        return reject(new Error(`Got status code ${response.statusCode}`));
      }
      response.on("data", (chunk) => {
        data2 += chunk;
      });
      response.on("end", () => {
        try {
          return resolve2(String(data2));
        } catch {
          return reject(new Error("Chrome version not found"));
        }
      });
    }, false);
    request.on("error", (err) => {
      reject(err);
    });
  });
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function folder$3(platform2) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return "linux64";
    case BrowserPlatform.MAC_ARM:
      return "mac-arm64";
    case BrowserPlatform.MAC:
      return "mac-x64";
    case BrowserPlatform.WIN32:
      return "win32";
    case BrowserPlatform.WIN64:
      return "win64";
  }
}
function resolveDownloadUrl$4(platform2, buildId, baseUrl = "https://storage.googleapis.com/chrome-for-testing-public") {
  return `${baseUrl}/${resolveDownloadPath$4(platform2, buildId).join("/")}`;
}
function resolveDownloadPath$4(platform2, buildId) {
  return [buildId, folder$3(platform2), `chrome-${folder$3(platform2)}.zip`];
}
function relativeExecutablePath$4(platform2, _buildId) {
  switch (platform2) {
    case BrowserPlatform.MAC:
    case BrowserPlatform.MAC_ARM:
      return path$e.join("chrome-" + folder$3(platform2), "Google Chrome for Testing.app", "Contents", "MacOS", "Google Chrome for Testing");
    case BrowserPlatform.LINUX:
      return path$e.join("chrome-linux64", "chrome");
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return path$e.join("chrome-" + folder$3(platform2), "chrome.exe");
  }
}
async function getLastKnownGoodReleaseForChannel(channel) {
  const data2 = await getJSON(new URL("https://googlechromelabs.github.io/chrome-for-testing/last-known-good-versions.json"));
  for (const channel2 of Object.keys(data2.channels)) {
    data2.channels[channel2.toLowerCase()] = data2.channels[channel2];
    delete data2.channels[channel2];
  }
  return data2.channels[channel];
}
async function getLastKnownGoodReleaseForMilestone(milestone) {
  const data2 = await getJSON(new URL("https://googlechromelabs.github.io/chrome-for-testing/latest-versions-per-milestone.json"));
  return data2.milestones[milestone];
}
async function getLastKnownGoodReleaseForBuild(buildPrefix) {
  const data2 = await getJSON(new URL("https://googlechromelabs.github.io/chrome-for-testing/latest-patch-versions-per-build.json"));
  return data2.builds[buildPrefix];
}
async function resolveBuildId$3(channel) {
  var _a3, _b3;
  if (Object.values(ChromeReleaseChannel).includes(channel)) {
    return (await getLastKnownGoodReleaseForChannel(channel)).version;
  }
  if (channel.match(/^\d+$/)) {
    return (_a3 = await getLastKnownGoodReleaseForMilestone(channel)) == null ? void 0 : _a3.version;
  }
  if (channel.match(/^\d+\.\d+\.\d+$/)) {
    return (_b3 = await getLastKnownGoodReleaseForBuild(channel)) == null ? void 0 : _b3.version;
  }
  return;
}
function resolveSystemExecutablePath$1(platform2, channel) {
  switch (platform2) {
    case BrowserPlatform.WIN64:
    case BrowserPlatform.WIN32:
      switch (channel) {
        case ChromeReleaseChannel.STABLE:
          return `${process.env["PROGRAMFILES"]}\\Google\\Chrome\\Application\\chrome.exe`;
        case ChromeReleaseChannel.BETA:
          return `${process.env["PROGRAMFILES"]}\\Google\\Chrome Beta\\Application\\chrome.exe`;
        case ChromeReleaseChannel.CANARY:
          return `${process.env["PROGRAMFILES"]}\\Google\\Chrome SxS\\Application\\chrome.exe`;
        case ChromeReleaseChannel.DEV:
          return `${process.env["PROGRAMFILES"]}\\Google\\Chrome Dev\\Application\\chrome.exe`;
      }
    case BrowserPlatform.MAC_ARM:
    case BrowserPlatform.MAC:
      switch (channel) {
        case ChromeReleaseChannel.STABLE:
          return "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome";
        case ChromeReleaseChannel.BETA:
          return "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta";
        case ChromeReleaseChannel.CANARY:
          return "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary";
        case ChromeReleaseChannel.DEV:
          return "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev";
      }
    case BrowserPlatform.LINUX:
      switch (channel) {
        case ChromeReleaseChannel.STABLE:
          return "/opt/google/chrome/chrome";
        case ChromeReleaseChannel.BETA:
          return "/opt/google/chrome-beta/chrome";
        case ChromeReleaseChannel.DEV:
          return "/opt/google/chrome-unstable/chrome";
      }
  }
  throw new Error(`Unable to detect browser executable path for '${channel}' on ${platform2}.`);
}
function compareVersions$2(a2, b2) {
  if (!semver$1.valid(a2)) {
    throw new Error(`Version ${a2} is not a valid semver version`);
  }
  if (!semver$1.valid(b2)) {
    throw new Error(`Version ${b2} is not a valid semver version`);
  }
  if (semver$1.gt(a2, b2)) {
    return 1;
  } else if (semver$1.lt(a2, b2)) {
    return -1;
  } else {
    return 0;
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function folder$2(platform2) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return "linux64";
    case BrowserPlatform.MAC_ARM:
      return "mac-arm64";
    case BrowserPlatform.MAC:
      return "mac-x64";
    case BrowserPlatform.WIN32:
      return "win32";
    case BrowserPlatform.WIN64:
      return "win64";
  }
}
function resolveDownloadUrl$3(platform2, buildId, baseUrl = "https://storage.googleapis.com/chrome-for-testing-public") {
  return `${baseUrl}/${resolveDownloadPath$3(platform2, buildId).join("/")}`;
}
function resolveDownloadPath$3(platform2, buildId) {
  return [
    buildId,
    folder$2(platform2),
    `chrome-headless-shell-${folder$2(platform2)}.zip`
  ];
}
function relativeExecutablePath$3(platform2, _buildId) {
  switch (platform2) {
    case BrowserPlatform.MAC:
    case BrowserPlatform.MAC_ARM:
      return path$e.join("chrome-headless-shell-" + folder$2(platform2), "chrome-headless-shell");
    case BrowserPlatform.LINUX:
      return path$e.join("chrome-headless-shell-linux64", "chrome-headless-shell");
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return path$e.join("chrome-headless-shell-" + folder$2(platform2), "chrome-headless-shell.exe");
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function folder$1(platform2) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return "linux64";
    case BrowserPlatform.MAC_ARM:
      return "mac-arm64";
    case BrowserPlatform.MAC:
      return "mac-x64";
    case BrowserPlatform.WIN32:
      return "win32";
    case BrowserPlatform.WIN64:
      return "win64";
  }
}
function resolveDownloadUrl$2(platform2, buildId, baseUrl = "https://storage.googleapis.com/chrome-for-testing-public") {
  return `${baseUrl}/${resolveDownloadPath$2(platform2, buildId).join("/")}`;
}
function resolveDownloadPath$2(platform2, buildId) {
  return [buildId, folder$1(platform2), `chromedriver-${folder$1(platform2)}.zip`];
}
function relativeExecutablePath$2(platform2, _buildId) {
  switch (platform2) {
    case BrowserPlatform.MAC:
    case BrowserPlatform.MAC_ARM:
      return path$e.join("chromedriver-" + folder$1(platform2), "chromedriver");
    case BrowserPlatform.LINUX:
      return path$e.join("chromedriver-linux64", "chromedriver");
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return path$e.join("chromedriver-" + folder$1(platform2), "chromedriver.exe");
  }
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function archive$1(platform2, buildId) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return "chrome-linux";
    case BrowserPlatform.MAC_ARM:
    case BrowserPlatform.MAC:
      return "chrome-mac";
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return parseInt(buildId, 10) > 591479 ? "chrome-win" : "chrome-win32";
  }
}
function folder(platform2) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return "Linux_x64";
    case BrowserPlatform.MAC_ARM:
      return "Mac_Arm";
    case BrowserPlatform.MAC:
      return "Mac";
    case BrowserPlatform.WIN32:
      return "Win";
    case BrowserPlatform.WIN64:
      return "Win_x64";
  }
}
function resolveDownloadUrl$1(platform2, buildId, baseUrl = "https://storage.googleapis.com/chromium-browser-snapshots") {
  return `${baseUrl}/${resolveDownloadPath$1(platform2, buildId).join("/")}`;
}
function resolveDownloadPath$1(platform2, buildId) {
  return [folder(platform2), buildId, `${archive$1(platform2, buildId)}.zip`];
}
function relativeExecutablePath$1(platform2, _buildId) {
  switch (platform2) {
    case BrowserPlatform.MAC:
    case BrowserPlatform.MAC_ARM:
      return path$e.join("chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium");
    case BrowserPlatform.LINUX:
      return path$e.join("chrome-linux", "chrome");
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return path$e.join("chrome-win", "chrome.exe");
  }
}
async function resolveBuildId$2(platform2) {
  return await getText(new URL(`https://storage.googleapis.com/chromium-browser-snapshots/${folder(platform2)}/LAST_CHANGE`));
}
function compareVersions$1(a2, b2) {
  return Number(a2) - Number(b2);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function archiveNightly(platform2, buildId) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return `firefox-${buildId}.en-US.${platform2}-x86_64.tar.bz2`;
    case BrowserPlatform.MAC_ARM:
    case BrowserPlatform.MAC:
      return `firefox-${buildId}.en-US.mac.dmg`;
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return `firefox-${buildId}.en-US.${platform2}.zip`;
  }
}
function archive(platform2, buildId) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return `firefox-${buildId}.tar.bz2`;
    case BrowserPlatform.MAC_ARM:
    case BrowserPlatform.MAC:
      return `Firefox ${buildId}.dmg`;
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return `Firefox Setup ${buildId}.exe`;
  }
}
function platformName(platform2) {
  switch (platform2) {
    case BrowserPlatform.LINUX:
      return `linux-x86_64`;
    case BrowserPlatform.MAC_ARM:
    case BrowserPlatform.MAC:
      return `mac`;
    case BrowserPlatform.WIN32:
    case BrowserPlatform.WIN64:
      return platform2;
  }
}
function parseBuildId(buildId) {
  for (const value of Object.values(FirefoxChannel)) {
    if (buildId.startsWith(value + "_")) {
      buildId = buildId.substring(value.length + 1);
      return [value, buildId];
    }
  }
  return [FirefoxChannel.NIGHTLY, buildId];
}
function resolveDownloadUrl(platform2, buildId, baseUrl) {
  const [channel, resolvedBuildId] = parseBuildId(buildId);
  switch (channel) {
    case FirefoxChannel.NIGHTLY:
      baseUrl ?? (baseUrl = "https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central");
      break;
    case FirefoxChannel.DEVEDITION:
      baseUrl ?? (baseUrl = "https://archive.mozilla.org/pub/devedition/releases");
      break;
    case FirefoxChannel.BETA:
    case FirefoxChannel.STABLE:
    case FirefoxChannel.ESR:
      baseUrl ?? (baseUrl = "https://archive.mozilla.org/pub/firefox/releases");
      break;
  }
  switch (channel) {
    case FirefoxChannel.NIGHTLY:
      return `${baseUrl}/${resolveDownloadPath(platform2, resolvedBuildId).join("/")}`;
    case FirefoxChannel.DEVEDITION:
    case FirefoxChannel.BETA:
    case FirefoxChannel.STABLE:
    case FirefoxChannel.ESR:
      return `${baseUrl}/${resolvedBuildId}/${platformName(platform2)}/en-US/${archive(platform2, resolvedBuildId)}`;
  }
}
function resolveDownloadPath(platform2, buildId) {
  return [archiveNightly(platform2, buildId)];
}
function relativeExecutablePath(platform2, buildId) {
  const [channel] = parseBuildId(buildId);
  switch (channel) {
    case FirefoxChannel.NIGHTLY:
      switch (platform2) {
        case BrowserPlatform.MAC_ARM:
        case BrowserPlatform.MAC:
          return path$e.join("Firefox Nightly.app", "Contents", "MacOS", "firefox");
        case BrowserPlatform.LINUX:
          return path$e.join("firefox", "firefox");
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
          return path$e.join("firefox", "firefox.exe");
      }
    case FirefoxChannel.BETA:
    case FirefoxChannel.DEVEDITION:
    case FirefoxChannel.ESR:
    case FirefoxChannel.STABLE:
      switch (platform2) {
        case BrowserPlatform.MAC_ARM:
        case BrowserPlatform.MAC:
          return path$e.join("Firefox.app", "Contents", "MacOS", "firefox");
        case BrowserPlatform.LINUX:
          return path$e.join("firefox", "firefox");
        case BrowserPlatform.WIN32:
        case BrowserPlatform.WIN64:
          return path$e.join("core", "firefox.exe");
      }
  }
}
var FirefoxChannel;
(function(FirefoxChannel2) {
  FirefoxChannel2["STABLE"] = "stable";
  FirefoxChannel2["ESR"] = "esr";
  FirefoxChannel2["DEVEDITION"] = "devedition";
  FirefoxChannel2["BETA"] = "beta";
  FirefoxChannel2["NIGHTLY"] = "nightly";
})(FirefoxChannel || (FirefoxChannel = {}));
async function resolveBuildId$1(channel = FirefoxChannel.NIGHTLY) {
  const channelToVersionKey = {
    [FirefoxChannel.ESR]: "FIREFOX_ESR",
    [FirefoxChannel.STABLE]: "LATEST_FIREFOX_VERSION",
    [FirefoxChannel.DEVEDITION]: "FIREFOX_DEVEDITION",
    [FirefoxChannel.BETA]: "FIREFOX_DEVEDITION",
    [FirefoxChannel.NIGHTLY]: "FIREFOX_NIGHTLY"
  };
  const versions = await getJSON(new URL("https://product-details.mozilla.org/1.0/firefox_versions.json"));
  const version2 = versions[channelToVersionKey[channel]];
  if (!version2) {
    throw new Error(`Channel ${channel} is not found.`);
  }
  return channel + "_" + version2;
}
async function createProfile$1(options) {
  if (!fs$o.existsSync(options.path)) {
    await fs$o.promises.mkdir(options.path, {
      recursive: true
    });
  }
  await writePreferences({
    preferences: {
      ...defaultProfilePreferences(options.preferences),
      ...options.preferences
    },
    path: options.path
  });
}
function defaultProfilePreferences(extraPrefs) {
  const server = "dummy.test";
  const defaultPrefs = {
    // Make sure Shield doesn't hit the network.
    "app.normandy.api_url": "",
    // Disable Firefox old build background check
    "app.update.checkInstallTime": false,
    // Disable automatically upgrading Firefox
    "app.update.disabledForTesting": true,
    // Increase the APZ content response timeout to 1 minute
    "apz.content_response_timeout": 6e4,
    // Prevent various error message on the console
    // jest-puppeteer asserts that no error message is emitted by the console
    "browser.contentblocking.features.standard": "-tp,tpPrivate,cookieBehavior0,-cm,-fp",
    // Enable the dump function: which sends messages to the system
    // console
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1543115
    "browser.dom.window.dump.enabled": true,
    // Disable topstories
    "browser.newtabpage.activity-stream.feeds.system.topstories": false,
    // Always display a blank page
    "browser.newtabpage.enabled": false,
    // Background thumbnails in particular cause grief: and disabling
    // thumbnails in general cannot hurt
    "browser.pagethumbnails.capturing_disabled": true,
    // Disable safebrowsing components.
    "browser.safebrowsing.blockedURIs.enabled": false,
    "browser.safebrowsing.downloads.enabled": false,
    "browser.safebrowsing.malware.enabled": false,
    "browser.safebrowsing.phishing.enabled": false,
    // Disable updates to search engines.
    "browser.search.update": false,
    // Do not restore the last open set of tabs if the browser has crashed
    "browser.sessionstore.resume_from_crash": false,
    // Skip check for default browser on startup
    "browser.shell.checkDefaultBrowser": false,
    // Disable newtabpage
    "browser.startup.homepage": "about:blank",
    // Do not redirect user when a milstone upgrade of Firefox is detected
    "browser.startup.homepage_override.mstone": "ignore",
    // Start with a blank page about:blank
    "browser.startup.page": 0,
    // Do not allow background tabs to be zombified on Android: otherwise for
    // tests that open additional tabs: the test harness tab itself might get
    // unloaded
    "browser.tabs.disableBackgroundZombification": false,
    // Do not warn when closing all other open tabs
    "browser.tabs.warnOnCloseOtherTabs": false,
    // Do not warn when multiple tabs will be opened
    "browser.tabs.warnOnOpen": false,
    // Do not automatically offer translations, as tests do not expect this.
    "browser.translations.automaticallyPopup": false,
    // Disable the UI tour.
    "browser.uitour.enabled": false,
    // Turn off search suggestions in the location bar so as not to trigger
    // network connections.
    "browser.urlbar.suggest.searches": false,
    // Disable first run splash page on Windows 10
    "browser.usedOnWindows10.introURL": "",
    // Do not warn on quitting Firefox
    "browser.warnOnQuit": false,
    // Defensively disable data reporting systems
    "datareporting.healthreport.documentServerURI": `http://${server}/dummy/healthreport/`,
    "datareporting.healthreport.logging.consoleEnabled": false,
    "datareporting.healthreport.service.enabled": false,
    "datareporting.healthreport.service.firstRun": false,
    "datareporting.healthreport.uploadEnabled": false,
    // Do not show datareporting policy notifications which can interfere with tests
    "datareporting.policy.dataSubmissionEnabled": false,
    "datareporting.policy.dataSubmissionPolicyBypassNotification": true,
    // DevTools JSONViewer sometimes fails to load dependencies with its require.js.
    // This doesn't affect Puppeteer but spams console (Bug 1424372)
    "devtools.jsonview.enabled": false,
    // Disable popup-blocker
    "dom.disable_open_during_load": false,
    // Enable the support for File object creation in the content process
    // Required for |Page.setFileInputFiles| protocol method.
    "dom.file.createInChild": true,
    // Disable the ProcessHangMonitor
    "dom.ipc.reportProcessHangs": false,
    // Disable slow script dialogues
    "dom.max_chrome_script_run_time": 0,
    "dom.max_script_run_time": 0,
    // Only load extensions from the application and user profile
    // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
    "extensions.autoDisableScopes": 0,
    "extensions.enabledScopes": 5,
    // Disable metadata caching for installed add-ons by default
    "extensions.getAddons.cache.enabled": false,
    // Disable installing any distribution extensions or add-ons.
    "extensions.installDistroAddons": false,
    // Disabled screenshots extension
    "extensions.screenshots.disabled": true,
    // Turn off extension updates so they do not bother tests
    "extensions.update.enabled": false,
    // Turn off extension updates so they do not bother tests
    "extensions.update.notifyUser": false,
    // Make sure opening about:addons will not hit the network
    "extensions.webservice.discoverURL": `http://${server}/dummy/discoveryURL`,
    // Allow the application to have focus even it runs in the background
    "focusmanager.testmode": true,
    // Disable useragent updates
    "general.useragent.updates.enabled": false,
    // Always use network provider for geolocation tests so we bypass the
    // macOS dialog raised by the corelocation provider
    "geo.provider.testing": true,
    // Do not scan Wifi
    "geo.wifi.scan": false,
    // No hang monitor
    "hangmonitor.timeout": 0,
    // Show chrome errors and warnings in the error console
    "javascript.options.showInConsole": true,
    // Disable download and usage of OpenH264: and Widevine plugins
    "media.gmp-manager.updateEnabled": false,
    // Disable the GFX sanity window
    "media.sanity-test.disabled": true,
    // Disable experimental feature that is only available in Nightly
    "network.cookie.sameSite.laxByDefault": false,
    // Do not prompt for temporary redirects
    "network.http.prompt-temp-redirect": false,
    // Disable speculative connections so they are not reported as leaking
    // when they are hanging around
    "network.http.speculative-parallel-limit": 0,
    // Do not automatically switch between offline and online
    "network.manage-offline-status": false,
    // Make sure SNTP requests do not hit the network
    "network.sntp.pools": server,
    // Disable Flash.
    "plugin.state.flash": 0,
    "privacy.trackingprotection.enabled": false,
    // Can be removed once Firefox 89 is no longer supported
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1710839
    "remote.enabled": true,
    // Don't do network connections for mitm priming
    "security.certerrors.mitm.priming.enabled": false,
    // Local documents have access to all other local documents,
    // including directory listings
    "security.fileuri.strict_origin_policy": false,
    // Do not wait for the notification button security delay
    "security.notification_enable_delay": 0,
    // Ensure blocklist updates do not hit the network
    "services.settings.server": `http://${server}/dummy/blocklist/`,
    // Do not automatically fill sign-in forms with known usernames and
    // passwords
    "signon.autofillForms": false,
    // Disable password capture, so that tests that include forms are not
    // influenced by the presence of the persistent doorhanger notification
    "signon.rememberSignons": false,
    // Disable first-run welcome page
    "startup.homepage_welcome_url": "about:blank",
    // Disable first-run welcome page
    "startup.homepage_welcome_url.additional": "",
    // Disable browser animations (tabs, fullscreen, sliding alerts)
    "toolkit.cosmeticAnimations.enabled": false,
    // Prevent starting into safe mode after application crashes
    "toolkit.startup.max_resumed_crashes": -1
  };
  return Object.assign(defaultPrefs, extraPrefs);
}
async function writePreferences(options) {
  const prefsPath = path$e.join(options.path, "prefs.js");
  const lines = Object.entries(options.preferences).map(([key, value]) => {
    return `user_pref(${JSON.stringify(key)}, ${JSON.stringify(value)});`;
  });
  const result = await Promise.allSettled([
    fs$o.promises.writeFile(path$e.join(options.path, "user.js"), lines.join("\n")),
    // Create a backup of the preferences file if it already exitsts.
    fs$o.promises.access(prefsPath, fs$o.constants.F_OK).then(
      async () => {
        await fs$o.promises.copyFile(prefsPath, path$e.join(options.path, "prefs.js.puppeteer"));
      },
      // Swallow only if file does not exist
      () => {
      }
    )
  ]);
  for (const command of result) {
    if (command.status === "rejected") {
      throw command.reason;
    }
  }
}
function compareVersions(a2, b2) {
  return parseInt(a2.replace(".", ""), 16) - parseInt(b2.replace(".", ""), 16);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
({
  [Browser2.CHROMEDRIVER]: resolveDownloadUrl$2,
  [Browser2.CHROMEHEADLESSSHELL]: resolveDownloadUrl$3,
  [Browser2.CHROME]: resolveDownloadUrl$4,
  [Browser2.CHROMIUM]: resolveDownloadUrl$1,
  [Browser2.FIREFOX]: resolveDownloadUrl
});
({
  [Browser2.CHROMEDRIVER]: resolveDownloadPath$2,
  [Browser2.CHROMEHEADLESSSHELL]: resolveDownloadPath$3,
  [Browser2.CHROME]: resolveDownloadPath$4,
  [Browser2.CHROMIUM]: resolveDownloadPath$1,
  [Browser2.FIREFOX]: resolveDownloadPath
});
const executablePathByBrowser = {
  [Browser2.CHROMEDRIVER]: relativeExecutablePath$2,
  [Browser2.CHROMEHEADLESSSHELL]: relativeExecutablePath$3,
  [Browser2.CHROME]: relativeExecutablePath$4,
  [Browser2.CHROMIUM]: relativeExecutablePath$1,
  [Browser2.FIREFOX]: relativeExecutablePath
};
const versionComparators = {
  [Browser2.CHROMEDRIVER]: compareVersions$2,
  [Browser2.CHROMEHEADLESSSHELL]: compareVersions$2,
  [Browser2.CHROME]: compareVersions$2,
  [Browser2.CHROMIUM]: compareVersions$1,
  [Browser2.FIREFOX]: compareVersions
};
async function resolveBuildIdForBrowserTag(browser2, platform2, tag) {
  switch (browser2) {
    case Browser2.FIREFOX:
      switch (tag) {
        case BrowserTag.LATEST:
          return await resolveBuildId$1(FirefoxChannel.NIGHTLY);
        case BrowserTag.BETA:
          return await resolveBuildId$1(FirefoxChannel.BETA);
        case BrowserTag.NIGHTLY:
          return await resolveBuildId$1(FirefoxChannel.NIGHTLY);
        case BrowserTag.DEVEDITION:
          return await resolveBuildId$1(FirefoxChannel.DEVEDITION);
        case BrowserTag.STABLE:
          return await resolveBuildId$1(FirefoxChannel.STABLE);
        case BrowserTag.ESR:
          return await resolveBuildId$1(FirefoxChannel.ESR);
        case BrowserTag.CANARY:
        case BrowserTag.DEV:
          throw new Error(`${tag.toUpperCase()} is not available for Firefox`);
      }
    case Browser2.CHROME: {
      switch (tag) {
        case BrowserTag.LATEST:
          return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
        case BrowserTag.BETA:
          return await resolveBuildId$3(ChromeReleaseChannel.BETA);
        case BrowserTag.CANARY:
          return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
        case BrowserTag.DEV:
          return await resolveBuildId$3(ChromeReleaseChannel.DEV);
        case BrowserTag.STABLE:
          return await resolveBuildId$3(ChromeReleaseChannel.STABLE);
        case BrowserTag.NIGHTLY:
        case BrowserTag.DEVEDITION:
        case BrowserTag.ESR:
          throw new Error(`${tag.toUpperCase()} is not available for Chrome`);
      }
    }
    case Browser2.CHROMEDRIVER: {
      switch (tag) {
        case BrowserTag.LATEST:
        case BrowserTag.CANARY:
          return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
        case BrowserTag.BETA:
          return await resolveBuildId$3(ChromeReleaseChannel.BETA);
        case BrowserTag.DEV:
          return await resolveBuildId$3(ChromeReleaseChannel.DEV);
        case BrowserTag.STABLE:
          return await resolveBuildId$3(ChromeReleaseChannel.STABLE);
        case BrowserTag.NIGHTLY:
        case BrowserTag.DEVEDITION:
        case BrowserTag.ESR:
          throw new Error(`${tag.toUpperCase()} is not available for ChromeDriver`);
      }
    }
    case Browser2.CHROMEHEADLESSSHELL: {
      switch (tag) {
        case BrowserTag.LATEST:
        case BrowserTag.CANARY:
          return await resolveBuildId$3(ChromeReleaseChannel.CANARY);
        case BrowserTag.BETA:
          return await resolveBuildId$3(ChromeReleaseChannel.BETA);
        case BrowserTag.DEV:
          return await resolveBuildId$3(ChromeReleaseChannel.DEV);
        case BrowserTag.STABLE:
          return await resolveBuildId$3(ChromeReleaseChannel.STABLE);
        case BrowserTag.NIGHTLY:
        case BrowserTag.DEVEDITION:
        case BrowserTag.ESR:
          throw new Error(`${tag} is not available for chrome-headless-shell`);
      }
    }
    case Browser2.CHROMIUM:
      switch (tag) {
        case BrowserTag.LATEST:
          return await resolveBuildId$2(platform2);
        case BrowserTag.NIGHTLY:
        case BrowserTag.CANARY:
        case BrowserTag.DEV:
        case BrowserTag.DEVEDITION:
        case BrowserTag.BETA:
        case BrowserTag.STABLE:
        case BrowserTag.ESR:
          throw new Error(`${tag} is not supported for Chromium. Use 'latest' instead.`);
      }
  }
}
async function resolveBuildId(browser2, platform2, tag) {
  const browserTag = tag;
  if (Object.values(BrowserTag).includes(browserTag)) {
    return await resolveBuildIdForBrowserTag(browser2, platform2, browserTag);
  }
  switch (browser2) {
    case Browser2.FIREFOX:
      return tag;
    case Browser2.CHROME:
      const chromeResult = await resolveBuildId$3(tag);
      if (chromeResult) {
        return chromeResult;
      }
      return tag;
    case Browser2.CHROMEDRIVER:
      const chromeDriverResult = await resolveBuildId$3(tag);
      if (chromeDriverResult) {
        return chromeDriverResult;
      }
      return tag;
    case Browser2.CHROMEHEADLESSSHELL:
      const chromeHeadlessShellResult = await resolveBuildId$3(tag);
      if (chromeHeadlessShellResult) {
        return chromeHeadlessShellResult;
      }
      return tag;
    case Browser2.CHROMIUM:
      return tag;
  }
}
async function createProfile(browser2, opts) {
  switch (browser2) {
    case Browser2.FIREFOX:
      return await createProfile$1(opts);
    case Browser2.CHROME:
    case Browser2.CHROMIUM:
      throw new Error(`Profile creation is not support for ${browser2} yet`);
  }
}
function resolveSystemExecutablePath(browser2, platform2, channel) {
  switch (browser2) {
    case Browser2.CHROMEDRIVER:
    case Browser2.CHROMEHEADLESSSHELL:
    case Browser2.FIREFOX:
    case Browser2.CHROMIUM:
      throw new Error(`System browser detection is not supported for ${browser2} yet.`);
    case Browser2.CHROME:
      return resolveSystemExecutablePath$1(platform2, channel);
  }
}
function getVersionComparator(browser2) {
  return versionComparators[browser2];
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
function detectBrowserPlatform() {
  const platform2 = os.platform();
  switch (platform2) {
    case "darwin":
      return os.arch() === "arm64" ? BrowserPlatform.MAC_ARM : BrowserPlatform.MAC;
    case "linux":
      return BrowserPlatform.LINUX;
    case "win32":
      return os.arch() === "x64" || // Windows 11 for ARM supports x64 emulation
      os.arch() === "arm64" && isWindows11(os.release()) ? BrowserPlatform.WIN64 : BrowserPlatform.WIN32;
    default:
      return void 0;
  }
}
function isWindows11(version2) {
  const parts = version2.split(".");
  if (parts.length > 2) {
    const major2 = parseInt(parts[0], 10);
    const minor2 = parseInt(parts[1], 10);
    const patch2 = parseInt(parts[2], 10);
    return major2 > 10 || major2 === 10 && minor2 > 0 || major2 === 10 && minor2 === 0 && patch2 >= 22e3;
  }
  return false;
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugCache = debug$d("puppeteer:browsers:cache");
class InstalledBrowser {
  /**
   * @internal
   */
  constructor(cache, browser2, buildId, platform2) {
    __publicField(this, "browser");
    __publicField(this, "buildId");
    __publicField(this, "platform");
    __publicField(this, "executablePath");
    __privateAdd(this, _cache, void 0);
    __privateSet(this, _cache, cache);
    this.browser = browser2;
    this.buildId = buildId;
    this.platform = platform2;
    this.executablePath = cache.computeExecutablePath({
      browser: browser2,
      buildId,
      platform: platform2
    });
  }
  /**
   * Path to the root of the installation folder. Use
   * {@link computeExecutablePath} to get the path to the executable binary.
   */
  get path() {
    return __privateGet(this, _cache).installationDir(this.browser, this.platform, this.buildId);
  }
  readMetadata() {
    return __privateGet(this, _cache).readMetadata(this.browser);
  }
  writeMetadata(metadata) {
    __privateGet(this, _cache).writeMetadata(this.browser, metadata);
  }
}
_cache = new WeakMap();
class Cache {
  constructor(rootDir) {
    __privateAdd(this, _rootDir, void 0);
    __privateSet(this, _rootDir, rootDir);
  }
  /**
   * @internal
   */
  get rootDir() {
    return __privateGet(this, _rootDir);
  }
  browserRoot(browser2) {
    return path$e.join(__privateGet(this, _rootDir), browser2);
  }
  metadataFile(browser2) {
    return path$e.join(this.browserRoot(browser2), ".metadata");
  }
  readMetadata(browser2) {
    const metatadaPath = this.metadataFile(browser2);
    if (!fs$o.existsSync(metatadaPath)) {
      return { aliases: {} };
    }
    const data2 = JSON.parse(fs$o.readFileSync(metatadaPath, "utf8"));
    if (typeof data2 !== "object") {
      throw new Error(".metadata is not an object");
    }
    return data2;
  }
  writeMetadata(browser2, metadata) {
    const metatadaPath = this.metadataFile(browser2);
    fs$o.mkdirSync(path$e.dirname(metatadaPath), { recursive: true });
    fs$o.writeFileSync(metatadaPath, JSON.stringify(metadata, null, 2));
  }
  resolveAlias(browser2, alias) {
    const metadata = this.readMetadata(browser2);
    if (alias === "latest") {
      return Object.values(metadata.aliases || {}).sort(getVersionComparator(browser2)).at(-1);
    }
    return metadata.aliases[alias];
  }
  installationDir(browser2, platform2, buildId) {
    return path$e.join(this.browserRoot(browser2), `${platform2}-${buildId}`);
  }
  clear() {
    fs$o.rmSync(__privateGet(this, _rootDir), {
      force: true,
      recursive: true,
      maxRetries: 10,
      retryDelay: 500
    });
  }
  uninstall(browser2, platform2, buildId) {
    const metadata = this.readMetadata(browser2);
    for (const alias of Object.keys(metadata.aliases)) {
      if (metadata.aliases[alias] === buildId) {
        delete metadata.aliases[alias];
      }
    }
    fs$o.rmSync(this.installationDir(browser2, platform2, buildId), {
      force: true,
      recursive: true,
      maxRetries: 10,
      retryDelay: 500
    });
  }
  getInstalledBrowsers() {
    if (!fs$o.existsSync(__privateGet(this, _rootDir))) {
      return [];
    }
    const types2 = fs$o.readdirSync(__privateGet(this, _rootDir));
    const browsers = types2.filter((t2) => {
      return Object.values(Browser2).includes(t2);
    });
    return browsers.flatMap((browser2) => {
      const files2 = fs$o.readdirSync(this.browserRoot(browser2));
      return files2.map((file2) => {
        const result = parseFolderPath(path$e.join(this.browserRoot(browser2), file2));
        if (!result) {
          return null;
        }
        return new InstalledBrowser(this, browser2, result.buildId, result.platform);
      }).filter((item) => {
        return item !== null;
      });
    });
  }
  computeExecutablePath(options) {
    options.platform ?? (options.platform = detectBrowserPlatform());
    if (!options.platform) {
      throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);
    }
    try {
      options.buildId = this.resolveAlias(options.browser, options.buildId) ?? options.buildId;
    } catch {
      debugCache("could not read .metadata file for the browser");
    }
    const installationDir = this.installationDir(options.browser, options.platform, options.buildId);
    return path$e.join(installationDir, executablePathByBrowser[options.browser](options.platform, options.buildId));
  }
}
_rootDir = new WeakMap();
function parseFolderPath(folderPath) {
  const name2 = path$e.basename(folderPath);
  const splits = name2.split("-");
  if (splits.length !== 2) {
    return;
  }
  const [platform2, buildId] = splits;
  if (!buildId || !platform2) {
    return;
  }
  return { platform: platform2, buildId };
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const debugLaunch = debug$d("puppeteer:browsers:launcher");
function computeExecutablePath(options) {
  return new Cache(options.cacheDir).computeExecutablePath(options);
}
function computeSystemExecutablePath(options) {
  options.platform ?? (options.platform = detectBrowserPlatform());
  if (!options.platform) {
    throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);
  }
  const path2 = resolveSystemExecutablePath(options.browser, options.platform, options.channel);
  try {
    fs$o.accessSync(path2);
  } catch (error) {
    throw new Error(`Could not find Google Chrome executable for channel '${options.channel}' at '${path2}'.`);
  }
  return path2;
}
function launch(opts) {
  return new Process(opts);
}
const CDP_WEBSOCKET_ENDPOINT_REGEX = /^DevTools listening on (ws:\/\/.*)$/;
const WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX = /^WebDriver BiDi listening on (ws:\/\/.*)$/;
const processListeners = /* @__PURE__ */ new Map();
const dispatchers = {
  exit: (...args) => {
    var _a3;
    (_a3 = processListeners.get("exit")) == null ? void 0 : _a3.forEach((handler) => {
      return handler(...args);
    });
  },
  SIGINT: (...args) => {
    var _a3;
    (_a3 = processListeners.get("SIGINT")) == null ? void 0 : _a3.forEach((handler) => {
      return handler(...args);
    });
  },
  SIGHUP: (...args) => {
    var _a3;
    (_a3 = processListeners.get("SIGHUP")) == null ? void 0 : _a3.forEach((handler) => {
      return handler(...args);
    });
  },
  SIGTERM: (...args) => {
    var _a3;
    (_a3 = processListeners.get("SIGTERM")) == null ? void 0 : _a3.forEach((handler) => {
      return handler(...args);
    });
  }
};
function subscribeToProcessEvent(event, handler) {
  const listeners = processListeners.get(event) || [];
  if (listeners.length === 0) {
    process.on(event, dispatchers[event]);
  }
  listeners.push(handler);
  processListeners.set(event, listeners);
}
function unsubscribeFromProcessEvent(event, handler) {
  const listeners = processListeners.get(event) || [];
  const existingListenerIdx = listeners.indexOf(handler);
  if (existingListenerIdx === -1) {
    return;
  }
  listeners.splice(existingListenerIdx, 1);
  processListeners.set(event, listeners);
  if (listeners.length === 0) {
    process.off(event, dispatchers[event]);
  }
}
class Process {
  constructor(opts) {
    __privateAdd(this, _runHooks);
    __privateAdd(this, _configureStdio);
    __privateAdd(this, _clearListeners);
    __privateAdd(this, _executablePath, void 0);
    __privateAdd(this, _args3, void 0);
    __privateAdd(this, _browserProcess, void 0);
    __privateAdd(this, _exited, false);
    // The browser process can be closed externally or from the driver process. We
    // need to invoke the hooks only once though but we don't know how many times
    // we will be invoked.
    __privateAdd(this, _hooksRan, false);
    __privateAdd(this, _onExitHook, async () => {
    });
    __privateAdd(this, _browserProcessExiting, void 0);
    __privateAdd(this, _onDriverProcessExit, (_code2) => {
      this.kill();
    });
    __privateAdd(this, _onDriverProcessSignal, (signal) => {
      switch (signal) {
        case "SIGINT":
          this.kill();
          process.exit(130);
        case "SIGTERM":
        case "SIGHUP":
          void this.close();
          break;
      }
    });
    var _a3, _b3;
    __privateSet(this, _executablePath, opts.executablePath);
    __privateSet(this, _args3, opts.args ?? []);
    opts.pipe ?? (opts.pipe = false);
    opts.dumpio ?? (opts.dumpio = false);
    opts.handleSIGINT ?? (opts.handleSIGINT = true);
    opts.handleSIGTERM ?? (opts.handleSIGTERM = true);
    opts.handleSIGHUP ?? (opts.handleSIGHUP = true);
    opts.detached ?? (opts.detached = process.platform !== "win32");
    const stdio = __privateMethod(this, _configureStdio, configureStdio_fn).call(this, {
      pipe: opts.pipe,
      dumpio: opts.dumpio
    });
    const env2 = opts.env || {};
    debugLaunch(`Launching ${__privateGet(this, _executablePath)} ${__privateGet(this, _args3).join(" ")}`, {
      detached: opts.detached,
      env: Object.keys(env2).reduce((res, key) => {
        if (key.toLowerCase().startsWith("puppeteer_")) {
          res[key] = env2[key];
        }
        return res;
      }, {}),
      stdio
    });
    __privateSet(this, _browserProcess, childProcess.spawn(__privateGet(this, _executablePath), __privateGet(this, _args3), {
      detached: opts.detached,
      env: env2,
      stdio
    }));
    debugLaunch(`Launched ${__privateGet(this, _browserProcess).pid}`);
    if (opts.dumpio) {
      (_a3 = __privateGet(this, _browserProcess).stderr) == null ? void 0 : _a3.pipe(process.stderr);
      (_b3 = __privateGet(this, _browserProcess).stdout) == null ? void 0 : _b3.pipe(process.stdout);
    }
    subscribeToProcessEvent("exit", __privateGet(this, _onDriverProcessExit));
    if (opts.handleSIGINT) {
      subscribeToProcessEvent("SIGINT", __privateGet(this, _onDriverProcessSignal));
    }
    if (opts.handleSIGTERM) {
      subscribeToProcessEvent("SIGTERM", __privateGet(this, _onDriverProcessSignal));
    }
    if (opts.handleSIGHUP) {
      subscribeToProcessEvent("SIGHUP", __privateGet(this, _onDriverProcessSignal));
    }
    if (opts.onExit) {
      __privateSet(this, _onExitHook, opts.onExit);
    }
    __privateSet(this, _browserProcessExiting, new Promise((resolve2, reject) => {
      __privateGet(this, _browserProcess).once("exit", async () => {
        debugLaunch(`Browser process ${__privateGet(this, _browserProcess).pid} onExit`);
        __privateMethod(this, _clearListeners, clearListeners_fn).call(this);
        __privateSet(this, _exited, true);
        try {
          await __privateMethod(this, _runHooks, runHooks_fn).call(this);
        } catch (err) {
          reject(err);
          return;
        }
        resolve2();
      });
    }));
  }
  get nodeProcess() {
    return __privateGet(this, _browserProcess);
  }
  async close() {
    await __privateMethod(this, _runHooks, runHooks_fn).call(this);
    if (!__privateGet(this, _exited)) {
      this.kill();
    }
    return await __privateGet(this, _browserProcessExiting);
  }
  hasClosed() {
    return __privateGet(this, _browserProcessExiting);
  }
  kill() {
    debugLaunch(`Trying to kill ${__privateGet(this, _browserProcess).pid}`);
    if (__privateGet(this, _browserProcess) && __privateGet(this, _browserProcess).pid && pidExists(__privateGet(this, _browserProcess).pid)) {
      try {
        debugLaunch(`Browser process ${__privateGet(this, _browserProcess).pid} exists`);
        if (process.platform === "win32") {
          try {
            childProcess.execSync(`taskkill /pid ${__privateGet(this, _browserProcess).pid} /T /F`);
          } catch (error) {
            debugLaunch(`Killing ${__privateGet(this, _browserProcess).pid} using taskkill failed`, error);
            __privateGet(this, _browserProcess).kill();
          }
        } else {
          const processGroupId = -__privateGet(this, _browserProcess).pid;
          try {
            process.kill(processGroupId, "SIGKILL");
          } catch (error) {
            debugLaunch(`Killing ${__privateGet(this, _browserProcess).pid} using process.kill failed`, error);
            __privateGet(this, _browserProcess).kill("SIGKILL");
          }
        }
      } catch (error) {
        throw new Error(`${PROCESS_ERROR_EXPLANATION}
Error cause: ${isErrorLike(error) ? error.stack : error}`);
      }
    }
    __privateMethod(this, _clearListeners, clearListeners_fn).call(this);
  }
  waitForLineOutput(regex, timeout2 = 0) {
    if (!__privateGet(this, _browserProcess).stderr) {
      throw new Error("`browserProcess` does not have stderr.");
    }
    const rl = readline.createInterface(__privateGet(this, _browserProcess).stderr);
    let stderr = "";
    return new Promise((resolve2, reject) => {
      rl.on("line", onLine);
      rl.on("close", onClose);
      __privateGet(this, _browserProcess).on("exit", onClose);
      __privateGet(this, _browserProcess).on("error", onClose);
      const timeoutId = timeout2 > 0 ? setTimeout(onTimeout, timeout2) : void 0;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        rl.off("line", onLine);
        rl.off("close", onClose);
        __privateGet(this, _browserProcess).off("exit", onClose);
        __privateGet(this, _browserProcess).off("error", onClose);
      };
      function onClose(error) {
        cleanup();
        reject(new Error([
          `Failed to launch the browser process!${error ? " " + error.message : ""}`,
          stderr,
          "",
          "TROUBLESHOOTING: https://pptr.dev/troubleshooting",
          ""
        ].join("\n")));
      }
      function onTimeout() {
        cleanup();
        reject(new TimeoutError2(`Timed out after ${timeout2} ms while waiting for the WS endpoint URL to appear in stdout!`));
      }
      function onLine(line) {
        stderr += line + "\n";
        const match = line.match(regex);
        if (!match) {
          return;
        }
        cleanup();
        resolve2(match[1]);
      }
    });
  }
}
_executablePath = new WeakMap();
_args3 = new WeakMap();
_browserProcess = new WeakMap();
_exited = new WeakMap();
_hooksRan = new WeakMap();
_onExitHook = new WeakMap();
_browserProcessExiting = new WeakMap();
_runHooks = new WeakSet();
runHooks_fn = async function() {
  if (__privateGet(this, _hooksRan)) {
    return;
  }
  __privateSet(this, _hooksRan, true);
  await __privateGet(this, _onExitHook).call(this);
};
_configureStdio = new WeakSet();
configureStdio_fn = function(opts) {
  if (opts.pipe) {
    if (opts.dumpio) {
      return ["ignore", "pipe", "pipe", "pipe", "pipe"];
    } else {
      return ["ignore", "ignore", "ignore", "pipe", "pipe"];
    }
  } else {
    if (opts.dumpio) {
      return ["pipe", "pipe", "pipe"];
    } else {
      return ["pipe", "ignore", "pipe"];
    }
  }
};
_clearListeners = new WeakSet();
clearListeners_fn = function() {
  unsubscribeFromProcessEvent("exit", __privateGet(this, _onDriverProcessExit));
  unsubscribeFromProcessEvent("SIGINT", __privateGet(this, _onDriverProcessSignal));
  unsubscribeFromProcessEvent("SIGTERM", __privateGet(this, _onDriverProcessSignal));
  unsubscribeFromProcessEvent("SIGHUP", __privateGet(this, _onDriverProcessSignal));
};
_onDriverProcessExit = new WeakMap();
_onDriverProcessSignal = new WeakMap();
const PROCESS_ERROR_EXPLANATION = `Puppeteer was unable to kill the process which ran the browser binary.
This means that, on future Puppeteer launches, Puppeteer might not be able to launch the browser.
Please check your open processes and ensure that the browser processes that Puppeteer launched have been killed.
If you think this is a bug, please report it on the Puppeteer issue tracker.`;
function pidExists(pid) {
  try {
    return process.kill(pid, 0);
  } catch (error) {
    if (isErrnoException(error)) {
      if (error.code && error.code === "ESRCH") {
        return false;
      }
    }
    throw error;
  }
}
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
}
function isErrnoException(obj) {
  return isErrorLike(obj) && ("errno" in obj || "code" in obj || "path" in obj || "syscall" in obj);
}
class TimeoutError2 extends Error {
  /**
   * @internal
   */
  constructor(message2) {
    super(message2);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}
var getStream$1 = { exports: {} };
var once$3 = { exports: {} };
var wrappy_1 = wrappy$1;
function wrappy$1(fn, cb) {
  if (fn && cb)
    return wrappy$1(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k2) {
    wrapper[k2] = fn[k2];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k2) {
        ret[k2] = cb2[k2];
      });
    }
    return ret;
  }
}
var wrappy = wrappy_1;
once$3.exports = wrappy(once$2);
once$3.exports.strict = wrappy(onceStrict);
once$2.proto = once$2(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once$2(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: true
  });
});
function once$2(fn) {
  var f2 = function() {
    if (f2.called)
      return f2.value;
    f2.called = true;
    return f2.value = fn.apply(this, arguments);
  };
  f2.called = false;
  return f2;
}
function onceStrict(fn) {
  var f2 = function() {
    if (f2.called)
      throw new Error(f2.onceError);
    f2.called = true;
    return f2.value = fn.apply(this, arguments);
  };
  var name2 = fn.name || "Function wrapped with `once`";
  f2.onceError = name2 + " shouldn't be called more than once";
  f2.called = false;
  return f2;
}
var onceExports = once$3.exports;
var once$1 = onceExports;
var noop$1 = function() {
};
var isRequest$1 = function(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
};
var isChildProcess = function(stream2) {
  return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
};
var eos$1 = function(stream2, opts, callback) {
  if (typeof opts === "function")
    return eos$1(stream2, null, opts);
  if (!opts)
    opts = {};
  callback = once$1(callback || noop$1);
  var ws = stream2._writableState;
  var rs = stream2._readableState;
  var readable = opts.readable || opts.readable !== false && stream2.readable;
  var writable = opts.writable || opts.writable !== false && stream2.writable;
  var cancelled = false;
  var onlegacyfinish = function() {
    if (!stream2.writable)
      onfinish();
  };
  var onfinish = function() {
    writable = false;
    if (!readable)
      callback.call(stream2);
  };
  var onend = function() {
    readable = false;
    if (!writable)
      callback.call(stream2);
  };
  var onexit = function(exitCode) {
    callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
  };
  var onerror = function(err) {
    callback.call(stream2, err);
  };
  var onclose = function() {
    process.nextTick(onclosenexttick);
  };
  var onclosenexttick = function() {
    if (cancelled)
      return;
    if (readable && !(rs && (rs.ended && !rs.destroyed)))
      return callback.call(stream2, new Error("premature close"));
    if (writable && !(ws && (ws.ended && !ws.destroyed)))
      return callback.call(stream2, new Error("premature close"));
  };
  var onrequest = function() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req)
      onrequest();
    else
      stream2.on("request", onrequest);
  } else if (writable && !ws) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  if (isChildProcess(stream2))
    stream2.on("exit", onexit);
  stream2.on("end", onend);
  stream2.on("finish", onfinish);
  if (opts.error !== false)
    stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    cancelled = true;
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req)
      stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("exit", onexit);
    stream2.removeListener("end", onend);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
};
var endOfStream = eos$1;
var once = onceExports;
var eos = endOfStream;
var fs$4 = fs$o;
var noop = function() {
};
var ancient = /^v?\.0/.test(process.version);
var isFn = function(fn) {
  return typeof fn === "function";
};
var isFS = function(stream2) {
  if (!ancient)
    return false;
  if (!fs$4)
    return false;
  return (stream2 instanceof (fs$4.ReadStream || noop) || stream2 instanceof (fs$4.WriteStream || noop)) && isFn(stream2.close);
};
var isRequest = function(stream2) {
  return stream2.setHeader && isFn(stream2.abort);
};
var destroyer = function(stream2, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  eos(stream2, { readable: reading, writable: writing }, function(err) {
    if (err)
      return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isFS(stream2))
      return stream2.close(noop);
    if (isRequest(stream2))
      return stream2.abort();
    if (isFn(stream2.destroy))
      return stream2.destroy();
    callback(err || new Error("stream was destroyed"));
  };
};
var call = function(fn) {
  fn();
};
var pipe = function(from2, to) {
  return from2.pipe(to);
};
var pump$1 = function() {
  var streams = Array.prototype.slice.call(arguments);
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2)
    throw new Error("pump requires two streams per minimum");
  var error;
  var destroys = streams.map(function(stream2, i2) {
    var reading = i2 < streams.length - 1;
    var writing = i2 > 0;
    return destroyer(stream2, reading, writing, function(err) {
      if (!error)
        error = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
};
var pump_1 = pump$1;
const { PassThrough: PassThroughStream } = require$$0$5;
var bufferStream$1 = (options) => {
  options = { ...options };
  const { array } = options;
  let { encoding } = options;
  const isBuffer2 = encoding === "buffer";
  let objectMode = false;
  if (array) {
    objectMode = !(encoding || isBuffer2);
  } else {
    encoding = encoding || "utf8";
  }
  if (isBuffer2) {
    encoding = null;
  }
  const stream2 = new PassThroughStream({ objectMode });
  if (encoding) {
    stream2.setEncoding(encoding);
  }
  let length = 0;
  const chunks = [];
  stream2.on("data", (chunk) => {
    chunks.push(chunk);
    if (objectMode) {
      length = chunks.length;
    } else {
      length += chunk.length;
    }
  });
  stream2.getBufferedValue = () => {
    if (array) {
      return chunks;
    }
    return isBuffer2 ? Buffer.concat(chunks, length) : chunks.join("");
  };
  stream2.getBufferedLength = () => length;
  return stream2;
};
const { constants: BufferConstants } = require$$0$4;
const pump = pump_1;
const bufferStream = bufferStream$1;
class MaxBufferError extends Error {
  constructor() {
    super("maxBuffer exceeded");
    this.name = "MaxBufferError";
  }
}
async function getStream(inputStream, options) {
  if (!inputStream) {
    return Promise.reject(new Error("Expected a stream"));
  }
  options = {
    maxBuffer: Infinity,
    ...options
  };
  const { maxBuffer } = options;
  let stream2;
  await new Promise((resolve2, reject) => {
    const rejectPromise = (error) => {
      if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
        error.bufferedData = stream2.getBufferedValue();
      }
      reject(error);
    };
    stream2 = pump(inputStream, bufferStream(options), (error) => {
      if (error) {
        rejectPromise(error);
        return;
      }
      resolve2();
    });
    stream2.on("data", () => {
      if (stream2.getBufferedLength() > maxBuffer) {
        rejectPromise(new MaxBufferError());
      }
    });
  });
  return stream2.getBufferedValue();
}
getStream$1.exports = getStream;
getStream$1.exports.default = getStream;
getStream$1.exports.buffer = (stream2, options) => getStream(stream2, { ...options, encoding: "buffer" });
getStream$1.exports.array = (stream2, options) => getStream(stream2, { ...options, array: true });
getStream$1.exports.MaxBufferError = MaxBufferError;
var yauzl$1 = {};
var fdSlicer = {};
var pend = Pend$1;
function Pend$1() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}
Pend$1.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};
Pend$1.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};
Pend$1.prototype.hold = function() {
  return pendHold(this);
};
function pendHold(self2) {
  self2.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called)
      throw new Error("callback called twice");
    called = true;
    self2.error = self2.error || err;
    self2.pending -= 1;
    if (self2.waiting.length > 0 && self2.pending < self2.max) {
      pendGo(self2, self2.waiting.shift());
    } else if (self2.pending === 0) {
      var listeners = self2.listeners;
      self2.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self2.error);
  }
}
function pendGo(self2, fn) {
  fn(pendHold(self2));
}
var fs$3 = fs$o;
var util$2 = require$$4;
var stream$1 = require$$0$5;
var Readable = stream$1.Readable;
var Writable$1 = stream$1.Writable;
var PassThrough$1 = stream$1.PassThrough;
var Pend = pend;
var EventEmitter$1 = require$$3$2.EventEmitter;
fdSlicer.createFromBuffer = createFromBuffer;
fdSlicer.createFromFd = createFromFd;
fdSlicer.BufferSlicer = BufferSlicer;
fdSlicer.FdSlicer = FdSlicer;
util$2.inherits(FdSlicer, EventEmitter$1);
function FdSlicer(fd, options) {
  options = options || {};
  EventEmitter$1.call(this);
  this.fd = fd;
  this.pend = new Pend();
  this.pend.max = 1;
  this.refCount = 0;
  this.autoClose = !!options.autoClose;
}
FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var self2 = this;
  self2.pend.go(function(cb) {
    fs$3.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
      cb();
      callback(err, bytesRead, buffer2);
    });
  });
};
FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  var self2 = this;
  self2.pend.go(function(cb) {
    fs$3.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
      cb();
      callback(err, written, buffer2);
    });
  });
};
FdSlicer.prototype.createReadStream = function(options) {
  return new ReadStream(this, options);
};
FdSlicer.prototype.createWriteStream = function(options) {
  return new WriteStream(this, options);
};
FdSlicer.prototype.ref = function() {
  this.refCount += 1;
};
FdSlicer.prototype.unref = function() {
  var self2 = this;
  self2.refCount -= 1;
  if (self2.refCount > 0)
    return;
  if (self2.refCount < 0)
    throw new Error("invalid unref");
  if (self2.autoClose) {
    fs$3.close(self2.fd, onCloseDone);
  }
  function onCloseDone(err) {
    if (err) {
      self2.emit("error", err);
    } else {
      self2.emit("close");
    }
  }
};
util$2.inherits(ReadStream, Readable);
function ReadStream(context2, options) {
  options = options || {};
  Readable.call(this, options);
  this.context = context2;
  this.context.ref();
  this.start = options.start || 0;
  this.endOffset = options.end;
  this.pos = this.start;
  this.destroyed = false;
}
ReadStream.prototype._read = function(n2) {
  var self2 = this;
  if (self2.destroyed)
    return;
  var toRead = Math.min(self2._readableState.highWaterMark, n2);
  if (self2.endOffset != null) {
    toRead = Math.min(toRead, self2.endOffset - self2.pos);
  }
  if (toRead <= 0) {
    self2.destroyed = true;
    self2.push(null);
    self2.context.unref();
    return;
  }
  self2.context.pend.go(function(cb) {
    if (self2.destroyed)
      return cb();
    var buffer = new Buffer(toRead);
    fs$3.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
      if (err) {
        self2.destroy(err);
      } else if (bytesRead === 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
      } else {
        self2.pos += bytesRead;
        self2.push(buffer.slice(0, bytesRead));
      }
      cb();
    });
  });
};
ReadStream.prototype.destroy = function(err) {
  if (this.destroyed)
    return;
  err = err || new Error("stream destroyed");
  this.destroyed = true;
  this.emit("error", err);
  this.context.unref();
};
util$2.inherits(WriteStream, Writable$1);
function WriteStream(context2, options) {
  options = options || {};
  Writable$1.call(this, options);
  this.context = context2;
  this.context.ref();
  this.start = options.start || 0;
  this.endOffset = options.end == null ? Infinity : +options.end;
  this.bytesWritten = 0;
  this.pos = this.start;
  this.destroyed = false;
  this.on("finish", this.destroy.bind(this));
}
WriteStream.prototype._write = function(buffer, encoding, callback) {
  var self2 = this;
  if (self2.destroyed)
    return;
  if (self2.pos + buffer.length > self2.endOffset) {
    var err = new Error("maximum file length exceeded");
    err.code = "ETOOBIG";
    self2.destroy();
    callback(err);
    return;
  }
  self2.context.pend.go(function(cb) {
    if (self2.destroyed)
      return cb();
    fs$3.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
      if (err2) {
        self2.destroy();
        cb();
        callback(err2);
      } else {
        self2.bytesWritten += bytes;
        self2.pos += bytes;
        self2.emit("progress");
        cb();
        callback();
      }
    });
  });
};
WriteStream.prototype.destroy = function() {
  if (this.destroyed)
    return;
  this.destroyed = true;
  this.context.unref();
};
util$2.inherits(BufferSlicer, EventEmitter$1);
function BufferSlicer(buffer, options) {
  EventEmitter$1.call(this);
  options = options || {};
  this.refCount = 0;
  this.buffer = buffer;
  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
}
BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
  var end = position + length;
  var delta = end - this.buffer.length;
  var written = delta > 0 ? delta : length;
  this.buffer.copy(buffer, offset, position, end);
  setImmediate(function() {
    callback(null, written);
  });
};
BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
  buffer.copy(this.buffer, position, offset, offset + length);
  setImmediate(function() {
    callback(null, length, buffer);
  });
};
BufferSlicer.prototype.createReadStream = function(options) {
  options = options || {};
  var readStream = new PassThrough$1(options);
  readStream.destroyed = false;
  readStream.start = options.start || 0;
  readStream.endOffset = options.end;
  readStream.pos = readStream.endOffset || this.buffer.length;
  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
  var offset = 0;
  while (true) {
    var nextOffset = offset + this.maxChunkSize;
    if (nextOffset >= entireSlice.length) {
      if (offset < entireSlice.length) {
        readStream.write(entireSlice.slice(offset, entireSlice.length));
      }
      break;
    }
    readStream.write(entireSlice.slice(offset, nextOffset));
    offset = nextOffset;
  }
  readStream.end();
  readStream.destroy = function() {
    readStream.destroyed = true;
  };
  return readStream;
};
BufferSlicer.prototype.createWriteStream = function(options) {
  var bufferSlicer = this;
  options = options || {};
  var writeStream = new Writable$1(options);
  writeStream.start = options.start || 0;
  writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
  writeStream.bytesWritten = 0;
  writeStream.pos = writeStream.start;
  writeStream.destroyed = false;
  writeStream._write = function(buffer, encoding, callback) {
    if (writeStream.destroyed)
      return;
    var end = writeStream.pos + buffer.length;
    if (end > writeStream.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      writeStream.destroyed = true;
      callback(err);
      return;
    }
    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
    writeStream.bytesWritten += buffer.length;
    writeStream.pos = end;
    writeStream.emit("progress");
    callback();
  };
  writeStream.destroy = function() {
    writeStream.destroyed = true;
  };
  return writeStream;
};
BufferSlicer.prototype.ref = function() {
  this.refCount += 1;
};
BufferSlicer.prototype.unref = function() {
  this.refCount -= 1;
  if (this.refCount < 0) {
    throw new Error("invalid unref");
  }
};
function createFromBuffer(buffer, options) {
  return new BufferSlicer(buffer, options);
}
function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}
var Buffer$1 = require$$0$4.Buffer;
var CRC_TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}
function ensureBuffer(input) {
  if (Buffer$1.isBuffer(input)) {
    return input;
  }
  var hasNewBufferAPI = typeof Buffer$1.alloc === "function" && typeof Buffer$1.from === "function";
  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer$1.alloc(input) : new Buffer$1(input);
  } else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer$1.from(input) : new Buffer$1(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
}
function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}
function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer$1.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n2 = 0; n2 < buf.length; n2++) {
    crc = CRC_TABLE[(crc ^ buf[n2]) & 255] ^ crc >>> 8;
  }
  return crc ^ -1;
}
function crc32$1() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32$1.signed = function() {
  return _crc32.apply(null, arguments);
};
crc32$1.unsigned = function() {
  return _crc32.apply(null, arguments) >>> 0;
};
var bufferCrc32 = crc32$1;
var fs$2 = fs$o;
var zlib = require$$1$2;
var fd_slicer = fdSlicer;
var crc32 = bufferCrc32;
var util$1 = require$$4;
var EventEmitter = require$$3$2.EventEmitter;
var Transform = require$$0$5.Transform;
var PassThrough = require$$0$5.PassThrough;
var Writable = require$$0$5.Writable;
yauzl$1.open = open;
yauzl$1.fromFd = fromFd;
yauzl$1.fromBuffer = fromBuffer;
yauzl$1.fromRandomAccessReader = fromRandomAccessReader;
yauzl$1.dosDateTimeToDate = dosDateTimeToDate;
yauzl$1.validateFileName = validateFileName;
yauzl$1.ZipFile = ZipFile;
yauzl$1.Entry = Entry2;
yauzl$1.RandomAccessReader = RandomAccessReader;
function open(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null)
    options = {};
  if (options.autoClose == null)
    options.autoClose = true;
  if (options.lazyEntries == null)
    options.lazyEntries = false;
  if (options.decodeStrings == null)
    options.decodeStrings = true;
  if (options.validateEntrySizes == null)
    options.validateEntrySizes = true;
  if (options.strictFileNames == null)
    options.strictFileNames = false;
  if (callback == null)
    callback = defaultCallback;
  fs$2.open(path2, "r", function(err, fd) {
    if (err)
      return callback(err);
    fromFd(fd, options, function(err2, zipfile) {
      if (err2)
        fs$2.close(fd, defaultCallback);
      callback(err2, zipfile);
    });
  });
}
function fromFd(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null)
    options = {};
  if (options.autoClose == null)
    options.autoClose = false;
  if (options.lazyEntries == null)
    options.lazyEntries = false;
  if (options.decodeStrings == null)
    options.decodeStrings = true;
  if (options.validateEntrySizes == null)
    options.validateEntrySizes = true;
  if (options.strictFileNames == null)
    options.strictFileNames = false;
  if (callback == null)
    callback = defaultCallback;
  fs$2.fstat(fd, function(err, stats) {
    if (err)
      return callback(err);
    var reader = fd_slicer.createFromFd(fd, { autoClose: true });
    fromRandomAccessReader(reader, stats.size, options, callback);
  });
}
function fromBuffer(buffer, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null)
    options = {};
  options.autoClose = false;
  if (options.lazyEntries == null)
    options.lazyEntries = false;
  if (options.decodeStrings == null)
    options.decodeStrings = true;
  if (options.validateEntrySizes == null)
    options.validateEntrySizes = true;
  if (options.strictFileNames == null)
    options.strictFileNames = false;
  var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
  fromRandomAccessReader(reader, buffer.length, options, callback);
}
function fromRandomAccessReader(reader, totalSize, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null)
    options = {};
  if (options.autoClose == null)
    options.autoClose = true;
  if (options.lazyEntries == null)
    options.lazyEntries = false;
  if (options.decodeStrings == null)
    options.decodeStrings = true;
  var decodeStrings = !!options.decodeStrings;
  if (options.validateEntrySizes == null)
    options.validateEntrySizes = true;
  if (options.strictFileNames == null)
    options.strictFileNames = false;
  if (callback == null)
    callback = defaultCallback;
  if (typeof totalSize !== "number")
    throw new Error("expected totalSize parameter to be a number");
  if (totalSize > Number.MAX_SAFE_INTEGER) {
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
  }
  reader.ref();
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 65535;
  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
  var buffer = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer.length;
  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
    if (err)
      return callback(err);
    for (var i2 = bufferSize - eocdrWithoutCommentSize; i2 >= 0; i2 -= 1) {
      if (buffer.readUInt32LE(i2) !== 101010256)
        continue;
      var eocdrBuffer = buffer.slice(i2);
      var diskNumber = eocdrBuffer.readUInt16LE(4);
      if (diskNumber !== 0) {
        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
      }
      var entryCount = eocdrBuffer.readUInt16LE(10);
      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
      var commentLength = eocdrBuffer.readUInt16LE(20);
      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
      if (commentLength !== expectedCommentLength) {
        return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
      }
      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
      if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
      }
      var zip64EocdlBuffer = newBuffer(20);
      var zip64EocdlOffset = bufferReadStart + i2 - zip64EocdlBuffer.length;
      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
        if (err2)
          return callback(err2);
        if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
          return callback(new Error("invalid zip64 end of central directory locator signature"));
        }
        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
        var zip64EocdrBuffer = newBuffer(56);
        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
          if (err3)
            return callback(err3);
          if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
            return callback(new Error("invalid zip64 end of central directory record signature"));
          }
          entryCount = readUInt64LE(zip64EocdrBuffer, 32);
          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        });
      });
      return;
    }
    callback(new Error("end of central directory record signature not found"));
  });
}
util$1.inherits(ZipFile, EventEmitter);
function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
  var self2 = this;
  EventEmitter.call(self2);
  self2.reader = reader;
  self2.reader.on("error", function(err) {
    emitError(self2, err);
  });
  self2.reader.once("close", function() {
    self2.emit("close");
  });
  self2.readEntryCursor = centralDirectoryOffset;
  self2.fileSize = fileSize;
  self2.entryCount = entryCount;
  self2.comment = comment;
  self2.entriesRead = 0;
  self2.autoClose = !!autoClose;
  self2.lazyEntries = !!lazyEntries;
  self2.decodeStrings = !!decodeStrings;
  self2.validateEntrySizes = !!validateEntrySizes;
  self2.strictFileNames = !!strictFileNames;
  self2.isOpen = true;
  self2.emittedError = false;
  if (!self2.lazyEntries)
    self2._readEntry();
}
ZipFile.prototype.close = function() {
  if (!this.isOpen)
    return;
  this.isOpen = false;
  this.reader.unref();
};
function emitErrorAndAutoClose(self2, err) {
  if (self2.autoClose)
    self2.close();
  emitError(self2, err);
}
function emitError(self2, err) {
  if (self2.emittedError)
    return;
  self2.emittedError = true;
  self2.emit("error", err);
}
ZipFile.prototype.readEntry = function() {
  if (!this.lazyEntries)
    throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
ZipFile.prototype._readEntry = function() {
  var self2 = this;
  if (self2.entryCount === self2.entriesRead) {
    setImmediate(function() {
      if (self2.autoClose)
        self2.close();
      if (self2.emittedError)
        return;
      self2.emit("end");
    });
    return;
  }
  if (self2.emittedError)
    return;
  var buffer = newBuffer(46);
  readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
    if (err)
      return emitErrorAndAutoClose(self2, err);
    if (self2.emittedError)
      return;
    var entry = new Entry2();
    var signature = buffer.readUInt32LE(0);
    if (signature !== 33639248)
      return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
    entry.versionMadeBy = buffer.readUInt16LE(4);
    entry.versionNeededToExtract = buffer.readUInt16LE(6);
    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
    entry.compressionMethod = buffer.readUInt16LE(10);
    entry.lastModFileTime = buffer.readUInt16LE(12);
    entry.lastModFileDate = buffer.readUInt16LE(14);
    entry.crc32 = buffer.readUInt32LE(16);
    entry.compressedSize = buffer.readUInt32LE(20);
    entry.uncompressedSize = buffer.readUInt32LE(24);
    entry.fileNameLength = buffer.readUInt16LE(28);
    entry.extraFieldLength = buffer.readUInt16LE(30);
    entry.fileCommentLength = buffer.readUInt16LE(32);
    entry.internalFileAttributes = buffer.readUInt16LE(36);
    entry.externalFileAttributes = buffer.readUInt32LE(38);
    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
    if (entry.generalPurposeBitFlag & 64)
      return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
    self2.readEntryCursor += 46;
    buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
    readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
      if (err2)
        return emitErrorAndAutoClose(self2, err2);
      if (self2.emittedError)
        return;
      var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
      entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
      entry.extraFields = [];
      var i2 = 0;
      while (i2 < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i2 + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i2 + 2);
        var dataStart = i2 + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length)
          return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
        var dataBuffer = newBuffer(dataSize);
        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
        entry.extraFields.push({
          id: headerId,
          data: dataBuffer
        });
        i2 = dataEnd;
      }
      entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
      entry.comment = entry.fileComment;
      self2.readEntryCursor += buffer.length;
      self2.entriesRead += 1;
      if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
        var zip64EiefBuffer = null;
        for (var i2 = 0; i2 < entry.extraFields.length; i2++) {
          var extraField = entry.extraFields[i2];
          if (extraField.id === 1) {
            zip64EiefBuffer = extraField.data;
            break;
          }
        }
        if (zip64EiefBuffer == null) {
          return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
        }
        var index2 = 0;
        if (entry.uncompressedSize === 4294967295) {
          if (index2 + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
          }
          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index2);
          index2 += 8;
        }
        if (entry.compressedSize === 4294967295) {
          if (index2 + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
          }
          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index2);
          index2 += 8;
        }
        if (entry.relativeOffsetOfLocalHeader === 4294967295) {
          if (index2 + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
          }
          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index2);
          index2 += 8;
        }
      }
      if (self2.decodeStrings) {
        for (var i2 = 0; i2 < entry.extraFields.length; i2++) {
          var extraField = entry.extraFields[i2];
          if (extraField.id === 28789) {
            if (extraField.data.length < 6) {
              continue;
            }
            if (extraField.data.readUInt8(0) !== 1) {
              continue;
            }
            var oldNameCrc32 = extraField.data.readUInt32LE(1);
            if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
              continue;
            }
            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
            break;
          }
        }
      }
      if (self2.validateEntrySizes && entry.compressionMethod === 0) {
        var expectedCompressedSize = entry.uncompressedSize;
        if (entry.isEncrypted()) {
          expectedCompressedSize += 12;
        }
        if (entry.compressedSize !== expectedCompressedSize) {
          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
          return emitErrorAndAutoClose(self2, new Error(msg));
        }
      }
      if (self2.decodeStrings) {
        if (!self2.strictFileNames) {
          entry.fileName = entry.fileName.replace(/\\/g, "/");
        }
        var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
        if (errorMessage != null)
          return emitErrorAndAutoClose(self2, new Error(errorMessage));
      }
      self2.emit("entry", entry);
      if (!self2.lazyEntries)
        self2._readEntry();
    });
  });
};
ZipFile.prototype.openReadStream = function(entry, options, callback) {
  var self2 = this;
  var relativeStart = 0;
  var relativeEnd = entry.compressedSize;
  if (callback == null) {
    callback = options;
    options = {};
  } else {
    if (options.decrypt != null) {
      if (!entry.isEncrypted()) {
        throw new Error("options.decrypt can only be specified for encrypted entries");
      }
      if (options.decrypt !== false)
        throw new Error("invalid options.decrypt value: " + options.decrypt);
      if (entry.isCompressed()) {
        if (options.decompress !== false)
          throw new Error("entry is encrypted and compressed, and options.decompress !== false");
      }
    }
    if (options.decompress != null) {
      if (!entry.isCompressed()) {
        throw new Error("options.decompress can only be specified for compressed entries");
      }
      if (!(options.decompress === false || options.decompress === true)) {
        throw new Error("invalid options.decompress value: " + options.decompress);
      }
    }
    if (options.start != null || options.end != null) {
      if (entry.isCompressed() && options.decompress !== false) {
        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
      }
      if (entry.isEncrypted() && options.decrypt !== false) {
        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
      }
    }
    if (options.start != null) {
      relativeStart = options.start;
      if (relativeStart < 0)
        throw new Error("options.start < 0");
      if (relativeStart > entry.compressedSize)
        throw new Error("options.start > entry.compressedSize");
    }
    if (options.end != null) {
      relativeEnd = options.end;
      if (relativeEnd < 0)
        throw new Error("options.end < 0");
      if (relativeEnd > entry.compressedSize)
        throw new Error("options.end > entry.compressedSize");
      if (relativeEnd < relativeStart)
        throw new Error("options.end < options.start");
    }
  }
  if (!self2.isOpen)
    return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false)
      return callback(new Error("entry is encrypted, and options.decrypt !== false"));
  }
  self2.reader.ref();
  var buffer = newBuffer(30);
  readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
    try {
      if (err)
        return callback(err);
      var signature = buffer.readUInt32LE(0);
      if (signature !== 67324752) {
        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
      }
      var fileNameLength = buffer.readUInt16LE(26);
      var extraFieldLength = buffer.readUInt16LE(28);
      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
      var decompress;
      if (entry.compressionMethod === 0) {
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        decompress = options.decompress != null ? options.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      var fileDataStart = localFileHeaderEnd;
      var fileDataEnd = fileDataStart + entry.compressedSize;
      if (entry.compressedSize !== 0) {
        if (fileDataEnd > self2.fileSize) {
          return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
        }
      }
      var readStream = self2.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err2) {
          setImmediate(function() {
            if (!destroyed)
              inflateFilter.emit("error", err2);
          });
        });
        readStream.pipe(inflateFilter);
        if (self2.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(entry.uncompressedSize);
          inflateFilter.on("error", function(err2) {
            setImmediate(function() {
              if (!destroyed)
                endpointStream.emit("error", err2);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          endpointStream = inflateFilter;
        }
        endpointStream.destroy = function() {
          destroyed = true;
          if (inflateFilter !== endpointStream)
            inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          readStream.destroy();
        };
      }
      callback(null, endpointStream);
    } finally {
      self2.reader.unref();
    }
  });
};
function Entry2() {
}
Entry2.prototype.getLastModDate = function() {
  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry2.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 1) !== 0;
};
Entry2.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};
function dosDateTimeToDate(date, time) {
  var day = date & 31;
  var month = (date >> 5 & 15) - 1;
  var year = (date >> 9 & 127) + 1980;
  var millisecond = 0;
  var second = (time & 31) * 2;
  var minute = time >> 5 & 63;
  var hour = time >> 11 & 31;
  return new Date(year, month, day, hour, minute, second, millisecond);
}
function validateFileName(fileName) {
  if (fileName.indexOf("\\") !== -1) {
    return "invalid characters in fileName: " + fileName;
  }
  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
    return "absolute path: " + fileName;
  }
  if (fileName.split("/").indexOf("..") !== -1) {
    return "invalid relative path: " + fileName;
  }
  return null;
}
function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
  if (length === 0) {
    return setImmediate(function() {
      callback(null, newBuffer(0));
    });
  }
  reader.read(buffer, offset, length, position, function(err, bytesRead) {
    if (err)
      return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
  });
}
util$1.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
  Transform.call(this);
  this.actualByteCount = 0;
  this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
  this.actualByteCount += chunk.length;
  if (this.actualByteCount > this.expectedByteCount) {
    var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb(null, chunk);
};
AssertByteCountStream.prototype._flush = function(cb) {
  if (this.actualByteCount < this.expectedByteCount) {
    var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb();
};
util$1.inherits(RandomAccessReader, EventEmitter);
function RandomAccessReader() {
  EventEmitter.call(this);
  this.refCount = 0;
}
RandomAccessReader.prototype.ref = function() {
  this.refCount += 1;
};
RandomAccessReader.prototype.unref = function() {
  var self2 = this;
  self2.refCount -= 1;
  if (self2.refCount > 0)
    return;
  if (self2.refCount < 0)
    throw new Error("invalid unref");
  self2.close(onCloseDone);
  function onCloseDone(err) {
    if (err)
      return self2.emit("error", err);
    self2.emit("close");
  }
};
RandomAccessReader.prototype.createReadStream = function(options) {
  var start = options.start;
  var end = options.end;
  if (start === end) {
    var emptyStream = new PassThrough();
    setImmediate(function() {
      emptyStream.end();
    });
    return emptyStream;
  }
  var stream2 = this._readStreamForRange(start, end);
  var destroyed = false;
  var refUnrefFilter = new RefUnrefFilter(this);
  stream2.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed)
        refUnrefFilter.emit("error", err);
    });
  });
  refUnrefFilter.destroy = function() {
    stream2.unpipe(refUnrefFilter);
    refUnrefFilter.unref();
    stream2.destroy();
  };
  var byteCounter = new AssertByteCountStream(end - start);
  refUnrefFilter.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed)
        byteCounter.emit("error", err);
    });
  });
  byteCounter.destroy = function() {
    destroyed = true;
    refUnrefFilter.unpipe(byteCounter);
    refUnrefFilter.destroy();
  };
  return stream2.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function(start, end) {
  throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
  var readStream = this.createReadStream({ start: position, end: position + length });
  var writeStream = new Writable();
  var written = 0;
  writeStream._write = function(chunk, encoding, cb) {
    chunk.copy(buffer, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream.on("error", function(error) {
    callback(error);
  });
  readStream.pipe(writeStream);
};
RandomAccessReader.prototype.close = function(callback) {
  setImmediate(callback);
};
util$1.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context2) {
  PassThrough.call(this);
  this.context = context2;
  this.context.ref();
  this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function(cb) {
  this.unref();
  cb();
};
RefUnrefFilter.prototype.unref = function(cb) {
  if (this.unreffedYet)
    return;
  this.unreffedYet = true;
  this.context.unref();
};
var cp437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function decodeBuffer(buffer, start, end, isUtf8) {
  if (isUtf8) {
    return buffer.toString("utf8", start, end);
  } else {
    var result = "";
    for (var i2 = start; i2 < end; i2++) {
      result += cp437[buffer[i2]];
    }
    return result;
  }
}
function readUInt64LE(buffer, offset) {
  var lower32 = buffer.readUInt32LE(offset);
  var upper32 = buffer.readUInt32LE(offset + 4);
  return upper32 * 4294967296 + lower32;
}
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function(len) {
    return new Buffer(len);
  };
}
function defaultCallback(err) {
  if (err)
    throw err;
}
srcExports("extract-zip");
const { promisify } = require$$4;
const stream = require$$0$5;
const yauzl = yauzl$1;
promisify(yauzl.open);
promisify(stream.pipeline);
var queueMicrotask_1;
var hasRequiredQueueMicrotask;
function requireQueueMicrotask() {
  if (hasRequiredQueueMicrotask)
    return queueMicrotask_1;
  hasRequiredQueueMicrotask = 1;
  queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  return queueMicrotask_1;
}
typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : requireQueueMicrotask();
function isBuffer(value) {
  return Buffer.isBuffer(value) || value instanceof Uint8Array;
}
function isEncoding(encoding) {
  return Buffer.isEncoding(encoding);
}
function alloc(size, fill2, encoding) {
  return Buffer.alloc(size, fill2, encoding);
}
function allocUnsafe(size) {
  return Buffer.allocUnsafe(size);
}
function allocUnsafeSlow(size) {
  return Buffer.allocUnsafeSlow(size);
}
function byteLength(string, encoding) {
  return Buffer.byteLength(string, encoding);
}
function compare(a2, b2) {
  return Buffer.compare(a2, b2);
}
function concat(buffers, totalLength) {
  return Buffer.concat(buffers, totalLength);
}
function copy(source2, target, targetStart, start, end) {
  return toBuffer(source2).copy(target, targetStart, start, end);
}
function equals(a2, b2) {
  return toBuffer(a2).equals(b2);
}
function fill(buffer, value, offset, end, encoding) {
  return toBuffer(buffer).fill(value, offset, end, encoding);
}
function from(value, encodingOrOffset, length) {
  return Buffer.from(value, encodingOrOffset, length);
}
function includes(buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).includes(value, byteOffset, encoding);
}
function indexOf(buffer, value, byfeOffset, encoding) {
  return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
}
function lastIndexOf(buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
}
function swap16(buffer) {
  return toBuffer(buffer).swap16();
}
function swap32(buffer) {
  return toBuffer(buffer).swap32();
}
function swap64(buffer) {
  return toBuffer(buffer).swap64();
}
function toBuffer(buffer) {
  if (Buffer.isBuffer(buffer))
    return buffer;
  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
function toString(buffer, encoding, start, end) {
  return toBuffer(buffer).toString(encoding, start, end);
}
function write(buffer, string, offset, length, encoding) {
  return toBuffer(buffer).write(string, offset, length, encoding);
}
function writeDoubleLE(buffer, value, offset) {
  return toBuffer(buffer).writeDoubleLE(value, offset);
}
function writeFloatLE(buffer, value, offset) {
  return toBuffer(buffer).writeFloatLE(value, offset);
}
function writeUInt32LE(buffer, value, offset) {
  return toBuffer(buffer).writeUInt32LE(value, offset);
}
function writeInt32LE(buffer, value, offset) {
  return toBuffer(buffer).writeInt32LE(value, offset);
}
function readDoubleLE(buffer, offset) {
  return toBuffer(buffer).readDoubleLE(offset);
}
function readFloatLE(buffer, offset) {
  return toBuffer(buffer).readFloatLE(offset);
}
function readUInt32LE(buffer, offset) {
  return toBuffer(buffer).readUInt32LE(offset);
}
function readInt32LE(buffer, offset) {
  return toBuffer(buffer).readInt32LE(offset);
}
var b4a$3 = {
  isBuffer,
  isEncoding,
  alloc,
  allocUnsafe,
  allocUnsafeSlow,
  byteLength,
  compare,
  concat,
  copy,
  equals,
  fill,
  from,
  includes,
  indexOf,
  lastIndexOf,
  swap16,
  swap32,
  swap64,
  toBuffer,
  toString,
  write,
  writeDoubleLE,
  writeFloatLE,
  writeUInt32LE,
  writeInt32LE,
  readDoubleLE,
  readFloatLE,
  readUInt32LE,
  readInt32LE
};
const b4a$2 = b4a$3;
const ZERO_OFFSET = "0".charCodeAt(0);
b4a$2.from([117, 115, 116, 97, 114, 0]);
b4a$2.from([ZERO_OFFSET, ZERO_OFFSET]);
b4a$2.from([117, 115, 116, 97, 114, 32]);
b4a$2.from([32, 0]);
const b4a$1 = b4a$3;
b4a$1.alloc(0);
var constants$1 = { exports: {} };
const constants = {
  // just for envs without fs
  S_IFMT: 61440,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960
};
try {
  constants$1.exports = require("fs").constants || constants;
} catch {
  constants$1.exports = constants;
}
const b4a = b4a$3;
b4a.alloc(1024);
(((_g = commonjsGlobal.Bare) == null ? void 0 : _g.platform) || process.platform) === "win32";
var through = { exports: {} };
(function(module2, exports2) {
  var Stream2 = require$$0$5;
  module2.exports = through2;
  through2.through = through2;
  function through2(write2, end, opts) {
    write2 = write2 || function(data2) {
      this.queue(data2);
    };
    end = end || function() {
      this.queue(null);
    };
    var ended = false, destroyed = false, buffer = [], _ended = false;
    var stream2 = new Stream2();
    stream2.readable = stream2.writable = true;
    stream2.paused = false;
    stream2.autoDestroy = !(opts && opts.autoDestroy === false);
    stream2.write = function(data2) {
      write2.call(this, data2);
      return !stream2.paused;
    };
    function drain() {
      while (buffer.length && !stream2.paused) {
        var data2 = buffer.shift();
        if (null === data2)
          return stream2.emit("end");
        else
          stream2.emit("data", data2);
      }
    }
    stream2.queue = stream2.push = function(data2) {
      if (_ended)
        return stream2;
      if (data2 === null)
        _ended = true;
      buffer.push(data2);
      drain();
      return stream2;
    };
    stream2.on("end", function() {
      stream2.readable = false;
      if (!stream2.writable && stream2.autoDestroy)
        process.nextTick(function() {
          stream2.destroy();
        });
    });
    function _end() {
      stream2.writable = false;
      end.call(stream2);
      if (!stream2.readable && stream2.autoDestroy)
        stream2.destroy();
    }
    stream2.end = function(data2) {
      if (ended)
        return;
      ended = true;
      if (arguments.length)
        stream2.write(data2);
      _end();
      return stream2;
    };
    stream2.destroy = function() {
      if (destroyed)
        return;
      destroyed = true;
      ended = true;
      buffer.length = 0;
      stream2.writable = stream2.readable = false;
      stream2.emit("close");
      return stream2;
    };
    stream2.pause = function() {
      if (stream2.paused)
        return;
      stream2.paused = true;
      return stream2;
    };
    stream2.resume = function() {
      if (stream2.paused) {
        stream2.paused = false;
        stream2.emit("resume");
      }
      drain();
      if (!stream2.paused)
        stream2.emit("drain");
      return stream2;
    };
    return stream2;
  }
})(through);
function Bzip2Error(message2) {
  this.name = "Bzip2Error";
  this.message = message2;
  this.stack = new Error().stack;
}
Bzip2Error.prototype = new Error();
var message = {
  Error: function(message2) {
    throw new Bzip2Error(message2);
  }
};
var bzip2 = {};
bzip2.Bzip2Error = Bzip2Error;
bzip2.crcTable = [
  0,
  79764919,
  159529838,
  222504665,
  319059676,
  398814059,
  445009330,
  507990021,
  638119352,
  583659535,
  797628118,
  726387553,
  890018660,
  835552979,
  1015980042,
  944750013,
  1276238704,
  1221641927,
  1167319070,
  1095957929,
  1595256236,
  1540665371,
  1452775106,
  1381403509,
  1780037320,
  1859660671,
  1671105958,
  1733955601,
  2031960084,
  2111593891,
  1889500026,
  1952343757,
  2552477408,
  2632100695,
  2443283854,
  2506133561,
  2334638140,
  2414271883,
  2191915858,
  2254759653,
  3190512472,
  3135915759,
  3081330742,
  3009969537,
  2905550212,
  2850959411,
  2762807018,
  2691435357,
  3560074640,
  3505614887,
  3719321342,
  3648080713,
  3342211916,
  3287746299,
  3467911202,
  3396681109,
  4063920168,
  4143685023,
  4223187782,
  4286162673,
  3779000052,
  3858754371,
  3904687514,
  3967668269,
  881225847,
  809987520,
  1023691545,
  969234094,
  662832811,
  591600412,
  771767749,
  717299826,
  311336399,
  374308984,
  453813921,
  533576470,
  25881363,
  88864420,
  134795389,
  214552010,
  2023205639,
  2086057648,
  1897238633,
  1976864222,
  1804852699,
  1867694188,
  1645340341,
  1724971778,
  1587496639,
  1516133128,
  1461550545,
  1406951526,
  1302016099,
  1230646740,
  1142491917,
  1087903418,
  2896545431,
  2825181984,
  2770861561,
  2716262478,
  3215044683,
  3143675388,
  3055782693,
  3001194130,
  2326604591,
  2389456536,
  2200899649,
  2280525302,
  2578013683,
  2640855108,
  2418763421,
  2498394922,
  3769900519,
  3832873040,
  3912640137,
  3992402750,
  4088425275,
  4151408268,
  4197601365,
  4277358050,
  3334271071,
  3263032808,
  3476998961,
  3422541446,
  3585640067,
  3514407732,
  3694837229,
  3640369242,
  1762451694,
  1842216281,
  1619975040,
  1682949687,
  2047383090,
  2127137669,
  1938468188,
  2001449195,
  1325665622,
  1271206113,
  1183200824,
  1111960463,
  1543535498,
  1489069629,
  1434599652,
  1363369299,
  622672798,
  568075817,
  748617968,
  677256519,
  907627842,
  853037301,
  1067152940,
  995781531,
  51762726,
  131386257,
  177728840,
  240578815,
  269590778,
  349224269,
  429104020,
  491947555,
  4046411278,
  4126034873,
  4172115296,
  4234965207,
  3794477266,
  3874110821,
  3953728444,
  4016571915,
  3609705398,
  3555108353,
  3735388376,
  3664026991,
  3290680682,
  3236090077,
  3449943556,
  3378572211,
  3174993278,
  3120533705,
  3032266256,
  2961025959,
  2923101090,
  2868635157,
  2813903052,
  2742672763,
  2604032198,
  2683796849,
  2461293480,
  2524268063,
  2284983834,
  2364738477,
  2175806836,
  2238787779,
  1569362073,
  1498123566,
  1409854455,
  1355396672,
  1317987909,
  1246755826,
  1192025387,
  1137557660,
  2072149281,
  2135122070,
  1912620623,
  1992383480,
  1753615357,
  1816598090,
  1627664531,
  1707420964,
  295390185,
  358241886,
  404320391,
  483945776,
  43990325,
  106832002,
  186451547,
  266083308,
  932423249,
  861060070,
  1041341759,
  986742920,
  613929101,
  542559546,
  756411363,
  701822548,
  3316196985,
  3244833742,
  3425377559,
  3370778784,
  3601682597,
  3530312978,
  3744426955,
  3689838204,
  3819031489,
  3881883254,
  3928223919,
  4007849240,
  4037393693,
  4100235434,
  4180117107,
  4259748804,
  2310601993,
  2373574846,
  2151335527,
  2231098320,
  2596047829,
  2659030626,
  2470359227,
  2550115596,
  2947551409,
  2876312838,
  2788305887,
  2733848168,
  3165939309,
  3094707162,
  3040238851,
  2985771188
];
bzip2.array = function(bytes) {
  var bit = 0, byte = 0;
  var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
  return function(n2) {
    var result = 0;
    while (n2 > 0) {
      var left2 = 8 - bit;
      if (n2 >= left2) {
        result <<= left2;
        result |= BITMASK[left2] & bytes[byte++];
        bit = 0;
        n2 -= left2;
      } else {
        result <<= n2;
        result |= (bytes[byte] & BITMASK[n2] << 8 - n2 - bit) >> 8 - n2 - bit;
        bit += n2;
        n2 = 0;
      }
    }
    return result;
  };
};
bzip2.simple = function(srcbuffer, stream2) {
  var bits = bzip2.array(srcbuffer);
  var size = bzip2.header(bits);
  var ret = false;
  var bufsize = 1e5 * size;
  var buf = new Int32Array(bufsize);
  do {
    ret = bzip2.decompress(bits, stream2, buf, bufsize);
  } while (!ret);
};
bzip2.header = function(bits) {
  this.byteCount = new Int32Array(256);
  this.symToByte = new Uint8Array(256);
  this.mtfSymbol = new Int32Array(256);
  this.selectors = new Uint8Array(32768);
  if (bits(8 * 3) != 4348520)
    message.Error("No magic number found");
  var i2 = bits(8) - 48;
  if (i2 < 1 || i2 > 9)
    message.Error("Not a BZIP archive");
  return i2;
};
bzip2.decompress = function(bits, stream2, buf, bufsize, streamCRC) {
  var MAX_HUFCODE_BITS = 20;
  var MAX_SYMBOLS = 258;
  var SYMBOL_RUNA = 0;
  var SYMBOL_RUNB = 1;
  var GROUP_SIZE = 50;
  var crc = 0 ^ -1;
  for (var h2 = "", i2 = 0; i2 < 6; i2++)
    h2 += bits(8).toString(16);
  if (h2 == "177245385090") {
    var finalCRC = bits(32) | 0;
    if (finalCRC !== streamCRC)
      message.Error("Error in bzip2: crc32 do not match");
    bits(null);
    return null;
  }
  if (h2 != "314159265359")
    message.Error("eek not valid bzip data");
  var crcblock = bits(32) | 0;
  if (bits(1))
    message.Error("unsupported obsolete version");
  var origPtr = bits(24);
  if (origPtr > bufsize)
    message.Error("Initial position larger than buffer size");
  var t2 = bits(16);
  var symTotal = 0;
  for (i2 = 0; i2 < 16; i2++) {
    if (t2 & 1 << 15 - i2) {
      var k2 = bits(16);
      for (j2 = 0; j2 < 16; j2++) {
        if (k2 & 1 << 15 - j2) {
          this.symToByte[symTotal++] = 16 * i2 + j2;
        }
      }
    }
  }
  var groupCount = bits(3);
  if (groupCount < 2 || groupCount > 6)
    message.Error("another error");
  var nSelectors = bits(15);
  if (nSelectors == 0)
    message.Error("meh");
  for (var i2 = 0; i2 < groupCount; i2++)
    this.mtfSymbol[i2] = i2;
  for (var i2 = 0; i2 < nSelectors; i2++) {
    for (var j2 = 0; bits(1); j2++)
      if (j2 >= groupCount)
        message.Error("whoops another error");
    var uc = this.mtfSymbol[j2];
    for (var k2 = j2 - 1; k2 >= 0; k2--) {
      this.mtfSymbol[k2 + 1] = this.mtfSymbol[k2];
    }
    this.mtfSymbol[0] = uc;
    this.selectors[i2] = uc;
  }
  var symCount = symTotal + 2;
  var groups = [];
  var length = new Uint8Array(MAX_SYMBOLS), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
  var hufGroup;
  for (var j2 = 0; j2 < groupCount; j2++) {
    t2 = bits(5);
    for (var i2 = 0; i2 < symCount; i2++) {
      while (true) {
        if (t2 < 1 || t2 > MAX_HUFCODE_BITS)
          message.Error("I gave up a while ago on writing error messages");
        if (!bits(1))
          break;
        if (!bits(1))
          t2++;
        else
          t2--;
      }
      length[i2] = t2;
    }
    var minLen, maxLen;
    minLen = maxLen = length[0];
    for (var i2 = 1; i2 < symCount; i2++) {
      if (length[i2] > maxLen)
        maxLen = length[i2];
      else if (length[i2] < minLen)
        minLen = length[i2];
    }
    hufGroup = groups[j2] = {};
    hufGroup.permute = new Int32Array(MAX_SYMBOLS);
    hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
    hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);
    hufGroup.minLen = minLen;
    hufGroup.maxLen = maxLen;
    var base = hufGroup.base;
    var limit = hufGroup.limit;
    var pp = 0;
    for (var i2 = minLen; i2 <= maxLen; i2++)
      for (var t2 = 0; t2 < symCount; t2++)
        if (length[t2] == i2)
          hufGroup.permute[pp++] = t2;
    for (i2 = minLen; i2 <= maxLen; i2++)
      temp[i2] = limit[i2] = 0;
    for (i2 = 0; i2 < symCount; i2++)
      temp[length[i2]]++;
    pp = t2 = 0;
    for (i2 = minLen; i2 < maxLen; i2++) {
      pp += temp[i2];
      limit[i2] = pp - 1;
      pp <<= 1;
      base[i2 + 1] = pp - (t2 += temp[i2]);
    }
    limit[maxLen] = pp + temp[maxLen] - 1;
    base[minLen] = 0;
  }
  for (var i2 = 0; i2 < 256; i2++) {
    this.mtfSymbol[i2] = i2;
    this.byteCount[i2] = 0;
  }
  var runPos, count, symCount, selector;
  runPos = count = symCount = selector = 0;
  while (true) {
    if (!symCount--) {
      symCount = GROUP_SIZE - 1;
      if (selector >= nSelectors)
        message.Error("meow i'm a kitty, that's an error");
      hufGroup = groups[this.selectors[selector++]];
      base = hufGroup.base;
      limit = hufGroup.limit;
    }
    i2 = hufGroup.minLen;
    j2 = bits(i2);
    while (true) {
      if (i2 > hufGroup.maxLen)
        message.Error("rawr i'm a dinosaur");
      if (j2 <= limit[i2])
        break;
      i2++;
      j2 = j2 << 1 | bits(1);
    }
    j2 -= base[i2];
    if (j2 < 0 || j2 >= MAX_SYMBOLS)
      message.Error("moo i'm a cow");
    var nextSym = hufGroup.permute[j2];
    if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
      if (!runPos) {
        runPos = 1;
        t2 = 0;
      }
      if (nextSym == SYMBOL_RUNA)
        t2 += runPos;
      else
        t2 += 2 * runPos;
      runPos <<= 1;
      continue;
    }
    if (runPos) {
      runPos = 0;
      if (count + t2 > bufsize)
        message.Error("Boom.");
      uc = this.symToByte[this.mtfSymbol[0]];
      this.byteCount[uc] += t2;
      while (t2--)
        buf[count++] = uc;
    }
    if (nextSym > symTotal)
      break;
    if (count >= bufsize)
      message.Error("I can't think of anything. Error");
    i2 = nextSym - 1;
    uc = this.mtfSymbol[i2];
    for (var k2 = i2 - 1; k2 >= 0; k2--) {
      this.mtfSymbol[k2 + 1] = this.mtfSymbol[k2];
    }
    this.mtfSymbol[0] = uc;
    uc = this.symToByte[uc];
    this.byteCount[uc]++;
    buf[count++] = uc;
  }
  if (origPtr < 0 || origPtr >= count)
    message.Error("I'm a monkey and I'm throwing something at someone, namely you");
  var j2 = 0;
  for (var i2 = 0; i2 < 256; i2++) {
    k2 = j2 + this.byteCount[i2];
    this.byteCount[i2] = j2;
    j2 = k2;
  }
  for (var i2 = 0; i2 < count; i2++) {
    uc = buf[i2] & 255;
    buf[this.byteCount[uc]] |= i2 << 8;
    this.byteCount[uc]++;
  }
  var pos = 0, current = 0, run = 0;
  if (count) {
    pos = buf[origPtr];
    current = pos & 255;
    pos >>= 8;
    run = -1;
  }
  count = count;
  var copies, previous, outbyte;
  while (count) {
    count--;
    previous = current;
    pos = buf[pos];
    current = pos & 255;
    pos >>= 8;
    if (run++ == 3) {
      copies = current;
      outbyte = previous;
      current = -1;
    } else {
      copies = 1;
      outbyte = current;
    }
    while (copies--) {
      crc = (crc << 8 ^ this.crcTable[(crc >> 24 ^ outbyte) & 255]) & 4294967295;
      stream2(outbyte);
    }
    if (current != previous)
      run = 0;
  }
  crc = (crc ^ -1) >>> 0;
  if ((crc | 0) != (crcblock | 0))
    message.Error("Error in bzip2: crc32 do not match");
  streamCRC = (crc ^ (streamCRC << 1 | streamCRC >>> 31)) & 4294967295;
  return streamCRC;
};
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
require$$4.promisify(childProcess.exec);
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
debug$d("puppeteer:browsers:install");
async function uninstall(options) {
  options.platform ?? (options.platform = detectBrowserPlatform());
  if (!options.platform) {
    throw new Error(`Cannot detect the browser platform for: ${os.platform()} (${os.arch()})`);
  }
  new Cache(options.cacheDir).uninstall(options.browser, options.platform, options.buildId);
}
async function getInstalledBrowsers(options) {
  return new Cache(options.cacheDir).getInstalledBrowsers();
}
var nodeProgress = { exports: {} };
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
(function(module2, exports2) {
  module2.exports = ProgressBar;
  function ProgressBar(fmt, options) {
    this.stream = options.stream || process.stderr;
    if (typeof options == "number") {
      var total = options;
      options = {};
      options.total = total;
    } else {
      options = options || {};
      if ("string" != typeof fmt)
        throw new Error("format required");
      if ("number" != typeof options.total)
        throw new Error("total required");
    }
    this.fmt = fmt;
    this.curr = options.curr || 0;
    this.total = options.total;
    this.width = options.width || this.total;
    this.clear = options.clear;
    this.chars = {
      complete: options.complete || "=",
      incomplete: options.incomplete || "-",
      head: options.head || (options.complete || "=")
    };
    this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
    this.lastRender = -Infinity;
    this.callback = options.callback || function() {
    };
    this.tokens = {};
    this.lastDraw = "";
  }
  ProgressBar.prototype.tick = function(len, tokens) {
    if (len !== 0)
      len = len || 1;
    if ("object" == typeof len)
      tokens = len, len = 1;
    if (tokens)
      this.tokens = tokens;
    if (0 == this.curr)
      this.start = /* @__PURE__ */ new Date();
    this.curr += len;
    this.render();
    if (this.curr >= this.total) {
      this.render(void 0, true);
      this.complete = true;
      this.terminate();
      this.callback(this);
      return;
    }
  };
  ProgressBar.prototype.render = function(tokens, force) {
    force = force !== void 0 ? force : false;
    if (tokens)
      this.tokens = tokens;
    if (!this.stream.isTTY)
      return;
    var now = Date.now();
    var delta = now - this.lastRender;
    if (!force && delta < this.renderThrottle) {
      return;
    } else {
      this.lastRender = now;
    }
    var ratio = this.curr / this.total;
    ratio = Math.min(Math.max(ratio, 0), 1);
    var percent = Math.floor(ratio * 100);
    var incomplete, complete, completeLength;
    var elapsed = /* @__PURE__ */ new Date() - this.start;
    var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
    var rate = this.curr / (elapsed / 1e3);
    var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
    var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
    if (availableSpace && process.platform === "win32") {
      availableSpace = availableSpace - 1;
    }
    var width = Math.min(this.width, availableSpace);
    completeLength = Math.round(width * ratio);
    complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
    incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
    if (completeLength > 0)
      complete = complete.slice(0, -1) + this.chars.head;
    str = str.replace(":bar", complete + incomplete);
    if (this.tokens)
      for (var key in this.tokens)
        str = str.replace(":" + key, this.tokens[key]);
    if (this.lastDraw !== str) {
      this.stream.cursorTo(0);
      this.stream.write(str);
      this.stream.clearLine(1);
      this.lastDraw = str;
    }
  };
  ProgressBar.prototype.update = function(ratio, tokens) {
    var goal = Math.floor(ratio * this.total);
    var delta = goal - this.curr;
    this.tick(delta, tokens);
  };
  ProgressBar.prototype.interrupt = function(message2) {
    this.stream.clearLine();
    this.stream.cursorTo(0);
    this.stream.write(message2);
    this.stream.write("\n");
    this.stream.write(this.lastDraw);
  };
  ProgressBar.prototype.terminate = function() {
    if (this.clear) {
      if (this.stream.clearLine) {
        this.stream.clearLine();
        this.stream.cursorTo(0);
      }
    } else {
      this.stream.write("\n");
    }
  };
})(nodeProgress);
class YError extends Error {
  constructor(msg) {
    super(msg || "yargs error");
    this.name = "YError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, YError);
    }
  }
}
function getProcessArgvBinIndex() {
  if (isBundledElectronApp())
    return 0;
  return 1;
}
function isBundledElectronApp() {
  return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
  return !!process.versions.electron;
}
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i2 = leadingHyphens ? leadingHyphens[0].length : 0; i2 < str.length; i2++) {
      let chr = str.charAt(i2);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i2 !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    const chrLower = lowercase.charAt(i2);
    const chrString = str.charAt(i2);
    if (chrLower !== chrString && i2 > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i2)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x2) {
  if (x2 === null || x2 === void 0)
    return false;
  if (typeof x2 === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x2))
    return true;
  if (/^0[^.]/.test(x2))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x2);
}
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e2) => typeof e2 !== "string" ? e2 + "" : e2);
  }
  argString = argString.trim();
  let i2 = 0;
  let prevC = null;
  let c2 = null;
  let opening = null;
  const args = [];
  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c2;
    c2 = argString.charAt(ii);
    if (c2 === " " && !opening) {
      if (!(prevC === " ")) {
        i2++;
      }
      continue;
    }
    if (c2 === opening) {
      opening = null;
    } else if ((c2 === "'" || c2 === '"') && !opening) {
      opening = c2;
    }
    if (!args[i2])
      args[i2] = "";
    args[i2] += c2;
  }
  return args;
}
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var DefaultValuesForTypeKey;
(function(DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
  DefaultValuesForTypeKey2["STRING"] = "string";
  DefaultValuesForTypeKey2["NUMBER"] = "number";
  DefaultValuesForTypeKey2["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
/**
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
let mixin$1;
class YargsParser {
  constructor(_mixin) {
    mixin$1 = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign({
      alias: void 0,
      array: void 0,
      boolean: void 0,
      config: void 0,
      configObjects: void 0,
      configuration: void 0,
      coerce: void 0,
      count: void 0,
      default: void 0,
      envPrefix: void 0,
      narg: void 0,
      normalize: void 0,
      string: void 0,
      number: void 0,
      __: void 0,
      key: void 0
    }, options);
    const args = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === "string";
    const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
    const configuration = Object.assign({
      "boolean-negation": true,
      "camel-case-expansion": true,
      "combine-arrays": false,
      "dot-notation": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": true,
      "greedy-arrays": true,
      "halt-at-non-option": false,
      "nargs-eats-options": false,
      "negation-prefix": "no-",
      "parse-numbers": true,
      "parse-positional-numbers": true,
      "populate--": false,
      "set-placeholder-key": false,
      "short-option-groups": true,
      "strip-aliased": false,
      "strip-dashed": false,
      "unknown-options-as-args": false
    }, opts.configuration);
    const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration["populate--"];
    const notFlagsArgv = notFlagsOption ? "--" : "_";
    const newAliases = /* @__PURE__ */ Object.create(null);
    const defaulted = /* @__PURE__ */ Object.create(null);
    const __ = opts.__ || mixin$1.format;
    const flags = {
      aliases: /* @__PURE__ */ Object.create(null),
      arrays: /* @__PURE__ */ Object.create(null),
      bools: /* @__PURE__ */ Object.create(null),
      strings: /* @__PURE__ */ Object.create(null),
      numbers: /* @__PURE__ */ Object.create(null),
      counts: /* @__PURE__ */ Object.create(null),
      normalize: /* @__PURE__ */ Object.create(null),
      configs: /* @__PURE__ */ Object.create(null),
      nargs: /* @__PURE__ */ Object.create(null),
      coercions: /* @__PURE__ */ Object.create(null),
      keys: []
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
    [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
      const key = typeof opt === "object" ? opt.key : opt;
      const assignment = Object.keys(opt).map(function(key2) {
        const arrayFlagKeys = {
          boolean: "bools",
          string: "strings",
          number: "numbers"
        };
        return arrayFlagKeys[key2];
      }).filter(Boolean).pop();
      if (assignment) {
        flags[assignment][key] = true;
      }
      flags.arrays[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
      flags.bools[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
      flags.numbers[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
      flags.counts[key] = true;
      flags.keys.push(key);
    });
    [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
      flags.normalize[key] = true;
      flags.keys.push(key);
    });
    if (typeof opts.narg === "object") {
      Object.entries(opts.narg).forEach(([key, value]) => {
        if (typeof value === "number") {
          flags.nargs[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === "object") {
      Object.entries(opts.coerce).forEach(([key, value]) => {
        if (typeof value === "function") {
          flags.coercions[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== "undefined") {
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags.configs[key] = true;
        });
      } else if (typeof opts.config === "object") {
        Object.entries(opts.config).forEach(([key, value]) => {
          if (typeof value === "boolean" || typeof value === "function") {
            flags.configs[key] = value;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function(key) {
      (flags.aliases[key] || []).forEach(function(alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const arg = args[i2];
      const truncatedArg = arg.replace(/^-{3,}/, "---");
      let broken;
      let key;
      let letters;
      let m2;
      let next;
      let value;
      if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
        m2 = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m2 !== null && Array.isArray(m2) && m2.length >= 3) {
          if (checkAllAliases(m2[1], flags.arrays)) {
            i2 = eatArray(i2, m2[1], args, m2[2]);
          } else if (checkAllAliases(m2[1], flags.nargs) !== false) {
            i2 = eatNargs(i2, m2[1], args, m2[2]);
          } else {
            setArg(m2[1], m2[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
        m2 = arg.match(negatedBoolean);
        if (m2 !== null && Array.isArray(m2) && m2.length >= 2) {
          key = m2[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        }
      } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
        m2 = arg.match(/^--?(.+)/);
        if (m2 !== null && Array.isArray(m2) && m2.length >= 2) {
          key = m2[1];
          if (checkAllAliases(key, flags.arrays)) {
            i2 = eatArray(i2, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i2 = eatNargs(i2, key, args);
          } else {
            next = args[i2 + 1];
            if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i2++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i2++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m2 = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m2 !== null && Array.isArray(m2) && m2.length >= 3) {
          setArg(m2[1], m2[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i2 + 1];
        m2 = arg.match(/^-(.\..+)/);
        if (m2 !== null && Array.isArray(m2) && m2.length >= 2) {
          key = m2[1];
          if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i2++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split("");
        broken = false;
        for (let j2 = 0; j2 < letters.length; j2++) {
          next = arg.slice(j2 + 2);
          if (letters[j2 + 1] && letters[j2 + 1] === "=") {
            value = arg.slice(j2 + 3);
            key = letters[j2];
            if (checkAllAliases(key, flags.arrays)) {
              i2 = eatArray(i2, key, args, value);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i2 = eatNargs(i2, key, args, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === "-") {
            setArg(letters[j2], next);
            continue;
          }
          if (/[A-Za-z]/.test(letters[j2]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
            setArg(letters[j2], next);
            broken = true;
            break;
          }
          if (letters[j2 + 1] && letters[j2 + 1].match(/\W/)) {
            setArg(letters[j2], next);
            broken = true;
            break;
          } else {
            setArg(letters[j2], defaultValue(letters[j2]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== "-") {
          if (checkAllAliases(key, flags.arrays)) {
            i2 = eatArray(i2, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i2 = eatNargs(i2, key, args);
          } else {
            next = args[i2 + 1];
            if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i2++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i2++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === "--") {
        notFlags = args.slice(i2 + 1);
        break;
      } else if (configuration["halt-at-non-option"]) {
        notFlags = args.slice(i2);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration["set-placeholder-key"])
      setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function(key) {
      if (!hasKey(argv, key.split(".")))
        setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length)
      argv[notFlagsArgv] = [];
    notFlags.forEach(function(key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
      Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
        delete argv[key];
      });
    }
    if (configuration["strip-aliased"]) {
      [].concat(...Object.keys(aliases).map((k2) => aliases[k2])).forEach((alias) => {
        if (configuration["camel-case-expansion"] && alias.includes("-")) {
          delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber("_", arg);
      if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i2, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__("Argument unexpected for: %s", key));
        }
        setArg(key, defaultValue(key));
        return i2;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration["nargs-eats-options"]) {
        if (args2.length - (i2 + 1) + available < toEat) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        available = toEat;
      } else {
        for (ii = i2 + 1; ii < args2.length; ii++) {
          if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii]))
            available++;
          else
            break;
        }
        if (available < toEat)
          error = Error(__("Not enough arguments following: %s", key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i2 + 1; ii < consumed + i2 + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i2 + consumed;
    }
    function eatArray(i2, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i2 + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
        if (defaults[key] !== void 0) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i2 + 1; ii < args2.length; ii++) {
          if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
            break;
          i2 = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
        error = Error(__("Not enough arguments following: %s", key));
      }
      setArg(key, argsToSet);
      return i2;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration["camel-case-expansion"]) {
        const alias = key.split(".").map(function(prop) {
          return camelCase(prop);
        }).join(".");
        addNewAlias(key, alias);
      }
      const value = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split(".");
      setKey(argv, splitKey, value);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function(x2) {
          const keyProperties = x2.split(".");
          setKey(argv, keyProperties, value);
        });
      }
      if (splitKey.length > 1 && configuration["dot-notation"]) {
        (flags.aliases[splitKey[0]] || []).forEach(function(x2) {
          let keyProperties = x2.split(".");
          const a2 = [].concat(splitKey);
          a2.shift();
          keyProperties = keyProperties.concat(a2);
          if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
            setKey(argv, keyProperties, value);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function(key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === "string" ? mixin$1.normalize(value2) : value2;
            }
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === "string")
          val = val === "true";
      }
      let value = Array.isArray(val) ? val.map(function(v2) {
        return maybeCoerceNumber(key, v2);
      }) : maybeCoerceNumber(key, val);
      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
        value = increment();
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value = val.map((val2) => {
            return mixin$1.normalize(val2);
          });
        else
          value = mixin$1.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!configuration["parse-positional-numbers"] && key === "_")
        return value;
      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
        const shouldCoerceNumber = looksLikeNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {
          value = Number(value);
        }
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = /* @__PURE__ */ Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function(configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config2 = null;
            const resolvedConfigPath = mixin$1.resolve(mixin$1.cwd(), configPath);
            const resolveConfig = flags.configs[configKey];
            if (typeof resolveConfig === "function") {
              try {
                config2 = resolveConfig(resolvedConfigPath);
              } catch (e2) {
                config2 = e2;
              }
              if (config2 instanceof Error) {
                error = config2;
                return;
              }
            } else {
              config2 = mixin$1.require(resolvedConfigPath);
            }
            setConfigObject(config2);
          } catch (ex) {
            if (ex.name === "PermissionDenied")
              error = ex;
            else if (argv2[configKey])
              error = Error(__("Invalid JSON config file: %s", configPath));
          }
        }
      });
    }
    function setConfigObject(config2, prev) {
      Object.keys(config2).forEach(function(key) {
        const value = config2[key];
        const fullKey = prev ? prev + "." + key : key;
        if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
          setConfigObject(value, fullKey);
        } else {
          if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== "undefined") {
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === "undefined")
        return;
      const prefix = typeof envPrefix === "string" ? envPrefix : "";
      const env2 = mixin$1.env();
      Object.keys(env2).forEach(function(envVar) {
        if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split("__").map(function(key, i2) {
            if (i2 === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
            setArg(keys.join("."), env2[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce2;
      const applied = /* @__PURE__ */ new Set();
      Object.keys(argv2).forEach(function(key) {
        if (!applied.has(key)) {
          coerce2 = checkAllAliases(key, flags.coercions);
          if (typeof coerce2 === "function") {
            try {
              const value = maybeCoerceNumber(key, coerce2(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf("."))
          return;
        if (typeof argv2[key] === "undefined")
          argv2[key] = void 0;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function(key) {
        if (!hasKey(obj, key.split("."))) {
          setKey(obj, key.split("."), defaults2[key]);
          if (canLog)
            defaulted[key] = true;
          (aliases2[key] || []).forEach(function(x2) {
            if (hasKey(obj, x2.split(".")))
              return;
            setKey(obj, x2.split("."), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o2 = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        o2 = o2[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o2 !== "object")
        return false;
      else
        return key in o2;
    }
    function setKey(obj, keys, value) {
      let o2 = obj;
      if (!configuration["dot-notation"])
        keys = [keys.join(".")];
      keys.slice(0, -1).forEach(function(key2) {
        key2 = sanitizeKey(key2);
        if (typeof o2 === "object" && o2[key2] === void 0) {
          o2[key2] = {};
        }
        if (typeof o2[key2] !== "object" || Array.isArray(o2[key2])) {
          if (Array.isArray(o2[key2])) {
            o2[key2].push({});
          } else {
            o2[key2] = [o2[key2], {}];
          }
          o2 = o2[key2][o2[key2].length - 1];
        } else {
          o2 = o2[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration["duplicate-arguments-array"];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (!isUndefined(o2[key]) && flags.nargs[key] === 1 || Array.isArray(o2[key]) && o2[key].length === flags.nargs[key]) {
          o2[key] = void 0;
        }
      }
      if (value === increment()) {
        o2[key] = increment(o2[key]);
      } else if (Array.isArray(o2[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o2[key] = configuration["flatten-duplicate-arrays"] ? o2[key].concat(value) : (Array.isArray(o2[key][0]) ? o2[key] : [o2[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o2[key] = value;
        } else {
          o2[key] = o2[key].concat([value]);
        }
      } else if (o2[key] === void 0 && isTypeArray) {
        o2[key] = isValueArray ? value : [value];
      } else if (duplicate && !(o2[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
        o2[key] = [o2[key], value];
      } else {
        o2[key] = value;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function(obj) {
        Object.keys(obj || {}).forEach(function(key) {
          if (flags.aliases[key])
            return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function(x2) {
            if (/-/.test(x2) && configuration["camel-case-expansion"]) {
              const c2 = camelCase(x2);
              if (c2 !== key && flags.aliases[key].indexOf(c2) === -1) {
                flags.aliases[key].push(c2);
                newAliases[c2] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function(x2) {
            if (x2.length > 1 && /[A-Z]/.test(x2) && configuration["camel-case-expansion"]) {
              const c2 = decamelize(x2, "-");
              if (c2 !== key && flags.aliases[key].indexOf(c2) === -1) {
                flags.aliases[key].push(c2);
                newAliases[c2] = true;
              }
            }
          });
          flags.aliases[key].forEach(function(x2) {
            flags.aliases[x2] = [key].concat(flags.aliases[key].filter(function(y2) {
              return x2 !== y2;
            }));
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags);
      const toCheck = [].concat(flagsKeys.map((k2) => flags[k2]));
      return toCheck.some(function(flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function(pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split("");
      for (let j2 = 0; j2 < letters.length; j2++) {
        next = arg.slice(j2 + 2);
        if (!hasAnyFlag(letters[j2])) {
          hasAllFlags = false;
          break;
        }
        if (letters[j2 + 1] && letters[j2 + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j2]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j2 + 1] && letters[j2 + 1].match(/\W/)) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration["unknown-options-as-args"] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, "--");
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
    }
    function defaultValue(key) {
      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
        return defaults[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: "",
        [DefaultValuesForTypeKey.NUMBER]: void 0,
        [DefaultValuesForTypeKey.ARRAY]: []
      };
      return def[type];
    }
    function guessType(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags.strings))
        type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags.numbers))
        type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags.bools))
        type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags.arrays))
        type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === void 0;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases)
    };
  }
}
function combineAliases(aliases) {
  const aliasArrays = [];
  const combined = /* @__PURE__ */ Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i2 = 0; i2 < aliasArrays.length; i2++) {
      for (let ii = i2 + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i2].filter(function(v2) {
          return aliasArrays[ii].indexOf(v2) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i2] = aliasArrays[i2].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v2, i2, self2) {
      return self2.indexOf(v2) === i2;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== void 0 && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}
function increment(orig) {
  return orig !== void 0 ? orig + 1 : 1;
}
function sanitizeKey(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
}
function stripQuotes(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}
/**
 * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
 * CJS and ESM environments.
 *
 * @license
 * Copyright (c) 2016, Contributors
 * SPDX-License-Identifier: ISC
 */
var _a, _b, _c;
const minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
const nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
if (nodeVersion) {
  const major2 = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major2 < minNodeVersion) {
    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
  }
}
const env = process ? process.env : {};
const parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env;
  },
  format: require$$4.format,
  normalize: path$e.normalize,
  resolve: path$e.resolve,
  // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
  // we can exercise all the lines below:
  require: (path2) => {
    if (typeof require !== "undefined") {
      return require(path2);
    } else if (path2.match(/\.json$/)) {
      return JSON.parse(fs$o.readFileSync(path2, "utf8"));
    } else {
      throw Error("only .json config files are supported in ESM");
    }
  }
});
const yargsParser = function Parser(args, opts) {
  const result = parser.parse(args.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function(args, opts) {
  return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
const lib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yargsParser
}, Symbol.toStringTag, { value: "Module" }));
var stringWidth$3 = { exports: {} };
var ansiRegex$1 = ({ onlyFirst = false } = {}) => {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
};
const ansiRegex = ansiRegex$1;
var stripAnsi$3 = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
var isFullwidthCodePoint$2 = { exports: {} };
const isFullwidthCodePoint$1 = (codePoint) => {
  if (Number.isNaN(codePoint)) {
    return false;
  }
  if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
  codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
  43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
  44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
  63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
  65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
  110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
  127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= codePoint && codePoint <= 262141)) {
    return true;
  }
  return false;
};
isFullwidthCodePoint$2.exports = isFullwidthCodePoint$1;
isFullwidthCodePoint$2.exports.default = isFullwidthCodePoint$1;
var isFullwidthCodePointExports = isFullwidthCodePoint$2.exports;
var emojiRegex$1 = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
const stripAnsi$2 = stripAnsi$3;
const isFullwidthCodePoint = isFullwidthCodePointExports;
const emojiRegex = emojiRegex$1;
const stringWidth$2 = (string) => {
  if (typeof string !== "string" || string.length === 0) {
    return 0;
  }
  string = stripAnsi$2(string);
  if (string.length === 0) {
    return 0;
  }
  string = string.replace(emojiRegex(), "  ");
  let width = 0;
  for (let i2 = 0; i2 < string.length; i2++) {
    const code2 = string.codePointAt(i2);
    if (code2 <= 31 || code2 >= 127 && code2 <= 159) {
      continue;
    }
    if (code2 >= 768 && code2 <= 879) {
      continue;
    }
    if (code2 > 65535) {
      i2++;
    }
    width += isFullwidthCodePoint(code2) ? 2 : 1;
  }
  return width;
};
stringWidth$3.exports = stringWidth$2;
stringWidth$3.exports.default = stringWidth$2;
var stringWidthExports = stringWidth$3.exports;
var ansiStyles$1 = { exports: {} };
var colorName;
var hasRequiredColorName;
function requireColorName() {
  if (hasRequiredColorName)
    return colorName;
  hasRequiredColorName = 1;
  colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  return colorName;
}
var conversions;
var hasRequiredConversions;
function requireConversions() {
  if (hasRequiredConversions)
    return conversions;
  hasRequiredConversions = 1;
  const cssKeywords = requireColorName();
  const reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  const convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  conversions = convert;
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const min = Math.min(r2, g2, b2);
    const max = Math.max(r2, g2, b2);
    const delta = max - min;
    let h2;
    let s2;
    if (max === min) {
      h2 = 0;
    } else if (r2 === max) {
      h2 = (g2 - b2) / delta;
    } else if (g2 === max) {
      h2 = 2 + (b2 - r2) / delta;
    } else if (b2 === max) {
      h2 = 4 + (r2 - g2) / delta;
    }
    h2 = Math.min(h2 * 60, 360);
    if (h2 < 0) {
      h2 += 360;
    }
    const l2 = (min + max) / 2;
    if (max === min) {
      s2 = 0;
    } else if (l2 <= 0.5) {
      s2 = delta / (max + min);
    } else {
      s2 = delta / (2 - max - min);
    }
    return [h2, s2 * 100, l2 * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h2;
    let s2;
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const v2 = Math.max(r2, g2, b2);
    const diff2 = v2 - Math.min(r2, g2, b2);
    const diffc = function(c2) {
      return (v2 - c2) / 6 / diff2 + 1 / 2;
    };
    if (diff2 === 0) {
      h2 = 0;
      s2 = 0;
    } else {
      s2 = diff2 / v2;
      rdif = diffc(r2);
      gdif = diffc(g2);
      bdif = diffc(b2);
      if (r2 === v2) {
        h2 = bdif - gdif;
      } else if (g2 === v2) {
        h2 = 1 / 3 + rdif - bdif;
      } else if (b2 === v2) {
        h2 = 2 / 3 + gdif - rdif;
      }
      if (h2 < 0) {
        h2 += 1;
      } else if (h2 > 1) {
        h2 -= 1;
      }
    }
    return [
      h2 * 360,
      s2 * 100,
      v2 * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r2 = rgb[0];
    const g2 = rgb[1];
    let b2 = rgb[2];
    const h2 = convert.rgb.hsl(rgb)[0];
    const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
    b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
    return [h2, w2 * 100, b2 * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
    const c2 = (1 - r2 - k2) / (1 - k2) || 0;
    const m2 = (1 - g2 - k2) / (1 - k2) || 0;
    const y2 = (1 - b2 - k2) / (1 - k2) || 0;
    return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
  };
  function comparativeDistance(x2, y2) {
    return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword2 of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword2];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword2;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword2) {
    return cssKeywords[keyword2];
  };
  convert.rgb.xyz = function(rgb) {
    let r2 = rgb[0] / 255;
    let g2 = rgb[1] / 255;
    let b2 = rgb[2] / 255;
    r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
    g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
    b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
    const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
    const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
    const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
    return [x2 * 100, y2 * 100, z2 * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x2 = xyz[0];
    let y2 = xyz[1];
    let z2 = xyz[2];
    x2 /= 95.047;
    y2 /= 100;
    z2 /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
    const l2 = 116 * y2 - 16;
    const a2 = 500 * (x2 - y2);
    const b2 = 200 * (y2 - z2);
    return [l2, a2, b2];
  };
  convert.hsl.rgb = function(hsl) {
    const h2 = hsl[0] / 360;
    const s2 = hsl[1] / 100;
    const l2 = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s2 === 0) {
      val = l2 * 255;
      return [val, val, val];
    }
    if (l2 < 0.5) {
      t2 = l2 * (1 + s2);
    } else {
      t2 = l2 + s2 - l2 * s2;
    }
    const t1 = 2 * l2 - t2;
    const rgb = [0, 0, 0];
    for (let i2 = 0; i2 < 3; i2++) {
      t3 = h2 + 1 / 3 * -(i2 - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i2] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h2 = hsl[0];
    let s2 = hsl[1] / 100;
    let l2 = hsl[2] / 100;
    let smin = s2;
    const lmin = Math.max(l2, 0.01);
    l2 *= 2;
    s2 *= l2 <= 1 ? l2 : 2 - l2;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v2 = (l2 + s2) / 2;
    const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
    return [h2, sv * 100, v2 * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h2 = hsv[0] / 60;
    const s2 = hsv[1] / 100;
    let v2 = hsv[2] / 100;
    const hi = Math.floor(h2) % 6;
    const f2 = h2 - Math.floor(h2);
    const p2 = 255 * v2 * (1 - s2);
    const q2 = 255 * v2 * (1 - s2 * f2);
    const t2 = 255 * v2 * (1 - s2 * (1 - f2));
    v2 *= 255;
    switch (hi) {
      case 0:
        return [v2, t2, p2];
      case 1:
        return [q2, v2, p2];
      case 2:
        return [p2, v2, t2];
      case 3:
        return [p2, q2, v2];
      case 4:
        return [t2, p2, v2];
      case 5:
        return [v2, p2, q2];
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h2 = hsv[0];
    const s2 = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const vmin = Math.max(v2, 0.01);
    let sl;
    let l2;
    l2 = (2 - s2) * v2;
    const lmin = (2 - s2) * vmin;
    sl = s2 * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l2 /= 2;
    return [h2, sl * 100, l2 * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h2 = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f2;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i2 = Math.floor(6 * h2);
    const v2 = 1 - bl;
    f2 = 6 * h2 - i2;
    if ((i2 & 1) !== 0) {
      f2 = 1 - f2;
    }
    const n2 = wh + f2 * (v2 - wh);
    let r2;
    let g2;
    let b2;
    switch (i2) {
      default:
      case 6:
      case 0:
        r2 = v2;
        g2 = n2;
        b2 = wh;
        break;
      case 1:
        r2 = n2;
        g2 = v2;
        b2 = wh;
        break;
      case 2:
        r2 = wh;
        g2 = v2;
        b2 = n2;
        break;
      case 3:
        r2 = wh;
        g2 = n2;
        b2 = v2;
        break;
      case 4:
        r2 = n2;
        g2 = wh;
        b2 = v2;
        break;
      case 5:
        r2 = v2;
        g2 = wh;
        b2 = n2;
        break;
    }
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c2 = cmyk[0] / 100;
    const m2 = cmyk[1] / 100;
    const y2 = cmyk[2] / 100;
    const k2 = cmyk[3] / 100;
    const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
    const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
    const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x2 = xyz[0] / 100;
    const y2 = xyz[1] / 100;
    const z2 = xyz[2] / 100;
    let r2;
    let g2;
    let b2;
    r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
    g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
    b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
    r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
    g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
    b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
    r2 = Math.min(Math.max(0, r2), 1);
    g2 = Math.min(Math.max(0, g2), 1);
    b2 = Math.min(Math.max(0, b2), 1);
    return [r2 * 255, g2 * 255, b2 * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x2 = xyz[0];
    let y2 = xyz[1];
    let z2 = xyz[2];
    x2 /= 95.047;
    y2 /= 100;
    z2 /= 108.883;
    x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
    y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
    z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
    const l2 = 116 * y2 - 16;
    const a2 = 500 * (x2 - y2);
    const b2 = 200 * (y2 - z2);
    return [l2, a2, b2];
  };
  convert.lab.xyz = function(lab) {
    const l2 = lab[0];
    const a2 = lab[1];
    const b2 = lab[2];
    let x2;
    let y2;
    let z2;
    y2 = (l2 + 16) / 116;
    x2 = a2 / 500 + y2;
    z2 = y2 - b2 / 200;
    const y22 = y2 ** 3;
    const x22 = x2 ** 3;
    const z22 = z2 ** 3;
    y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
    x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
    z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
    x2 *= 95.047;
    y2 *= 100;
    z2 *= 108.883;
    return [x2, y2, z2];
  };
  convert.lab.lch = function(lab) {
    const l2 = lab[0];
    const a2 = lab[1];
    const b2 = lab[2];
    let h2;
    const hr = Math.atan2(b2, a2);
    h2 = hr * 360 / 2 / Math.PI;
    if (h2 < 0) {
      h2 += 360;
    }
    const c2 = Math.sqrt(a2 * a2 + b2 * b2);
    return [l2, c2, h2];
  };
  convert.lch.lab = function(lch) {
    const l2 = lch[0];
    const c2 = lch[1];
    const h2 = lch[2];
    const hr = h2 / 360 * 2 * Math.PI;
    const a2 = c2 * Math.cos(hr);
    const b2 = c2 * Math.sin(hr);
    return [l2, a2, b2];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r2, g2, b2] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r2 = args[0];
    const g2 = args[1];
    const b2 = args[2];
    if (r2 === g2 && g2 === b2) {
      if (r2 < 8) {
        return 16;
      }
      if (r2 > 248) {
        return 231;
      }
      return Math.round((r2 - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r2 = (color & 1) * mult * 255;
    const g2 = (color >> 1 & 1) * mult * 255;
    const b2 = (color >> 2 & 1) * mult * 255;
    return [r2, g2, b2];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c2 = (args - 232) * 10 + 8;
      return [c2, c2, c2];
    }
    args -= 16;
    let rem;
    const r2 = Math.floor(args / 36) / 5 * 255;
    const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b2 = rem % 6 / 5 * 255;
    return [r2, g2, b2];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r2 = integer >> 16 & 255;
    const g2 = integer >> 8 & 255;
    const b2 = integer & 255;
    return [r2, g2, b2];
  };
  convert.rgb.hcg = function(rgb) {
    const r2 = rgb[0] / 255;
    const g2 = rgb[1] / 255;
    const b2 = rgb[2] / 255;
    const max = Math.max(Math.max(r2, g2), b2);
    const min = Math.min(Math.min(r2, g2), b2);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r2) {
      hue = (g2 - b2) / chroma % 6;
    } else if (max === g2) {
      hue = 2 + (b2 - r2) / chroma;
    } else {
      hue = 4 + (r2 - g2) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s2 = hsl[1] / 100;
    const l2 = hsl[2] / 100;
    const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
    let f2 = 0;
    if (c2 < 1) {
      f2 = (l2 - 0.5 * c2) / (1 - c2);
    }
    return [hsl[0], c2 * 100, f2 * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s2 = hsv[1] / 100;
    const v2 = hsv[2] / 100;
    const c2 = s2 * v2;
    let f2 = 0;
    if (c2 < 1) {
      f2 = (v2 - c2) / (1 - c2);
    }
    return [hsv[0], c2 * 100, f2 * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h2 = hcg[0] / 360;
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    if (c2 === 0) {
      return [g2 * 255, g2 * 255, g2 * 255];
    }
    const pure = [0, 0, 0];
    const hi = h2 % 1 * 6;
    const v2 = hi % 1;
    const w2 = 1 - v2;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v2;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w2;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v2;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w2;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v2;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w2;
    }
    mg = (1 - c2) * g2;
    return [
      (c2 * pure[0] + mg) * 255,
      (c2 * pure[1] + mg) * 255,
      (c2 * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c2 + g2 * (1 - c2);
    let f2 = 0;
    if (v2 > 0) {
      f2 = c2 / v2;
    }
    return [hcg[0], f2 * 100, v2 * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const l2 = g2 * (1 - c2) + 0.5 * c2;
    let s2 = 0;
    if (l2 > 0 && l2 < 0.5) {
      s2 = c2 / (2 * l2);
    } else if (l2 >= 0.5 && l2 < 1) {
      s2 = c2 / (2 * (1 - l2));
    }
    return [hcg[0], s2 * 100, l2 * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c2 = hcg[1] / 100;
    const g2 = hcg[2] / 100;
    const v2 = c2 + g2 * (1 - c2);
    return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w2 = hwb[1] / 100;
    const b2 = hwb[2] / 100;
    const v2 = 1 - b2;
    const c2 = v2 - w2;
    let g2 = 0;
    if (c2 < 1) {
      g2 = (v2 - c2) / (1 - c2);
    }
    return [hwb[0], c2 * 100, g2 * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
  return conversions;
}
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute)
    return route;
  hasRequiredRoute = 1;
  const conversions2 = requireConversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions2);
    for (let len = models.length, i2 = 0; i2 < len; i2++) {
      graph[models[i2]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions2[current]);
      for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
        const adjacent = adjacents[i2];
        const node2 = graph[adjacent];
        if (node2.distance === -1) {
          node2.distance = graph[current].distance + 1;
          node2.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link2(from2, to) {
    return function(args) {
      return to(from2(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions2[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link2(conversions2[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  route = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i2 = 0; i2 < len; i2++) {
      const toModel = models[i2];
      const node2 = graph[toModel];
      if (node2.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
  return route;
}
var colorConvert;
var hasRequiredColorConvert;
function requireColorConvert() {
  if (hasRequiredColorConvert)
    return colorConvert;
  hasRequiredColorConvert = 1;
  const conversions2 = requireConversions();
  const route2 = requireRoute();
  const convert = {};
  const models = Object.keys(conversions2);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i2 = 0; i2 < len; i2++) {
          result[i2] = Math.round(result[i2]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", { value: conversions2[fromModel].channels });
    Object.defineProperty(convert[fromModel], "labels", { value: conversions2[fromModel].labels });
    const routes = route2(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  colorConvert = convert;
  return colorConvert;
}
ansiStyles$1.exports;
(function(module2) {
  const wrapAnsi16 = (fn, offset) => (...args) => {
    const code2 = fn(...args);
    return `\x1B[${code2 + offset}m`;
  };
  const wrapAnsi256 = (fn, offset) => (...args) => {
    const code2 = fn(...args);
    return `\x1B[${38 + offset};5;${code2}m`;
  };
  const wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  const ansi2ansi = (n2) => n2;
  const rgb2rgb = (r2, g2, b2) => [r2, g2, b2];
  const setLazyProperty = (object, property, get2) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get2();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  let colorConvert2;
  const makeDynamicStyles = (wrap2, targetSpace, identity2, isBackground) => {
    if (colorConvert2 === void 0) {
      colorConvert2 = requireColorConvert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert2)) {
      const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name2] = wrap2(identity2, offset);
      } else if (typeof suite === "object") {
        styles[name2] = wrap2(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
})(ansiStyles$1);
var ansiStylesExports = ansiStyles$1.exports;
const stringWidth$1 = stringWidthExports;
const stripAnsi$1 = stripAnsi$3;
const ansiStyles = ansiStylesExports;
const ESCAPES = /* @__PURE__ */ new Set([
  "\x1B",
  ""
]);
const END_CODE = 39;
const ANSI_ESCAPE_BELL = "\x07";
const ANSI_CSI = "[";
const ANSI_OSC = "]";
const ANSI_SGR_TERMINATOR = "m";
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;
const wrapAnsi = (code2) => `${ESCAPES.values().next().value}${ANSI_CSI}${code2}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;
const wordLengths = (string) => string.split(" ").map((character) => stringWidth$1(character));
const wrapWord = (rows, word, columns) => {
  const characters = [...word];
  let isInsideEscape = false;
  let isInsideLinkEscape = false;
  let visible = stringWidth$1(stripAnsi$1(rows[rows.length - 1]));
  for (const [index2, character] of characters.entries()) {
    const characterLength = stringWidth$1(character);
    if (visible + characterLength <= columns) {
      rows[rows.length - 1] += character;
    } else {
      rows.push(character);
      visible = 0;
    }
    if (ESCAPES.has(character)) {
      isInsideEscape = true;
      isInsideLinkEscape = characters.slice(index2 + 1).join("").startsWith(ANSI_ESCAPE_LINK);
    }
    if (isInsideEscape) {
      if (isInsideLinkEscape) {
        if (character === ANSI_ESCAPE_BELL) {
          isInsideEscape = false;
          isInsideLinkEscape = false;
        }
      } else if (character === ANSI_SGR_TERMINATOR) {
        isInsideEscape = false;
      }
      continue;
    }
    visible += characterLength;
    if (visible === columns && index2 < characters.length - 1) {
      rows.push("");
      visible = 0;
    }
  }
  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
    rows[rows.length - 2] += rows.pop();
  }
};
const stringVisibleTrimSpacesRight = (string) => {
  const words = string.split(" ");
  let last2 = words.length;
  while (last2 > 0) {
    if (stringWidth$1(words[last2 - 1]) > 0) {
      break;
    }
    last2--;
  }
  if (last2 === words.length) {
    return string;
  }
  return words.slice(0, last2).join(" ") + words.slice(last2).join("");
};
const exec = (string, columns, options = {}) => {
  if (options.trim !== false && string.trim() === "") {
    return "";
  }
  let returnValue = "";
  let escapeCode;
  let escapeUrl;
  const lengths = wordLengths(string);
  let rows = [""];
  for (const [index2, word] of string.split(" ").entries()) {
    if (options.trim !== false) {
      rows[rows.length - 1] = rows[rows.length - 1].trimStart();
    }
    let rowLength = stringWidth$1(rows[rows.length - 1]);
    if (index2 !== 0) {
      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
        rows.push("");
        rowLength = 0;
      }
      if (rowLength > 0 || options.trim === false) {
        rows[rows.length - 1] += " ";
        rowLength++;
      }
    }
    if (options.hard && lengths[index2] > columns) {
      const remainingColumns = columns - rowLength;
      const breaksStartingThisLine = 1 + Math.floor((lengths[index2] - remainingColumns - 1) / columns);
      const breaksStartingNextLine = Math.floor((lengths[index2] - 1) / columns);
      if (breaksStartingNextLine < breaksStartingThisLine) {
        rows.push("");
      }
      wrapWord(rows, word, columns);
      continue;
    }
    if (rowLength + lengths[index2] > columns && rowLength > 0 && lengths[index2] > 0) {
      if (options.wordWrap === false && rowLength < columns) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows.push("");
    }
    if (rowLength + lengths[index2] > columns && options.wordWrap === false) {
      wrapWord(rows, word, columns);
      continue;
    }
    rows[rows.length - 1] += word;
  }
  if (options.trim !== false) {
    rows = rows.map(stringVisibleTrimSpacesRight);
  }
  const pre = [...rows.join("\n")];
  for (const [index2, character] of pre.entries()) {
    returnValue += character;
    if (ESCAPES.has(character)) {
      const { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index2).join("")) || { groups: {} };
      if (groups.code !== void 0) {
        const code3 = Number.parseFloat(groups.code);
        escapeCode = code3 === END_CODE ? void 0 : code3;
      } else if (groups.uri !== void 0) {
        escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri;
      }
    }
    const code2 = ansiStyles.codes.get(Number(escapeCode));
    if (pre[index2 + 1] === "\n") {
      if (escapeUrl) {
        returnValue += wrapAnsiHyperlink("");
      }
      if (escapeCode && code2) {
        returnValue += wrapAnsi(code2);
      }
    } else if (character === "\n") {
      if (escapeCode && code2) {
        returnValue += wrapAnsi(escapeCode);
      }
      if (escapeUrl) {
        returnValue += wrapAnsiHyperlink(escapeUrl);
      }
    }
  }
  return returnValue;
};
var wrapAnsi_1 = (string, columns, options) => {
  return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec(line, columns, options)).join("\n");
};
const align = {
  right: alignRight,
  center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
class UI {
  constructor(opts) {
    var _a3;
    this.width = opts.width;
    this.wrap = (_a3 = opts.wrap) !== null && _a3 !== void 0 ? _a3 : true;
    this.rows = [];
  }
  span(...args) {
    const cols = this.div(...args);
    cols.span = true;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...args) {
    if (args.length === 0) {
      this.div("");
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === "string") {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }
  shouldApplyLayoutDSL(...args) {
    return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
  }
  applyLayoutDSL(str) {
    const rows = str.split("\n").map((row) => row.split("	"));
    let leftColumnWidth = 0;
    rows.forEach((columns) => {
      if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
      }
    });
    rows.forEach((columns) => {
      this.div(...columns.map((r2, i2) => {
        return {
          text: r2.trim(),
          padding: this.measurePadding(r2),
          width: i2 === 0 && columns.length > 1 ? leftColumnWidth : void 0
        };
      }));
    });
    return this.rows[this.rows.length - 1];
  }
  colFromString(text) {
    return {
      text,
      padding: this.measurePadding(text)
    };
  }
  measurePadding(str) {
    const noAnsi = mixin.stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }
  toString() {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
  }
  rowToString(row, lines) {
    this.rasterize(row).forEach((rrow, r2) => {
      let str = "";
      rrow.forEach((col, c2) => {
        const { width } = row[c2];
        const wrapWidth = this.negatePadding(row[c2]);
        let ts = col;
        if (wrapWidth > mixin.stringWidth(col)) {
          ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
        }
        if (row[c2].align && row[c2].align !== "left" && this.wrap) {
          const fn = align[row[c2].align];
          ts = fn(ts, wrapWidth);
          if (mixin.stringWidth(ts) < wrapWidth) {
            ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
          }
        }
        const padding = row[c2].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str += " ".repeat(padding[left]);
        }
        str += addBorder(row[c2], ts, "| ");
        str += ts;
        str += addBorder(row[c2], ts, " |");
        if (padding[right]) {
          str += " ".repeat(padding[right]);
        }
        if (r2 === 0 && lines.length > 0) {
          str = this.renderInline(str, lines[lines.length - 1]);
        }
      });
      lines.push({
        text: str.replace(/ +$/, ""),
        span: row.span
      });
    });
    return lines;
  }
  // if the full 'source' can render in
  // the target line, do so.
  renderInline(source2, previousLine) {
    const match = source2.match(/^ */);
    const leadingWhitespace = match ? match[0].length : 0;
    const target = previousLine.text;
    const targetTextWidth = mixin.stringWidth(target.trimRight());
    if (!previousLine.span) {
      return source2;
    }
    if (!this.wrap) {
      previousLine.hidden = true;
      return target + source2;
    }
    if (leadingWhitespace < targetTextWidth) {
      return source2;
    }
    previousLine.hidden = true;
    return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source2.trimLeft();
  }
  rasterize(row) {
    const rrows = [];
    const widths = this.columnWidths(row);
    let wrapped;
    row.forEach((col, c2) => {
      col.width = widths[c2];
      if (this.wrap) {
        wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split("\n");
      } else {
        wrapped = col.text.split("\n");
      }
      if (col.border) {
        wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
        wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
      }
      if (col.padding) {
        wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
        wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
      }
      wrapped.forEach((str, r2) => {
        if (!rrows[r2]) {
          rrows.push([]);
        }
        const rrow = rrows[r2];
        for (let i2 = 0; i2 < c2; i2++) {
          if (rrow[i2] === void 0) {
            rrow.push("");
          }
        }
        rrow.push(str);
      });
    });
    return rrows;
  }
  negatePadding(col) {
    let wrapWidth = col.width || 0;
    if (col.padding) {
      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    }
    if (col.border) {
      wrapWidth -= 4;
    }
    return wrapWidth;
  }
  columnWidths(row) {
    if (!this.wrap) {
      return row.map((col) => {
        return col.width || mixin.stringWidth(col.text);
      });
    }
    let unset = row.length;
    let remainingWidth = this.width;
    const widths = row.map((col) => {
      if (col.width) {
        unset--;
        remainingWidth -= col.width;
        return col.width;
      }
      return void 0;
    });
    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
    return widths.map((w2, i2) => {
      if (w2 === void 0) {
        return Math.max(unsetWidth, _minWidth(row[i2]));
      }
      return w2;
    });
  }
}
function addBorder(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return "";
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return "  ";
  }
  return "";
}
function _minWidth(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
}
function getWindowWidth() {
  if (typeof process === "object" && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
}
function alignRight(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth < width) {
    return " ".repeat(width - strWidth) + str;
  }
  return str;
}
function alignCenter(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return " ".repeat(width - strWidth >> 1) + str;
}
let mixin;
function cliui(opts, _mixin) {
  mixin = _mixin;
  return new UI({
    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
  });
}
const stringWidth = stringWidthExports;
const stripAnsi = stripAnsi$3;
const wrap = wrapAnsi_1;
function ui(opts) {
  return cliui(opts, {
    stringWidth,
    stripAnsi,
    wrap
  });
}
var build$2 = ui;
const cliui$1 = /* @__PURE__ */ getDefaultExportFromCjs(build$2);
const { dirname: dirname$1, resolve: resolve$1 } = path$e;
const { readdirSync, statSync } = fs$o;
var sync = function(start, callback) {
  let dir = resolve$1(".", start);
  let tmp, stats = statSync(dir);
  if (!stats.isDirectory()) {
    dir = dirname$1(dir);
  }
  while (true) {
    tmp = callback(dir, readdirSync(dir));
    if (tmp)
      return resolve$1(dir, tmp);
    dir = dirname$1(tmp = dir);
    if (tmp === dir)
      break;
  }
};
const escalade = /* @__PURE__ */ getDefaultExportFromCjs(sync);
var fs$1 = fs$o;
var util = require$$4;
var path = path$e;
let shim;
class Y18N {
  constructor(opts) {
    opts = opts || {};
    this.directory = opts.directory || "./locales";
    this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
    this.locale = opts.locale || "en";
    this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
    this.cache = /* @__PURE__ */ Object.create(null);
    this.writeQueue = [];
  }
  __(...args) {
    if (typeof arguments[0] !== "string") {
      return this._taggedLiteral(arguments[0], ...arguments);
    }
    const str = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    cb = cb || function() {
    };
    if (!this.cache[this.locale])
      this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));
  }
  __n() {
    const args = Array.prototype.slice.call(arguments);
    const singular = args.shift();
    const plural = args.shift();
    const quantity = args.shift();
    let cb = function() {
    };
    if (typeof args[args.length - 1] === "function")
      cb = args.pop();
    if (!this.cache[this.locale])
      this._readLocaleFile();
    let str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular];
      str = entry[quantity === 1 ? "one" : "other"];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural
      };
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb
      });
    } else {
      cb();
    }
    const values = [str];
    if (~str.indexOf("%d"))
      values.push(quantity);
    return shim.format.apply(shim.format, values.concat(args));
  }
  setLocale(locale) {
    this.locale = locale;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(obj) {
    if (!this.cache[this.locale])
      this._readLocaleFile();
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key];
      }
    }
  }
  _taggedLiteral(parts, ...args) {
    let str = "";
    parts.forEach(function(part, i2) {
      const arg = args[i2 + 1];
      str += part;
      if (typeof arg !== "undefined") {
        str += "%s";
      }
    });
    return this.__.apply(this, [str].concat([].slice.call(args, 1)));
  }
  _enqueueWrite(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1)
      this._processWriteQueue();
  }
  _processWriteQueue() {
    const _this = this;
    const work = this.writeQueue[0];
    const directory = work.directory;
    const locale = work.locale;
    const cb = work.cb;
    const languageFile = this._resolveLocaleFile(directory, locale);
    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0)
        _this._processWriteQueue();
      cb(err);
    });
  }
  _readLocaleFile() {
    let localeLookup = {};
    const languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      if (shim.fs.readFileSync) {
        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
      }
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = "syntax error in " + languageFile;
      }
      if (err.code === "ENOENT")
        localeLookup = {};
      else
        throw err;
    }
    this.cache[this.locale] = localeLookup;
  }
  _resolveLocaleFile(directory, locale) {
    let file2 = shim.resolve(directory, "./", locale + ".json");
    if (this.fallbackToLanguage && !this._fileExistsSync(file2) && ~locale.lastIndexOf("_")) {
      const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
      if (this._fileExistsSync(languageFile))
        file2 = languageFile;
    }
    return file2;
  }
  _fileExistsSync(file2) {
    return shim.exists(file2);
  }
}
function y18n$1(opts, _shim) {
  shim = _shim;
  const y18n2 = new Y18N(opts);
  return {
    __: y18n2.__.bind(y18n2),
    __n: y18n2.__n.bind(y18n2),
    setLocale: y18n2.setLocale.bind(y18n2),
    getLocale: y18n2.getLocale.bind(y18n2),
    updateLocale: y18n2.updateLocale.bind(y18n2),
    locale: y18n2.locale
  };
}
var nodePlatformShim = {
  fs: {
    readFileSync: fs$1.readFileSync,
    writeFile: fs$1.writeFile
  },
  format: util.format,
  resolve: path.resolve,
  exists: (file2) => {
    try {
      return fs$1.statSync(file2).isFile();
    } catch (err) {
      return false;
    }
  }
};
const y18n = (opts) => {
  return y18n$1(opts, nodePlatformShim);
};
var build$1 = y18n;
const y18n$2 = /* @__PURE__ */ getDefaultExportFromCjs(build$1);
const REQUIRE_ERROR = "require is not supported by ESM";
const REQUIRE_DIRECTORY_ERROR = "loading a directory of commands is not supported yet for ESM";
let __dirname$1;
try {
  __dirname$1 = require$$5$1.fileURLToPath(typeof document === "undefined" ? require("url").pathToFileURL(__filename).href : _documentCurrentScript && _documentCurrentScript.src || new URL("main-BFKTUpjP.js", document.baseURI).href);
} catch (e2) {
  __dirname$1 = process.cwd();
}
const mainFilename = __dirname$1.substring(0, __dirname$1.lastIndexOf("node_modules"));
({
  assert: {
    notStrictEqual: require$$2.notStrictEqual,
    strictEqual: require$$2.strictEqual
  },
  cliui: cliui$1,
  findUp: escalade,
  getEnv: (key) => {
    return process.env[key];
  },
  inspect: require$$4.inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: yargsParser,
  path: {
    basename: path$e.basename,
    dirname: path$e.dirname,
    extname: path$e.extname,
    relative: path$e.relative,
    resolve: path$e.resolve
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
  },
  readFileSync: fs$o.readFileSync,
  require: () => {
    throw new YError(REQUIRE_ERROR);
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  stringWidth: (str) => {
    return [...str].length;
  },
  y18n: y18n$2({
    directory: path$e.resolve(__dirname$1, "../../../locales"),
    updateFiles: false
  })
});
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib);
var getCallerFile = function getCallerFile2(position) {
  if (position === void 0) {
    position = 2;
  }
  if (position >= Error.stackTraceLimit) {
    throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
  }
  var oldPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = function(_2, stack2) {
    return stack2;
  };
  var stack = new Error().stack;
  Error.prepareStackTrace = oldPrepareStackTrace;
  if (stack !== null && typeof stack === "object") {
    return stack[position] ? stack[position].getFileName() : void 0;
  }
};
var requireDirectory$1 = { exports: {} };
var fs = fs$o, join = path$e.join, resolve = path$e.resolve, dirname = path$e.dirname, defaultOptions = {
  extensions: ["js", "json", "coffee"],
  recurse: true,
  rename: function(name2) {
    return name2;
  },
  visit: function(obj) {
    return obj;
  }
};
function checkFileInclusion(path2, filename, options) {
  return (
    // verify file has valid extension
    new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && // if options.include is a RegExp, evaluate it and make sure the path passes
    !(options.include && options.include instanceof RegExp && !options.include.test(path2)) && // if options.include is a function, evaluate it and make sure the path passes
    !(options.include && typeof options.include === "function" && !options.include(path2, filename)) && // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path2)) && // if options.exclude is a function, evaluate it and make sure the path doesn't pass
    !(options.exclude && typeof options.exclude === "function" && options.exclude(path2, filename))
  );
}
function requireDirectory(m2, path2, options) {
  var retval = {};
  if (path2 && !options && typeof path2 !== "string") {
    options = path2;
    path2 = null;
  }
  options = options || {};
  for (var prop in defaultOptions) {
    if (typeof options[prop] === "undefined") {
      options[prop] = defaultOptions[prop];
    }
  }
  path2 = !path2 ? dirname(m2.filename) : resolve(dirname(m2.filename), path2);
  fs.readdirSync(path2).forEach(function(filename) {
    var joined = join(path2, filename), files2, key, obj;
    if (fs.statSync(joined).isDirectory() && options.recurse) {
      files2 = requireDirectory(m2, joined, options);
      if (Object.keys(files2).length) {
        retval[options.rename(filename, joined, filename)] = files2;
      }
    } else {
      if (joined !== m2.filename && checkFileInclusion(joined, filename, options)) {
        key = filename.substring(0, filename.lastIndexOf("."));
        obj = m2.require(joined);
        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
      }
    }
  });
  return retval;
}
requireDirectory$1.exports = requireDirectory;
requireDirectory$1.exports.defaults = defaultOptions;
var requireDirectoryExports = requireDirectory$1.exports;
var t = require$$2;
class e extends Error {
  constructor(t2) {
    super(t2 || "yargs error"), this.name = "YError", Error.captureStackTrace && Error.captureStackTrace(this, e);
  }
}
let s, i = [];
function n(t2, o2, a2, h2) {
  s = h2;
  let l2 = {};
  if (Object.prototype.hasOwnProperty.call(t2, "extends")) {
    if ("string" != typeof t2.extends)
      return l2;
    const r2 = /\.json|\..*rc$/.test(t2.extends);
    let h3 = null;
    if (r2)
      h3 = function(t3, e2) {
        return s.path.resolve(t3, e2);
      }(o2, t2.extends);
    else
      try {
        h3 = require.resolve(t2.extends);
      } catch (e2) {
        return t2;
      }
    !function(t3) {
      if (i.indexOf(t3) > -1)
        throw new e(`Circular extended configurations: '${t3}'.`);
    }(h3), i.push(h3), l2 = r2 ? JSON.parse(s.readFileSync(h3, "utf8")) : commonjsRequire(t2.extends), delete t2.extends, l2 = n(l2, s.path.dirname(h3), a2, s);
  }
  return i = [], a2 ? r(l2, t2) : Object.assign({}, l2, t2);
}
function r(t2, e2) {
  const s2 = {};
  function i2(t3) {
    return t3 && "object" == typeof t3 && !Array.isArray(t3);
  }
  Object.assign(s2, t2);
  for (const n2 of Object.keys(e2))
    i2(e2[n2]) && i2(s2[n2]) ? s2[n2] = r(t2[n2], e2[n2]) : s2[n2] = e2[n2];
  return s2;
}
function o(t2) {
  const e2 = t2.replace(/\s{2,}/g, " ").split(/\s+(?![^[]*]|[^<]*>)/), s2 = /\.*[\][<>]/g, i2 = e2.shift();
  if (!i2)
    throw new Error(`No command found in: ${t2}`);
  const n2 = { cmd: i2.replace(s2, ""), demanded: [], optional: [] };
  return e2.forEach((t3, i3) => {
    let r2 = false;
    t3 = t3.replace(/\s/g, ""), /\.+[\]>]/.test(t3) && i3 === e2.length - 1 && (r2 = true), /^\[/.test(t3) ? n2.optional.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 }) : n2.demanded.push({ cmd: t3.replace(s2, "").split("|"), variadic: r2 });
  }), n2;
}
const a = ["first", "second", "third", "fourth", "fifth", "sixth"];
function h(t2, s2, i2) {
  try {
    let n2 = 0;
    const [r2, a2, h2] = "object" == typeof t2 ? [{ demanded: [], optional: [] }, t2, s2] : [o(`cmd ${t2}`), s2, i2], f2 = [].slice.call(a2);
    for (; f2.length && void 0 === f2[f2.length - 1]; )
      f2.pop();
    const d2 = h2 || f2.length;
    if (d2 < r2.demanded.length)
      throw new e(`Not enough arguments provided. Expected ${r2.demanded.length} but received ${f2.length}.`);
    const u2 = r2.demanded.length + r2.optional.length;
    if (d2 > u2)
      throw new e(`Too many arguments provided. Expected max ${u2} but received ${d2}.`);
    r2.demanded.forEach((t3) => {
      const e2 = l(f2.shift());
      0 === t3.cmd.filter((t4) => t4 === e2 || "*" === t4).length && c(e2, t3.cmd, n2), n2 += 1;
    }), r2.optional.forEach((t3) => {
      if (0 === f2.length)
        return;
      const e2 = l(f2.shift());
      0 === t3.cmd.filter((t4) => t4 === e2 || "*" === t4).length && c(e2, t3.cmd, n2), n2 += 1;
    });
  } catch (t3) {
    console.warn(t3.stack);
  }
}
function l(t2) {
  return Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
}
function c(t2, s2, i2) {
  throw new e(`Invalid ${a[i2] || "manyith"} argument. Expected ${s2.join(" or ")} but received ${t2}.`);
}
function f(t2) {
  return !!t2 && !!t2.then && "function" == typeof t2.then;
}
function d(t2, e2, s2, i2) {
  s2.assert.notStrictEqual(t2, e2, i2);
}
function u(t2, e2) {
  e2.assert.strictEqual(typeof t2, "string");
}
function p(t2) {
  return Object.keys(t2);
}
function g(t2 = {}, e2 = () => true) {
  const s2 = {};
  return p(t2).forEach((i2) => {
    e2(i2, t2[i2]) && (s2[i2] = t2[i2]);
  }), s2;
}
function m() {
  return process.versions.electron && !process.defaultApp ? 0 : 1;
}
function y() {
  return process.argv[m()];
}
var b = Object.freeze({ __proto__: null, hideBin: function(t2) {
  return t2.slice(m() + 1);
}, getProcessArgvBin: y });
function v(t2, e2, s2, i2) {
  if ("a" === s2 && !i2)
    throw new TypeError("Private accessor was defined without a getter");
  if ("function" == typeof e2 ? t2 !== e2 || !i2 : !e2.has(t2))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return "m" === s2 ? i2 : "a" === s2 ? i2.call(t2) : i2 ? i2.value : e2.get(t2);
}
function O(t2, e2, s2, i2, n2) {
  if ("m" === i2)
    throw new TypeError("Private method is not writable");
  if ("a" === i2 && !n2)
    throw new TypeError("Private accessor was defined without a setter");
  if ("function" == typeof e2 ? t2 !== e2 || !n2 : !e2.has(t2))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return "a" === i2 ? n2.call(t2, s2) : n2 ? n2.value = s2 : e2.set(t2, s2), s2;
}
class w {
  constructor(t2) {
    this.globalMiddleware = [], this.frozens = [], this.yargs = t2;
  }
  addMiddleware(t2, e2, s2 = true, i2 = false) {
    if (h("<array|function> [boolean] [boolean] [boolean]", [t2, e2, s2], arguments.length), Array.isArray(t2)) {
      for (let i3 = 0; i3 < t2.length; i3++) {
        if ("function" != typeof t2[i3])
          throw Error("middleware must be a function");
        const n2 = t2[i3];
        n2.applyBeforeValidation = e2, n2.global = s2;
      }
      Array.prototype.push.apply(this.globalMiddleware, t2);
    } else if ("function" == typeof t2) {
      const n2 = t2;
      n2.applyBeforeValidation = e2, n2.global = s2, n2.mutates = i2, this.globalMiddleware.push(t2);
    }
    return this.yargs;
  }
  addCoerceMiddleware(t2, e2) {
    const s2 = this.yargs.getAliases();
    return this.globalMiddleware = this.globalMiddleware.filter((t3) => {
      const i2 = [...s2[e2] || [], e2];
      return !t3.option || !i2.includes(t3.option);
    }), t2.option = e2, this.addMiddleware(t2, true, true, true);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const t2 = this.frozens.pop();
    void 0 !== t2 && (this.globalMiddleware = t2);
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((t2) => t2.global);
  }
}
function C(t2, e2, s2, i2) {
  return s2.reduce((t3, s3) => {
    if (s3.applyBeforeValidation !== i2)
      return t3;
    if (s3.mutates) {
      if (s3.applied)
        return t3;
      s3.applied = true;
    }
    if (f(t3))
      return t3.then((t4) => Promise.all([t4, s3(t4, e2)])).then(([t4, e3]) => Object.assign(t4, e3));
    {
      const i3 = s3(t3, e2);
      return f(i3) ? i3.then((e3) => Object.assign(t3, e3)) : Object.assign(t3, i3);
    }
  }, t2);
}
function j(t2, e2, s2 = (t3) => {
  throw t3;
}) {
  try {
    const s3 = "function" == typeof t2 ? t2() : t2;
    return f(s3) ? s3.then((t3) => e2(t3)) : e2(s3);
  } catch (t3) {
    return s2(t3);
  }
}
const M = /(^\*)|(^\$0)/;
class _ {
  constructor(t2, e2, s2, i2) {
    this.requireCache = /* @__PURE__ */ new Set(), this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = i2, this.usage = t2, this.globalMiddleware = s2, this.validation = e2;
  }
  addDirectory(t2, e2, s2, i2) {
    "boolean" != typeof (i2 = i2 || {}).recurse && (i2.recurse = false), Array.isArray(i2.extensions) || (i2.extensions = ["js"]);
    const n2 = "function" == typeof i2.visit ? i2.visit : (t3) => t3;
    i2.visit = (t3, e3, s3) => {
      const i3 = n2(t3, e3, s3);
      if (i3) {
        if (this.requireCache.has(e3))
          return i3;
        this.requireCache.add(e3), this.addHandler(i3);
      }
      return i3;
    }, this.shim.requireDirectory({ require: e2, filename: s2 }, t2, i2);
  }
  addHandler(t2, e2, s2, i2, n2, r2) {
    let a2 = [];
    const h2 = function(t3) {
      return t3 ? t3.map((t4) => (t4.applyBeforeValidation = false, t4)) : [];
    }(n2);
    if (i2 = i2 || (() => {
    }), Array.isArray(t2))
      if (function(t3) {
        return t3.every((t4) => "string" == typeof t4);
      }(t2))
        [t2, ...a2] = t2;
      else
        for (const e3 of t2)
          this.addHandler(e3);
    else {
      if (function(t3) {
        return "object" == typeof t3 && !Array.isArray(t3);
      }(t2)) {
        let e3 = Array.isArray(t2.command) || "string" == typeof t2.command ? t2.command : this.moduleName(t2);
        return t2.aliases && (e3 = [].concat(e3).concat(t2.aliases)), void this.addHandler(e3, this.extractDesc(t2), t2.builder, t2.handler, t2.middlewares, t2.deprecated);
      }
      if (k(s2))
        return void this.addHandler([t2].concat(a2), e2, s2.builder, s2.handler, s2.middlewares, s2.deprecated);
    }
    if ("string" == typeof t2) {
      const n3 = o(t2);
      a2 = a2.map((t3) => o(t3).cmd);
      let l2 = false;
      const c2 = [n3.cmd].concat(a2).filter((t3) => !M.test(t3) || (l2 = true, false));
      0 === c2.length && l2 && c2.push("$0"), l2 && (n3.cmd = c2[0], a2 = c2.slice(1), t2 = t2.replace(M, n3.cmd)), a2.forEach((t3) => {
        this.aliasMap[t3] = n3.cmd;
      }), false !== e2 && this.usage.command(t2, e2, l2, a2, r2), this.handlers[n3.cmd] = { original: t2, description: e2, handler: i2, builder: s2 || {}, middlewares: h2, deprecated: r2, demanded: n3.demanded, optional: n3.optional }, l2 && (this.defaultCommand = this.handlers[n3.cmd]);
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(t2, e2, s2, i2, n2, r2) {
    const o2 = this.handlers[t2] || this.handlers[this.aliasMap[t2]] || this.defaultCommand, a2 = e2.getInternalMethods().getContext(), h2 = a2.commands.slice(), l2 = !t2;
    t2 && (a2.commands.push(t2), a2.fullCommands.push(o2.original));
    const c2 = this.applyBuilderUpdateUsageAndParse(l2, o2, e2, s2.aliases, h2, i2, n2, r2);
    return f(c2) ? c2.then((t3) => this.applyMiddlewareAndGetResult(l2, o2, t3.innerArgv, a2, n2, t3.aliases, e2)) : this.applyMiddlewareAndGetResult(l2, o2, c2.innerArgv, a2, n2, c2.aliases, e2);
  }
  applyBuilderUpdateUsageAndParse(t2, e2, s2, i2, n2, r2, o2, a2) {
    const h2 = e2.builder;
    let l2 = s2;
    if (x(h2)) {
      s2.getInternalMethods().getUsageInstance().freeze();
      const c2 = h2(s2.getInternalMethods().reset(i2), a2);
      if (f(c2))
        return c2.then((i3) => {
          var a3;
          return l2 = (a3 = i3) && "function" == typeof a3.getInternalMethods ? i3 : s2, this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
        });
    } else
      /* @__PURE__ */ (function(t3) {
        return "object" == typeof t3;
      })(h2) && (s2.getInternalMethods().getUsageInstance().freeze(), l2 = s2.getInternalMethods().reset(i2), Object.keys(e2.builder).forEach((t3) => {
        l2.option(t3, h2[t3]);
      }));
    return this.parseAndUpdateUsage(t2, e2, l2, n2, r2, o2);
  }
  parseAndUpdateUsage(t2, e2, s2, i2, n2, r2) {
    t2 && s2.getInternalMethods().getUsageInstance().unfreeze(true), this.shouldUpdateUsage(s2) && s2.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i2, e2), e2.description);
    const o2 = s2.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, true, n2, r2);
    return f(o2) ? o2.then((t3) => ({ aliases: s2.parsed.aliases, innerArgv: t3 })) : { aliases: s2.parsed.aliases, innerArgv: o2 };
  }
  shouldUpdateUsage(t2) {
    return !t2.getInternalMethods().getUsageInstance().getUsageDisabled() && 0 === t2.getInternalMethods().getUsageInstance().getUsage().length;
  }
  usageFromParentCommandsCommandHandler(t2, e2) {
    const s2 = M.test(e2.original) ? e2.original.replace(M, "").trim() : e2.original, i2 = t2.filter((t3) => !M.test(t3));
    return i2.push(s2), `$0 ${i2.join(" ")}`;
  }
  handleValidationAndGetResult(t2, e2, s2, i2, n2, r2, o2, a2) {
    if (!r2.getInternalMethods().getHasOutput()) {
      const e3 = r2.getInternalMethods().runValidation(n2, a2, r2.parsed.error, t2);
      s2 = j(s2, (t3) => (e3(t3), t3));
    }
    if (e2.handler && !r2.getInternalMethods().getHasOutput()) {
      r2.getInternalMethods().setHasOutput();
      const i3 = !!r2.getOptions().configuration["populate--"];
      r2.getInternalMethods().postProcess(s2, i3, false, false), s2 = j(s2 = C(s2, r2, o2, false), (t3) => {
        const s3 = e2.handler(t3);
        return f(s3) ? s3.then(() => t3) : t3;
      }), t2 || r2.getInternalMethods().getUsageInstance().cacheHelpMessage(), f(s2) && !r2.getInternalMethods().hasParseCallback() && s2.catch((t3) => {
        try {
          r2.getInternalMethods().getUsageInstance().fail(null, t3);
        } catch (t4) {
        }
      });
    }
    return t2 || (i2.commands.pop(), i2.fullCommands.pop()), s2;
  }
  applyMiddlewareAndGetResult(t2, e2, s2, i2, n2, r2, o2) {
    let a2 = {};
    if (n2)
      return s2;
    o2.getInternalMethods().getHasOutput() || (a2 = this.populatePositionals(e2, s2, i2, o2));
    const h2 = this.globalMiddleware.getMiddleware().slice(0).concat(e2.middlewares), l2 = C(s2, o2, h2, true);
    return f(l2) ? l2.then((s3) => this.handleValidationAndGetResult(t2, e2, s3, i2, r2, o2, h2, a2)) : this.handleValidationAndGetResult(t2, e2, l2, i2, r2, o2, h2, a2);
  }
  populatePositionals(t2, e2, s2, i2) {
    e2._ = e2._.slice(s2.commands.length);
    const n2 = t2.demanded.slice(0), r2 = t2.optional.slice(0), o2 = {};
    for (this.validation.positionalCount(n2.length, e2._.length); n2.length; ) {
      const t3 = n2.shift();
      this.populatePositional(t3, e2, o2);
    }
    for (; r2.length; ) {
      const t3 = r2.shift();
      this.populatePositional(t3, e2, o2);
    }
    return e2._ = s2.commands.concat(e2._.map((t3) => "" + t3)), this.postProcessPositionals(e2, o2, this.cmdToParseOptions(t2.original), i2), o2;
  }
  populatePositional(t2, e2, s2) {
    const i2 = t2.cmd[0];
    t2.variadic ? s2[i2] = e2._.splice(0).map(String) : e2._.length && (s2[i2] = [String(e2._.shift())]);
  }
  cmdToParseOptions(t2) {
    const e2 = { array: [], default: {}, alias: {}, demand: {} }, s2 = o(t2);
    return s2.demanded.forEach((t3) => {
      const [s3, ...i2] = t3.cmd;
      t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2, e2.demand[s3] = true;
    }), s2.optional.forEach((t3) => {
      const [s3, ...i2] = t3.cmd;
      t3.variadic && (e2.array.push(s3), e2.default[s3] = []), e2.alias[s3] = i2;
    }), e2;
  }
  postProcessPositionals(t2, e2, s2, i2) {
    const n2 = Object.assign({}, i2.getOptions());
    n2.default = Object.assign(s2.default, n2.default);
    for (const t3 of Object.keys(s2.alias))
      n2.alias[t3] = (n2.alias[t3] || []).concat(s2.alias[t3]);
    n2.array = n2.array.concat(s2.array), n2.config = {};
    const r2 = [];
    if (Object.keys(e2).forEach((t3) => {
      e2[t3].map((e3) => {
        n2.configuration["unknown-options-as-args"] && (n2.key[t3] = true), r2.push(`--${t3}`), r2.push(e3);
      });
    }), !r2.length)
      return;
    const o2 = Object.assign({}, n2.configuration, { "populate--": false }), a2 = this.shim.Parser.detailed(r2, Object.assign({}, n2, { configuration: o2 }));
    if (a2.error)
      i2.getInternalMethods().getUsageInstance().fail(a2.error.message, a2.error);
    else {
      const s3 = Object.keys(e2);
      Object.keys(e2).forEach((t3) => {
        s3.push(...a2.aliases[t3]);
      }), Object.keys(a2.argv).forEach((n3) => {
        s3.includes(n3) && (e2[n3] || (e2[n3] = a2.argv[n3]), !this.isInConfigs(i2, n3) && !this.isDefaulted(i2, n3) && Object.prototype.hasOwnProperty.call(t2, n3) && Object.prototype.hasOwnProperty.call(a2.argv, n3) && (Array.isArray(t2[n3]) || Array.isArray(a2.argv[n3])) ? t2[n3] = [].concat(t2[n3], a2.argv[n3]) : t2[n3] = a2.argv[n3]);
      });
    }
  }
  isDefaulted(t2, e2) {
    const { default: s2 } = t2.getOptions();
    return Object.prototype.hasOwnProperty.call(s2, e2) || Object.prototype.hasOwnProperty.call(s2, this.shim.Parser.camelCase(e2));
  }
  isInConfigs(t2, e2) {
    const { configObjects: s2 } = t2.getOptions();
    return s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, e2)) || s2.some((t3) => Object.prototype.hasOwnProperty.call(t3, this.shim.Parser.camelCase(e2)));
  }
  runDefaultBuilderOn(t2) {
    if (!this.defaultCommand)
      return;
    if (this.shouldUpdateUsage(t2)) {
      const e3 = M.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
      t2.getInternalMethods().getUsageInstance().usage(e3, this.defaultCommand.description);
    }
    const e2 = this.defaultCommand.builder;
    if (x(e2))
      return e2(t2, true);
    k(e2) || Object.keys(e2).forEach((s2) => {
      t2.option(s2, e2[s2]);
    });
  }
  moduleName(t2) {
    const e2 = function(t3) {
      if ("undefined" == typeof commonjsRequire)
        return null;
      for (let e3, s2 = 0, i2 = Object.keys(require.cache); s2 < i2.length; s2++)
        if (e3 = require.cache[i2[s2]], e3.exports === t3)
          return e3;
      return null;
    }(t2);
    if (!e2)
      throw new Error(`No command name given for module: ${this.shim.inspect(t2)}`);
    return this.commandFromFilename(e2.filename);
  }
  commandFromFilename(t2) {
    return this.shim.path.basename(t2, this.shim.path.extname(t2));
  }
  extractDesc({ describe: t2, description: e2, desc: s2 }) {
    for (const i2 of [t2, e2, s2]) {
      if ("string" == typeof i2 || false === i2)
        return i2;
      d(i2, true, this.shim);
    }
    return false;
  }
  freeze() {
    this.frozens.push({ handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand });
  }
  unfreeze() {
    const t2 = this.frozens.pop();
    d(t2, void 0, this.shim), { handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand } = t2;
  }
  reset() {
    return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = void 0, this.requireCache = /* @__PURE__ */ new Set(), this;
  }
}
function k(t2) {
  return "object" == typeof t2 && !!t2.builder && "function" == typeof t2.handler;
}
function x(t2) {
  return "function" == typeof t2;
}
function E(t2) {
  "undefined" != typeof process && [process.stdout, process.stderr].forEach((e2) => {
    const s2 = e2;
    s2._handle && s2.isTTY && "function" == typeof s2._handle.setBlocking && s2._handle.setBlocking(t2);
  });
}
function A(t2) {
  return "boolean" == typeof t2;
}
function P(t2, s2) {
  const i2 = s2.y18n.__, n2 = {}, r2 = [];
  n2.failFn = function(t3) {
    r2.push(t3);
  };
  let o2 = null, a2 = null, h2 = true;
  n2.showHelpOnFail = function(e2 = true, s3) {
    const [i3, r3] = "string" == typeof e2 ? [true, e2] : [e2, s3];
    return t2.getInternalMethods().isGlobalContext() && (a2 = r3), o2 = r3, h2 = i3, n2;
  };
  let l2 = false;
  n2.fail = function(s3, i3) {
    const c3 = t2.getInternalMethods().getLoggerInstance();
    if (!r2.length) {
      if (t2.getExitProcess() && E(true), !l2) {
        l2 = true, h2 && (t2.showHelp("error"), c3.error()), (s3 || i3) && c3.error(s3 || i3);
        const e2 = o2 || a2;
        e2 && ((s3 || i3) && c3.error(""), c3.error(e2));
      }
      if (i3 = i3 || new e(s3), t2.getExitProcess())
        return t2.exit(1);
      if (t2.getInternalMethods().hasParseCallback())
        return t2.exit(1, i3);
      throw i3;
    }
    for (let t3 = r2.length - 1; t3 >= 0; --t3) {
      const e2 = r2[t3];
      if (A(e2)) {
        if (i3)
          throw i3;
        if (s3)
          throw Error(s3);
      } else
        e2(s3, i3, n2);
    }
  };
  let c2 = [], f2 = false;
  n2.usage = (t3, e2) => null === t3 ? (f2 = true, c2 = [], n2) : (f2 = false, c2.push([t3, e2 || ""]), n2), n2.getUsage = () => c2, n2.getUsageDisabled = () => f2, n2.getPositionalGroupName = () => i2("Positionals:");
  let d2 = [];
  n2.example = (t3, e2) => {
    d2.push([t3, e2 || ""]);
  };
  let u2 = [];
  n2.command = function(t3, e2, s3, i3, n3 = false) {
    s3 && (u2 = u2.map((t4) => (t4[2] = false, t4))), u2.push([t3, e2 || "", s3, i3, n3]);
  }, n2.getCommands = () => u2;
  let p2 = {};
  n2.describe = function(t3, e2) {
    Array.isArray(t3) ? t3.forEach((t4) => {
      n2.describe(t4, e2);
    }) : "object" == typeof t3 ? Object.keys(t3).forEach((e3) => {
      n2.describe(e3, t3[e3]);
    }) : p2[t3] = e2;
  }, n2.getDescriptions = () => p2;
  let m2 = [];
  n2.epilog = (t3) => {
    m2.push(t3);
  };
  let y2, b2 = false;
  n2.wrap = (t3) => {
    b2 = true, y2 = t3;
  }, n2.getWrap = () => s2.getEnv("YARGS_DISABLE_WRAP") ? null : (b2 || (y2 = function() {
    const t3 = 80;
    return s2.process.stdColumns ? Math.min(t3, s2.process.stdColumns) : t3;
  }(), b2 = true), y2);
  const v2 = "__yargsString__:";
  function O2(t3, e2, i3) {
    let n3 = 0;
    return Array.isArray(t3) || (t3 = Object.values(t3).map((t4) => [t4])), t3.forEach((t4) => {
      n3 = Math.max(s2.stringWidth(i3 ? `${i3} ${I(t4[0])}` : I(t4[0])) + $(t4[0]), n3);
    }), e2 && (n3 = Math.min(n3, parseInt((0.5 * e2).toString(), 10))), n3;
  }
  let w2;
  function C2(e2) {
    return t2.getOptions().hiddenOptions.indexOf(e2) < 0 || t2.parsed.argv[t2.getOptions().showHiddenOpt];
  }
  function j2(t3, e2) {
    let s3 = `[${i2("default:")} `;
    if (void 0 === t3 && !e2)
      return null;
    if (e2)
      s3 += e2;
    else
      switch (typeof t3) {
        case "string":
          s3 += `"${t3}"`;
          break;
        case "object":
          s3 += JSON.stringify(t3);
          break;
        default:
          s3 += t3;
      }
    return `${s3}]`;
  }
  n2.deferY18nLookup = (t3) => v2 + t3, n2.help = function() {
    if (w2)
      return w2;
    !function() {
      const e3 = t2.getDemandedOptions(), s3 = t2.getOptions();
      (Object.keys(s3.alias) || []).forEach((i3) => {
        s3.alias[i3].forEach((r4) => {
          p2[r4] && n2.describe(i3, p2[r4]), r4 in e3 && t2.demandOption(i3, e3[r4]), s3.boolean.includes(r4) && t2.boolean(i3), s3.count.includes(r4) && t2.count(i3), s3.string.includes(r4) && t2.string(i3), s3.normalize.includes(r4) && t2.normalize(i3), s3.array.includes(r4) && t2.array(i3), s3.number.includes(r4) && t2.number(i3);
        });
      });
    }();
    const e2 = t2.customScriptName ? t2.$0 : s2.path.basename(t2.$0), r3 = t2.getDemandedOptions(), o3 = t2.getDemandedCommands(), a3 = t2.getDeprecatedOptions(), h3 = t2.getGroups(), l3 = t2.getOptions();
    let g2 = [];
    g2 = g2.concat(Object.keys(p2)), g2 = g2.concat(Object.keys(r3)), g2 = g2.concat(Object.keys(o3)), g2 = g2.concat(Object.keys(l3.default)), g2 = g2.filter(C2), g2 = Object.keys(g2.reduce((t3, e3) => ("_" !== e3 && (t3[e3] = true), t3), {}));
    const y3 = n2.getWrap(), b3 = s2.cliui({ width: y3, wrap: !!y3 });
    if (!f2) {
      if (c2.length)
        c2.forEach((t3) => {
          b3.div({ text: `${t3[0].replace(/\$0/g, e2)}` }), t3[1] && b3.div({ text: `${t3[1]}`, padding: [1, 0, 0, 0] });
        }), b3.div();
      else if (u2.length) {
        let t3 = null;
        t3 = o3._ ? `${e2} <${i2("command")}>
` : `${e2} [${i2("command")}]
`, b3.div(`${t3}`);
      }
    }
    if (u2.length > 1 || 1 === u2.length && !u2[0][2]) {
      b3.div(i2("Commands:"));
      const s3 = t2.getInternalMethods().getContext(), n3 = s3.commands.length ? `${s3.commands.join(" ")} ` : "";
      true === t2.getInternalMethods().getParserConfiguration()["sort-commands"] && (u2 = u2.sort((t3, e3) => t3[0].localeCompare(e3[0])));
      const r4 = e2 ? `${e2} ` : "";
      u2.forEach((t3) => {
        const s4 = `${r4}${n3}${t3[0].replace(/^\$0 ?/, "")}`;
        b3.span({ text: s4, padding: [0, 2, 0, 2], width: O2(u2, y3, `${e2}${n3}`) + 4 }, { text: t3[1] });
        const o4 = [];
        t3[2] && o4.push(`[${i2("default")}]`), t3[3] && t3[3].length && o4.push(`[${i2("aliases:")} ${t3[3].join(", ")}]`), t3[4] && ("string" == typeof t3[4] ? o4.push(`[${i2("deprecated: %s", t3[4])}]`) : o4.push(`[${i2("deprecated")}]`)), o4.length ? b3.div({ text: o4.join(" "), padding: [0, 0, 0, 2], align: "right" }) : b3.div();
      }), b3.div();
    }
    const M3 = (Object.keys(l3.alias) || []).concat(Object.keys(t2.parsed.newAliases) || []);
    g2 = g2.filter((e3) => !t2.parsed.newAliases[e3] && M3.every((t3) => -1 === (l3.alias[t3] || []).indexOf(e3)));
    const _3 = i2("Options:");
    h3[_3] || (h3[_3] = []), function(t3, e3, s3, i3) {
      let n3 = [], r4 = null;
      Object.keys(s3).forEach((t4) => {
        n3 = n3.concat(s3[t4]);
      }), t3.forEach((t4) => {
        r4 = [t4].concat(e3[t4]), r4.some((t5) => -1 !== n3.indexOf(t5)) || s3[i3].push(t4);
      });
    }(g2, l3.alias, h3, _3);
    const k2 = (t3) => /^--/.test(I(t3)), x2 = Object.keys(h3).filter((t3) => h3[t3].length > 0).map((t3) => ({ groupName: t3, normalizedKeys: h3[t3].filter(C2).map((t4) => {
      if (M3.includes(t4))
        return t4;
      for (let e3, s3 = 0; void 0 !== (e3 = M3[s3]); s3++)
        if ((l3.alias[e3] || []).includes(t4))
          return e3;
      return t4;
    }) })).filter(({ normalizedKeys: t3 }) => t3.length > 0).map(({ groupName: t3, normalizedKeys: e3 }) => {
      const s3 = e3.reduce((e4, s4) => (e4[s4] = [s4].concat(l3.alias[s4] || []).map((e5) => t3 === n2.getPositionalGroupName() ? e5 : (/^[0-9]$/.test(e5) ? l3.boolean.includes(s4) ? "-" : "--" : e5.length > 1 ? "--" : "-") + e5).sort((t4, e5) => k2(t4) === k2(e5) ? 0 : k2(t4) ? 1 : -1).join(", "), e4), {});
      return { groupName: t3, normalizedKeys: e3, switches: s3 };
    });
    if (x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).some(({ normalizedKeys: t3, switches: e3 }) => !t3.every((t4) => k2(e3[t4]))) && x2.filter(({ groupName: t3 }) => t3 !== n2.getPositionalGroupName()).forEach(({ normalizedKeys: t3, switches: e3 }) => {
      t3.forEach((t4) => {
        var s3, i3;
        k2(e3[t4]) && (e3[t4] = (s3 = e3[t4], i3 = 4, S(s3) ? { text: s3.text, indentation: s3.indentation + i3 } : { text: s3, indentation: i3 }));
      });
    }), x2.forEach(({ groupName: e3, normalizedKeys: s3, switches: o4 }) => {
      b3.div(e3), s3.forEach((e4) => {
        const s4 = o4[e4];
        let h4 = p2[e4] || "", c3 = null;
        h4.includes(v2) && (h4 = i2(h4.substring(16))), l3.boolean.includes(e4) && (c3 = `[${i2("boolean")}]`), l3.count.includes(e4) && (c3 = `[${i2("count")}]`), l3.string.includes(e4) && (c3 = `[${i2("string")}]`), l3.normalize.includes(e4) && (c3 = `[${i2("string")}]`), l3.array.includes(e4) && (c3 = `[${i2("array")}]`), l3.number.includes(e4) && (c3 = `[${i2("number")}]`);
        const f3 = [e4 in a3 ? (d3 = a3[e4], "string" == typeof d3 ? `[${i2("deprecated: %s", d3)}]` : `[${i2("deprecated")}]`) : null, c3, e4 in r3 ? `[${i2("required")}]` : null, l3.choices && l3.choices[e4] ? `[${i2("choices:")} ${n2.stringifiedValues(l3.choices[e4])}]` : null, j2(l3.default[e4], l3.defaultDescription[e4])].filter(Boolean).join(" ");
        var d3;
        b3.span({ text: I(s4), padding: [0, 2, 0, 2 + $(s4)], width: O2(o4, y3) + 4 }, h4);
        const u3 = true === t2.getInternalMethods().getUsageConfiguration()["hide-types"];
        f3 && !u3 ? b3.div({ text: f3, padding: [0, 0, 0, 2], align: "right" }) : b3.div();
      }), b3.div();
    }), d2.length && (b3.div(i2("Examples:")), d2.forEach((t3) => {
      t3[0] = t3[0].replace(/\$0/g, e2);
    }), d2.forEach((t3) => {
      "" === t3[1] ? b3.div({ text: t3[0], padding: [0, 2, 0, 2] }) : b3.div({ text: t3[0], padding: [0, 2, 0, 2], width: O2(d2, y3) + 4 }, { text: t3[1] });
    }), b3.div()), m2.length > 0) {
      const t3 = m2.map((t4) => t4.replace(/\$0/g, e2)).join("\n");
      b3.div(`${t3}
`);
    }
    return b3.toString().replace(/\s*$/, "");
  }, n2.cacheHelpMessage = function() {
    w2 = this.help();
  }, n2.clearCachedHelpMessage = function() {
    w2 = void 0;
  }, n2.hasCachedHelpMessage = function() {
    return !!w2;
  }, n2.showHelp = (e2) => {
    const s3 = t2.getInternalMethods().getLoggerInstance();
    e2 || (e2 = "error");
    ("function" == typeof e2 ? e2 : s3[e2])(n2.help());
  }, n2.functionDescription = (t3) => ["(", t3.name ? s2.Parser.decamelize(t3.name, "-") : i2("generated-value"), ")"].join(""), n2.stringifiedValues = function(t3, e2) {
    let s3 = "";
    const i3 = e2 || ", ", n3 = [].concat(t3);
    return t3 && n3.length ? (n3.forEach((t4) => {
      s3.length && (s3 += i3), s3 += JSON.stringify(t4);
    }), s3) : s3;
  };
  let M2 = null;
  n2.version = (t3) => {
    M2 = t3;
  }, n2.showVersion = (e2) => {
    const s3 = t2.getInternalMethods().getLoggerInstance();
    e2 || (e2 = "error");
    ("function" == typeof e2 ? e2 : s3[e2])(M2);
  }, n2.reset = function(t3) {
    return o2 = null, l2 = false, c2 = [], f2 = false, m2 = [], d2 = [], u2 = [], p2 = g(p2, (e2) => !t3[e2]), n2;
  };
  const _2 = [];
  return n2.freeze = function() {
    _2.push({ failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 });
  }, n2.unfreeze = function(t3 = false) {
    const e2 = _2.pop();
    e2 && (t3 ? (p2 = { ...e2.descriptions, ...p2 }, u2 = [...e2.commands, ...u2], c2 = [...e2.usages, ...c2], d2 = [...e2.examples, ...d2], m2 = [...e2.epilogs, ...m2]) : { failMessage: o2, failureOutput: l2, usages: c2, usageDisabled: f2, epilogs: m2, examples: d2, commands: u2, descriptions: p2 } = e2);
  }, n2;
}
function S(t2) {
  return "object" == typeof t2;
}
function $(t2) {
  return S(t2) ? t2.indentation : 0;
}
function I(t2) {
  return S(t2) ? t2.text : t2;
}
class D {
  constructor(t2, e2, s2, i2) {
    var n2, r2, o2;
    this.yargs = t2, this.usage = e2, this.command = s2, this.shim = i2, this.completionKey = "get-yargs-completions", this.aliases = null, this.customCompletionFunction = null, this.indexAfterLastReset = 0, this.zshShell = null !== (o2 = (null === (n2 = this.shim.getEnv("SHELL")) || void 0 === n2 ? void 0 : n2.includes("zsh")) || (null === (r2 = this.shim.getEnv("ZSH_NAME")) || void 0 === r2 ? void 0 : r2.includes("zsh"))) && void 0 !== o2 && o2;
  }
  defaultCompletion(t2, e2, s2, i2) {
    const n2 = this.command.getCommandHandlers();
    for (let e3 = 0, s3 = t2.length; e3 < s3; ++e3)
      if (n2[t2[e3]] && n2[t2[e3]].builder) {
        const s4 = n2[t2[e3]].builder;
        if (x(s4)) {
          this.indexAfterLastReset = e3 + 1;
          const t3 = this.yargs.getInternalMethods().reset();
          return s4(t3, true), t3.argv;
        }
      }
    const r2 = [];
    this.commandCompletions(r2, t2, s2), this.optionCompletions(r2, t2, e2, s2), this.choicesFromOptionsCompletions(r2, t2, e2, s2), this.choicesFromPositionalsCompletions(r2, t2, e2, s2), i2(null, r2);
  }
  commandCompletions(t2, e2, s2) {
    const i2 = this.yargs.getInternalMethods().getContext().commands;
    s2.match(/^-/) || i2[i2.length - 1] === s2 || this.previousArgHasChoices(e2) || this.usage.getCommands().forEach((s3) => {
      const i3 = o(s3[0]).cmd;
      if (-1 === e2.indexOf(i3))
        if (this.zshShell) {
          const e3 = s3[1] || "";
          t2.push(i3.replace(/:/g, "\\:") + ":" + e3);
        } else
          t2.push(i3);
    });
  }
  optionCompletions(t2, e2, s2, i2) {
    if ((i2.match(/^-/) || "" === i2 && 0 === t2.length) && !this.previousArgHasChoices(e2)) {
      const s3 = this.yargs.getOptions(), n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(s3.key).forEach((r2) => {
        const o2 = !!s3.configuration["boolean-negation"] && s3.boolean.includes(r2);
        n2.includes(r2) || s3.hiddenOptions.includes(r2) || this.argsContainKey(e2, r2, o2) || this.completeOptionKey(r2, t2, i2, o2 && !!s3.default[r2]);
      });
    }
  }
  choicesFromOptionsCompletions(t2, e2, s2, i2) {
    if (this.previousArgHasChoices(e2)) {
      const s3 = this.getPreviousArgChoices(e2);
      s3 && s3.length > 0 && t2.push(...s3.map((t3) => t3.replace(/:/g, "\\:")));
    }
  }
  choicesFromPositionalsCompletions(t2, e2, s2, i2) {
    if ("" === i2 && t2.length > 0 && this.previousArgHasChoices(e2))
      return;
    const n2 = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [], r2 = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1), o2 = n2[s2._.length - r2 - 1];
    if (!o2)
      return;
    const a2 = this.yargs.getOptions().choices[o2] || [];
    for (const e3 of a2)
      e3.startsWith(i2) && t2.push(e3.replace(/:/g, "\\:"));
  }
  getPreviousArgChoices(t2) {
    if (t2.length < 1)
      return;
    let e2 = t2[t2.length - 1], s2 = "";
    if (!e2.startsWith("-") && t2.length > 1 && (s2 = e2, e2 = t2[t2.length - 2]), !e2.startsWith("-"))
      return;
    const i2 = e2.replace(/^-+/, ""), n2 = this.yargs.getOptions(), r2 = [i2, ...this.yargs.getAliases()[i2] || []];
    let o2;
    for (const t3 of r2)
      if (Object.prototype.hasOwnProperty.call(n2.key, t3) && Array.isArray(n2.choices[t3])) {
        o2 = n2.choices[t3];
        break;
      }
    return o2 ? o2.filter((t3) => !s2 || t3.startsWith(s2)) : void 0;
  }
  previousArgHasChoices(t2) {
    const e2 = this.getPreviousArgChoices(t2);
    return void 0 !== e2 && e2.length > 0;
  }
  argsContainKey(t2, e2, s2) {
    const i2 = (e3) => -1 !== t2.indexOf((/^[^0-9]$/.test(e3) ? "-" : "--") + e3);
    if (i2(e2))
      return true;
    if (s2 && i2(`no-${e2}`))
      return true;
    if (this.aliases) {
      for (const t3 of this.aliases[e2])
        if (i2(t3))
          return true;
    }
    return false;
  }
  completeOptionKey(t2, e2, s2, i2) {
    var n2, r2, o2, a2;
    let h2 = t2;
    if (this.zshShell) {
      const e3 = this.usage.getDescriptions(), s3 = null === (r2 = null === (n2 = null == this ? void 0 : this.aliases) || void 0 === n2 ? void 0 : n2[t2]) || void 0 === r2 ? void 0 : r2.find((t3) => {
        const s4 = e3[t3];
        return "string" == typeof s4 && s4.length > 0;
      }), i3 = s3 ? e3[s3] : void 0, l3 = null !== (a2 = null !== (o2 = e3[t2]) && void 0 !== o2 ? o2 : i3) && void 0 !== a2 ? a2 : "";
      h2 = `${t2.replace(/:/g, "\\:")}:${l3.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
    }
    const l2 = !/^--/.test(s2) && ((t3) => /^[^0-9]$/.test(t3))(t2) ? "-" : "--";
    e2.push(l2 + h2), i2 && e2.push(l2 + "no-" + h2);
  }
  customCompletion(t2, e2, s2, i2) {
    if (d(this.customCompletionFunction, null, this.shim), this.customCompletionFunction.length < 3) {
      const t3 = this.customCompletionFunction(s2, e2);
      return f(t3) ? t3.then((t4) => {
        this.shim.process.nextTick(() => {
          i2(null, t4);
        });
      }).catch((t4) => {
        this.shim.process.nextTick(() => {
          i2(t4, void 0);
        });
      }) : i2(null, t3);
    }
    return function(t3) {
      return t3.length > 3;
    }(this.customCompletionFunction) ? this.customCompletionFunction(s2, e2, (n2 = i2) => this.defaultCompletion(t2, e2, s2, n2), (t3) => {
      i2(null, t3);
    }) : this.customCompletionFunction(s2, e2, (t3) => {
      i2(null, t3);
    });
  }
  getCompletion(t2, e2) {
    const s2 = t2.length ? t2[t2.length - 1] : "", i2 = this.yargs.parse(t2, true), n2 = this.customCompletionFunction ? (i3) => this.customCompletion(t2, i3, s2, e2) : (i3) => this.defaultCompletion(t2, i3, s2, e2);
    return f(i2) ? i2.then(n2) : n2(i2);
  }
  generateCompletionScript(t2, e2) {
    let s2 = this.zshShell ? `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
` : '###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word="${COMP_WORDS[COMP_CWORD]}"\n    args=("${COMP_WORDS[@]}")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions "${args[@]}")\n\n    COMPREPLY=( $(compgen -W "${type_list}" -- ${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ ${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n';
    const i2 = this.shim.path.basename(t2);
    return t2.match(/\.js$/) && (t2 = `./${t2}`), s2 = s2.replace(/{{app_name}}/g, i2), s2 = s2.replace(/{{completion_command}}/g, e2), s2.replace(/{{app_path}}/g, t2);
  }
  registerFunction(t2) {
    this.customCompletionFunction = t2;
  }
  setParsed(t2) {
    this.aliases = t2.aliases;
  }
}
function N(t2, e2) {
  if (0 === t2.length)
    return e2.length;
  if (0 === e2.length)
    return t2.length;
  const s2 = [];
  let i2, n2;
  for (i2 = 0; i2 <= e2.length; i2++)
    s2[i2] = [i2];
  for (n2 = 0; n2 <= t2.length; n2++)
    s2[0][n2] = n2;
  for (i2 = 1; i2 <= e2.length; i2++)
    for (n2 = 1; n2 <= t2.length; n2++)
      e2.charAt(i2 - 1) === t2.charAt(n2 - 1) ? s2[i2][n2] = s2[i2 - 1][n2 - 1] : i2 > 1 && n2 > 1 && e2.charAt(i2 - 2) === t2.charAt(n2 - 1) && e2.charAt(i2 - 1) === t2.charAt(n2 - 2) ? s2[i2][n2] = s2[i2 - 2][n2 - 2] + 1 : s2[i2][n2] = Math.min(s2[i2 - 1][n2 - 1] + 1, Math.min(s2[i2][n2 - 1] + 1, s2[i2 - 1][n2] + 1));
  return s2[e2.length][t2.length];
}
const H = ["$0", "--", "_"];
var z, W, q, U, F, L, V, G, R, T, B, Y, K, J, Z, X, Q, tt, et, st, it, nt, rt, ot, at, ht, lt, ct, ft, dt, ut, pt, gt, mt, yt;
const bt = Symbol("copyDoubleDash"), vt = Symbol("copyDoubleDash"), Ot = Symbol("deleteFromParserHintObject"), wt = Symbol("emitWarning"), Ct = Symbol("freeze"), jt = Symbol("getDollarZero"), Mt = Symbol("getParserConfiguration"), _t = Symbol("getUsageConfiguration"), kt = Symbol("guessLocale"), xt = Symbol("guessVersion"), Et = Symbol("parsePositionalNumbers"), At = Symbol("pkgUp"), Pt = Symbol("populateParserHintArray"), St = Symbol("populateParserHintSingleValueDictionary"), $t = Symbol("populateParserHintArrayDictionary"), It = Symbol("populateParserHintDictionary"), Dt = Symbol("sanitizeKey"), Nt = Symbol("setKey"), Ht = Symbol("unfreeze"), zt = Symbol("validateAsync"), Wt = Symbol("getCommandInstance"), qt = Symbol("getContext"), Ut = Symbol("getHasOutput"), Ft = Symbol("getLoggerInstance"), Lt = Symbol("getParseContext"), Vt = Symbol("getUsageInstance"), Gt = Symbol("getValidationInstance"), Rt = Symbol("hasParseCallback"), Tt = Symbol("isGlobalContext"), Bt = Symbol("postProcess"), Yt = Symbol("rebase"), Kt = Symbol("reset"), Jt = Symbol("runYargsParserAndExecuteCommands"), Zt = Symbol("runValidation"), Xt = Symbol("setHasOutput"), Qt = Symbol("kTrackManuallySetKeys");
class te {
  constructor(t2 = [], e2, s2, i2) {
    this.customScriptName = false, this.parsed = false, z.set(this, void 0), W.set(this, void 0), q.set(this, { commands: [], fullCommands: [] }), U.set(this, null), F.set(this, null), L.set(this, "show-hidden"), V.set(this, null), G.set(this, true), R.set(this, {}), T.set(this, true), B.set(this, []), Y.set(this, void 0), K.set(this, {}), J.set(this, false), Z.set(this, null), X.set(this, true), Q.set(this, void 0), tt.set(this, ""), et.set(this, void 0), st.set(this, void 0), it.set(this, {}), nt.set(this, null), rt.set(this, null), ot.set(this, {}), at.set(this, {}), ht.set(this, void 0), lt.set(this, false), ct.set(this, void 0), ft.set(this, false), dt.set(this, false), ut.set(this, false), pt.set(this, void 0), gt.set(this, {}), mt.set(this, null), yt.set(this, void 0), O(this, ct, i2, "f"), O(this, ht, t2, "f"), O(this, W, e2, "f"), O(this, st, s2, "f"), O(this, Y, new w(this), "f"), this.$0 = this[jt](), this[Kt](), O(this, z, v(this, z, "f"), "f"), O(this, pt, v(this, pt, "f"), "f"), O(this, yt, v(this, yt, "f"), "f"), O(this, et, v(this, et, "f"), "f"), v(this, et, "f").showHiddenOpt = v(this, L, "f"), O(this, Q, this[vt](), "f");
  }
  addHelpOpt(t2, e2) {
    return h("[string|boolean] [string]", [t2, e2], arguments.length), v(this, Z, "f") && (this[Ot](v(this, Z, "f")), O(this, Z, null, "f")), false === t2 && void 0 === e2 || (O(this, Z, "string" == typeof t2 ? t2 : "help", "f"), this.boolean(v(this, Z, "f")), this.describe(v(this, Z, "f"), e2 || v(this, pt, "f").deferY18nLookup("Show help"))), this;
  }
  help(t2, e2) {
    return this.addHelpOpt(t2, e2);
  }
  addShowHiddenOpt(t2, e2) {
    if (h("[string|boolean] [string]", [t2, e2], arguments.length), false === t2 && void 0 === e2)
      return this;
    const s2 = "string" == typeof t2 ? t2 : v(this, L, "f");
    return this.boolean(s2), this.describe(s2, e2 || v(this, pt, "f").deferY18nLookup("Show hidden options")), v(this, et, "f").showHiddenOpt = s2, this;
  }
  showHidden(t2, e2) {
    return this.addShowHiddenOpt(t2, e2);
  }
  alias(t2, e2) {
    return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.alias.bind(this), "alias", t2, e2), this;
  }
  array(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("array", t2), this[Qt](t2), this;
  }
  boolean(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("boolean", t2), this[Qt](t2), this;
  }
  check(t2, e2) {
    return h("<function> [boolean]", [t2, e2], arguments.length), this.middleware((e3, s2) => j(() => t2(e3, s2.getOptions()), (s3) => (s3 ? ("string" == typeof s3 || s3 instanceof Error) && v(this, pt, "f").fail(s3.toString(), s3) : v(this, pt, "f").fail(v(this, ct, "f").y18n.__("Argument check failed: %s", t2.toString())), e3), (t3) => (v(this, pt, "f").fail(t3.message ? t3.message : t3.toString(), t3), e3)), false, e2), this;
  }
  choices(t2, e2) {
    return h("<object|string|array> [string|array]", [t2, e2], arguments.length), this[$t](this.choices.bind(this), "choices", t2, e2), this;
  }
  coerce(t2, s2) {
    if (h("<object|string|array> [function]", [t2, s2], arguments.length), Array.isArray(t2)) {
      if (!s2)
        throw new e("coerce callback must be provided");
      for (const e2 of t2)
        this.coerce(e2, s2);
      return this;
    }
    if ("object" == typeof t2) {
      for (const e2 of Object.keys(t2))
        this.coerce(e2, t2[e2]);
      return this;
    }
    if (!s2)
      throw new e("coerce callback must be provided");
    return v(this, et, "f").key[t2] = true, v(this, Y, "f").addCoerceMiddleware((i2, n2) => {
      let r2;
      return Object.prototype.hasOwnProperty.call(i2, t2) ? j(() => (r2 = n2.getAliases(), s2(i2[t2])), (e2) => {
        i2[t2] = e2;
        const s3 = n2.getInternalMethods().getParserConfiguration()["strip-aliased"];
        if (r2[t2] && true !== s3)
          for (const s4 of r2[t2])
            i2[s4] = e2;
        return i2;
      }, (t3) => {
        throw new e(t3.message);
      }) : i2;
    }, t2), this;
  }
  conflicts(t2, e2) {
    return h("<string|object> [string|array]", [t2, e2], arguments.length), v(this, yt, "f").conflicts(t2, e2), this;
  }
  config(t2 = "config", e2, s2) {
    return h("[object|string] [string|function] [function]", [t2, e2, s2], arguments.length), "object" != typeof t2 || Array.isArray(t2) ? ("function" == typeof e2 && (s2 = e2, e2 = void 0), this.describe(t2, e2 || v(this, pt, "f").deferY18nLookup("Path to JSON config file")), (Array.isArray(t2) ? t2 : [t2]).forEach((t3) => {
      v(this, et, "f").config[t3] = s2 || true;
    }), this) : (t2 = n(t2, v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(t2), this);
  }
  completion(t2, e2, s2) {
    return h("[string] [string|boolean|function] [function]", [t2, e2, s2], arguments.length), "function" == typeof e2 && (s2 = e2, e2 = void 0), O(this, F, t2 || v(this, F, "f") || "completion", "f"), e2 || false === e2 || (e2 = "generate completion script"), this.command(v(this, F, "f"), e2), s2 && v(this, U, "f").registerFunction(s2), this;
  }
  command(t2, e2, s2, i2, n2, r2) {
    return h("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [t2, e2, s2, i2, n2, r2], arguments.length), v(this, z, "f").addHandler(t2, e2, s2, i2, n2, r2), this;
  }
  commands(t2, e2, s2, i2, n2, r2) {
    return this.command(t2, e2, s2, i2, n2, r2);
  }
  commandDir(t2, e2) {
    h("<string> [object]", [t2, e2], arguments.length);
    const s2 = v(this, st, "f") || v(this, ct, "f").require;
    return v(this, z, "f").addDirectory(t2, s2, v(this, ct, "f").getCallerFile(), e2), this;
  }
  count(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("count", t2), this[Qt](t2), this;
  }
  default(t2, e2, s2) {
    return h("<object|string|array> [*] [string]", [t2, e2, s2], arguments.length), s2 && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] = s2), "function" == typeof e2 && (u(t2, v(this, ct, "f")), v(this, et, "f").defaultDescription[t2] || (v(this, et, "f").defaultDescription[t2] = v(this, pt, "f").functionDescription(e2)), e2 = e2.call()), this[St](this.default.bind(this), "default", t2, e2), this;
  }
  defaults(t2, e2, s2) {
    return this.default(t2, e2, s2);
  }
  demandCommand(t2 = 1, e2, s2, i2) {
    return h("[number] [number|string] [string|null|undefined] [string|null|undefined]", [t2, e2, s2, i2], arguments.length), "number" != typeof e2 && (s2 = e2, e2 = 1 / 0), this.global("_", false), v(this, et, "f").demandedCommands._ = { min: t2, max: e2, minMsg: s2, maxMsg: i2 }, this;
  }
  demand(t2, e2, s2) {
    return Array.isArray(e2) ? (e2.forEach((t3) => {
      d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
    }), e2 = 1 / 0) : "number" != typeof e2 && (s2 = e2, e2 = 1 / 0), "number" == typeof t2 ? (d(s2, true, v(this, ct, "f")), this.demandCommand(t2, e2, s2, s2)) : Array.isArray(t2) ? t2.forEach((t3) => {
      d(s2, true, v(this, ct, "f")), this.demandOption(t3, s2);
    }) : "string" == typeof s2 ? this.demandOption(t2, s2) : true !== s2 && void 0 !== s2 || this.demandOption(t2), this;
  }
  demandOption(t2, e2) {
    return h("<object|string|array> [string]", [t2, e2], arguments.length), this[St](this.demandOption.bind(this), "demandedOptions", t2, e2), this;
  }
  deprecateOption(t2, e2) {
    return h("<string> [string|boolean]", [t2, e2], arguments.length), v(this, et, "f").deprecatedOptions[t2] = e2, this;
  }
  describe(t2, e2) {
    return h("<object|string|array> [string]", [t2, e2], arguments.length), this[Nt](t2, true), v(this, pt, "f").describe(t2, e2), this;
  }
  detectLocale(t2) {
    return h("<boolean>", [t2], arguments.length), O(this, G, t2, "f"), this;
  }
  env(t2) {
    return h("[string|boolean]", [t2], arguments.length), false === t2 ? delete v(this, et, "f").envPrefix : v(this, et, "f").envPrefix = t2 || "", this;
  }
  epilogue(t2) {
    return h("<string>", [t2], arguments.length), v(this, pt, "f").epilog(t2), this;
  }
  epilog(t2) {
    return this.epilogue(t2);
  }
  example(t2, e2) {
    return h("<string|array> [string]", [t2, e2], arguments.length), Array.isArray(t2) ? t2.forEach((t3) => this.example(...t3)) : v(this, pt, "f").example(t2, e2), this;
  }
  exit(t2, e2) {
    O(this, J, true, "f"), O(this, V, e2, "f"), v(this, T, "f") && v(this, ct, "f").process.exit(t2);
  }
  exitProcess(t2 = true) {
    return h("[boolean]", [t2], arguments.length), O(this, T, t2, "f"), this;
  }
  fail(t2) {
    if (h("<function|boolean>", [t2], arguments.length), "boolean" == typeof t2 && false !== t2)
      throw new e("Invalid first argument. Expected function or boolean 'false'");
    return v(this, pt, "f").failFn(t2), this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(t2, e2) {
    return h("<array> [function]", [t2, e2], arguments.length), e2 ? v(this, U, "f").getCompletion(t2, e2) : new Promise((e3, s2) => {
      v(this, U, "f").getCompletion(t2, (t3, i2) => {
        t3 ? s2(t3) : e3(i2);
      });
    });
  }
  getDemandedOptions() {
    return h([], 0), v(this, et, "f").demandedOptions;
  }
  getDemandedCommands() {
    return h([], 0), v(this, et, "f").demandedCommands;
  }
  getDeprecatedOptions() {
    return h([], 0), v(this, et, "f").deprecatedOptions;
  }
  getDetectLocale() {
    return v(this, G, "f");
  }
  getExitProcess() {
    return v(this, T, "f");
  }
  getGroups() {
    return Object.assign({}, v(this, K, "f"), v(this, at, "f"));
  }
  getHelp() {
    if (O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const t3 = this[Jt](v(this, ht, "f"), void 0, void 0, 0, true);
        if (f(t3))
          return t3.then(() => v(this, pt, "f").help());
      }
      const t2 = v(this, z, "f").runDefaultBuilderOn(this);
      if (f(t2))
        return t2.then(() => v(this, pt, "f").help());
    }
    return Promise.resolve(v(this, pt, "f").help());
  }
  getOptions() {
    return v(this, et, "f");
  }
  getStrict() {
    return v(this, ft, "f");
  }
  getStrictCommands() {
    return v(this, dt, "f");
  }
  getStrictOptions() {
    return v(this, ut, "f");
  }
  global(t2, e2) {
    return h("<string|array> [boolean]", [t2, e2], arguments.length), t2 = [].concat(t2), false !== e2 ? v(this, et, "f").local = v(this, et, "f").local.filter((e3) => -1 === t2.indexOf(e3)) : t2.forEach((t3) => {
      v(this, et, "f").local.includes(t3) || v(this, et, "f").local.push(t3);
    }), this;
  }
  group(t2, e2) {
    h("<string|array> <string>", [t2, e2], arguments.length);
    const s2 = v(this, at, "f")[e2] || v(this, K, "f")[e2];
    v(this, at, "f")[e2] && delete v(this, at, "f")[e2];
    const i2 = {};
    return v(this, K, "f")[e2] = (s2 || []).concat(t2).filter((t3) => !i2[t3] && (i2[t3] = true)), this;
  }
  hide(t2) {
    return h("<string>", [t2], arguments.length), v(this, et, "f").hiddenOptions.push(t2), this;
  }
  implies(t2, e2) {
    return h("<string|object> [number|string|array]", [t2, e2], arguments.length), v(this, yt, "f").implies(t2, e2), this;
  }
  locale(t2) {
    return h("[string]", [t2], arguments.length), void 0 === t2 ? (this[kt](), v(this, ct, "f").y18n.getLocale()) : (O(this, G, false, "f"), v(this, ct, "f").y18n.setLocale(t2), this);
  }
  middleware(t2, e2, s2) {
    return v(this, Y, "f").addMiddleware(t2, !!e2, s2);
  }
  nargs(t2, e2) {
    return h("<string|object|array> [number]", [t2, e2], arguments.length), this[St](this.nargs.bind(this), "narg", t2, e2), this;
  }
  normalize(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("normalize", t2), this;
  }
  number(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("number", t2), this[Qt](t2), this;
  }
  option(t2, e2) {
    if (h("<string|object> [object]", [t2, e2], arguments.length), "object" == typeof t2)
      Object.keys(t2).forEach((e3) => {
        this.options(e3, t2[e3]);
      });
    else {
      "object" != typeof e2 && (e2 = {}), this[Qt](t2), !v(this, mt, "f") || "version" !== t2 && "version" !== (null == e2 ? void 0 : e2.alias) || this[wt](['"version" is a reserved word.', "Please do one of the following:", '- Disable version with `yargs.version(false)` if using "version" as an option', "- Use the built-in `yargs.version` method instead (if applicable)", "- Use a different option key", "https://yargs.js.org/docs/#api-reference-version"].join("\n"), void 0, "versionWarning"), v(this, et, "f").key[t2] = true, e2.alias && this.alias(t2, e2.alias);
      const s2 = e2.deprecate || e2.deprecated;
      s2 && this.deprecateOption(t2, s2);
      const i2 = e2.demand || e2.required || e2.require;
      i2 && this.demand(t2, i2), e2.demandOption && this.demandOption(t2, "string" == typeof e2.demandOption ? e2.demandOption : void 0), e2.conflicts && this.conflicts(t2, e2.conflicts), "default" in e2 && this.default(t2, e2.default), void 0 !== e2.implies && this.implies(t2, e2.implies), void 0 !== e2.nargs && this.nargs(t2, e2.nargs), e2.config && this.config(t2, e2.configParser), e2.normalize && this.normalize(t2), e2.choices && this.choices(t2, e2.choices), e2.coerce && this.coerce(t2, e2.coerce), e2.group && this.group(t2, e2.group), (e2.boolean || "boolean" === e2.type) && (this.boolean(t2), e2.alias && this.boolean(e2.alias)), (e2.array || "array" === e2.type) && (this.array(t2), e2.alias && this.array(e2.alias)), (e2.number || "number" === e2.type) && (this.number(t2), e2.alias && this.number(e2.alias)), (e2.string || "string" === e2.type) && (this.string(t2), e2.alias && this.string(e2.alias)), (e2.count || "count" === e2.type) && this.count(t2), "boolean" == typeof e2.global && this.global(t2, e2.global), e2.defaultDescription && (v(this, et, "f").defaultDescription[t2] = e2.defaultDescription), e2.skipValidation && this.skipValidation(t2);
      const n2 = e2.describe || e2.description || e2.desc, r2 = v(this, pt, "f").getDescriptions();
      Object.prototype.hasOwnProperty.call(r2, t2) && "string" != typeof n2 || this.describe(t2, n2), e2.hidden && this.hide(t2), e2.requiresArg && this.requiresArg(t2);
    }
    return this;
  }
  options(t2, e2) {
    return this.option(t2, e2);
  }
  parse(t2, e2, s2) {
    h("[string|array] [function|boolean|object] [function]", [t2, e2, s2], arguments.length), this[Ct](), void 0 === t2 && (t2 = v(this, ht, "f")), "object" == typeof e2 && (O(this, rt, e2, "f"), e2 = s2), "function" == typeof e2 && (O(this, nt, e2, "f"), e2 = false), e2 || O(this, ht, t2, "f"), v(this, nt, "f") && O(this, T, false, "f");
    const i2 = this[Jt](t2, !!e2), n2 = this.parsed;
    return v(this, U, "f").setParsed(this.parsed), f(i2) ? i2.then((t3) => (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), t3, v(this, tt, "f")), t3)).catch((t3) => {
      throw v(this, nt, "f") && v(this, nt, "f")(t3, this.parsed.argv, v(this, tt, "f")), t3;
    }).finally(() => {
      this[Ht](), this.parsed = n2;
    }) : (v(this, nt, "f") && v(this, nt, "f").call(this, v(this, V, "f"), i2, v(this, tt, "f")), this[Ht](), this.parsed = n2, i2);
  }
  parseAsync(t2, e2, s2) {
    const i2 = this.parse(t2, e2, s2);
    return f(i2) ? i2 : Promise.resolve(i2);
  }
  parseSync(t2, s2, i2) {
    const n2 = this.parse(t2, s2, i2);
    if (f(n2))
      throw new e(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
    return n2;
  }
  parserConfiguration(t2) {
    return h("<object>", [t2], arguments.length), O(this, it, t2, "f"), this;
  }
  pkgConf(t2, e2) {
    h("<string> [string]", [t2, e2], arguments.length);
    let s2 = null;
    const i2 = this[At](e2 || v(this, W, "f"));
    return i2[t2] && "object" == typeof i2[t2] && (s2 = n(i2[t2], e2 || v(this, W, "f"), this[Mt]()["deep-merge-config"] || false, v(this, ct, "f")), v(this, et, "f").configObjects = (v(this, et, "f").configObjects || []).concat(s2)), this;
  }
  positional(t2, e2) {
    h("<string> <object>", [t2, e2], arguments.length);
    const s2 = ["default", "defaultDescription", "implies", "normalize", "choices", "conflicts", "coerce", "type", "describe", "desc", "description", "alias"];
    e2 = g(e2, (t3, e3) => !("type" === t3 && !["string", "number", "boolean"].includes(e3)) && s2.includes(t3));
    const i2 = v(this, q, "f").fullCommands[v(this, q, "f").fullCommands.length - 1], n2 = i2 ? v(this, z, "f").cmdToParseOptions(i2) : { array: [], alias: {}, default: {}, demand: {} };
    return p(n2).forEach((s3) => {
      const i3 = n2[s3];
      Array.isArray(i3) ? -1 !== i3.indexOf(t2) && (e2[s3] = true) : i3[t2] && !(s3 in e2) && (e2[s3] = i3[t2]);
    }), this.group(t2, v(this, pt, "f").getPositionalGroupName()), this.option(t2, e2);
  }
  recommendCommands(t2 = true) {
    return h("[boolean]", [t2], arguments.length), O(this, lt, t2, "f"), this;
  }
  required(t2, e2, s2) {
    return this.demand(t2, e2, s2);
  }
  require(t2, e2, s2) {
    return this.demand(t2, e2, s2);
  }
  requiresArg(t2) {
    return h("<array|string|object> [number]", [t2], arguments.length), "string" == typeof t2 && v(this, et, "f").narg[t2] || this[St](this.requiresArg.bind(this), "narg", t2, NaN), this;
  }
  showCompletionScript(t2, e2) {
    return h("[string] [string]", [t2, e2], arguments.length), t2 = t2 || this.$0, v(this, Q, "f").log(v(this, U, "f").generateCompletionScript(t2, e2 || v(this, F, "f") || "completion")), this;
  }
  showHelp(t2) {
    if (h("[string|function]", [t2], arguments.length), O(this, J, true, "f"), !v(this, pt, "f").hasCachedHelpMessage()) {
      if (!this.parsed) {
        const e3 = this[Jt](v(this, ht, "f"), void 0, void 0, 0, true);
        if (f(e3))
          return e3.then(() => {
            v(this, pt, "f").showHelp(t2);
          }), this;
      }
      const e2 = v(this, z, "f").runDefaultBuilderOn(this);
      if (f(e2))
        return e2.then(() => {
          v(this, pt, "f").showHelp(t2);
        }), this;
    }
    return v(this, pt, "f").showHelp(t2), this;
  }
  scriptName(t2) {
    return this.customScriptName = true, this.$0 = t2, this;
  }
  showHelpOnFail(t2, e2) {
    return h("[boolean|string] [string]", [t2, e2], arguments.length), v(this, pt, "f").showHelpOnFail(t2, e2), this;
  }
  showVersion(t2) {
    return h("[string|function]", [t2], arguments.length), v(this, pt, "f").showVersion(t2), this;
  }
  skipValidation(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("skipValidation", t2), this;
  }
  strict(t2) {
    return h("[boolean]", [t2], arguments.length), O(this, ft, false !== t2, "f"), this;
  }
  strictCommands(t2) {
    return h("[boolean]", [t2], arguments.length), O(this, dt, false !== t2, "f"), this;
  }
  strictOptions(t2) {
    return h("[boolean]", [t2], arguments.length), O(this, ut, false !== t2, "f"), this;
  }
  string(t2) {
    return h("<array|string>", [t2], arguments.length), this[Pt]("string", t2), this[Qt](t2), this;
  }
  terminalWidth() {
    return h([], 0), v(this, ct, "f").process.stdColumns;
  }
  updateLocale(t2) {
    return this.updateStrings(t2);
  }
  updateStrings(t2) {
    return h("<object>", [t2], arguments.length), O(this, G, false, "f"), v(this, ct, "f").y18n.updateLocale(t2), this;
  }
  usage(t2, s2, i2, n2) {
    if (h("<string|null|undefined> [string|boolean] [function|object] [function]", [t2, s2, i2, n2], arguments.length), void 0 !== s2) {
      if (d(t2, null, v(this, ct, "f")), (t2 || "").match(/^\$0( |$)/))
        return this.command(t2, s2, i2, n2);
      throw new e(".usage() description must start with $0 if being used as alias for .command()");
    }
    return v(this, pt, "f").usage(t2), this;
  }
  usageConfiguration(t2) {
    return h("<object>", [t2], arguments.length), O(this, gt, t2, "f"), this;
  }
  version(t2, e2, s2) {
    const i2 = "version";
    if (h("[boolean|string] [string] [string]", [t2, e2, s2], arguments.length), v(this, mt, "f") && (this[Ot](v(this, mt, "f")), v(this, pt, "f").version(void 0), O(this, mt, null, "f")), 0 === arguments.length)
      s2 = this[xt](), t2 = i2;
    else if (1 === arguments.length) {
      if (false === t2)
        return this;
      s2 = t2, t2 = i2;
    } else
      2 === arguments.length && (s2 = e2, e2 = void 0);
    return O(this, mt, "string" == typeof t2 ? t2 : i2, "f"), e2 = e2 || v(this, pt, "f").deferY18nLookup("Show version number"), v(this, pt, "f").version(s2 || void 0), this.boolean(v(this, mt, "f")), this.describe(v(this, mt, "f"), e2), this;
  }
  wrap(t2) {
    return h("<number|null|undefined>", [t2], arguments.length), v(this, pt, "f").wrap(t2), this;
  }
  [(z = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap(), q = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), Z = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap(), tt = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), nt = /* @__PURE__ */ new WeakMap(), rt = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), at = /* @__PURE__ */ new WeakMap(), ht = /* @__PURE__ */ new WeakMap(), lt = /* @__PURE__ */ new WeakMap(), ct = /* @__PURE__ */ new WeakMap(), ft = /* @__PURE__ */ new WeakMap(), dt = /* @__PURE__ */ new WeakMap(), ut = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), mt = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), bt)](t2) {
    if (!t2._ || !t2["--"])
      return t2;
    t2._.push.apply(t2._, t2["--"]);
    try {
      delete t2["--"];
    } catch (t3) {
    }
    return t2;
  }
  [vt]() {
    return { log: (...t2) => {
      this[Rt]() || console.log(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + "\n", "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
    }, error: (...t2) => {
      this[Rt]() || console.error(...t2), O(this, J, true, "f"), v(this, tt, "f").length && O(this, tt, v(this, tt, "f") + "\n", "f"), O(this, tt, v(this, tt, "f") + t2.join(" "), "f");
    } };
  }
  [Ot](t2) {
    p(v(this, et, "f")).forEach((e2) => {
      if ("configObjects" === e2)
        return;
      const s2 = v(this, et, "f")[e2];
      Array.isArray(s2) ? s2.includes(t2) && s2.splice(s2.indexOf(t2), 1) : "object" == typeof s2 && delete s2[t2];
    }), delete v(this, pt, "f").getDescriptions()[t2];
  }
  [wt](t2, e2, s2) {
    v(this, R, "f")[s2] || (v(this, ct, "f").process.emitWarning(t2, e2), v(this, R, "f")[s2] = true);
  }
  [Ct]() {
    v(this, B, "f").push({ options: v(this, et, "f"), configObjects: v(this, et, "f").configObjects.slice(0), exitProcess: v(this, T, "f"), groups: v(this, K, "f"), strict: v(this, ft, "f"), strictCommands: v(this, dt, "f"), strictOptions: v(this, ut, "f"), completionCommand: v(this, F, "f"), output: v(this, tt, "f"), exitError: v(this, V, "f"), hasOutput: v(this, J, "f"), parsed: this.parsed, parseFn: v(this, nt, "f"), parseContext: v(this, rt, "f") }), v(this, pt, "f").freeze(), v(this, yt, "f").freeze(), v(this, z, "f").freeze(), v(this, Y, "f").freeze();
  }
  [jt]() {
    let t2, e2 = "";
    return t2 = /\b(node|iojs|electron)(\.exe)?$/.test(v(this, ct, "f").process.argv()[0]) ? v(this, ct, "f").process.argv().slice(1, 2) : v(this, ct, "f").process.argv().slice(0, 1), e2 = t2.map((t3) => {
      const e3 = this[Yt](v(this, W, "f"), t3);
      return t3.match(/^(\/|([a-zA-Z]:)?\\)/) && e3.length < t3.length ? e3 : t3;
    }).join(" ").trim(), v(this, ct, "f").getEnv("_") && v(this, ct, "f").getProcessArgvBin() === v(this, ct, "f").getEnv("_") && (e2 = v(this, ct, "f").getEnv("_").replace(`${v(this, ct, "f").path.dirname(v(this, ct, "f").process.execPath())}/`, "")), e2;
  }
  [Mt]() {
    return v(this, it, "f");
  }
  [_t]() {
    return v(this, gt, "f");
  }
  [kt]() {
    if (!v(this, G, "f"))
      return;
    const t2 = v(this, ct, "f").getEnv("LC_ALL") || v(this, ct, "f").getEnv("LC_MESSAGES") || v(this, ct, "f").getEnv("LANG") || v(this, ct, "f").getEnv("LANGUAGE") || "en_US";
    this.locale(t2.replace(/[.:].*/, ""));
  }
  [xt]() {
    return this[At]().version || "unknown";
  }
  [Et](t2) {
    const e2 = t2["--"] ? t2["--"] : t2._;
    for (let t3, s2 = 0; void 0 !== (t3 = e2[s2]); s2++)
      v(this, ct, "f").Parser.looksLikeNumber(t3) && Number.isSafeInteger(Math.floor(parseFloat(`${t3}`))) && (e2[s2] = Number(t3));
    return t2;
  }
  [At](t2) {
    const e2 = t2 || "*";
    if (v(this, ot, "f")[e2])
      return v(this, ot, "f")[e2];
    let s2 = {};
    try {
      let e3 = t2 || v(this, ct, "f").mainFilename;
      !t2 && v(this, ct, "f").path.extname(e3) && (e3 = v(this, ct, "f").path.dirname(e3));
      const i2 = v(this, ct, "f").findUp(e3, (t3, e4) => e4.includes("package.json") ? "package.json" : void 0);
      d(i2, void 0, v(this, ct, "f")), s2 = JSON.parse(v(this, ct, "f").readFileSync(i2, "utf8"));
    } catch (t3) {
    }
    return v(this, ot, "f")[e2] = s2 || {}, v(this, ot, "f")[e2];
  }
  [Pt](t2, e2) {
    (e2 = [].concat(e2)).forEach((e3) => {
      e3 = this[Dt](e3), v(this, et, "f")[t2].push(e3);
    });
  }
  [St](t2, e2, s2, i2) {
    this[It](t2, e2, s2, i2, (t3, e3, s3) => {
      v(this, et, "f")[t3][e3] = s3;
    });
  }
  [$t](t2, e2, s2, i2) {
    this[It](t2, e2, s2, i2, (t3, e3, s3) => {
      v(this, et, "f")[t3][e3] = (v(this, et, "f")[t3][e3] || []).concat(s3);
    });
  }
  [It](t2, e2, s2, i2, n2) {
    if (Array.isArray(s2))
      s2.forEach((e3) => {
        t2(e3, i2);
      });
    else if (/* @__PURE__ */ ((t3) => "object" == typeof t3)(s2))
      for (const e3 of p(s2))
        t2(e3, s2[e3]);
    else
      n2(e2, this[Dt](s2), i2);
  }
  [Dt](t2) {
    return "__proto__" === t2 ? "___proto___" : t2;
  }
  [Nt](t2, e2) {
    return this[St](this[Nt].bind(this), "key", t2, e2), this;
  }
  [Ht]() {
    var t2, e2, s2, i2, n2, r2, o2, a2, h2, l2, c2, f2;
    const u2 = v(this, B, "f").pop();
    let p2;
    d(u2, void 0, v(this, ct, "f")), t2 = this, e2 = this, s2 = this, i2 = this, n2 = this, r2 = this, o2 = this, a2 = this, h2 = this, l2 = this, c2 = this, f2 = this, { options: { set value(e3) {
      O(t2, et, e3, "f");
    } }.value, configObjects: p2, exitProcess: { set value(t3) {
      O(e2, T, t3, "f");
    } }.value, groups: { set value(t3) {
      O(s2, K, t3, "f");
    } }.value, output: { set value(t3) {
      O(i2, tt, t3, "f");
    } }.value, exitError: { set value(t3) {
      O(n2, V, t3, "f");
    } }.value, hasOutput: { set value(t3) {
      O(r2, J, t3, "f");
    } }.value, parsed: this.parsed, strict: { set value(t3) {
      O(o2, ft, t3, "f");
    } }.value, strictCommands: { set value(t3) {
      O(a2, dt, t3, "f");
    } }.value, strictOptions: { set value(t3) {
      O(h2, ut, t3, "f");
    } }.value, completionCommand: { set value(t3) {
      O(l2, F, t3, "f");
    } }.value, parseFn: { set value(t3) {
      O(c2, nt, t3, "f");
    } }.value, parseContext: { set value(t3) {
      O(f2, rt, t3, "f");
    } }.value } = u2, v(this, et, "f").configObjects = p2, v(this, pt, "f").unfreeze(), v(this, yt, "f").unfreeze(), v(this, z, "f").unfreeze(), v(this, Y, "f").unfreeze();
  }
  [zt](t2, e2) {
    return j(e2, (e3) => (t2(e3), e3));
  }
  getInternalMethods() {
    return { getCommandInstance: this[Wt].bind(this), getContext: this[qt].bind(this), getHasOutput: this[Ut].bind(this), getLoggerInstance: this[Ft].bind(this), getParseContext: this[Lt].bind(this), getParserConfiguration: this[Mt].bind(this), getUsageConfiguration: this[_t].bind(this), getUsageInstance: this[Vt].bind(this), getValidationInstance: this[Gt].bind(this), hasParseCallback: this[Rt].bind(this), isGlobalContext: this[Tt].bind(this), postProcess: this[Bt].bind(this), reset: this[Kt].bind(this), runValidation: this[Zt].bind(this), runYargsParserAndExecuteCommands: this[Jt].bind(this), setHasOutput: this[Xt].bind(this) };
  }
  [Wt]() {
    return v(this, z, "f");
  }
  [qt]() {
    return v(this, q, "f");
  }
  [Ut]() {
    return v(this, J, "f");
  }
  [Ft]() {
    return v(this, Q, "f");
  }
  [Lt]() {
    return v(this, rt, "f") || {};
  }
  [Vt]() {
    return v(this, pt, "f");
  }
  [Gt]() {
    return v(this, yt, "f");
  }
  [Rt]() {
    return !!v(this, nt, "f");
  }
  [Tt]() {
    return v(this, X, "f");
  }
  [Bt](t2, e2, s2, i2) {
    if (s2)
      return t2;
    if (f(t2))
      return t2;
    e2 || (t2 = this[bt](t2));
    return (this[Mt]()["parse-positional-numbers"] || void 0 === this[Mt]()["parse-positional-numbers"]) && (t2 = this[Et](t2)), i2 && (t2 = C(t2, this, v(this, Y, "f").getMiddleware(), false)), t2;
  }
  [Kt](t2 = {}) {
    O(this, et, v(this, et, "f") || {}, "f");
    const e2 = {};
    e2.local = v(this, et, "f").local || [], e2.configObjects = v(this, et, "f").configObjects || [];
    const s2 = {};
    e2.local.forEach((e3) => {
      s2[e3] = true, (t2[e3] || []).forEach((t3) => {
        s2[t3] = true;
      });
    }), Object.assign(v(this, at, "f"), Object.keys(v(this, K, "f")).reduce((t3, e3) => {
      const i2 = v(this, K, "f")[e3].filter((t4) => !(t4 in s2));
      return i2.length > 0 && (t3[e3] = i2), t3;
    }, {})), O(this, K, {}, "f");
    return ["array", "boolean", "string", "skipValidation", "count", "normalize", "number", "hiddenOptions"].forEach((t3) => {
      e2[t3] = (v(this, et, "f")[t3] || []).filter((t4) => !s2[t4]);
    }), ["narg", "key", "alias", "default", "defaultDescription", "config", "choices", "demandedOptions", "demandedCommands", "deprecatedOptions"].forEach((t3) => {
      e2[t3] = g(v(this, et, "f")[t3], (t4) => !s2[t4]);
    }), e2.envPrefix = v(this, et, "f").envPrefix, O(this, et, e2, "f"), O(this, pt, v(this, pt, "f") ? v(this, pt, "f").reset(s2) : P(this, v(this, ct, "f")), "f"), O(this, yt, v(this, yt, "f") ? v(this, yt, "f").reset(s2) : function(t3, e3, s3) {
      const i2 = s3.y18n.__, n2 = s3.y18n.__n, r2 = { nonOptionCount: function(s4) {
        const i3 = t3.getDemandedCommands(), r3 = s4._.length + (s4["--"] ? s4["--"].length : 0) - t3.getInternalMethods().getContext().commands.length;
        i3._ && (r3 < i3._.min || r3 > i3._.max) && (r3 < i3._.min ? void 0 !== i3._.minMsg ? e3.fail(i3._.minMsg ? i3._.minMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.min.toString()) : null) : e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", r3, r3.toString(), i3._.min.toString())) : r3 > i3._.max && (void 0 !== i3._.maxMsg ? e3.fail(i3._.maxMsg ? i3._.maxMsg.replace(/\$0/g, r3.toString()).replace(/\$1/, i3._.max.toString()) : null) : e3.fail(n2("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", r3, r3.toString(), i3._.max.toString()))));
      }, positionalCount: function(t4, s4) {
        s4 < t4 && e3.fail(n2("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", s4, s4 + "", t4 + ""));
      }, requiredArguments: function(t4, s4) {
        let i3 = null;
        for (const e4 of Object.keys(s4))
          Object.prototype.hasOwnProperty.call(t4, e4) && void 0 !== t4[e4] || (i3 = i3 || {}, i3[e4] = s4[e4]);
        if (i3) {
          const t5 = [];
          for (const e4 of Object.keys(i3)) {
            const s6 = i3[e4];
            s6 && t5.indexOf(s6) < 0 && t5.push(s6);
          }
          const s5 = t5.length ? `
${t5.join("\n")}` : "";
          e3.fail(n2("Missing required argument: %s", "Missing required arguments: %s", Object.keys(i3).length, Object.keys(i3).join(", ") + s5));
        }
      }, unknownArguments: function(s4, i3, o3, a3, h2 = true) {
        var l3;
        const c3 = t3.getInternalMethods().getCommandInstance().getCommands(), f2 = [], d2 = t3.getInternalMethods().getContext();
        if (Object.keys(s4).forEach((e4) => {
          H.includes(e4) || Object.prototype.hasOwnProperty.call(o3, e4) || Object.prototype.hasOwnProperty.call(t3.getInternalMethods().getParseContext(), e4) || r2.isValidAndSomeAliasIsNotNew(e4, i3) || f2.push(e4);
        }), h2 && (d2.commands.length > 0 || c3.length > 0 || a3) && s4._.slice(d2.commands.length).forEach((t4) => {
          c3.includes("" + t4) || f2.push("" + t4);
        }), h2) {
          const e4 = (null === (l3 = t3.getDemandedCommands()._) || void 0 === l3 ? void 0 : l3.max) || 0, i4 = d2.commands.length + e4;
          i4 < s4._.length && s4._.slice(i4).forEach((t4) => {
            t4 = String(t4), d2.commands.includes(t4) || f2.includes(t4) || f2.push(t4);
          });
        }
        f2.length && e3.fail(n2("Unknown argument: %s", "Unknown arguments: %s", f2.length, f2.map((t4) => t4.trim() ? t4 : `"${t4}"`).join(", ")));
      }, unknownCommands: function(s4) {
        const i3 = t3.getInternalMethods().getCommandInstance().getCommands(), r3 = [], o3 = t3.getInternalMethods().getContext();
        return (o3.commands.length > 0 || i3.length > 0) && s4._.slice(o3.commands.length).forEach((t4) => {
          i3.includes("" + t4) || r3.push("" + t4);
        }), r3.length > 0 && (e3.fail(n2("Unknown command: %s", "Unknown commands: %s", r3.length, r3.join(", "))), true);
      }, isValidAndSomeAliasIsNotNew: function(e4, s4) {
        if (!Object.prototype.hasOwnProperty.call(s4, e4))
          return false;
        const i3 = t3.parsed.newAliases;
        return [e4, ...s4[e4]].some((t4) => !Object.prototype.hasOwnProperty.call(i3, t4) || !i3[e4]);
      }, limitedChoices: function(s4) {
        const n3 = t3.getOptions(), r3 = {};
        if (!Object.keys(n3.choices).length)
          return;
        Object.keys(s4).forEach((t4) => {
          -1 === H.indexOf(t4) && Object.prototype.hasOwnProperty.call(n3.choices, t4) && [].concat(s4[t4]).forEach((e4) => {
            -1 === n3.choices[t4].indexOf(e4) && void 0 !== e4 && (r3[t4] = (r3[t4] || []).concat(e4));
          });
        });
        const o3 = Object.keys(r3);
        if (!o3.length)
          return;
        let a3 = i2("Invalid values:");
        o3.forEach((t4) => {
          a3 += `
  ${i2("Argument: %s, Given: %s, Choices: %s", t4, e3.stringifiedValues(r3[t4]), e3.stringifiedValues(n3.choices[t4]))}`;
        }), e3.fail(a3);
      } };
      let o2 = {};
      function a2(t4, e4) {
        const s4 = Number(e4);
        return "number" == typeof (e4 = isNaN(s4) ? e4 : s4) ? e4 = t4._.length >= e4 : e4.match(/^--no-.+/) ? (e4 = e4.match(/^--no-(.+)/)[1], e4 = !Object.prototype.hasOwnProperty.call(t4, e4)) : e4 = Object.prototype.hasOwnProperty.call(t4, e4), e4;
      }
      r2.implies = function(e4, i3) {
        h("<string|object> [array|number|string]", [e4, i3], arguments.length), "object" == typeof e4 ? Object.keys(e4).forEach((t4) => {
          r2.implies(t4, e4[t4]);
        }) : (t3.global(e4), o2[e4] || (o2[e4] = []), Array.isArray(i3) ? i3.forEach((t4) => r2.implies(e4, t4)) : (d(i3, void 0, s3), o2[e4].push(i3)));
      }, r2.getImplied = function() {
        return o2;
      }, r2.implications = function(t4) {
        const s4 = [];
        if (Object.keys(o2).forEach((e4) => {
          const i3 = e4;
          (o2[e4] || []).forEach((e5) => {
            let n3 = i3;
            const r3 = e5;
            n3 = a2(t4, n3), e5 = a2(t4, e5), n3 && !e5 && s4.push(` ${i3} -> ${r3}`);
          });
        }), s4.length) {
          let t5 = `${i2("Implications failed:")}
`;
          s4.forEach((e4) => {
            t5 += e4;
          }), e3.fail(t5);
        }
      };
      let l2 = {};
      r2.conflicts = function(e4, s4) {
        h("<string|object> [array|string]", [e4, s4], arguments.length), "object" == typeof e4 ? Object.keys(e4).forEach((t4) => {
          r2.conflicts(t4, e4[t4]);
        }) : (t3.global(e4), l2[e4] || (l2[e4] = []), Array.isArray(s4) ? s4.forEach((t4) => r2.conflicts(e4, t4)) : l2[e4].push(s4));
      }, r2.getConflicting = () => l2, r2.conflicting = function(n3) {
        Object.keys(n3).forEach((t4) => {
          l2[t4] && l2[t4].forEach((s4) => {
            s4 && void 0 !== n3[t4] && void 0 !== n3[s4] && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, s4));
          });
        }), t3.getInternalMethods().getParserConfiguration()["strip-dashed"] && Object.keys(l2).forEach((t4) => {
          l2[t4].forEach((r3) => {
            r3 && void 0 !== n3[s3.Parser.camelCase(t4)] && void 0 !== n3[s3.Parser.camelCase(r3)] && e3.fail(i2("Arguments %s and %s are mutually exclusive", t4, r3));
          });
        });
      }, r2.recommendCommands = function(t4, s4) {
        s4 = s4.sort((t5, e4) => e4.length - t5.length);
        let n3 = null, r3 = 1 / 0;
        for (let e4, i3 = 0; void 0 !== (e4 = s4[i3]); i3++) {
          const s5 = N(t4, e4);
          s5 <= 3 && s5 < r3 && (r3 = s5, n3 = e4);
        }
        n3 && e3.fail(i2("Did you mean %s?", n3));
      }, r2.reset = function(t4) {
        return o2 = g(o2, (e4) => !t4[e4]), l2 = g(l2, (e4) => !t4[e4]), r2;
      };
      const c2 = [];
      return r2.freeze = function() {
        c2.push({ implied: o2, conflicting: l2 });
      }, r2.unfreeze = function() {
        const t4 = c2.pop();
        d(t4, void 0, s3), { implied: o2, conflicting: l2 } = t4;
      }, r2;
    }(this, v(this, pt, "f"), v(this, ct, "f")), "f"), O(this, z, v(this, z, "f") ? v(this, z, "f").reset() : function(t3, e3, s3, i2) {
      return new _(t3, e3, s3, i2);
    }(v(this, pt, "f"), v(this, yt, "f"), v(this, Y, "f"), v(this, ct, "f")), "f"), v(this, U, "f") || O(this, U, function(t3, e3, s3, i2) {
      return new D(t3, e3, s3, i2);
    }(this, v(this, pt, "f"), v(this, z, "f"), v(this, ct, "f")), "f"), v(this, Y, "f").reset(), O(this, F, null, "f"), O(this, tt, "", "f"), O(this, V, null, "f"), O(this, J, false, "f"), this.parsed = false, this;
  }
  [Yt](t2, e2) {
    return v(this, ct, "f").path.relative(t2, e2);
  }
  [Jt](t2, s2, i2, n2 = 0, r2 = false) {
    let o2 = !!i2 || r2;
    t2 = t2 || v(this, ht, "f"), v(this, et, "f").__ = v(this, ct, "f").y18n.__, v(this, et, "f").configuration = this[Mt]();
    const a2 = !!v(this, et, "f").configuration["populate--"], h2 = Object.assign({}, v(this, et, "f").configuration, { "populate--": true }), l2 = v(this, ct, "f").Parser.detailed(t2, Object.assign({}, v(this, et, "f"), { configuration: { "parse-positional-numbers": false, ...h2 } })), c2 = Object.assign(l2.argv, v(this, rt, "f"));
    let d2;
    const u2 = l2.aliases;
    let p2 = false, g2 = false;
    Object.keys(c2).forEach((t3) => {
      t3 === v(this, Z, "f") && c2[t3] ? p2 = true : t3 === v(this, mt, "f") && c2[t3] && (g2 = true);
    }), c2.$0 = this.$0, this.parsed = l2, 0 === n2 && v(this, pt, "f").clearCachedHelpMessage();
    try {
      if (this[kt](), s2)
        return this[Bt](c2, a2, !!i2, false);
      if (v(this, Z, "f")) {
        [v(this, Z, "f")].concat(u2[v(this, Z, "f")] || []).filter((t3) => t3.length > 1).includes("" + c2._[c2._.length - 1]) && (c2._.pop(), p2 = true);
      }
      O(this, X, false, "f");
      const h3 = v(this, z, "f").getCommands(), m2 = v(this, U, "f").completionKey in c2, y2 = p2 || m2 || r2;
      if (c2._.length) {
        if (h3.length) {
          let t3;
          for (let e2, s3 = n2 || 0; void 0 !== c2._[s3]; s3++) {
            if (e2 = String(c2._[s3]), h3.includes(e2) && e2 !== v(this, F, "f")) {
              const t4 = v(this, z, "f").runCommand(e2, this, l2, s3 + 1, r2, p2 || g2 || r2);
              return this[Bt](t4, a2, !!i2, false);
            }
            if (!t3 && e2 !== v(this, F, "f")) {
              t3 = e2;
              break;
            }
          }
          !v(this, z, "f").hasDefaultCommand() && v(this, lt, "f") && t3 && !y2 && v(this, yt, "f").recommendCommands(t3, h3);
        }
        v(this, F, "f") && c2._.includes(v(this, F, "f")) && !m2 && (v(this, T, "f") && E(true), this.showCompletionScript(), this.exit(0));
      }
      if (v(this, z, "f").hasDefaultCommand() && !y2) {
        const t3 = v(this, z, "f").runCommand(null, this, l2, 0, r2, p2 || g2 || r2);
        return this[Bt](t3, a2, !!i2, false);
      }
      if (m2) {
        v(this, T, "f") && E(true);
        const s3 = (t2 = [].concat(t2)).slice(t2.indexOf(`--${v(this, U, "f").completionKey}`) + 1);
        return v(this, U, "f").getCompletion(s3, (t3, s4) => {
          if (t3)
            throw new e(t3.message);
          (s4 || []).forEach((t4) => {
            v(this, Q, "f").log(t4);
          }), this.exit(0);
        }), this[Bt](c2, !a2, !!i2, false);
      }
      if (v(this, J, "f") || (p2 ? (v(this, T, "f") && E(true), o2 = true, this.showHelp("log"), this.exit(0)) : g2 && (v(this, T, "f") && E(true), o2 = true, v(this, pt, "f").showVersion("log"), this.exit(0))), !o2 && v(this, et, "f").skipValidation.length > 0 && (o2 = Object.keys(c2).some((t3) => v(this, et, "f").skipValidation.indexOf(t3) >= 0 && true === c2[t3])), !o2) {
        if (l2.error)
          throw new e(l2.error.message);
        if (!m2) {
          const t3 = this[Zt](u2, {}, l2.error);
          i2 || (d2 = C(c2, this, v(this, Y, "f").getMiddleware(), true)), d2 = this[zt](t3, null != d2 ? d2 : c2), f(d2) && !i2 && (d2 = d2.then(() => C(c2, this, v(this, Y, "f").getMiddleware(), false)));
        }
      }
    } catch (t3) {
      if (!(t3 instanceof e))
        throw t3;
      v(this, pt, "f").fail(t3.message, t3);
    }
    return this[Bt](null != d2 ? d2 : c2, a2, !!i2, true);
  }
  [Zt](t2, s2, i2, n2) {
    const r2 = { ...this.getDemandedOptions() };
    return (o2) => {
      if (i2)
        throw new e(i2.message);
      v(this, yt, "f").nonOptionCount(o2), v(this, yt, "f").requiredArguments(o2, r2);
      let a2 = false;
      v(this, dt, "f") && (a2 = v(this, yt, "f").unknownCommands(o2)), v(this, ft, "f") && !a2 ? v(this, yt, "f").unknownArguments(o2, t2, s2, !!n2) : v(this, ut, "f") && v(this, yt, "f").unknownArguments(o2, t2, {}, false, false), v(this, yt, "f").limitedChoices(o2), v(this, yt, "f").implications(o2), v(this, yt, "f").conflicting(o2);
    };
  }
  [Xt]() {
    O(this, J, true, "f");
  }
  [Qt](t2) {
    if ("string" == typeof t2)
      v(this, et, "f").key[t2] = true;
    else
      for (const e2 of t2)
        v(this, et, "f").key[e2] = true;
  }
}
var ee, se;
const { readFileSync: ie } = fs$o, { inspect: ne } = require$$4, { resolve: re } = path$e, oe = build$1, ae = require$$5;
var he, le = { assert: { notStrictEqual: t.notStrictEqual, strictEqual: t.strictEqual }, cliui: build$2, findUp: sync, getEnv: (t2) => process.env[t2], getCallerFile, getProcessArgvBin: y, inspect: ne, mainFilename: null !== (se = null === (ee = null === commonjsRequire || void 0 === commonjsRequire ? void 0 : require.main) || void 0 === ee ? void 0 : ee.filename) && void 0 !== se ? se : process.cwd(), Parser: ae, path: path$e, process: { argv: () => process.argv, cwd: process.cwd, emitWarning: (t2, e2) => process.emitWarning(t2, e2), execPath: () => process.execPath, exit: (t2) => {
  process.exit(t2);
}, nextTick: process.nextTick, stdColumns: void 0 !== process.stdout.columns ? process.stdout.columns : null }, readFileSync: ie, require: commonjsRequire, requireDirectory: requireDirectoryExports, stringWidth: stringWidthExports, y18n: oe({ directory: re(__dirname, "../locales"), updateFiles: false }) };
const ce = (null === (he = null === process || void 0 === process ? void 0 : process.env) || void 0 === he ? void 0 : he.YARGS_MIN_NODE_VERSION) ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
if (process && process.version) {
  if (Number(process.version.match(/v([^.]+)/)[1]) < ce)
    throw Error(`yargs supports a minimum Node.js version of ${ce}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
}
const fe = require$$5;
var de, ue = { applyExtends: n, cjsPlatformShim: le, Yargs: (de = le, (t2 = [], e2 = de.process.cwd(), s2) => {
  const i2 = new te(t2, e2, s2, de);
  return Object.defineProperty(i2, "argv", { get: () => i2.parse(), enumerable: true }), i2.help(), i2.version(), i2;
}), argsert: h, isPromise: f, objFilter: g, parseCommand: o, Parser: fe, processArgv: b, YError: e };
var build = ue;
const pkg = /* @__PURE__ */ getDefaultExportFromCjs(build);
const { applyExtends, cjsPlatformShim, Parser: Parser2, processArgv, Yargs } = pkg;
Yargs.applyExtends = (config2, cwd2, mergeExtends) => {
  return applyExtends(config2, cwd2, mergeExtends, cjsPlatformShim);
};
Yargs.hideBin = processArgv.hideBin;
Yargs.Parser = Parser2;
var browser = function() {
  throw new Error(
    "ws does not work in the browser. Browser clients must use the native WebSocket object"
  );
};
const NodeWebSocket = /* @__PURE__ */ getDefaultExportFromCjs(browser);
const packageVersion = "22.9.0";
/**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const _NodeWebSocketTransport = class _NodeWebSocketTransport {
  constructor(ws) {
    __privateAdd(this, _ws, void 0);
    __publicField(this, "onmessage");
    __publicField(this, "onclose");
    __privateSet(this, _ws, ws);
    __privateGet(this, _ws).addEventListener("message", (event) => {
      setImmediate(() => {
        if (this.onmessage) {
          this.onmessage.call(null, event.data);
        }
      });
    });
    __privateGet(this, _ws).addEventListener("close", () => {
      setImmediate(() => {
        if (this.onclose) {
          this.onclose.call(null);
        }
      });
    });
    __privateGet(this, _ws).addEventListener("error", () => {
    });
  }
  static create(url, headers) {
    return new Promise((resolve2, reject) => {
      const ws = new NodeWebSocket(url, [], {
        followRedirects: true,
        perMessageDeflate: false,
        maxPayload: 256 * 1024 * 1024,
        // 256Mb
        headers: {
          "User-Agent": `Puppeteer ${packageVersion}`,
          ...headers
        }
      });
      ws.addEventListener("open", () => {
        return resolve2(new _NodeWebSocketTransport(ws));
      });
      ws.addEventListener("error", reject);
    });
  }
  send(message2) {
    __privateGet(this, _ws).send(message2);
  }
  close() {
    __privateGet(this, _ws).close();
  }
};
_ws = new WeakMap();
let NodeWebSocketTransport = _NodeWebSocketTransport;
const NodeWebSocketTransport$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NodeWebSocketTransport
}, Symbol.toStringTag, { value: "Module" }));
class PipeTransport {
  constructor(pipeWrite, pipeRead) {
    __privateAdd(this, _dispatch);
    __privateAdd(this, _pipeWrite, void 0);
    __privateAdd(this, _subscriptions3, new DisposableStack());
    __privateAdd(this, _isClosed, false);
    __privateAdd(this, _pendingMessage, "");
    __publicField(this, "onclose");
    __publicField(this, "onmessage");
    __privateSet(this, _pipeWrite, pipeWrite);
    __privateGet(this, _subscriptions3).use(new EventSubscription(pipeRead, "data", (buffer) => {
      return __privateMethod(this, _dispatch, dispatch_fn).call(this, buffer);
    }));
    __privateGet(this, _subscriptions3).use(new EventSubscription(pipeRead, "close", () => {
      if (this.onclose) {
        this.onclose.call(null);
      }
    }));
    __privateGet(this, _subscriptions3).use(new EventSubscription(pipeRead, "error", debugError));
    __privateGet(this, _subscriptions3).use(new EventSubscription(pipeWrite, "error", debugError));
  }
  send(message2) {
    assert$1(!__privateGet(this, _isClosed), "`PipeTransport` is closed.");
    __privateGet(this, _pipeWrite).write(message2);
    __privateGet(this, _pipeWrite).write("\0");
  }
  close() {
    __privateSet(this, _isClosed, true);
    __privateGet(this, _subscriptions3).dispose();
  }
}
_pipeWrite = new WeakMap();
_subscriptions3 = new WeakMap();
_isClosed = new WeakMap();
_pendingMessage = new WeakMap();
_dispatch = new WeakSet();
dispatch_fn = function(buffer) {
  assert$1(!__privateGet(this, _isClosed), "`PipeTransport` is closed.");
  let end = buffer.indexOf("\0");
  if (end === -1) {
    __privateSet(this, _pendingMessage, __privateGet(this, _pendingMessage) + buffer.toString());
    return;
  }
  const message2 = __privateGet(this, _pendingMessage) + buffer.toString(void 0, 0, end);
  if (this.onmessage) {
    this.onmessage.call(null, message2);
  }
  let start = end + 1;
  end = buffer.indexOf("\0", start);
  while (end !== -1) {
    if (this.onmessage) {
      this.onmessage.call(null, buffer.toString(void 0, start, end));
    }
    start = end + 1;
    end = buffer.indexOf("\0", start);
  }
  __privateSet(this, _pendingMessage, buffer.toString(void 0, start));
};
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ProductLauncher {
  /**
   * @internal
   */
  constructor(puppeteer2, product) {
    __privateAdd(this, _product, void 0);
    /**
     * @internal
     */
    __publicField(this, "puppeteer");
    /**
     * @internal
     */
    __publicField(this, "actualBrowserRevision");
    this.puppeteer = puppeteer2;
    __privateSet(this, _product, product);
  }
  get product() {
    return __privateGet(this, _product);
  }
  async launch(options = {}) {
    const { dumpio = false, env: env2 = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT, slowMo = 0, timeout: timeout2 = 3e4, waitForInitialPage = true, protocolTimeout, protocol } = options;
    const launchArgs = await this.computeLaunchArguments(options);
    if (!fs$o.existsSync(launchArgs.executablePath)) {
      throw new Error(`Browser was not found at the configured executablePath (${launchArgs.executablePath})`);
    }
    const usePipe = launchArgs.args.includes("--remote-debugging-pipe");
    const onProcessExit = async () => {
      await this.cleanUserDataDir(launchArgs.userDataDir, {
        isTemp: launchArgs.isTempUserDataDir
      });
    };
    if (__privateGet(this, _product) === "firefox" && protocol !== "webDriverBiDi" && this.puppeteer.configuration.logLevel === "warn") {
      console.warn(`Chrome DevTools Protocol (CDP) support for Firefox is deprecated in Puppeteer and it will be eventually removed. Use WebDriver BiDi instead (see https://pptr.dev/webdriver-bidi#get-started).`);
    }
    const browserProcess = launch({
      executablePath: launchArgs.executablePath,
      args: launchArgs.args,
      handleSIGHUP,
      handleSIGTERM,
      handleSIGINT,
      dumpio,
      env: env2,
      pipe: usePipe,
      onExit: onProcessExit
    });
    let browser2;
    let cdpConnection;
    let closing = false;
    const browserCloseCallback = async () => {
      if (closing) {
        return;
      }
      closing = true;
      await this.closeBrowser(browserProcess, cdpConnection);
    };
    try {
      if (__privateGet(this, _product) === "firefox" && protocol === "webDriverBiDi") {
        browser2 = await this.createBiDiBrowser(browserProcess, browserCloseCallback, {
          timeout: timeout2,
          protocolTimeout,
          slowMo,
          defaultViewport,
          ignoreHTTPSErrors
        });
      } else {
        if (usePipe) {
          cdpConnection = await this.createCdpPipeConnection(browserProcess, {
            timeout: timeout2,
            protocolTimeout,
            slowMo
          });
        } else {
          cdpConnection = await this.createCdpSocketConnection(browserProcess, {
            timeout: timeout2,
            protocolTimeout,
            slowMo
          });
        }
        if (protocol === "webDriverBiDi") {
          browser2 = await this.createBiDiOverCdpBrowser(browserProcess, cdpConnection, browserCloseCallback, {
            timeout: timeout2,
            protocolTimeout,
            slowMo,
            defaultViewport,
            ignoreHTTPSErrors
          });
        } else {
          browser2 = await CdpBrowser._create(this.product, cdpConnection, [], ignoreHTTPSErrors, defaultViewport, browserProcess.nodeProcess, browserCloseCallback, options.targetFilter);
        }
      }
    } catch (error) {
      void browserCloseCallback();
      if (error instanceof TimeoutError2) {
        throw new TimeoutError$1(error.message);
      }
      throw error;
    }
    if (waitForInitialPage && protocol !== "webDriverBiDi") {
      await this.waitForPageTarget(browser2, timeout2);
    }
    return browser2;
  }
  /**
   * Set only for Firefox, after the launcher resolves the `latest` revision to
   * the actual revision.
   * @internal
   */
  getActualBrowserRevision() {
    return this.actualBrowserRevision;
  }
  /**
   * @internal
   */
  async closeBrowser(browserProcess, cdpConnection) {
    if (cdpConnection) {
      try {
        await cdpConnection.closeBrowser();
        await browserProcess.hasClosed();
      } catch (error) {
        debugError(error);
        await browserProcess.close();
      }
    } else {
      await firstValueFrom(race(from$1(browserProcess.hasClosed()), timer(5e3).pipe(map(() => {
        return from$1(browserProcess.close());
      }))));
    }
  }
  /**
   * @internal
   */
  async waitForPageTarget(browser2, timeout2) {
    try {
      await browser2.waitForTarget((t2) => {
        return t2.type() === "page";
      }, { timeout: timeout2 });
    } catch (error) {
      await browser2.close();
      throw error;
    }
  }
  /**
   * @internal
   */
  async createCdpSocketConnection(browserProcess, opts) {
    const browserWSEndpoint = await browserProcess.waitForLineOutput(CDP_WEBSOCKET_ENDPOINT_REGEX, opts.timeout);
    const transport = await NodeWebSocketTransport.create(browserWSEndpoint);
    return new Connection(browserWSEndpoint, transport, opts.slowMo, opts.protocolTimeout);
  }
  /**
   * @internal
   */
  async createCdpPipeConnection(browserProcess, opts) {
    const { 3: pipeWrite, 4: pipeRead } = browserProcess.nodeProcess.stdio;
    const transport = new PipeTransport(pipeWrite, pipeRead);
    return new Connection("", transport, opts.slowMo, opts.protocolTimeout);
  }
  /**
   * @internal
   */
  async createBiDiOverCdpBrowser(browserProcess, connection, closeCallback, opts) {
    const BiDi = await Promise.resolve().then(() => require(
      /* webpackIgnore: true */
      "./bidi-CcyBpVJ6.js"
    ));
    const bidiConnection = await BiDi.connectBidiOverCdp(connection, {
      acceptInsecureCerts: opts.ignoreHTTPSErrors ?? false
    });
    return await BiDi.BidiBrowser.create({
      connection: bidiConnection,
      closeCallback,
      process: browserProcess.nodeProcess,
      defaultViewport: opts.defaultViewport,
      ignoreHTTPSErrors: opts.ignoreHTTPSErrors
    });
  }
  /**
   * @internal
   */
  async createBiDiBrowser(browserProcess, closeCallback, opts) {
    const browserWSEndpoint = await browserProcess.waitForLineOutput(WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX, opts.timeout) + "/session";
    const transport = await NodeWebSocketTransport.create(browserWSEndpoint);
    const BiDi = await Promise.resolve().then(() => require(
      /* webpackIgnore: true */
      "./bidi-CcyBpVJ6.js"
    ));
    const bidiConnection = new BiDi.BidiConnection(browserWSEndpoint, transport, opts.slowMo, opts.protocolTimeout);
    return await BiDi.BidiBrowser.create({
      connection: bidiConnection,
      closeCallback,
      process: browserProcess.nodeProcess,
      defaultViewport: opts.defaultViewport,
      ignoreHTTPSErrors: opts.ignoreHTTPSErrors
    });
  }
  /**
   * @internal
   */
  getProfilePath() {
    return path$e.join(this.puppeteer.configuration.temporaryDirectory ?? os.tmpdir(), `puppeteer_dev_${this.product}_profile-`);
  }
  /**
   * @internal
   */
  resolveExecutablePath(headless) {
    let executablePath = this.puppeteer.configuration.executablePath;
    if (executablePath) {
      if (!fs$o.existsSync(executablePath)) {
        throw new Error(`Tried to find the browser at the configured path (${executablePath}), but no executable was found.`);
      }
      return executablePath;
    }
    function productToBrowser(product, headless2) {
      switch (product) {
        case "chrome":
          if (headless2 === "shell") {
            return Browser2.CHROMEHEADLESSSHELL;
          }
          return Browser2.CHROME;
        case "firefox":
          return Browser2.FIREFOX;
      }
      return Browser2.CHROME;
    }
    executablePath = computeExecutablePath({
      cacheDir: this.puppeteer.defaultDownloadPath,
      browser: productToBrowser(this.product, headless),
      buildId: this.puppeteer.browserRevision
    });
    if (!fs$o.existsSync(executablePath)) {
      if (this.puppeteer.configuration.browserRevision) {
        throw new Error(`Tried to find the browser at the configured path (${executablePath}) for revision ${this.puppeteer.browserRevision}, but no executable was found.`);
      }
      switch (this.product) {
        case "chrome":
          throw new Error(`Could not find Chrome (ver. ${this.puppeteer.browserRevision}). This can occur if either
 1. you did not perform an installation before running the script (e.g. \`npx puppeteer browsers install chrome\`) or
 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).
For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.`);
        case "firefox":
          throw new Error(`Could not find Firefox (rev. ${this.puppeteer.browserRevision}). This can occur if either
 1. you did not perform an installation for Firefox before running the script (e.g. \`npx puppeteer browsers install firefox\`) or
 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).
For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.`);
      }
    }
    return executablePath;
  }
}
_product = new WeakMap();
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const rmOptions = {
  force: true,
  recursive: true,
  maxRetries: 5
};
async function rm(path2) {
  await fs$o.promises.rm(path2, rmOptions);
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class ChromeLauncher extends ProductLauncher {
  constructor(puppeteer2) {
    super(puppeteer2, "chrome");
  }
  launch(options = {}) {
    var _a3;
    if (this.puppeteer.configuration.logLevel === "warn" && process.platform === "darwin" && process.arch === "x64") {
      const cpus = os.cpus();
      if ((_a3 = cpus[0]) == null ? void 0 : _a3.model.includes("Apple")) {
        console.warn([
          "\x1B[1m\x1B[43m\x1B[30m",
          "Degraded performance warning:\x1B[0m\x1B[33m",
          "Launching Chrome on Mac Silicon (arm64) from an x64 Node installation results in",
          "Rosetta translating the Chrome binary, even if Chrome is already arm64. This would",
          "result in huge performance issues. To resolve this, you must run Puppeteer with",
          "a version of Node built for arm64."
        ].join("\n  "));
      }
    }
    return super.launch(options);
  }
  /**
   * @internal
   */
  async computeLaunchArguments(options = {}) {
    const { ignoreDefaultArgs = false, args = [], pipe: pipe2 = false, debuggingPort, channel, executablePath } = options;
    const chromeArguments = [];
    if (!ignoreDefaultArgs) {
      chromeArguments.push(...this.defaultArgs(options));
    } else if (Array.isArray(ignoreDefaultArgs)) {
      chromeArguments.push(...this.defaultArgs(options).filter((arg) => {
        return !ignoreDefaultArgs.includes(arg);
      }));
    } else {
      chromeArguments.push(...args);
    }
    if (!chromeArguments.some((argument) => {
      return argument.startsWith("--remote-debugging-");
    })) {
      if (pipe2) {
        assert$1(!debuggingPort, "Browser should be launched with either pipe or debugging port - not both.");
        chromeArguments.push("--remote-debugging-pipe");
      } else {
        chromeArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
      }
    }
    let isTempUserDataDir = false;
    let userDataDirIndex = chromeArguments.findIndex((arg) => {
      return arg.startsWith("--user-data-dir");
    });
    if (userDataDirIndex < 0) {
      isTempUserDataDir = true;
      chromeArguments.push(`--user-data-dir=${await promises.mkdtemp(this.getProfilePath())}`);
      userDataDirIndex = chromeArguments.length - 1;
    }
    const userDataDir = chromeArguments[userDataDirIndex].split("=", 2)[1];
    assert$1(typeof userDataDir === "string", "`--user-data-dir` is malformed");
    let chromeExecutable = executablePath;
    if (!chromeExecutable) {
      assert$1(channel || !this.puppeteer._isPuppeteerCore, `An \`executablePath\` or \`channel\` must be specified for \`puppeteer-core\``);
      chromeExecutable = this.executablePath(channel, options.headless ?? true);
    }
    return {
      executablePath: chromeExecutable,
      args: chromeArguments,
      isTempUserDataDir,
      userDataDir
    };
  }
  /**
   * @internal
   */
  async cleanUserDataDir(path2, opts) {
    if (opts.isTemp) {
      try {
        await rm(path2);
      } catch (error) {
        debugError(error);
        throw error;
      }
    }
  }
  defaultArgs(options = {}) {
    const userDisabledFeatures = getFeatures("--disable-features", options.args);
    if (options.args && userDisabledFeatures.length > 0) {
      removeMatchingFlags(options.args, "--disable-features");
    }
    const turnOnExperimentalFeaturesForTesting = process.env["PUPPETEER_TEST_EXPERIMENTAL_CHROME_FEATURES"] === "true";
    const disabledFeatures = [
      "Translate",
      // AcceptCHFrame disabled because of crbug.com/1348106.
      "AcceptCHFrame",
      "MediaRouter",
      "OptimizationHints",
      ...turnOnExperimentalFeaturesForTesting ? [] : [
        // https://crbug.com/1492053
        "ProcessPerSiteUpToMainFrameThreshold",
        // https://github.com/puppeteer/puppeteer/issues/10715
        "IsolateSandboxedIframes"
      ],
      ...userDisabledFeatures
    ].filter((feature) => {
      return feature !== "";
    });
    const userEnabledFeatures = getFeatures("--enable-features", options.args);
    if (options.args && userEnabledFeatures.length > 0) {
      removeMatchingFlags(options.args, "--enable-features");
    }
    const enabledFeatures = [
      "PdfOopif",
      // Add features to enable by default here.
      ...userEnabledFeatures
    ].filter((feature) => {
      return feature !== "";
    });
    const chromeArguments = [
      "--allow-pre-commit-input",
      "--disable-background-networking",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-component-extensions-with-background-pages",
      "--disable-component-update",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-hang-monitor",
      "--disable-infobars",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-search-engine-choice-screen",
      "--disable-sync",
      "--enable-automation",
      "--export-tagged-pdf",
      "--generate-pdf-document-outline",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--password-store=basic",
      "--use-mock-keychain",
      `--disable-features=${disabledFeatures.join(",")}`,
      `--enable-features=${enabledFeatures.join(",")}`
    ].filter((arg) => {
      return arg !== "";
    });
    const { devtools = false, headless = !devtools, args = [], userDataDir } = options;
    if (userDataDir) {
      chromeArguments.push(`--user-data-dir=${path$e.resolve(userDataDir)}`);
    }
    if (devtools) {
      chromeArguments.push("--auto-open-devtools-for-tabs");
    }
    if (headless) {
      chromeArguments.push(headless === "shell" ? "--headless" : "--headless=new", "--hide-scrollbars", "--mute-audio");
    }
    if (args.every((arg) => {
      return arg.startsWith("-");
    })) {
      chromeArguments.push("about:blank");
    }
    chromeArguments.push(...args);
    return chromeArguments;
  }
  executablePath(channel, headless) {
    if (channel) {
      return computeSystemExecutablePath({
        browser: Browser2.CHROME,
        channel: convertPuppeteerChannelToBrowsersChannel(channel)
      });
    } else {
      return this.resolveExecutablePath(headless);
    }
  }
}
function convertPuppeteerChannelToBrowsersChannel(channel) {
  switch (channel) {
    case "chrome":
      return ChromeReleaseChannel.STABLE;
    case "chrome-dev":
      return ChromeReleaseChannel.DEV;
    case "chrome-beta":
      return ChromeReleaseChannel.BETA;
    case "chrome-canary":
      return ChromeReleaseChannel.CANARY;
  }
}
function getFeatures(flag, options = []) {
  return options.filter((s2) => {
    return s2.startsWith(flag.endsWith("=") ? flag : `${flag}=`);
  }).map((s2) => {
    var _a3;
    return (_a3 = s2.split(new RegExp(`${flag}=\\s*`))[1]) == null ? void 0 : _a3.trim();
  }).filter((s2) => {
    return s2;
  });
}
function removeMatchingFlags(array, flag) {
  const regex = new RegExp(`^${flag}=.*`);
  let i2 = 0;
  while (i2 < array.length) {
    if (regex.test(array[i2])) {
      array.splice(i2, 1);
    } else {
      i2++;
    }
  }
  return array;
}
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class FirefoxLauncher extends ProductLauncher {
  constructor(puppeteer2) {
    super(puppeteer2, "firefox");
  }
  static getPreferences(extraPrefsFirefox, protocol) {
    return {
      ...extraPrefsFirefox,
      ...protocol === "webDriverBiDi" ? {
        // Only enable the WebDriver BiDi protocol
        "remote.active-protocols": 1
      } : {
        // Do not close the window when the last tab gets closed
        "browser.tabs.closeWindowWithLastTab": false,
        // Prevent various error message on the console
        // jest-puppeteer asserts that no error message is emitted by the console
        "network.cookie.cookieBehavior": 0,
        // Temporarily force disable BFCache in parent (https://bit.ly/bug-1732263)
        "fission.bfcacheInParent": false,
        // Only enable the CDP protocol
        "remote.active-protocols": 2
      },
      // Force all web content to use a single content process. TODO: remove
      // this once Firefox supports mouse event dispatch from the main frame
      // context. Once this happens, webContentIsolationStrategy should only
      // be set for CDP. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1773393
      "fission.webContentIsolationStrategy": 0
    };
  }
  /**
   * @internal
   */
  async computeLaunchArguments(options = {}) {
    const { ignoreDefaultArgs = false, args = [], executablePath, pipe: pipe2 = false, extraPrefsFirefox = {}, debuggingPort = null } = options;
    const firefoxArguments = [];
    if (!ignoreDefaultArgs) {
      firefoxArguments.push(...this.defaultArgs(options));
    } else if (Array.isArray(ignoreDefaultArgs)) {
      firefoxArguments.push(...this.defaultArgs(options).filter((arg) => {
        return !ignoreDefaultArgs.includes(arg);
      }));
    } else {
      firefoxArguments.push(...args);
    }
    if (!firefoxArguments.some((argument) => {
      return argument.startsWith("--remote-debugging-");
    })) {
      if (pipe2) {
        assert$1(debuggingPort === null, "Browser should be launched with either pipe or debugging port - not both.");
      }
      firefoxArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
    }
    let userDataDir;
    let isTempUserDataDir = true;
    const profileArgIndex = firefoxArguments.findIndex((arg) => {
      return ["-profile", "--profile"].includes(arg);
    });
    if (profileArgIndex !== -1) {
      userDataDir = firefoxArguments[profileArgIndex + 1];
      if (!userDataDir || !fs$o.existsSync(userDataDir)) {
        throw new Error(`Firefox profile not found at '${userDataDir}'`);
      }
      isTempUserDataDir = false;
    } else {
      userDataDir = await promises.mkdtemp(this.getProfilePath());
      firefoxArguments.push("--profile");
      firefoxArguments.push(userDataDir);
    }
    await createProfile(Browser2.FIREFOX, {
      path: userDataDir,
      preferences: FirefoxLauncher.getPreferences(extraPrefsFirefox, options.protocol)
    });
    let firefoxExecutable;
    if (this.puppeteer._isPuppeteerCore || executablePath) {
      assert$1(executablePath, `An \`executablePath\` must be specified for \`puppeteer-core\``);
      firefoxExecutable = executablePath;
    } else {
      firefoxExecutable = this.executablePath();
    }
    return {
      isTempUserDataDir,
      userDataDir,
      args: firefoxArguments,
      executablePath: firefoxExecutable
    };
  }
  /**
   * @internal
   */
  async cleanUserDataDir(userDataDir, opts) {
    if (opts.isTemp) {
      try {
        await rm(userDataDir);
      } catch (error) {
        debugError(error);
        throw error;
      }
    } else {
      try {
        await promises.unlink(path$e.join(userDataDir, "user.js"));
        const prefsBackupPath = path$e.join(userDataDir, "prefs.js.puppeteer");
        if (fs$o.existsSync(prefsBackupPath)) {
          const prefsPath = path$e.join(userDataDir, "prefs.js");
          await promises.unlink(prefsPath);
          await promises.rename(prefsBackupPath, prefsPath);
        }
      } catch (error) {
        debugError(error);
      }
    }
  }
  executablePath() {
    if (this.puppeteer.browserRevision === "latest") {
      const cache = new Cache(this.puppeteer.defaultDownloadPath);
      const installedFirefox = cache.getInstalledBrowsers().find((browser2) => {
        return browser2.platform === detectBrowserPlatform() && browser2.browser === Browser2.FIREFOX;
      });
      if (installedFirefox) {
        this.actualBrowserRevision = installedFirefox.buildId;
      }
    }
    return this.resolveExecutablePath();
  }
  defaultArgs(options = {}) {
    const { devtools = false, headless = !devtools, args = [], userDataDir = null } = options;
    const firefoxArguments = ["--no-remote"];
    switch (os.platform()) {
      case "darwin":
        firefoxArguments.push("--foreground");
        break;
      case "win32":
        firefoxArguments.push("--wait-for-browser");
        break;
    }
    if (userDataDir) {
      firefoxArguments.push("--profile");
      firefoxArguments.push(userDataDir);
    }
    if (headless) {
      firefoxArguments.push("--headless");
    }
    if (devtools) {
      firefoxArguments.push("--devtools");
    }
    if (args.every((arg) => {
      return arg.startsWith("-");
    })) {
      firefoxArguments.push("about:blank");
    }
    firefoxArguments.push(...args);
    return firefoxArguments;
  }
}
/**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
class PuppeteerNode extends Puppeteer {
  /**
   * @internal
   */
  constructor(settings) {
    const { configuration, ...commonSettings } = settings;
    super(commonSettings);
    /**
     * @internal
     */
    __privateAdd(this, _launcher);
    __privateAdd(this, __launcher, void 0);
    __privateAdd(this, _lastLaunchedProduct, void 0);
    /**
     * @internal
     */
    __publicField(this, "defaultBrowserRevision");
    /**
     * @internal
     */
    __publicField(this, "configuration", {});
    if (configuration) {
      this.configuration = configuration;
    }
    switch (this.configuration.defaultProduct) {
      case "firefox":
        this.defaultBrowserRevision = PUPPETEER_REVISIONS.firefox;
        break;
      default:
        this.configuration.defaultProduct = "chrome";
        this.defaultBrowserRevision = PUPPETEER_REVISIONS.chrome;
        break;
    }
    this.connect = this.connect.bind(this);
    this.launch = this.launch.bind(this);
    this.executablePath = this.executablePath.bind(this);
    this.defaultArgs = this.defaultArgs.bind(this);
    this.trimCache = this.trimCache.bind(this);
  }
  /**
   * This method attaches Puppeteer to an existing browser instance.
   *
   * @param options - Set of configurable options to set on the browser.
   * @returns Promise which resolves to browser instance.
   */
  connect(options) {
    return super.connect(options);
  }
  /**
   * Launches a browser instance with given arguments and options when
   * specified.
   *
   * When using with `puppeteer-core`,
   * {@link LaunchOptions.executablePath | options.executablePath} or
   * {@link LaunchOptions.channel | options.channel} must be provided.
   *
   * @example
   * You can use {@link LaunchOptions.ignoreDefaultArgs | options.ignoreDefaultArgs}
   * to filter out `--mute-audio` from default arguments:
   *
   * ```ts
   * const browser = await puppeteer.launch({
   *   ignoreDefaultArgs: ['--mute-audio'],
   * });
   * ```
   *
   * @remarks
   * Puppeteer can also be used to control the Chrome browser, but it works best
   * with the version of Chrome for Testing downloaded by default.
   * There is no guarantee it will work with any other version. If Google Chrome
   * (rather than Chrome for Testing) is preferred, a
   * {@link https://www.google.com/chrome/browser/canary.html | Chrome Canary}
   * or
   * {@link https://www.chromium.org/getting-involved/dev-channel | Dev Channel}
   * build is suggested. See
   * {@link https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/ | this article}
   * for a description of the differences between Chromium and Chrome.
   * {@link https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md | This article}
   * describes some differences for Linux users. See
   * {@link https://developer.chrome.com/blog/chrome-for-testing/ | this doc} for the description
   * of Chrome for Testing.
   *
   * @param options - Options to configure launching behavior.
   */
  launch(options = {}) {
    const { product = this.defaultProduct } = options;
    __privateSet(this, _lastLaunchedProduct, product);
    return __privateGet(this, _launcher, launcher_get).launch(options);
  }
  /**
   * The default executable path.
   */
  executablePath(channel) {
    return __privateGet(this, _launcher, launcher_get).executablePath(channel);
  }
  /**
   * @internal
   */
  get browserRevision() {
    var _a3;
    return ((_a3 = __privateGet(this, __launcher)) == null ? void 0 : _a3.getActualBrowserRevision()) ?? this.configuration.browserRevision ?? this.defaultBrowserRevision;
  }
  /**
   * The default download path for puppeteer. For puppeteer-core, this
   * code should never be called as it is never defined.
   *
   * @internal
   */
  get defaultDownloadPath() {
    return this.configuration.cacheDirectory;
  }
  /**
   * The name of the browser that was last launched.
   */
  get lastLaunchedProduct() {
    return __privateGet(this, _lastLaunchedProduct) ?? this.defaultProduct;
  }
  /**
   * The name of the browser that will be launched by default. For
   * `puppeteer`, this is influenced by your configuration. Otherwise, it's
   * `chrome`.
   */
  get defaultProduct() {
    return this.configuration.defaultProduct ?? "chrome";
  }
  /**
   * @deprecated Do not use as this field as it does not take into account
   * multiple browsers of different types. Use
   * {@link PuppeteerNode.defaultProduct | defaultProduct} or
   * {@link PuppeteerNode.lastLaunchedProduct | lastLaunchedProduct}.
   *
   * @returns The name of the browser that is under automation.
   */
  get product() {
    return __privateGet(this, _launcher, launcher_get).product;
  }
  /**
   * @param options - Set of configurable options to set on the browser.
   *
   * @returns The default flags that Chromium will be launched with.
   */
  defaultArgs(options = {}) {
    return __privateGet(this, _launcher, launcher_get).defaultArgs(options);
  }
  /**
   * Removes all non-current Firefox and Chrome binaries in the cache directory
   * identified by the provided Puppeteer configuration. The current browser
   * version is determined by resolving PUPPETEER_REVISIONS from Puppeteer
   * unless `configuration.browserRevision` is provided.
   *
   * @remarks
   *
   * Note that the method does not check if any other Puppeteer versions
   * installed on the host that use the same cache directory require the
   * non-current binaries.
   *
   * @public
   */
  async trimCache() {
    const platform2 = detectBrowserPlatform();
    if (!platform2) {
      throw new Error("The current platform is not supported.");
    }
    const cacheDir = this.configuration.cacheDirectory;
    const installedBrowsers = await getInstalledBrowsers({
      cacheDir
    });
    const product = this.configuration.defaultProduct;
    const puppeteerBrowsers = [
      {
        product: "chrome",
        browser: Browser2.CHROME,
        currentBuildId: ""
      },
      {
        product: "firefox",
        browser: Browser2.FIREFOX,
        currentBuildId: ""
      }
    ];
    for (const item of puppeteerBrowsers) {
      item.currentBuildId = await resolveBuildId(item.browser, platform2, (product === item.product ? this.configuration.browserRevision : null) || PUPPETEER_REVISIONS[item.product]);
    }
    const currentBrowserBuilds = new Set(puppeteerBrowsers.map((browser2) => {
      return `${browser2.browser}_${browser2.currentBuildId}`;
    }));
    const currentBrowsers = new Set(puppeteerBrowsers.map((browser2) => {
      return browser2.browser;
    }));
    for (const installedBrowser of installedBrowsers) {
      if (!currentBrowsers.has(installedBrowser.browser)) {
        continue;
      }
      if (currentBrowserBuilds.has(`${installedBrowser.browser}_${installedBrowser.buildId}`)) {
        continue;
      }
      await uninstall({
        browser: installedBrowser.browser,
        platform: platform2,
        cacheDir,
        buildId: installedBrowser.buildId
      });
    }
  }
}
__launcher = new WeakMap();
_lastLaunchedProduct = new WeakMap();
_launcher = new WeakSet();
launcher_get = function() {
  if (__privateGet(this, __launcher) && __privateGet(this, __launcher).product === this.lastLaunchedProduct) {
    return __privateGet(this, __launcher);
  }
  switch (this.lastLaunchedProduct) {
    case "chrome":
      this.defaultBrowserRevision = PUPPETEER_REVISIONS.chrome;
      __privateSet(this, __launcher, new ChromeLauncher(this));
      break;
    case "firefox":
      this.defaultBrowserRevision = PUPPETEER_REVISIONS.firefox;
      __privateSet(this, __launcher, new FirefoxLauncher(this));
      break;
    default:
      throw new Error(`Unknown product: ${__privateGet(this, _lastLaunchedProduct)}`);
  }
  return __privateGet(this, __launcher);
};
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function")
      throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p2 in contextIn)
      context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access)
      context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f2) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_2 = accept(result.get))
        descriptor.get = _2;
      if (_2 = accept(result.set))
        descriptor.set = _2;
      if (_2 = accept(result.init))
        initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_2);
      else
        descriptor[key] = _2;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __setFunctionName = function(f2, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
};
const CRF_VALUE = 30;
const DEFAULT_FPS = 30;
const debugFfmpeg = debug$d("puppeteer:ffmpeg");
let ScreenRecorder = (() => {
  var _page2, _process2, _controller, _lastFrame, _getFormatArgs, getFormatArgs_fn, _writeFrame, writeFrame_get, _a3;
  let _classSuper = require$$0$5.PassThrough;
  let _instanceExtraInitializers = [];
  let _private_writeFrame_decorators;
  let _private_writeFrame_descriptor;
  let _stop_decorators;
  return _a3 = class extends _classSuper {
    /**
     * @internal
     */
    constructor(page, width, height, { speed, scale, crop, format, path: path2 } = {}) {
      super({ allowHalfOpen: false });
      __privateAdd(this, _getFormatArgs);
      __privateAdd(this, _writeFrame);
      __privateAdd(this, _page2, (__runInitializers(this, _instanceExtraInitializers), void 0));
      __privateAdd(this, _process2, void 0);
      __privateAdd(this, _controller, new AbortController());
      __privateAdd(this, _lastFrame, void 0);
      path2 ?? (path2 = "ffmpeg");
      const { error } = childProcess.spawnSync(path2);
      if (error) {
        throw error;
      }
      __privateSet(this, _process2, childProcess.spawn(
        path2,
        // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.
        [
          ["-loglevel", "error"],
          // Reduces general buffering.
          ["-avioflags", "direct"],
          // Reduces initial buffering while analyzing input fps and other stats.
          [
            "-fpsprobesize",
            "0",
            "-probesize",
            "32",
            "-analyzeduration",
            "0",
            "-fflags",
            "nobuffer"
          ],
          // Forces input to be read from standard input, and forces png input
          // image format.
          ["-f", "image2pipe", "-c:v", "png", "-i", "pipe:0"],
          // Overwrite output and no audio.
          ["-y", "-an"],
          // This drastically reduces stalling when cpu is overbooked. By default
          // VP9 tries to use all available threads?
          ["-threads", "1"],
          // Specifies the frame rate we are giving ffmpeg.
          ["-framerate", `${DEFAULT_FPS}`],
          // Specifies the encoding and format we are using.
          __privateMethod(this, _getFormatArgs, getFormatArgs_fn).call(this, format ?? "webm"),
          // Disable bitrate.
          ["-b:v", "0"],
          // Filters to ensure the images are piped correctly.
          [
            "-vf",
            `${speed ? `setpts=${1 / speed}*PTS,` : ""}crop='min(${width},iw):min(${height},ih):0:0',pad=${width}:${height}:0:0${crop ? `,crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}` : ""}${scale ? `,scale=iw*${scale}:-1` : ""}`
          ],
          "pipe:1"
        ].flat(),
        { stdio: ["pipe", "pipe", "pipe"] }
      ));
      __privateGet(this, _process2).stdout.pipe(this);
      __privateGet(this, _process2).stderr.on("data", (data2) => {
        debugFfmpeg(data2.toString("utf8"));
      });
      __privateSet(this, _page2, page);
      const { client } = __privateGet(this, _page2).mainFrame();
      client.once(CDPSessionEvent.Disconnected, () => {
        void this.stop().catch(debugError);
      });
      __privateSet(this, _lastFrame, lastValueFrom(fromEmitterEvent(client, "Page.screencastFrame").pipe(tap((event) => {
        void client.send("Page.screencastFrameAck", {
          sessionId: event.sessionId
        });
      }), filter((event) => {
        return event.metadata.timestamp !== void 0;
      }), map((event) => {
        return {
          buffer: Buffer.from(event.data, "base64"),
          timestamp: event.metadata.timestamp
        };
      }), bufferCount(2, 1), concatMap(([{ timestamp: previousTimestamp, buffer }, { timestamp }]) => {
        return from$1(Array(Math.round(DEFAULT_FPS * Math.max(timestamp - previousTimestamp, 0))).fill(buffer));
      }), map((buffer) => {
        void __privateGet(this, _writeFrame, writeFrame_get).call(this, buffer);
        return [buffer, performance.now()];
      }), takeUntil(fromEvent(__privateGet(this, _controller).signal, "abort"))), { defaultValue: [Buffer.from([]), performance.now()] }));
    }
    /**
     * Stops the recorder.
     *
     * @public
     */
    async stop() {
      if (__privateGet(this, _controller).signal.aborted) {
        return;
      }
      await __privateGet(this, _page2)._stopScreencast().catch(debugError);
      __privateGet(this, _controller).abort();
      const [buffer, timestamp] = await __privateGet(this, _lastFrame);
      await Promise.all(Array(Math.max(1, Math.round(DEFAULT_FPS * (performance.now() - timestamp) / 1e3))).fill(buffer).map(__privateGet(this, _writeFrame, writeFrame_get).bind(this)));
      __privateGet(this, _process2).stdin.end();
      await new Promise((resolve2) => {
        __privateGet(this, _process2).once("close", resolve2);
      });
    }
    /**
     * @internal
     */
    async [(_private_writeFrame_decorators = [guarded()], _stop_decorators = [guarded()], asyncDisposeSymbol)]() {
      await this.stop();
    }
  }, _page2 = new WeakMap(), _process2 = new WeakMap(), _controller = new WeakMap(), _lastFrame = new WeakMap(), _getFormatArgs = new WeakSet(), getFormatArgs_fn = function(format) {
    switch (format) {
      case "webm":
        return [
          // Sets the codec to use.
          ["-c:v", "vp9"],
          // Sets the format
          ["-f", "webm"],
          // Sets the quality. Lower the better.
          ["-crf", `${CRF_VALUE}`],
          // Sets the quality and how efficient the compression will be.
          ["-deadline", "realtime", "-cpu-used", "8"]
        ].flat();
      case "gif":
        return [
          // Sets the frame rate and uses a custom palette generated from the
          // input.
          [
            "-vf",
            "fps=5,split[s0][s1];[s0]palettegen=stats_mode=diff[p];[s1][p]paletteuse"
          ],
          // Sets the format
          ["-f", "gif"]
        ].flat();
    }
  }, _writeFrame = new WeakSet(), writeFrame_get = function() {
    return _private_writeFrame_descriptor.value;
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    __esDecorate(_a3, _private_writeFrame_descriptor = { value: __setFunctionName(async function(buffer) {
      const error = await new Promise((resolve2) => {
        __privateGet(this, _process2).stdin.write(buffer, resolve2);
      });
      if (error) {
        console.log(`ffmpeg failed to write: ${error.message}.`);
      }
    }, "#writeFrame") }, _private_writeFrame_decorators, { kind: "method", name: "#writeFrame", static: false, private: true, access: { has: (obj) => __privateIn(_writeFrame, obj), get: (obj) => __privateGet(obj, _writeFrame, writeFrame_get) }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(_a3, null, _stop_decorators, { kind: "method", name: "stop", static: false, private: false, access: { has: (obj) => "stop" in obj, get: (obj) => obj.stop }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata)
      Object.defineProperty(_a3, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3;
})();
const ScreenRecorder$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ScreenRecorder
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
const puppeteer = new PuppeteerNode({
  isPuppeteerCore: true
});
process.env.DIST = path$f.join(__dirname, "../dist");
process.env.VITE_PUBLIC = electron.app.isPackaged ? process.env.DIST : path$f.join(process.env.DIST, "../public");
let win;
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const main = async () => {
  await pie.initialize(electron.app);
  const browser2 = await pie.connect(electron.app, puppeteer);
  const window2 = new electron.BrowserWindow();
  const url = "https://google.com/";
  await window2.loadURL(url);
  const page = await pie.getPage(browser2, window2);
  console.log(page.url());
};
main();
function createWindow() {
  win = new electron.BrowserWindow({
    height: 1080,
    width: 1920,
    // minHeight:700,
    // minWidth:1500,
    resizable: false,
    titleBarStyle: "hidden",
    autoHideMenuBar: true,
    icon: path$f.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    webPreferences: {
      preload: path$f.join(__dirname, "preload.js")
    }
  });
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$f.join(process.env.DIST, "index.html"));
  }
}
electron.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    electron.app.quit();
    win = null;
  }
});
electron.app.on("activate", () => {
  if (electron.BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
electron.app.whenReady().then(createWindow);
exports.ARIAQueryHandler = ARIAQueryHandler;
exports.Accessibility = Accessibility;
exports.AsyncIterableUtil = AsyncIterableUtil;
exports.Browser = Browser$1;
exports.BrowserContext = BrowserContext;
exports.CDPSession = CDPSession;
exports.CallbackRegistry = CallbackRegistry;
exports.ConsoleMessage = ConsoleMessage;
exports.Coverage = Coverage;
exports.Deferred = Deferred;
exports.Dialog = Dialog;
exports.DisposableStack = DisposableStack;
exports.ElementHandle = ElementHandle;
exports.EmulationManager = EmulationManager;
exports.EventEmitter = EventEmitter$2;
exports.Frame = Frame;
exports.HTTPRequest = HTTPRequest;
exports.HTTPResponse = HTTPResponse;
exports.JSHandle = JSHandle;
exports.Keyboard = Keyboard;
exports.LazyArg = LazyArg;
exports.Mouse = Mouse;
exports.MouseButton = MouseButton;
exports.Page = Page;
exports.ProtocolError = ProtocolError;
exports.PuppeteerURL = PuppeteerURL;
exports.Realm = Realm;
exports.SOURCE_URL_REGEX = SOURCE_URL_REGEX;
exports.STATUS_TEXTS = STATUS_TEXTS;
exports.Target = Target;
exports.TargetCloseError = TargetCloseError;
exports.TimeoutError = TimeoutError$1;
exports.Touchscreen = Touchscreen;
exports.Tracing = Tracing;
exports.UnsupportedOperation = UnsupportedOperation;
exports.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = WEB_PERMISSION_TO_PROTOCOL_PERMISSION;
exports.WebWorker = WebWorker;
exports.assert = assert$1;
exports.bubble = bubble;
exports.combineLatest = combineLatest;
exports.commonjsGlobal = commonjsGlobal;
exports.debug = debug$g;
exports.debugError = debugError;
exports.defer = defer;
exports.delayWhen = delayWhen;
exports.disposeSymbol = disposeSymbol;
exports.evaluationString = evaluationString;
exports.filter = filter;
exports.first = first;
exports.firstValueFrom = firstValueFrom;
exports.from = from$1;
exports.fromEmitterEvent = fromEmitterEvent;
exports.getAugmentedNamespace = getAugmentedNamespace;
exports.getSourcePuppeteerURLIfAvailable = getSourcePuppeteerURLIfAvailable;
exports.getSourceUrlComment = getSourceUrlComment;
exports.handleError = handleError;
exports.inertIfDisposed = inertIfDisposed;
exports.interpolateFunction = interpolateFunction;
exports.invokeAtMostOnceForArguments = invokeAtMostOnceForArguments;
exports.isDate = isDate;
exports.isErrorLike = isErrorLike$1;
exports.isPlainObject = isPlainObject;
exports.isRegExp = isRegExp;
exports.isString = isString;
exports.map = map;
exports.of = of;
exports.parsePDFOptions = parsePDFOptions;
exports.raceWith = raceWith;
exports.scriptInjector = scriptInjector;
exports.stringifyFunction = stringifyFunction;
exports.switchMap = switchMap;
exports.throwIfDetached = throwIfDetached;
exports.throwIfDisposed = throwIfDisposed;
exports.timeout = timeout;
